// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/theopenlane/core/internal/ent/customtypes"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/actionplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/apitoken"
	"github.com/theopenlane/core/internal/ent/generated/contact"
	"github.com/theopenlane/core/internal/ent/generated/contacthistory"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/controlhistory"
	"github.com/theopenlane/core/internal/ent/generated/controlobjective"
	"github.com/theopenlane/core/internal/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/core/internal/ent/generated/documentdata"
	"github.com/theopenlane/core/internal/ent/generated/documentdatahistory"
	"github.com/theopenlane/core/internal/ent/generated/emailverificationtoken"
	"github.com/theopenlane/core/internal/ent/generated/entitlement"
	"github.com/theopenlane/core/internal/ent/generated/entitlementhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplan"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanfeature"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanfeaturehistory"
	"github.com/theopenlane/core/internal/ent/generated/entitlementplanhistory"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/entityhistory"
	"github.com/theopenlane/core/internal/ent/generated/entitytype"
	"github.com/theopenlane/core/internal/ent/generated/entitytypehistory"
	"github.com/theopenlane/core/internal/ent/generated/event"
	"github.com/theopenlane/core/internal/ent/generated/eventhistory"
	"github.com/theopenlane/core/internal/ent/generated/feature"
	"github.com/theopenlane/core/internal/ent/generated/featurehistory"
	"github.com/theopenlane/core/internal/ent/generated/file"
	"github.com/theopenlane/core/internal/ent/generated/filehistory"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/grouphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupmembership"
	"github.com/theopenlane/core/internal/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/groupsetting"
	"github.com/theopenlane/core/internal/ent/generated/groupsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/hush"
	"github.com/theopenlane/core/internal/ent/generated/hushhistory"
	"github.com/theopenlane/core/internal/ent/generated/integration"
	"github.com/theopenlane/core/internal/ent/generated/integrationhistory"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/core/internal/ent/generated/invite"
	"github.com/theopenlane/core/internal/ent/generated/narrative"
	"github.com/theopenlane/core/internal/ent/generated/narrativehistory"
	"github.com/theopenlane/core/internal/ent/generated/note"
	"github.com/theopenlane/core/internal/ent/generated/notehistory"
	"github.com/theopenlane/core/internal/ent/generated/oauthprovider"
	"github.com/theopenlane/core/internal/ent/generated/oauthproviderhistory"
	"github.com/theopenlane/core/internal/ent/generated/ohauthtootoken"
	"github.com/theopenlane/core/internal/ent/generated/organization"
	"github.com/theopenlane/core/internal/ent/generated/organizationhistory"
	"github.com/theopenlane/core/internal/ent/generated/organizationsetting"
	"github.com/theopenlane/core/internal/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/orgmembership"
	"github.com/theopenlane/core/internal/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/core/internal/ent/generated/passwordresettoken"
	"github.com/theopenlane/core/internal/ent/generated/personalaccesstoken"
	"github.com/theopenlane/core/internal/ent/generated/predicate"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/procedurehistory"
	"github.com/theopenlane/core/internal/ent/generated/program"
	"github.com/theopenlane/core/internal/ent/generated/programhistory"
	"github.com/theopenlane/core/internal/ent/generated/risk"
	"github.com/theopenlane/core/internal/ent/generated/riskhistory"
	"github.com/theopenlane/core/internal/ent/generated/standard"
	"github.com/theopenlane/core/internal/ent/generated/standardhistory"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/ent/generated/subcontrolhistory"
	"github.com/theopenlane/core/internal/ent/generated/subscriber"
	"github.com/theopenlane/core/internal/ent/generated/task"
	"github.com/theopenlane/core/internal/ent/generated/taskhistory"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/templatehistory"
	"github.com/theopenlane/core/internal/ent/generated/tfasetting"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/internal/ent/generated/userhistory"
	"github.com/theopenlane/core/internal/ent/generated/usersetting"
	"github.com/theopenlane/core/internal/ent/generated/usersettinghistory"
	"github.com/theopenlane/core/internal/ent/generated/webauthn"
	"github.com/theopenlane/core/internal/ent/generated/webhook"
	"github.com/theopenlane/core/internal/ent/generated/webhookhistory"
	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/entx/history"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIToken                      = "APIToken"
	TypeActionPlan                    = "ActionPlan"
	TypeActionPlanHistory             = "ActionPlanHistory"
	TypeContact                       = "Contact"
	TypeContactHistory                = "ContactHistory"
	TypeControl                       = "Control"
	TypeControlHistory                = "ControlHistory"
	TypeControlObjective              = "ControlObjective"
	TypeControlObjectiveHistory       = "ControlObjectiveHistory"
	TypeDocumentData                  = "DocumentData"
	TypeDocumentDataHistory           = "DocumentDataHistory"
	TypeEmailVerificationToken        = "EmailVerificationToken"
	TypeEntitlement                   = "Entitlement"
	TypeEntitlementHistory            = "EntitlementHistory"
	TypeEntitlementPlan               = "EntitlementPlan"
	TypeEntitlementPlanFeature        = "EntitlementPlanFeature"
	TypeEntitlementPlanFeatureHistory = "EntitlementPlanFeatureHistory"
	TypeEntitlementPlanHistory        = "EntitlementPlanHistory"
	TypeEntity                        = "Entity"
	TypeEntityHistory                 = "EntityHistory"
	TypeEntityType                    = "EntityType"
	TypeEntityTypeHistory             = "EntityTypeHistory"
	TypeEvent                         = "Event"
	TypeEventHistory                  = "EventHistory"
	TypeFeature                       = "Feature"
	TypeFeatureHistory                = "FeatureHistory"
	TypeFile                          = "File"
	TypeFileHistory                   = "FileHistory"
	TypeGroup                         = "Group"
	TypeGroupHistory                  = "GroupHistory"
	TypeGroupMembership               = "GroupMembership"
	TypeGroupMembershipHistory        = "GroupMembershipHistory"
	TypeGroupSetting                  = "GroupSetting"
	TypeGroupSettingHistory           = "GroupSettingHistory"
	TypeHush                          = "Hush"
	TypeHushHistory                   = "HushHistory"
	TypeIntegration                   = "Integration"
	TypeIntegrationHistory            = "IntegrationHistory"
	TypeInternalPolicy                = "InternalPolicy"
	TypeInternalPolicyHistory         = "InternalPolicyHistory"
	TypeInvite                        = "Invite"
	TypeNarrative                     = "Narrative"
	TypeNarrativeHistory              = "NarrativeHistory"
	TypeNote                          = "Note"
	TypeNoteHistory                   = "NoteHistory"
	TypeOauthProvider                 = "OauthProvider"
	TypeOauthProviderHistory          = "OauthProviderHistory"
	TypeOhAuthTooToken                = "OhAuthTooToken"
	TypeOrgMembership                 = "OrgMembership"
	TypeOrgMembershipHistory          = "OrgMembershipHistory"
	TypeOrganization                  = "Organization"
	TypeOrganizationHistory           = "OrganizationHistory"
	TypeOrganizationSetting           = "OrganizationSetting"
	TypeOrganizationSettingHistory    = "OrganizationSettingHistory"
	TypePasswordResetToken            = "PasswordResetToken"
	TypePersonalAccessToken           = "PersonalAccessToken"
	TypeProcedure                     = "Procedure"
	TypeProcedureHistory              = "ProcedureHistory"
	TypeProgram                       = "Program"
	TypeProgramHistory                = "ProgramHistory"
	TypeRisk                          = "Risk"
	TypeRiskHistory                   = "RiskHistory"
	TypeStandard                      = "Standard"
	TypeStandardHistory               = "StandardHistory"
	TypeSubcontrol                    = "Subcontrol"
	TypeSubcontrolHistory             = "SubcontrolHistory"
	TypeSubscriber                    = "Subscriber"
	TypeTFASetting                    = "TFASetting"
	TypeTask                          = "Task"
	TypeTaskHistory                   = "TaskHistory"
	TypeTemplate                      = "Template"
	TypeTemplateHistory               = "TemplateHistory"
	TypeUser                          = "User"
	TypeUserHistory                   = "UserHistory"
	TypeUserSetting                   = "UserSetting"
	TypeUserSettingHistory            = "UserSettingHistory"
	TypeWebauthn                      = "Webauthn"
	TypeWebhook                       = "Webhook"
	TypeWebhookHistory                = "WebhookHistory"
)

// APITokenMutation represents an operation that mutates the APIToken nodes in the graph.
type APITokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	name          *string
	token         *string
	expires_at    *time.Time
	description   *string
	scopes        *[]string
	appendscopes  []string
	last_used_at  *time.Time
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*APIToken, error)
	predicates    []predicate.APIToken
}

var _ ent.Mutation = (*APITokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*APITokenMutation)

// newAPITokenMutation creates new mutation for the APIToken entity.
func newAPITokenMutation(c config, op Op, opts ...apitokenOption) *APITokenMutation {
	m := &APITokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPITokenID sets the ID field of the mutation.
func withAPITokenID(id string) apitokenOption {
	return func(m *APITokenMutation) {
		var (
			err   error
			once  sync.Once
			value *APIToken
		)
		m.oldValue = func(ctx context.Context) (*APIToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIToken sets the old APIToken of the mutation.
func withAPIToken(node *APIToken) apitokenOption {
	return func(m *APITokenMutation) {
		m.oldValue = func(context.Context) (*APIToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APITokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APITokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of APIToken entities.
func (m *APITokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APITokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APITokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APITokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APITokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *APITokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[apitoken.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *APITokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APITokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, apitoken.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APITokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APITokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *APITokenMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[apitoken.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *APITokenMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APITokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, apitoken.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *APITokenMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *APITokenMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *APITokenMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[apitoken.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *APITokenMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *APITokenMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, apitoken.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *APITokenMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *APITokenMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *APITokenMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[apitoken.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *APITokenMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *APITokenMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, apitoken.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APITokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APITokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *APITokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apitoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *APITokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APITokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apitoken.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *APITokenMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *APITokenMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *APITokenMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[apitoken.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *APITokenMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *APITokenMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, apitoken.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *APITokenMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *APITokenMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *APITokenMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *APITokenMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *APITokenMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *APITokenMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *APITokenMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *APITokenMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[apitoken.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *APITokenMutation) TagsCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *APITokenMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, apitoken.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *APITokenMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *APITokenMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *APITokenMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[apitoken.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *APITokenMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *APITokenMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, apitoken.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *APITokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APITokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APITokenMutation) ResetName() {
	m.name = nil
}

// SetToken sets the "token" field.
func (m *APITokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *APITokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *APITokenMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *APITokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APITokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APITokenMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apitoken.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APITokenMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APITokenMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apitoken.FieldExpiresAt)
}

// SetDescription sets the "description" field.
func (m *APITokenMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APITokenMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *APITokenMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[apitoken.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *APITokenMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *APITokenMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, apitoken.FieldDescription)
}

// SetScopes sets the "scopes" field.
func (m *APITokenMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *APITokenMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *APITokenMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *APITokenMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *APITokenMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[apitoken.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *APITokenMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *APITokenMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, apitoken.FieldScopes)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *APITokenMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *APITokenMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *APITokenMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apitoken.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *APITokenMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *APITokenMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apitoken.FieldLastUsedAt)
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *APITokenMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[apitoken.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *APITokenMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *APITokenMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *APITokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the APITokenMutation builder.
func (m *APITokenMutation) Where(ps ...predicate.APIToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APITokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APITokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APITokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APITokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIToken).
func (m *APITokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APITokenMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apitoken.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, apitoken.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, apitoken.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, apitoken.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, apitoken.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, apitoken.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, apitoken.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, apitoken.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, apitoken.FieldName)
	}
	if m.token != nil {
		fields = append(fields, apitoken.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, apitoken.FieldExpiresAt)
	}
	if m.description != nil {
		fields = append(fields, apitoken.FieldDescription)
	}
	if m.scopes != nil {
		fields = append(fields, apitoken.FieldScopes)
	}
	if m.last_used_at != nil {
		fields = append(fields, apitoken.FieldLastUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APITokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldCreatedAt:
		return m.CreatedAt()
	case apitoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case apitoken.FieldCreatedBy:
		return m.CreatedBy()
	case apitoken.FieldUpdatedBy:
		return m.UpdatedBy()
	case apitoken.FieldDeletedAt:
		return m.DeletedAt()
	case apitoken.FieldDeletedBy:
		return m.DeletedBy()
	case apitoken.FieldMappingID:
		return m.MappingID()
	case apitoken.FieldTags:
		return m.Tags()
	case apitoken.FieldOwnerID:
		return m.OwnerID()
	case apitoken.FieldName:
		return m.Name()
	case apitoken.FieldToken:
		return m.Token()
	case apitoken.FieldExpiresAt:
		return m.ExpiresAt()
	case apitoken.FieldDescription:
		return m.Description()
	case apitoken.FieldScopes:
		return m.Scopes()
	case apitoken.FieldLastUsedAt:
		return m.LastUsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APITokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apitoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apitoken.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case apitoken.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case apitoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apitoken.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case apitoken.FieldMappingID:
		return m.OldMappingID(ctx)
	case apitoken.FieldTags:
		return m.OldTags(ctx)
	case apitoken.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case apitoken.FieldName:
		return m.OldName(ctx)
	case apitoken.FieldToken:
		return m.OldToken(ctx)
	case apitoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apitoken.FieldDescription:
		return m.OldDescription(ctx)
	case apitoken.FieldScopes:
		return m.OldScopes(ctx)
	case apitoken.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APITokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apitoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apitoken.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case apitoken.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case apitoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apitoken.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case apitoken.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case apitoken.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case apitoken.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case apitoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apitoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case apitoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apitoken.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case apitoken.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case apitoken.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APITokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APITokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APITokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown APIToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APITokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apitoken.FieldCreatedAt) {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	if m.FieldCleared(apitoken.FieldUpdatedAt) {
		fields = append(fields, apitoken.FieldUpdatedAt)
	}
	if m.FieldCleared(apitoken.FieldCreatedBy) {
		fields = append(fields, apitoken.FieldCreatedBy)
	}
	if m.FieldCleared(apitoken.FieldUpdatedBy) {
		fields = append(fields, apitoken.FieldUpdatedBy)
	}
	if m.FieldCleared(apitoken.FieldDeletedAt) {
		fields = append(fields, apitoken.FieldDeletedAt)
	}
	if m.FieldCleared(apitoken.FieldDeletedBy) {
		fields = append(fields, apitoken.FieldDeletedBy)
	}
	if m.FieldCleared(apitoken.FieldTags) {
		fields = append(fields, apitoken.FieldTags)
	}
	if m.FieldCleared(apitoken.FieldOwnerID) {
		fields = append(fields, apitoken.FieldOwnerID)
	}
	if m.FieldCleared(apitoken.FieldExpiresAt) {
		fields = append(fields, apitoken.FieldExpiresAt)
	}
	if m.FieldCleared(apitoken.FieldDescription) {
		fields = append(fields, apitoken.FieldDescription)
	}
	if m.FieldCleared(apitoken.FieldScopes) {
		fields = append(fields, apitoken.FieldScopes)
	}
	if m.FieldCleared(apitoken.FieldLastUsedAt) {
		fields = append(fields, apitoken.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APITokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APITokenMutation) ClearField(name string) error {
	switch name {
	case apitoken.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case apitoken.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case apitoken.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case apitoken.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case apitoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case apitoken.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case apitoken.FieldTags:
		m.ClearTags()
		return nil
	case apitoken.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case apitoken.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case apitoken.FieldDescription:
		m.ClearDescription()
		return nil
	case apitoken.FieldScopes:
		m.ClearScopes()
		return nil
	case apitoken.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown APIToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APITokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apitoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apitoken.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case apitoken.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case apitoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apitoken.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case apitoken.FieldMappingID:
		m.ResetMappingID()
		return nil
	case apitoken.FieldTags:
		m.ResetTags()
		return nil
	case apitoken.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case apitoken.FieldName:
		m.ResetName()
		return nil
	case apitoken.FieldToken:
		m.ResetToken()
		return nil
	case apitoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apitoken.FieldDescription:
		m.ResetDescription()
		return nil
	case apitoken.FieldScopes:
		m.ResetScopes()
		return nil
	case apitoken.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown APIToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APITokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, apitoken.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APITokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APITokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APITokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APITokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, apitoken.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APITokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apitoken.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APITokenMutation) ClearEdge(name string) error {
	switch name {
	case apitoken.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown APIToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APITokenMutation) ResetEdge(name string) error {
	switch name {
	case apitoken.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown APIToken edge %s", name)
}

// ActionPlanMutation represents an operation that mutates the ActionPlan nodes in the graph.
type ActionPlanMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	deleted_at      *time.Time
	deleted_by      *string
	mapping_id      *string
	tags            *[]string
	appendtags      []string
	name            *string
	description     *string
	status          *string
	due_date        *time.Time
	priority        *string
	source          *string
	details         *map[string]interface{}
	clearedFields   map[string]struct{}
	standard        map[string]struct{}
	removedstandard map[string]struct{}
	clearedstandard bool
	risk            map[string]struct{}
	removedrisk     map[string]struct{}
	clearedrisk     bool
	control         map[string]struct{}
	removedcontrol  map[string]struct{}
	clearedcontrol  bool
	user            map[string]struct{}
	removeduser     map[string]struct{}
	cleareduser     bool
	program         map[string]struct{}
	removedprogram  map[string]struct{}
	clearedprogram  bool
	done            bool
	oldValue        func(context.Context) (*ActionPlan, error)
	predicates      []predicate.ActionPlan
}

var _ ent.Mutation = (*ActionPlanMutation)(nil)

// actionplanOption allows management of the mutation configuration using functional options.
type actionplanOption func(*ActionPlanMutation)

// newActionPlanMutation creates new mutation for the ActionPlan entity.
func newActionPlanMutation(c config, op Op, opts ...actionplanOption) *ActionPlanMutation {
	m := &ActionPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeActionPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionPlanID sets the ID field of the mutation.
func withActionPlanID(id string) actionplanOption {
	return func(m *ActionPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionPlan
		)
		m.oldValue = func(ctx context.Context) (*ActionPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionPlan sets the old ActionPlan of the mutation.
func withActionPlan(node *ActionPlan) actionplanOption {
	return func(m *ActionPlanMutation) {
		m.oldValue = func(context.Context) (*ActionPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActionPlan entities.
func (m *ActionPlanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionPlanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionPlanMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ActionPlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActionPlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ActionPlanMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[actionplan.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ActionPlanMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActionPlanMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, actionplan.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActionPlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActionPlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ActionPlanMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[actionplan.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ActionPlanMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActionPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, actionplan.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ActionPlanMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ActionPlanMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ActionPlanMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[actionplan.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ActionPlanMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ActionPlanMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, actionplan.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ActionPlanMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ActionPlanMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ActionPlanMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[actionplan.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ActionPlanMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ActionPlanMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, actionplan.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ActionPlanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ActionPlanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ActionPlanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[actionplan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ActionPlanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ActionPlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, actionplan.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ActionPlanMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ActionPlanMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ActionPlanMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[actionplan.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ActionPlanMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ActionPlanMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, actionplan.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ActionPlanMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ActionPlanMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ActionPlanMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *ActionPlanMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ActionPlanMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ActionPlanMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ActionPlanMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ActionPlanMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[actionplan.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ActionPlanMutation) TagsCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ActionPlanMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, actionplan.FieldTags)
}

// SetName sets the "name" field.
func (m *ActionPlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActionPlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActionPlanMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ActionPlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActionPlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ActionPlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[actionplan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ActionPlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ActionPlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, actionplan.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ActionPlanMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ActionPlanMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ActionPlanMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[actionplan.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ActionPlanMutation) StatusCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ActionPlanMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, actionplan.FieldStatus)
}

// SetDueDate sets the "due_date" field.
func (m *ActionPlanMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ActionPlanMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *ActionPlanMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[actionplan.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *ActionPlanMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ActionPlanMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, actionplan.FieldDueDate)
}

// SetPriority sets the "priority" field.
func (m *ActionPlanMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ActionPlanMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *ActionPlanMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[actionplan.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *ActionPlanMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *ActionPlanMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, actionplan.FieldPriority)
}

// SetSource sets the "source" field.
func (m *ActionPlanMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ActionPlanMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ActionPlanMutation) ClearSource() {
	m.source = nil
	m.clearedFields[actionplan.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ActionPlanMutation) SourceCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ActionPlanMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, actionplan.FieldSource)
}

// SetDetails sets the "details" field.
func (m *ActionPlanMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *ActionPlanMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ActionPlan entity.
// If the ActionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ActionPlanMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[actionplan.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ActionPlanMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[actionplan.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ActionPlanMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, actionplan.FieldDetails)
}

// AddStandardIDs adds the "standard" edge to the Standard entity by ids.
func (m *ActionPlanMutation) AddStandardIDs(ids ...string) {
	if m.standard == nil {
		m.standard = make(map[string]struct{})
	}
	for i := range ids {
		m.standard[ids[i]] = struct{}{}
	}
}

// ClearStandard clears the "standard" edge to the Standard entity.
func (m *ActionPlanMutation) ClearStandard() {
	m.clearedstandard = true
}

// StandardCleared reports if the "standard" edge to the Standard entity was cleared.
func (m *ActionPlanMutation) StandardCleared() bool {
	return m.clearedstandard
}

// RemoveStandardIDs removes the "standard" edge to the Standard entity by IDs.
func (m *ActionPlanMutation) RemoveStandardIDs(ids ...string) {
	if m.removedstandard == nil {
		m.removedstandard = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.standard, ids[i])
		m.removedstandard[ids[i]] = struct{}{}
	}
}

// RemovedStandard returns the removed IDs of the "standard" edge to the Standard entity.
func (m *ActionPlanMutation) RemovedStandardIDs() (ids []string) {
	for id := range m.removedstandard {
		ids = append(ids, id)
	}
	return
}

// StandardIDs returns the "standard" edge IDs in the mutation.
func (m *ActionPlanMutation) StandardIDs() (ids []string) {
	for id := range m.standard {
		ids = append(ids, id)
	}
	return
}

// ResetStandard resets all changes to the "standard" edge.
func (m *ActionPlanMutation) ResetStandard() {
	m.standard = nil
	m.clearedstandard = false
	m.removedstandard = nil
}

// AddRiskIDs adds the "risk" edge to the Risk entity by ids.
func (m *ActionPlanMutation) AddRiskIDs(ids ...string) {
	if m.risk == nil {
		m.risk = make(map[string]struct{})
	}
	for i := range ids {
		m.risk[ids[i]] = struct{}{}
	}
}

// ClearRisk clears the "risk" edge to the Risk entity.
func (m *ActionPlanMutation) ClearRisk() {
	m.clearedrisk = true
}

// RiskCleared reports if the "risk" edge to the Risk entity was cleared.
func (m *ActionPlanMutation) RiskCleared() bool {
	return m.clearedrisk
}

// RemoveRiskIDs removes the "risk" edge to the Risk entity by IDs.
func (m *ActionPlanMutation) RemoveRiskIDs(ids ...string) {
	if m.removedrisk == nil {
		m.removedrisk = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.risk, ids[i])
		m.removedrisk[ids[i]] = struct{}{}
	}
}

// RemovedRisk returns the removed IDs of the "risk" edge to the Risk entity.
func (m *ActionPlanMutation) RemovedRiskIDs() (ids []string) {
	for id := range m.removedrisk {
		ids = append(ids, id)
	}
	return
}

// RiskIDs returns the "risk" edge IDs in the mutation.
func (m *ActionPlanMutation) RiskIDs() (ids []string) {
	for id := range m.risk {
		ids = append(ids, id)
	}
	return
}

// ResetRisk resets all changes to the "risk" edge.
func (m *ActionPlanMutation) ResetRisk() {
	m.risk = nil
	m.clearedrisk = false
	m.removedrisk = nil
}

// AddControlIDs adds the "control" edge to the Control entity by ids.
func (m *ActionPlanMutation) AddControlIDs(ids ...string) {
	if m.control == nil {
		m.control = make(map[string]struct{})
	}
	for i := range ids {
		m.control[ids[i]] = struct{}{}
	}
}

// ClearControl clears the "control" edge to the Control entity.
func (m *ActionPlanMutation) ClearControl() {
	m.clearedcontrol = true
}

// ControlCleared reports if the "control" edge to the Control entity was cleared.
func (m *ActionPlanMutation) ControlCleared() bool {
	return m.clearedcontrol
}

// RemoveControlIDs removes the "control" edge to the Control entity by IDs.
func (m *ActionPlanMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrol == nil {
		m.removedcontrol = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.control, ids[i])
		m.removedcontrol[ids[i]] = struct{}{}
	}
}

// RemovedControl returns the removed IDs of the "control" edge to the Control entity.
func (m *ActionPlanMutation) RemovedControlIDs() (ids []string) {
	for id := range m.removedcontrol {
		ids = append(ids, id)
	}
	return
}

// ControlIDs returns the "control" edge IDs in the mutation.
func (m *ActionPlanMutation) ControlIDs() (ids []string) {
	for id := range m.control {
		ids = append(ids, id)
	}
	return
}

// ResetControl resets all changes to the "control" edge.
func (m *ActionPlanMutation) ResetControl() {
	m.control = nil
	m.clearedcontrol = false
	m.removedcontrol = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *ActionPlanMutation) AddUserIDs(ids ...string) {
	if m.user == nil {
		m.user = make(map[string]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *ActionPlanMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ActionPlanMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *ActionPlanMutation) RemoveUserIDs(ids ...string) {
	if m.removeduser == nil {
		m.removeduser = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *ActionPlanMutation) RemovedUserIDs() (ids []string) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *ActionPlanMutation) UserIDs() (ids []string) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ActionPlanMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddProgramIDs adds the "program" edge to the Program entity by ids.
func (m *ActionPlanMutation) AddProgramIDs(ids ...string) {
	if m.program == nil {
		m.program = make(map[string]struct{})
	}
	for i := range ids {
		m.program[ids[i]] = struct{}{}
	}
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *ActionPlanMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *ActionPlanMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// RemoveProgramIDs removes the "program" edge to the Program entity by IDs.
func (m *ActionPlanMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprogram == nil {
		m.removedprogram = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.program, ids[i])
		m.removedprogram[ids[i]] = struct{}{}
	}
}

// RemovedProgram returns the removed IDs of the "program" edge to the Program entity.
func (m *ActionPlanMutation) RemovedProgramIDs() (ids []string) {
	for id := range m.removedprogram {
		ids = append(ids, id)
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
func (m *ActionPlanMutation) ProgramIDs() (ids []string) {
	for id := range m.program {
		ids = append(ids, id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *ActionPlanMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
	m.removedprogram = nil
}

// Where appends a list predicates to the ActionPlanMutation builder.
func (m *ActionPlanMutation) Where(ps ...predicate.ActionPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionPlan).
func (m *ActionPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionPlanMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, actionplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, actionplan.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, actionplan.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, actionplan.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, actionplan.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, actionplan.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, actionplan.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, actionplan.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, actionplan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, actionplan.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, actionplan.FieldStatus)
	}
	if m.due_date != nil {
		fields = append(fields, actionplan.FieldDueDate)
	}
	if m.priority != nil {
		fields = append(fields, actionplan.FieldPriority)
	}
	if m.source != nil {
		fields = append(fields, actionplan.FieldSource)
	}
	if m.details != nil {
		fields = append(fields, actionplan.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actionplan.FieldCreatedAt:
		return m.CreatedAt()
	case actionplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case actionplan.FieldCreatedBy:
		return m.CreatedBy()
	case actionplan.FieldUpdatedBy:
		return m.UpdatedBy()
	case actionplan.FieldDeletedAt:
		return m.DeletedAt()
	case actionplan.FieldDeletedBy:
		return m.DeletedBy()
	case actionplan.FieldMappingID:
		return m.MappingID()
	case actionplan.FieldTags:
		return m.Tags()
	case actionplan.FieldName:
		return m.Name()
	case actionplan.FieldDescription:
		return m.Description()
	case actionplan.FieldStatus:
		return m.Status()
	case actionplan.FieldDueDate:
		return m.DueDate()
	case actionplan.FieldPriority:
		return m.Priority()
	case actionplan.FieldSource:
		return m.Source()
	case actionplan.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actionplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case actionplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case actionplan.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case actionplan.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case actionplan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case actionplan.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case actionplan.FieldMappingID:
		return m.OldMappingID(ctx)
	case actionplan.FieldTags:
		return m.OldTags(ctx)
	case actionplan.FieldName:
		return m.OldName(ctx)
	case actionplan.FieldDescription:
		return m.OldDescription(ctx)
	case actionplan.FieldStatus:
		return m.OldStatus(ctx)
	case actionplan.FieldDueDate:
		return m.OldDueDate(ctx)
	case actionplan.FieldPriority:
		return m.OldPriority(ctx)
	case actionplan.FieldSource:
		return m.OldSource(ctx)
	case actionplan.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown ActionPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actionplan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case actionplan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case actionplan.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case actionplan.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case actionplan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case actionplan.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case actionplan.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case actionplan.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case actionplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case actionplan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case actionplan.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case actionplan.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case actionplan.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case actionplan.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case actionplan.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown ActionPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionPlanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionPlanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActionPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actionplan.FieldCreatedAt) {
		fields = append(fields, actionplan.FieldCreatedAt)
	}
	if m.FieldCleared(actionplan.FieldUpdatedAt) {
		fields = append(fields, actionplan.FieldUpdatedAt)
	}
	if m.FieldCleared(actionplan.FieldCreatedBy) {
		fields = append(fields, actionplan.FieldCreatedBy)
	}
	if m.FieldCleared(actionplan.FieldUpdatedBy) {
		fields = append(fields, actionplan.FieldUpdatedBy)
	}
	if m.FieldCleared(actionplan.FieldDeletedAt) {
		fields = append(fields, actionplan.FieldDeletedAt)
	}
	if m.FieldCleared(actionplan.FieldDeletedBy) {
		fields = append(fields, actionplan.FieldDeletedBy)
	}
	if m.FieldCleared(actionplan.FieldTags) {
		fields = append(fields, actionplan.FieldTags)
	}
	if m.FieldCleared(actionplan.FieldDescription) {
		fields = append(fields, actionplan.FieldDescription)
	}
	if m.FieldCleared(actionplan.FieldStatus) {
		fields = append(fields, actionplan.FieldStatus)
	}
	if m.FieldCleared(actionplan.FieldDueDate) {
		fields = append(fields, actionplan.FieldDueDate)
	}
	if m.FieldCleared(actionplan.FieldPriority) {
		fields = append(fields, actionplan.FieldPriority)
	}
	if m.FieldCleared(actionplan.FieldSource) {
		fields = append(fields, actionplan.FieldSource)
	}
	if m.FieldCleared(actionplan.FieldDetails) {
		fields = append(fields, actionplan.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionPlanMutation) ClearField(name string) error {
	switch name {
	case actionplan.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case actionplan.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case actionplan.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case actionplan.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case actionplan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case actionplan.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case actionplan.FieldTags:
		m.ClearTags()
		return nil
	case actionplan.FieldDescription:
		m.ClearDescription()
		return nil
	case actionplan.FieldStatus:
		m.ClearStatus()
		return nil
	case actionplan.FieldDueDate:
		m.ClearDueDate()
		return nil
	case actionplan.FieldPriority:
		m.ClearPriority()
		return nil
	case actionplan.FieldSource:
		m.ClearSource()
		return nil
	case actionplan.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown ActionPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionPlanMutation) ResetField(name string) error {
	switch name {
	case actionplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case actionplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case actionplan.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case actionplan.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case actionplan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case actionplan.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case actionplan.FieldMappingID:
		m.ResetMappingID()
		return nil
	case actionplan.FieldTags:
		m.ResetTags()
		return nil
	case actionplan.FieldName:
		m.ResetName()
		return nil
	case actionplan.FieldDescription:
		m.ResetDescription()
		return nil
	case actionplan.FieldStatus:
		m.ResetStatus()
		return nil
	case actionplan.FieldDueDate:
		m.ResetDueDate()
		return nil
	case actionplan.FieldPriority:
		m.ResetPriority()
		return nil
	case actionplan.FieldSource:
		m.ResetSource()
		return nil
	case actionplan.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown ActionPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.standard != nil {
		edges = append(edges, actionplan.EdgeStandard)
	}
	if m.risk != nil {
		edges = append(edges, actionplan.EdgeRisk)
	}
	if m.control != nil {
		edges = append(edges, actionplan.EdgeControl)
	}
	if m.user != nil {
		edges = append(edges, actionplan.EdgeUser)
	}
	if m.program != nil {
		edges = append(edges, actionplan.EdgeProgram)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case actionplan.EdgeStandard:
		ids := make([]ent.Value, 0, len(m.standard))
		for id := range m.standard {
			ids = append(ids, id)
		}
		return ids
	case actionplan.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.risk))
		for id := range m.risk {
			ids = append(ids, id)
		}
		return ids
	case actionplan.EdgeControl:
		ids := make([]ent.Value, 0, len(m.control))
		for id := range m.control {
			ids = append(ids, id)
		}
		return ids
	case actionplan.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case actionplan.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.program))
		for id := range m.program {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedstandard != nil {
		edges = append(edges, actionplan.EdgeStandard)
	}
	if m.removedrisk != nil {
		edges = append(edges, actionplan.EdgeRisk)
	}
	if m.removedcontrol != nil {
		edges = append(edges, actionplan.EdgeControl)
	}
	if m.removeduser != nil {
		edges = append(edges, actionplan.EdgeUser)
	}
	if m.removedprogram != nil {
		edges = append(edges, actionplan.EdgeProgram)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case actionplan.EdgeStandard:
		ids := make([]ent.Value, 0, len(m.removedstandard))
		for id := range m.removedstandard {
			ids = append(ids, id)
		}
		return ids
	case actionplan.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.removedrisk))
		for id := range m.removedrisk {
			ids = append(ids, id)
		}
		return ids
	case actionplan.EdgeControl:
		ids := make([]ent.Value, 0, len(m.removedcontrol))
		for id := range m.removedcontrol {
			ids = append(ids, id)
		}
		return ids
	case actionplan.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case actionplan.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.removedprogram))
		for id := range m.removedprogram {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedstandard {
		edges = append(edges, actionplan.EdgeStandard)
	}
	if m.clearedrisk {
		edges = append(edges, actionplan.EdgeRisk)
	}
	if m.clearedcontrol {
		edges = append(edges, actionplan.EdgeControl)
	}
	if m.cleareduser {
		edges = append(edges, actionplan.EdgeUser)
	}
	if m.clearedprogram {
		edges = append(edges, actionplan.EdgeProgram)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case actionplan.EdgeStandard:
		return m.clearedstandard
	case actionplan.EdgeRisk:
		return m.clearedrisk
	case actionplan.EdgeControl:
		return m.clearedcontrol
	case actionplan.EdgeUser:
		return m.cleareduser
	case actionplan.EdgeProgram:
		return m.clearedprogram
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionPlanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ActionPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionPlanMutation) ResetEdge(name string) error {
	switch name {
	case actionplan.EdgeStandard:
		m.ResetStandard()
		return nil
	case actionplan.EdgeRisk:
		m.ResetRisk()
		return nil
	case actionplan.EdgeControl:
		m.ResetControl()
		return nil
	case actionplan.EdgeUser:
		m.ResetUser()
		return nil
	case actionplan.EdgeProgram:
		m.ResetProgram()
		return nil
	}
	return fmt.Errorf("unknown ActionPlan edge %s", name)
}

// ActionPlanHistoryMutation represents an operation that mutates the ActionPlanHistory nodes in the graph.
type ActionPlanHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	name          *string
	description   *string
	status        *string
	due_date      *time.Time
	priority      *string
	source        *string
	details       *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ActionPlanHistory, error)
	predicates    []predicate.ActionPlanHistory
}

var _ ent.Mutation = (*ActionPlanHistoryMutation)(nil)

// actionplanhistoryOption allows management of the mutation configuration using functional options.
type actionplanhistoryOption func(*ActionPlanHistoryMutation)

// newActionPlanHistoryMutation creates new mutation for the ActionPlanHistory entity.
func newActionPlanHistoryMutation(c config, op Op, opts ...actionplanhistoryOption) *ActionPlanHistoryMutation {
	m := &ActionPlanHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeActionPlanHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionPlanHistoryID sets the ID field of the mutation.
func withActionPlanHistoryID(id string) actionplanhistoryOption {
	return func(m *ActionPlanHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionPlanHistory
		)
		m.oldValue = func(ctx context.Context) (*ActionPlanHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionPlanHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionPlanHistory sets the old ActionPlanHistory of the mutation.
func withActionPlanHistory(node *ActionPlanHistory) actionplanhistoryOption {
	return func(m *ActionPlanHistoryMutation) {
		m.oldValue = func(context.Context) (*ActionPlanHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionPlanHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionPlanHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActionPlanHistory entities.
func (m *ActionPlanHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionPlanHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionPlanHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionPlanHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ActionPlanHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ActionPlanHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ActionPlanHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ActionPlanHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ActionPlanHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ActionPlanHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[actionplanhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ActionPlanHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, actionplanhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ActionPlanHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ActionPlanHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ActionPlanHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ActionPlanHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActionPlanHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ActionPlanHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[actionplanhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActionPlanHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, actionplanhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActionPlanHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActionPlanHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ActionPlanHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[actionplanhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActionPlanHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, actionplanhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ActionPlanHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ActionPlanHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ActionPlanHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[actionplanhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ActionPlanHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, actionplanhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ActionPlanHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ActionPlanHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ActionPlanHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[actionplanhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ActionPlanHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, actionplanhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ActionPlanHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ActionPlanHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ActionPlanHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[actionplanhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ActionPlanHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, actionplanhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ActionPlanHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ActionPlanHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ActionPlanHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[actionplanhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ActionPlanHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, actionplanhistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ActionPlanHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ActionPlanHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ActionPlanHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *ActionPlanHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ActionPlanHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ActionPlanHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ActionPlanHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ActionPlanHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[actionplanhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ActionPlanHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, actionplanhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *ActionPlanHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActionPlanHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActionPlanHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ActionPlanHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActionPlanHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ActionPlanHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[actionplanhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ActionPlanHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, actionplanhistory.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ActionPlanHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ActionPlanHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ActionPlanHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[actionplanhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ActionPlanHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, actionplanhistory.FieldStatus)
}

// SetDueDate sets the "due_date" field.
func (m *ActionPlanHistoryMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ActionPlanHistoryMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *ActionPlanHistoryMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[actionplanhistory.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ActionPlanHistoryMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, actionplanhistory.FieldDueDate)
}

// SetPriority sets the "priority" field.
func (m *ActionPlanHistoryMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ActionPlanHistoryMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *ActionPlanHistoryMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[actionplanhistory.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *ActionPlanHistoryMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, actionplanhistory.FieldPriority)
}

// SetSource sets the "source" field.
func (m *ActionPlanHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ActionPlanHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ActionPlanHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[actionplanhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ActionPlanHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, actionplanhistory.FieldSource)
}

// SetDetails sets the "details" field.
func (m *ActionPlanHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *ActionPlanHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ActionPlanHistory entity.
// If the ActionPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionPlanHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ActionPlanHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[actionplanhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ActionPlanHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[actionplanhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ActionPlanHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, actionplanhistory.FieldDetails)
}

// Where appends a list predicates to the ActionPlanHistoryMutation builder.
func (m *ActionPlanHistoryMutation) Where(ps ...predicate.ActionPlanHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionPlanHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionPlanHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionPlanHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionPlanHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionPlanHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionPlanHistory).
func (m *ActionPlanHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionPlanHistoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.history_time != nil {
		fields = append(fields, actionplanhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, actionplanhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, actionplanhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, actionplanhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, actionplanhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, actionplanhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, actionplanhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, actionplanhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, actionplanhistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, actionplanhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, actionplanhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, actionplanhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, actionplanhistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, actionplanhistory.FieldStatus)
	}
	if m.due_date != nil {
		fields = append(fields, actionplanhistory.FieldDueDate)
	}
	if m.priority != nil {
		fields = append(fields, actionplanhistory.FieldPriority)
	}
	if m.source != nil {
		fields = append(fields, actionplanhistory.FieldSource)
	}
	if m.details != nil {
		fields = append(fields, actionplanhistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionPlanHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actionplanhistory.FieldHistoryTime:
		return m.HistoryTime()
	case actionplanhistory.FieldRef:
		return m.Ref()
	case actionplanhistory.FieldOperation:
		return m.Operation()
	case actionplanhistory.FieldCreatedAt:
		return m.CreatedAt()
	case actionplanhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case actionplanhistory.FieldCreatedBy:
		return m.CreatedBy()
	case actionplanhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case actionplanhistory.FieldDeletedAt:
		return m.DeletedAt()
	case actionplanhistory.FieldDeletedBy:
		return m.DeletedBy()
	case actionplanhistory.FieldMappingID:
		return m.MappingID()
	case actionplanhistory.FieldTags:
		return m.Tags()
	case actionplanhistory.FieldName:
		return m.Name()
	case actionplanhistory.FieldDescription:
		return m.Description()
	case actionplanhistory.FieldStatus:
		return m.Status()
	case actionplanhistory.FieldDueDate:
		return m.DueDate()
	case actionplanhistory.FieldPriority:
		return m.Priority()
	case actionplanhistory.FieldSource:
		return m.Source()
	case actionplanhistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionPlanHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actionplanhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case actionplanhistory.FieldRef:
		return m.OldRef(ctx)
	case actionplanhistory.FieldOperation:
		return m.OldOperation(ctx)
	case actionplanhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case actionplanhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case actionplanhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case actionplanhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case actionplanhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case actionplanhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case actionplanhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case actionplanhistory.FieldTags:
		return m.OldTags(ctx)
	case actionplanhistory.FieldName:
		return m.OldName(ctx)
	case actionplanhistory.FieldDescription:
		return m.OldDescription(ctx)
	case actionplanhistory.FieldStatus:
		return m.OldStatus(ctx)
	case actionplanhistory.FieldDueDate:
		return m.OldDueDate(ctx)
	case actionplanhistory.FieldPriority:
		return m.OldPriority(ctx)
	case actionplanhistory.FieldSource:
		return m.OldSource(ctx)
	case actionplanhistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown ActionPlanHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionPlanHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actionplanhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case actionplanhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case actionplanhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case actionplanhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case actionplanhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case actionplanhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case actionplanhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case actionplanhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case actionplanhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case actionplanhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case actionplanhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case actionplanhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case actionplanhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case actionplanhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case actionplanhistory.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case actionplanhistory.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case actionplanhistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case actionplanhistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown ActionPlanHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionPlanHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionPlanHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionPlanHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActionPlanHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionPlanHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actionplanhistory.FieldRef) {
		fields = append(fields, actionplanhistory.FieldRef)
	}
	if m.FieldCleared(actionplanhistory.FieldCreatedAt) {
		fields = append(fields, actionplanhistory.FieldCreatedAt)
	}
	if m.FieldCleared(actionplanhistory.FieldUpdatedAt) {
		fields = append(fields, actionplanhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(actionplanhistory.FieldCreatedBy) {
		fields = append(fields, actionplanhistory.FieldCreatedBy)
	}
	if m.FieldCleared(actionplanhistory.FieldUpdatedBy) {
		fields = append(fields, actionplanhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(actionplanhistory.FieldDeletedAt) {
		fields = append(fields, actionplanhistory.FieldDeletedAt)
	}
	if m.FieldCleared(actionplanhistory.FieldDeletedBy) {
		fields = append(fields, actionplanhistory.FieldDeletedBy)
	}
	if m.FieldCleared(actionplanhistory.FieldTags) {
		fields = append(fields, actionplanhistory.FieldTags)
	}
	if m.FieldCleared(actionplanhistory.FieldDescription) {
		fields = append(fields, actionplanhistory.FieldDescription)
	}
	if m.FieldCleared(actionplanhistory.FieldStatus) {
		fields = append(fields, actionplanhistory.FieldStatus)
	}
	if m.FieldCleared(actionplanhistory.FieldDueDate) {
		fields = append(fields, actionplanhistory.FieldDueDate)
	}
	if m.FieldCleared(actionplanhistory.FieldPriority) {
		fields = append(fields, actionplanhistory.FieldPriority)
	}
	if m.FieldCleared(actionplanhistory.FieldSource) {
		fields = append(fields, actionplanhistory.FieldSource)
	}
	if m.FieldCleared(actionplanhistory.FieldDetails) {
		fields = append(fields, actionplanhistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionPlanHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionPlanHistoryMutation) ClearField(name string) error {
	switch name {
	case actionplanhistory.FieldRef:
		m.ClearRef()
		return nil
	case actionplanhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case actionplanhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case actionplanhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case actionplanhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case actionplanhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case actionplanhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case actionplanhistory.FieldTags:
		m.ClearTags()
		return nil
	case actionplanhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case actionplanhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case actionplanhistory.FieldDueDate:
		m.ClearDueDate()
		return nil
	case actionplanhistory.FieldPriority:
		m.ClearPriority()
		return nil
	case actionplanhistory.FieldSource:
		m.ClearSource()
		return nil
	case actionplanhistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown ActionPlanHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionPlanHistoryMutation) ResetField(name string) error {
	switch name {
	case actionplanhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case actionplanhistory.FieldRef:
		m.ResetRef()
		return nil
	case actionplanhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case actionplanhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case actionplanhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case actionplanhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case actionplanhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case actionplanhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case actionplanhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case actionplanhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case actionplanhistory.FieldTags:
		m.ResetTags()
		return nil
	case actionplanhistory.FieldName:
		m.ResetName()
		return nil
	case actionplanhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case actionplanhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case actionplanhistory.FieldDueDate:
		m.ResetDueDate()
		return nil
	case actionplanhistory.FieldPriority:
		m.ResetPriority()
		return nil
	case actionplanhistory.FieldSource:
		m.ResetSource()
		return nil
	case actionplanhistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown ActionPlanHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionPlanHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionPlanHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionPlanHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionPlanHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionPlanHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionPlanHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionPlanHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ActionPlanHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionPlanHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ActionPlanHistory edge %s", name)
}

// ContactMutation represents an operation that mutates the Contact nodes in the graph.
type ContactMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	mapping_id      *string
	deleted_at      *time.Time
	deleted_by      *string
	tags            *[]string
	appendtags      []string
	full_name       *string
	title           *string
	company         *string
	email           *string
	phone_number    *string
	address         *string
	status          *enums.UserStatus
	clearedFields   map[string]struct{}
	owner           *string
	clearedowner    bool
	entities        map[string]struct{}
	removedentities map[string]struct{}
	clearedentities bool
	files           map[string]struct{}
	removedfiles    map[string]struct{}
	clearedfiles    bool
	done            bool
	oldValue        func(context.Context) (*Contact, error)
	predicates      []predicate.Contact
}

var _ ent.Mutation = (*ContactMutation)(nil)

// contactOption allows management of the mutation configuration using functional options.
type contactOption func(*ContactMutation)

// newContactMutation creates new mutation for the Contact entity.
func newContactMutation(c config, op Op, opts ...contactOption) *ContactMutation {
	m := &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactID sets the ID field of the mutation.
func withContactID(id string) contactOption {
	return func(m *ContactMutation) {
		var (
			err   error
			once  sync.Once
			value *Contact
		)
		m.oldValue = func(ctx context.Context) (*Contact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContact sets the old Contact of the mutation.
func withContact(node *Contact) contactOption {
	return func(m *ContactMutation) {
		m.oldValue = func(context.Context) (*Contact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contact entities.
func (m *ContactMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContactMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contact.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContactMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contact.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContactMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contact.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContactMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contact.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContactMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contact.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContactMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contact.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ContactMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ContactMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ContactMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[contact.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ContactMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[contact.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ContactMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, contact.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ContactMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ContactMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ContactMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[contact.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ContactMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[contact.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ContactMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, contact.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ContactMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ContactMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ContactMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContactMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContactMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ContactMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[contact.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ContactMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[contact.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContactMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, contact.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ContactMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ContactMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ContactMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[contact.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ContactMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[contact.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ContactMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, contact.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ContactMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ContactMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ContactMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ContactMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ContactMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[contact.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ContactMutation) TagsCleared() bool {
	_, ok := m.clearedFields[contact.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ContactMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, contact.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *ContactMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ContactMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ContactMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[contact.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ContactMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[contact.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ContactMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, contact.FieldOwnerID)
}

// SetFullName sets the "full_name" field.
func (m *ContactMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *ContactMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *ContactMutation) ResetFullName() {
	m.full_name = nil
}

// SetTitle sets the "title" field.
func (m *ContactMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ContactMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ContactMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[contact.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ContactMutation) TitleCleared() bool {
	_, ok := m.clearedFields[contact.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ContactMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, contact.FieldTitle)
}

// SetCompany sets the "company" field.
func (m *ContactMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *ContactMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *ContactMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[contact.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *ContactMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[contact.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *ContactMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, contact.FieldCompany)
}

// SetEmail sets the "email" field.
func (m *ContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ContactMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[contact.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ContactMutation) EmailCleared() bool {
	_, ok := m.clearedFields[contact.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, contact.FieldEmail)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *ContactMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *ContactMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *ContactMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[contact.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *ContactMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[contact.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *ContactMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, contact.FieldPhoneNumber)
}

// SetAddress sets the "address" field.
func (m *ContactMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ContactMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *ContactMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[contact.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *ContactMutation) AddressCleared() bool {
	_, ok := m.clearedFields[contact.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *ContactMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, contact.FieldAddress)
}

// SetStatus sets the "status" field.
func (m *ContactMutation) SetStatus(es enums.UserStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ContactMutation) Status() (r enums.UserStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldStatus(ctx context.Context) (v enums.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ContactMutation) ResetStatus() {
	m.status = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *ContactMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[contact.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *ContactMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ContactMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *ContactMutation) AddEntityIDs(ids ...string) {
	if m.entities == nil {
		m.entities = make(map[string]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *ContactMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *ContactMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *ContactMutation) RemoveEntityIDs(ids ...string) {
	if m.removedentities == nil {
		m.removedentities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *ContactMutation) RemovedEntitiesIDs() (ids []string) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *ContactMutation) EntitiesIDs() (ids []string) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *ContactMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *ContactMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *ContactMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *ContactMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *ContactMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *ContactMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *ContactMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *ContactMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the ContactMutation builder.
func (m *ContactMutation) Where(ps ...predicate.Contact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, contact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contact.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, contact.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, contact.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, contact.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, contact.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, contact.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, contact.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, contact.FieldOwnerID)
	}
	if m.full_name != nil {
		fields = append(fields, contact.FieldFullName)
	}
	if m.title != nil {
		fields = append(fields, contact.FieldTitle)
	}
	if m.company != nil {
		fields = append(fields, contact.FieldCompany)
	}
	if m.email != nil {
		fields = append(fields, contact.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, contact.FieldPhoneNumber)
	}
	if m.address != nil {
		fields = append(fields, contact.FieldAddress)
	}
	if m.status != nil {
		fields = append(fields, contact.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldCreatedAt:
		return m.CreatedAt()
	case contact.FieldUpdatedAt:
		return m.UpdatedAt()
	case contact.FieldCreatedBy:
		return m.CreatedBy()
	case contact.FieldUpdatedBy:
		return m.UpdatedBy()
	case contact.FieldMappingID:
		return m.MappingID()
	case contact.FieldDeletedAt:
		return m.DeletedAt()
	case contact.FieldDeletedBy:
		return m.DeletedBy()
	case contact.FieldTags:
		return m.Tags()
	case contact.FieldOwnerID:
		return m.OwnerID()
	case contact.FieldFullName:
		return m.FullName()
	case contact.FieldTitle:
		return m.Title()
	case contact.FieldCompany:
		return m.Company()
	case contact.FieldEmail:
		return m.Email()
	case contact.FieldPhoneNumber:
		return m.PhoneNumber()
	case contact.FieldAddress:
		return m.Address()
	case contact.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contact.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case contact.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case contact.FieldMappingID:
		return m.OldMappingID(ctx)
	case contact.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case contact.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case contact.FieldTags:
		return m.OldTags(ctx)
	case contact.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case contact.FieldFullName:
		return m.OldFullName(ctx)
	case contact.FieldTitle:
		return m.OldTitle(ctx)
	case contact.FieldCompany:
		return m.OldCompany(ctx)
	case contact.FieldEmail:
		return m.OldEmail(ctx)
	case contact.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case contact.FieldAddress:
		return m.OldAddress(ctx)
	case contact.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Contact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contact.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case contact.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case contact.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case contact.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case contact.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case contact.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case contact.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case contact.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case contact.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case contact.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case contact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contact.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case contact.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case contact.FieldStatus:
		v, ok := value.(enums.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contact.FieldCreatedAt) {
		fields = append(fields, contact.FieldCreatedAt)
	}
	if m.FieldCleared(contact.FieldUpdatedAt) {
		fields = append(fields, contact.FieldUpdatedAt)
	}
	if m.FieldCleared(contact.FieldCreatedBy) {
		fields = append(fields, contact.FieldCreatedBy)
	}
	if m.FieldCleared(contact.FieldUpdatedBy) {
		fields = append(fields, contact.FieldUpdatedBy)
	}
	if m.FieldCleared(contact.FieldDeletedAt) {
		fields = append(fields, contact.FieldDeletedAt)
	}
	if m.FieldCleared(contact.FieldDeletedBy) {
		fields = append(fields, contact.FieldDeletedBy)
	}
	if m.FieldCleared(contact.FieldTags) {
		fields = append(fields, contact.FieldTags)
	}
	if m.FieldCleared(contact.FieldOwnerID) {
		fields = append(fields, contact.FieldOwnerID)
	}
	if m.FieldCleared(contact.FieldTitle) {
		fields = append(fields, contact.FieldTitle)
	}
	if m.FieldCleared(contact.FieldCompany) {
		fields = append(fields, contact.FieldCompany)
	}
	if m.FieldCleared(contact.FieldEmail) {
		fields = append(fields, contact.FieldEmail)
	}
	if m.FieldCleared(contact.FieldPhoneNumber) {
		fields = append(fields, contact.FieldPhoneNumber)
	}
	if m.FieldCleared(contact.FieldAddress) {
		fields = append(fields, contact.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	switch name {
	case contact.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contact.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contact.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case contact.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case contact.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case contact.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case contact.FieldTags:
		m.ClearTags()
		return nil
	case contact.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case contact.FieldTitle:
		m.ClearTitle()
		return nil
	case contact.FieldCompany:
		m.ClearCompany()
		return nil
	case contact.FieldEmail:
		m.ClearEmail()
		return nil
	case contact.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case contact.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contact.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case contact.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case contact.FieldMappingID:
		m.ResetMappingID()
		return nil
	case contact.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case contact.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case contact.FieldTags:
		m.ResetTags()
		return nil
	case contact.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case contact.FieldFullName:
		m.ResetFullName()
		return nil
	case contact.FieldTitle:
		m.ResetTitle()
		return nil
	case contact.FieldCompany:
		m.ResetCompany()
		return nil
	case contact.FieldEmail:
		m.ResetEmail()
		return nil
	case contact.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case contact.FieldAddress:
		m.ResetAddress()
		return nil
	case contact.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, contact.EdgeOwner)
	}
	if m.entities != nil {
		edges = append(edges, contact.EdgeEntities)
	}
	if m.files != nil {
		edges = append(edges, contact.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case contact.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	case contact.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedentities != nil {
		edges = append(edges, contact.EdgeEntities)
	}
	if m.removedfiles != nil {
		edges = append(edges, contact.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	case contact.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, contact.EdgeOwner)
	}
	if m.clearedentities {
		edges = append(edges, contact.EdgeEntities)
	}
	if m.clearedfiles {
		edges = append(edges, contact.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	switch name {
	case contact.EdgeOwner:
		return m.clearedowner
	case contact.EdgeEntities:
		return m.clearedentities
	case contact.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	switch name {
	case contact.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	switch name {
	case contact.EdgeOwner:
		m.ResetOwner()
		return nil
	case contact.EdgeEntities:
		m.ResetEntities()
		return nil
	case contact.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Contact edge %s", name)
}

// ContactHistoryMutation represents an operation that mutates the ContactHistory nodes in the graph.
type ContactHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	full_name     *string
	title         *string
	company       *string
	email         *string
	phone_number  *string
	address       *string
	status        *enums.UserStatus
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ContactHistory, error)
	predicates    []predicate.ContactHistory
}

var _ ent.Mutation = (*ContactHistoryMutation)(nil)

// contacthistoryOption allows management of the mutation configuration using functional options.
type contacthistoryOption func(*ContactHistoryMutation)

// newContactHistoryMutation creates new mutation for the ContactHistory entity.
func newContactHistoryMutation(c config, op Op, opts ...contacthistoryOption) *ContactHistoryMutation {
	m := &ContactHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeContactHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactHistoryID sets the ID field of the mutation.
func withContactHistoryID(id string) contacthistoryOption {
	return func(m *ContactHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ContactHistory
		)
		m.oldValue = func(ctx context.Context) (*ContactHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContactHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContactHistory sets the old ContactHistory of the mutation.
func withContactHistory(node *ContactHistory) contacthistoryOption {
	return func(m *ContactHistoryMutation) {
		m.oldValue = func(context.Context) (*ContactHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContactHistory entities.
func (m *ContactHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContactHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ContactHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ContactHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ContactHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ContactHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ContactHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ContactHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[contacthistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ContactHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ContactHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, contacthistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ContactHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ContactHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ContactHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ContactHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContactHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ContactHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[contacthistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ContactHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContactHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, contacthistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContactHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContactHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ContactHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[contacthistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ContactHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContactHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, contacthistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ContactHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ContactHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ContactHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[contacthistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ContactHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ContactHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, contacthistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ContactHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ContactHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ContactHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[contacthistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ContactHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ContactHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, contacthistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ContactHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ContactHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ContactHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContactHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContactHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ContactHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[contacthistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ContactHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContactHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, contacthistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ContactHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ContactHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ContactHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[contacthistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ContactHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ContactHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, contacthistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ContactHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ContactHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ContactHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ContactHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ContactHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[contacthistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ContactHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ContactHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, contacthistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *ContactHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ContactHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *ContactHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[contacthistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *ContactHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ContactHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, contacthistory.FieldOwnerID)
}

// SetFullName sets the "full_name" field.
func (m *ContactHistoryMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *ContactHistoryMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *ContactHistoryMutation) ResetFullName() {
	m.full_name = nil
}

// SetTitle sets the "title" field.
func (m *ContactHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ContactHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ContactHistoryMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[contacthistory.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ContactHistoryMutation) TitleCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ContactHistoryMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, contacthistory.FieldTitle)
}

// SetCompany sets the "company" field.
func (m *ContactHistoryMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *ContactHistoryMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *ContactHistoryMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[contacthistory.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *ContactHistoryMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *ContactHistoryMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, contacthistory.FieldCompany)
}

// SetEmail sets the "email" field.
func (m *ContactHistoryMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactHistoryMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ContactHistoryMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[contacthistory.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ContactHistoryMutation) EmailCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactHistoryMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, contacthistory.FieldEmail)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *ContactHistoryMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *ContactHistoryMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *ContactHistoryMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[contacthistory.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *ContactHistoryMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *ContactHistoryMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, contacthistory.FieldPhoneNumber)
}

// SetAddress sets the "address" field.
func (m *ContactHistoryMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ContactHistoryMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *ContactHistoryMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[contacthistory.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *ContactHistoryMutation) AddressCleared() bool {
	_, ok := m.clearedFields[contacthistory.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *ContactHistoryMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, contacthistory.FieldAddress)
}

// SetStatus sets the "status" field.
func (m *ContactHistoryMutation) SetStatus(es enums.UserStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ContactHistoryMutation) Status() (r enums.UserStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ContactHistory entity.
// If the ContactHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactHistoryMutation) OldStatus(ctx context.Context) (v enums.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ContactHistoryMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the ContactHistoryMutation builder.
func (m *ContactHistoryMutation) Where(ps ...predicate.ContactHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContactHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContactHistory).
func (m *ContactHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, contacthistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, contacthistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, contacthistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, contacthistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contacthistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, contacthistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, contacthistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, contacthistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, contacthistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, contacthistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, contacthistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, contacthistory.FieldOwnerID)
	}
	if m.full_name != nil {
		fields = append(fields, contacthistory.FieldFullName)
	}
	if m.title != nil {
		fields = append(fields, contacthistory.FieldTitle)
	}
	if m.company != nil {
		fields = append(fields, contacthistory.FieldCompany)
	}
	if m.email != nil {
		fields = append(fields, contacthistory.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, contacthistory.FieldPhoneNumber)
	}
	if m.address != nil {
		fields = append(fields, contacthistory.FieldAddress)
	}
	if m.status != nil {
		fields = append(fields, contacthistory.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contacthistory.FieldHistoryTime:
		return m.HistoryTime()
	case contacthistory.FieldRef:
		return m.Ref()
	case contacthistory.FieldOperation:
		return m.Operation()
	case contacthistory.FieldCreatedAt:
		return m.CreatedAt()
	case contacthistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case contacthistory.FieldCreatedBy:
		return m.CreatedBy()
	case contacthistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case contacthistory.FieldMappingID:
		return m.MappingID()
	case contacthistory.FieldDeletedAt:
		return m.DeletedAt()
	case contacthistory.FieldDeletedBy:
		return m.DeletedBy()
	case contacthistory.FieldTags:
		return m.Tags()
	case contacthistory.FieldOwnerID:
		return m.OwnerID()
	case contacthistory.FieldFullName:
		return m.FullName()
	case contacthistory.FieldTitle:
		return m.Title()
	case contacthistory.FieldCompany:
		return m.Company()
	case contacthistory.FieldEmail:
		return m.Email()
	case contacthistory.FieldPhoneNumber:
		return m.PhoneNumber()
	case contacthistory.FieldAddress:
		return m.Address()
	case contacthistory.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contacthistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case contacthistory.FieldRef:
		return m.OldRef(ctx)
	case contacthistory.FieldOperation:
		return m.OldOperation(ctx)
	case contacthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contacthistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contacthistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case contacthistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case contacthistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case contacthistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case contacthistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case contacthistory.FieldTags:
		return m.OldTags(ctx)
	case contacthistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case contacthistory.FieldFullName:
		return m.OldFullName(ctx)
	case contacthistory.FieldTitle:
		return m.OldTitle(ctx)
	case contacthistory.FieldCompany:
		return m.OldCompany(ctx)
	case contacthistory.FieldEmail:
		return m.OldEmail(ctx)
	case contacthistory.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case contacthistory.FieldAddress:
		return m.OldAddress(ctx)
	case contacthistory.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ContactHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contacthistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case contacthistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case contacthistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case contacthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contacthistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contacthistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case contacthistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case contacthistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case contacthistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case contacthistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case contacthistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case contacthistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case contacthistory.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case contacthistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case contacthistory.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case contacthistory.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contacthistory.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case contacthistory.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case contacthistory.FieldStatus:
		v, ok := value.(enums.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ContactHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ContactHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contacthistory.FieldRef) {
		fields = append(fields, contacthistory.FieldRef)
	}
	if m.FieldCleared(contacthistory.FieldCreatedAt) {
		fields = append(fields, contacthistory.FieldCreatedAt)
	}
	if m.FieldCleared(contacthistory.FieldUpdatedAt) {
		fields = append(fields, contacthistory.FieldUpdatedAt)
	}
	if m.FieldCleared(contacthistory.FieldCreatedBy) {
		fields = append(fields, contacthistory.FieldCreatedBy)
	}
	if m.FieldCleared(contacthistory.FieldUpdatedBy) {
		fields = append(fields, contacthistory.FieldUpdatedBy)
	}
	if m.FieldCleared(contacthistory.FieldDeletedAt) {
		fields = append(fields, contacthistory.FieldDeletedAt)
	}
	if m.FieldCleared(contacthistory.FieldDeletedBy) {
		fields = append(fields, contacthistory.FieldDeletedBy)
	}
	if m.FieldCleared(contacthistory.FieldTags) {
		fields = append(fields, contacthistory.FieldTags)
	}
	if m.FieldCleared(contacthistory.FieldOwnerID) {
		fields = append(fields, contacthistory.FieldOwnerID)
	}
	if m.FieldCleared(contacthistory.FieldTitle) {
		fields = append(fields, contacthistory.FieldTitle)
	}
	if m.FieldCleared(contacthistory.FieldCompany) {
		fields = append(fields, contacthistory.FieldCompany)
	}
	if m.FieldCleared(contacthistory.FieldEmail) {
		fields = append(fields, contacthistory.FieldEmail)
	}
	if m.FieldCleared(contacthistory.FieldPhoneNumber) {
		fields = append(fields, contacthistory.FieldPhoneNumber)
	}
	if m.FieldCleared(contacthistory.FieldAddress) {
		fields = append(fields, contacthistory.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactHistoryMutation) ClearField(name string) error {
	switch name {
	case contacthistory.FieldRef:
		m.ClearRef()
		return nil
	case contacthistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case contacthistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case contacthistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case contacthistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case contacthistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case contacthistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case contacthistory.FieldTags:
		m.ClearTags()
		return nil
	case contacthistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case contacthistory.FieldTitle:
		m.ClearTitle()
		return nil
	case contacthistory.FieldCompany:
		m.ClearCompany()
		return nil
	case contacthistory.FieldEmail:
		m.ClearEmail()
		return nil
	case contacthistory.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case contacthistory.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown ContactHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactHistoryMutation) ResetField(name string) error {
	switch name {
	case contacthistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case contacthistory.FieldRef:
		m.ResetRef()
		return nil
	case contacthistory.FieldOperation:
		m.ResetOperation()
		return nil
	case contacthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contacthistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contacthistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case contacthistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case contacthistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case contacthistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case contacthistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case contacthistory.FieldTags:
		m.ResetTags()
		return nil
	case contacthistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case contacthistory.FieldFullName:
		m.ResetFullName()
		return nil
	case contacthistory.FieldTitle:
		m.ResetTitle()
		return nil
	case contacthistory.FieldCompany:
		m.ResetCompany()
		return nil
	case contacthistory.FieldEmail:
		m.ResetEmail()
		return nil
	case contacthistory.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case contacthistory.FieldAddress:
		m.ResetAddress()
		return nil
	case contacthistory.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ContactHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ContactHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ContactHistory edge %s", name)
}

// ControlMutation represents an operation that mutates the Control nodes in the graph.
type ControlMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	deleted_at               *time.Time
	deleted_by               *string
	mapping_id               *string
	tags                     *[]string
	appendtags               []string
	name                     *string
	description              *string
	status                   *string
	control_type             *string
	version                  *string
	control_number           *string
	family                   *string
	class                    *string
	source                   *string
	satisfies                *string
	mapped_frameworks        *string
	details                  *map[string]interface{}
	clearedFields            map[string]struct{}
	procedures               map[string]struct{}
	removedprocedures        map[string]struct{}
	clearedprocedures        bool
	subcontrols              map[string]struct{}
	removedsubcontrols       map[string]struct{}
	clearedsubcontrols       bool
	controlobjectives        map[string]struct{}
	removedcontrolobjectives map[string]struct{}
	clearedcontrolobjectives bool
	standard                 map[string]struct{}
	removedstandard          map[string]struct{}
	clearedstandard          bool
	narratives               map[string]struct{}
	removednarratives        map[string]struct{}
	clearednarratives        bool
	risks                    map[string]struct{}
	removedrisks             map[string]struct{}
	clearedrisks             bool
	actionplans              map[string]struct{}
	removedactionplans       map[string]struct{}
	clearedactionplans       bool
	tasks                    map[string]struct{}
	removedtasks             map[string]struct{}
	clearedtasks             bool
	programs                 map[string]struct{}
	removedprograms          map[string]struct{}
	clearedprograms          bool
	done                     bool
	oldValue                 func(context.Context) (*Control, error)
	predicates               []predicate.Control
}

var _ ent.Mutation = (*ControlMutation)(nil)

// controlOption allows management of the mutation configuration using functional options.
type controlOption func(*ControlMutation)

// newControlMutation creates new mutation for the Control entity.
func newControlMutation(c config, op Op, opts ...controlOption) *ControlMutation {
	m := &ControlMutation{
		config:        c,
		op:            op,
		typ:           TypeControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withControlID sets the ID field of the mutation.
func withControlID(id string) controlOption {
	return func(m *ControlMutation) {
		var (
			err   error
			once  sync.Once
			value *Control
		)
		m.oldValue = func(ctx context.Context) (*Control, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Control.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withControl sets the old Control of the mutation.
func withControl(node *Control) controlOption {
	return func(m *ControlMutation) {
		m.oldValue = func(context.Context) (*Control, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Control entities.
func (m *ControlMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ControlMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ControlMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Control.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ControlMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[control.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ControlMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[control.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ControlMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, control.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ControlMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[control.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ControlMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[control.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, control.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ControlMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ControlMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ControlMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[control.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ControlMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[control.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ControlMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, control.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ControlMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ControlMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ControlMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[control.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ControlMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[control.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ControlMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, control.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ControlMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ControlMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ControlMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[control.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ControlMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[control.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ControlMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, control.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ControlMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ControlMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ControlMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[control.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ControlMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[control.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ControlMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, control.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ControlMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ControlMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ControlMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *ControlMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ControlMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ControlMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ControlMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ControlMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[control.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ControlMutation) TagsCleared() bool {
	_, ok := m.clearedFields[control.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ControlMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, control.FieldTags)
}

// SetName sets the "name" field.
func (m *ControlMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ControlMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ControlMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ControlMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ControlMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ControlMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[control.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ControlMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[control.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ControlMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, control.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ControlMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ControlMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ControlMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[control.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ControlMutation) StatusCleared() bool {
	_, ok := m.clearedFields[control.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ControlMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, control.FieldStatus)
}

// SetControlType sets the "control_type" field.
func (m *ControlMutation) SetControlType(s string) {
	m.control_type = &s
}

// ControlType returns the value of the "control_type" field in the mutation.
func (m *ControlMutation) ControlType() (r string, exists bool) {
	v := m.control_type
	if v == nil {
		return
	}
	return *v, true
}

// OldControlType returns the old "control_type" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldControlType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlType: %w", err)
	}
	return oldValue.ControlType, nil
}

// ClearControlType clears the value of the "control_type" field.
func (m *ControlMutation) ClearControlType() {
	m.control_type = nil
	m.clearedFields[control.FieldControlType] = struct{}{}
}

// ControlTypeCleared returns if the "control_type" field was cleared in this mutation.
func (m *ControlMutation) ControlTypeCleared() bool {
	_, ok := m.clearedFields[control.FieldControlType]
	return ok
}

// ResetControlType resets all changes to the "control_type" field.
func (m *ControlMutation) ResetControlType() {
	m.control_type = nil
	delete(m.clearedFields, control.FieldControlType)
}

// SetVersion sets the "version" field.
func (m *ControlMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ControlMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ControlMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[control.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ControlMutation) VersionCleared() bool {
	_, ok := m.clearedFields[control.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ControlMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, control.FieldVersion)
}

// SetControlNumber sets the "control_number" field.
func (m *ControlMutation) SetControlNumber(s string) {
	m.control_number = &s
}

// ControlNumber returns the value of the "control_number" field in the mutation.
func (m *ControlMutation) ControlNumber() (r string, exists bool) {
	v := m.control_number
	if v == nil {
		return
	}
	return *v, true
}

// OldControlNumber returns the old "control_number" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldControlNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlNumber: %w", err)
	}
	return oldValue.ControlNumber, nil
}

// ClearControlNumber clears the value of the "control_number" field.
func (m *ControlMutation) ClearControlNumber() {
	m.control_number = nil
	m.clearedFields[control.FieldControlNumber] = struct{}{}
}

// ControlNumberCleared returns if the "control_number" field was cleared in this mutation.
func (m *ControlMutation) ControlNumberCleared() bool {
	_, ok := m.clearedFields[control.FieldControlNumber]
	return ok
}

// ResetControlNumber resets all changes to the "control_number" field.
func (m *ControlMutation) ResetControlNumber() {
	m.control_number = nil
	delete(m.clearedFields, control.FieldControlNumber)
}

// SetFamily sets the "family" field.
func (m *ControlMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *ControlMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ClearFamily clears the value of the "family" field.
func (m *ControlMutation) ClearFamily() {
	m.family = nil
	m.clearedFields[control.FieldFamily] = struct{}{}
}

// FamilyCleared returns if the "family" field was cleared in this mutation.
func (m *ControlMutation) FamilyCleared() bool {
	_, ok := m.clearedFields[control.FieldFamily]
	return ok
}

// ResetFamily resets all changes to the "family" field.
func (m *ControlMutation) ResetFamily() {
	m.family = nil
	delete(m.clearedFields, control.FieldFamily)
}

// SetClass sets the "class" field.
func (m *ControlMutation) SetClass(s string) {
	m.class = &s
}

// Class returns the value of the "class" field in the mutation.
func (m *ControlMutation) Class() (r string, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ClearClass clears the value of the "class" field.
func (m *ControlMutation) ClearClass() {
	m.class = nil
	m.clearedFields[control.FieldClass] = struct{}{}
}

// ClassCleared returns if the "class" field was cleared in this mutation.
func (m *ControlMutation) ClassCleared() bool {
	_, ok := m.clearedFields[control.FieldClass]
	return ok
}

// ResetClass resets all changes to the "class" field.
func (m *ControlMutation) ResetClass() {
	m.class = nil
	delete(m.clearedFields, control.FieldClass)
}

// SetSource sets the "source" field.
func (m *ControlMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ControlMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ControlMutation) ClearSource() {
	m.source = nil
	m.clearedFields[control.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ControlMutation) SourceCleared() bool {
	_, ok := m.clearedFields[control.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ControlMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, control.FieldSource)
}

// SetSatisfies sets the "satisfies" field.
func (m *ControlMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *ControlMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *ControlMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[control.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *ControlMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[control.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *ControlMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, control.FieldSatisfies)
}

// SetMappedFrameworks sets the "mapped_frameworks" field.
func (m *ControlMutation) SetMappedFrameworks(s string) {
	m.mapped_frameworks = &s
}

// MappedFrameworks returns the value of the "mapped_frameworks" field in the mutation.
func (m *ControlMutation) MappedFrameworks() (r string, exists bool) {
	v := m.mapped_frameworks
	if v == nil {
		return
	}
	return *v, true
}

// OldMappedFrameworks returns the old "mapped_frameworks" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldMappedFrameworks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappedFrameworks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappedFrameworks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappedFrameworks: %w", err)
	}
	return oldValue.MappedFrameworks, nil
}

// ClearMappedFrameworks clears the value of the "mapped_frameworks" field.
func (m *ControlMutation) ClearMappedFrameworks() {
	m.mapped_frameworks = nil
	m.clearedFields[control.FieldMappedFrameworks] = struct{}{}
}

// MappedFrameworksCleared returns if the "mapped_frameworks" field was cleared in this mutation.
func (m *ControlMutation) MappedFrameworksCleared() bool {
	_, ok := m.clearedFields[control.FieldMappedFrameworks]
	return ok
}

// ResetMappedFrameworks resets all changes to the "mapped_frameworks" field.
func (m *ControlMutation) ResetMappedFrameworks() {
	m.mapped_frameworks = nil
	delete(m.clearedFields, control.FieldMappedFrameworks)
}

// SetDetails sets the "details" field.
func (m *ControlMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *ControlMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Control entity.
// If the Control object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ControlMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[control.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ControlMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[control.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ControlMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, control.FieldDetails)
}

// AddProcedureIDs adds the "procedures" edge to the Procedure entity by ids.
func (m *ControlMutation) AddProcedureIDs(ids ...string) {
	if m.procedures == nil {
		m.procedures = make(map[string]struct{})
	}
	for i := range ids {
		m.procedures[ids[i]] = struct{}{}
	}
}

// ClearProcedures clears the "procedures" edge to the Procedure entity.
func (m *ControlMutation) ClearProcedures() {
	m.clearedprocedures = true
}

// ProceduresCleared reports if the "procedures" edge to the Procedure entity was cleared.
func (m *ControlMutation) ProceduresCleared() bool {
	return m.clearedprocedures
}

// RemoveProcedureIDs removes the "procedures" edge to the Procedure entity by IDs.
func (m *ControlMutation) RemoveProcedureIDs(ids ...string) {
	if m.removedprocedures == nil {
		m.removedprocedures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.procedures, ids[i])
		m.removedprocedures[ids[i]] = struct{}{}
	}
}

// RemovedProcedures returns the removed IDs of the "procedures" edge to the Procedure entity.
func (m *ControlMutation) RemovedProceduresIDs() (ids []string) {
	for id := range m.removedprocedures {
		ids = append(ids, id)
	}
	return
}

// ProceduresIDs returns the "procedures" edge IDs in the mutation.
func (m *ControlMutation) ProceduresIDs() (ids []string) {
	for id := range m.procedures {
		ids = append(ids, id)
	}
	return
}

// ResetProcedures resets all changes to the "procedures" edge.
func (m *ControlMutation) ResetProcedures() {
	m.procedures = nil
	m.clearedprocedures = false
	m.removedprocedures = nil
}

// AddSubcontrolIDs adds the "subcontrols" edge to the Subcontrol entity by ids.
func (m *ControlMutation) AddSubcontrolIDs(ids ...string) {
	if m.subcontrols == nil {
		m.subcontrols = make(map[string]struct{})
	}
	for i := range ids {
		m.subcontrols[ids[i]] = struct{}{}
	}
}

// ClearSubcontrols clears the "subcontrols" edge to the Subcontrol entity.
func (m *ControlMutation) ClearSubcontrols() {
	m.clearedsubcontrols = true
}

// SubcontrolsCleared reports if the "subcontrols" edge to the Subcontrol entity was cleared.
func (m *ControlMutation) SubcontrolsCleared() bool {
	return m.clearedsubcontrols
}

// RemoveSubcontrolIDs removes the "subcontrols" edge to the Subcontrol entity by IDs.
func (m *ControlMutation) RemoveSubcontrolIDs(ids ...string) {
	if m.removedsubcontrols == nil {
		m.removedsubcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subcontrols, ids[i])
		m.removedsubcontrols[ids[i]] = struct{}{}
	}
}

// RemovedSubcontrols returns the removed IDs of the "subcontrols" edge to the Subcontrol entity.
func (m *ControlMutation) RemovedSubcontrolsIDs() (ids []string) {
	for id := range m.removedsubcontrols {
		ids = append(ids, id)
	}
	return
}

// SubcontrolsIDs returns the "subcontrols" edge IDs in the mutation.
func (m *ControlMutation) SubcontrolsIDs() (ids []string) {
	for id := range m.subcontrols {
		ids = append(ids, id)
	}
	return
}

// ResetSubcontrols resets all changes to the "subcontrols" edge.
func (m *ControlMutation) ResetSubcontrols() {
	m.subcontrols = nil
	m.clearedsubcontrols = false
	m.removedsubcontrols = nil
}

// AddControlobjectiveIDs adds the "controlobjectives" edge to the ControlObjective entity by ids.
func (m *ControlMutation) AddControlobjectiveIDs(ids ...string) {
	if m.controlobjectives == nil {
		m.controlobjectives = make(map[string]struct{})
	}
	for i := range ids {
		m.controlobjectives[ids[i]] = struct{}{}
	}
}

// ClearControlobjectives clears the "controlobjectives" edge to the ControlObjective entity.
func (m *ControlMutation) ClearControlobjectives() {
	m.clearedcontrolobjectives = true
}

// ControlobjectivesCleared reports if the "controlobjectives" edge to the ControlObjective entity was cleared.
func (m *ControlMutation) ControlobjectivesCleared() bool {
	return m.clearedcontrolobjectives
}

// RemoveControlobjectiveIDs removes the "controlobjectives" edge to the ControlObjective entity by IDs.
func (m *ControlMutation) RemoveControlobjectiveIDs(ids ...string) {
	if m.removedcontrolobjectives == nil {
		m.removedcontrolobjectives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controlobjectives, ids[i])
		m.removedcontrolobjectives[ids[i]] = struct{}{}
	}
}

// RemovedControlobjectives returns the removed IDs of the "controlobjectives" edge to the ControlObjective entity.
func (m *ControlMutation) RemovedControlobjectivesIDs() (ids []string) {
	for id := range m.removedcontrolobjectives {
		ids = append(ids, id)
	}
	return
}

// ControlobjectivesIDs returns the "controlobjectives" edge IDs in the mutation.
func (m *ControlMutation) ControlobjectivesIDs() (ids []string) {
	for id := range m.controlobjectives {
		ids = append(ids, id)
	}
	return
}

// ResetControlobjectives resets all changes to the "controlobjectives" edge.
func (m *ControlMutation) ResetControlobjectives() {
	m.controlobjectives = nil
	m.clearedcontrolobjectives = false
	m.removedcontrolobjectives = nil
}

// AddStandardIDs adds the "standard" edge to the Standard entity by ids.
func (m *ControlMutation) AddStandardIDs(ids ...string) {
	if m.standard == nil {
		m.standard = make(map[string]struct{})
	}
	for i := range ids {
		m.standard[ids[i]] = struct{}{}
	}
}

// ClearStandard clears the "standard" edge to the Standard entity.
func (m *ControlMutation) ClearStandard() {
	m.clearedstandard = true
}

// StandardCleared reports if the "standard" edge to the Standard entity was cleared.
func (m *ControlMutation) StandardCleared() bool {
	return m.clearedstandard
}

// RemoveStandardIDs removes the "standard" edge to the Standard entity by IDs.
func (m *ControlMutation) RemoveStandardIDs(ids ...string) {
	if m.removedstandard == nil {
		m.removedstandard = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.standard, ids[i])
		m.removedstandard[ids[i]] = struct{}{}
	}
}

// RemovedStandard returns the removed IDs of the "standard" edge to the Standard entity.
func (m *ControlMutation) RemovedStandardIDs() (ids []string) {
	for id := range m.removedstandard {
		ids = append(ids, id)
	}
	return
}

// StandardIDs returns the "standard" edge IDs in the mutation.
func (m *ControlMutation) StandardIDs() (ids []string) {
	for id := range m.standard {
		ids = append(ids, id)
	}
	return
}

// ResetStandard resets all changes to the "standard" edge.
func (m *ControlMutation) ResetStandard() {
	m.standard = nil
	m.clearedstandard = false
	m.removedstandard = nil
}

// AddNarrativeIDs adds the "narratives" edge to the Narrative entity by ids.
func (m *ControlMutation) AddNarrativeIDs(ids ...string) {
	if m.narratives == nil {
		m.narratives = make(map[string]struct{})
	}
	for i := range ids {
		m.narratives[ids[i]] = struct{}{}
	}
}

// ClearNarratives clears the "narratives" edge to the Narrative entity.
func (m *ControlMutation) ClearNarratives() {
	m.clearednarratives = true
}

// NarrativesCleared reports if the "narratives" edge to the Narrative entity was cleared.
func (m *ControlMutation) NarrativesCleared() bool {
	return m.clearednarratives
}

// RemoveNarrativeIDs removes the "narratives" edge to the Narrative entity by IDs.
func (m *ControlMutation) RemoveNarrativeIDs(ids ...string) {
	if m.removednarratives == nil {
		m.removednarratives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.narratives, ids[i])
		m.removednarratives[ids[i]] = struct{}{}
	}
}

// RemovedNarratives returns the removed IDs of the "narratives" edge to the Narrative entity.
func (m *ControlMutation) RemovedNarrativesIDs() (ids []string) {
	for id := range m.removednarratives {
		ids = append(ids, id)
	}
	return
}

// NarrativesIDs returns the "narratives" edge IDs in the mutation.
func (m *ControlMutation) NarrativesIDs() (ids []string) {
	for id := range m.narratives {
		ids = append(ids, id)
	}
	return
}

// ResetNarratives resets all changes to the "narratives" edge.
func (m *ControlMutation) ResetNarratives() {
	m.narratives = nil
	m.clearednarratives = false
	m.removednarratives = nil
}

// AddRiskIDs adds the "risks" edge to the Risk entity by ids.
func (m *ControlMutation) AddRiskIDs(ids ...string) {
	if m.risks == nil {
		m.risks = make(map[string]struct{})
	}
	for i := range ids {
		m.risks[ids[i]] = struct{}{}
	}
}

// ClearRisks clears the "risks" edge to the Risk entity.
func (m *ControlMutation) ClearRisks() {
	m.clearedrisks = true
}

// RisksCleared reports if the "risks" edge to the Risk entity was cleared.
func (m *ControlMutation) RisksCleared() bool {
	return m.clearedrisks
}

// RemoveRiskIDs removes the "risks" edge to the Risk entity by IDs.
func (m *ControlMutation) RemoveRiskIDs(ids ...string) {
	if m.removedrisks == nil {
		m.removedrisks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.risks, ids[i])
		m.removedrisks[ids[i]] = struct{}{}
	}
}

// RemovedRisks returns the removed IDs of the "risks" edge to the Risk entity.
func (m *ControlMutation) RemovedRisksIDs() (ids []string) {
	for id := range m.removedrisks {
		ids = append(ids, id)
	}
	return
}

// RisksIDs returns the "risks" edge IDs in the mutation.
func (m *ControlMutation) RisksIDs() (ids []string) {
	for id := range m.risks {
		ids = append(ids, id)
	}
	return
}

// ResetRisks resets all changes to the "risks" edge.
func (m *ControlMutation) ResetRisks() {
	m.risks = nil
	m.clearedrisks = false
	m.removedrisks = nil
}

// AddActionplanIDs adds the "actionplans" edge to the ActionPlan entity by ids.
func (m *ControlMutation) AddActionplanIDs(ids ...string) {
	if m.actionplans == nil {
		m.actionplans = make(map[string]struct{})
	}
	for i := range ids {
		m.actionplans[ids[i]] = struct{}{}
	}
}

// ClearActionplans clears the "actionplans" edge to the ActionPlan entity.
func (m *ControlMutation) ClearActionplans() {
	m.clearedactionplans = true
}

// ActionplansCleared reports if the "actionplans" edge to the ActionPlan entity was cleared.
func (m *ControlMutation) ActionplansCleared() bool {
	return m.clearedactionplans
}

// RemoveActionplanIDs removes the "actionplans" edge to the ActionPlan entity by IDs.
func (m *ControlMutation) RemoveActionplanIDs(ids ...string) {
	if m.removedactionplans == nil {
		m.removedactionplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.actionplans, ids[i])
		m.removedactionplans[ids[i]] = struct{}{}
	}
}

// RemovedActionplans returns the removed IDs of the "actionplans" edge to the ActionPlan entity.
func (m *ControlMutation) RemovedActionplansIDs() (ids []string) {
	for id := range m.removedactionplans {
		ids = append(ids, id)
	}
	return
}

// ActionplansIDs returns the "actionplans" edge IDs in the mutation.
func (m *ControlMutation) ActionplansIDs() (ids []string) {
	for id := range m.actionplans {
		ids = append(ids, id)
	}
	return
}

// ResetActionplans resets all changes to the "actionplans" edge.
func (m *ControlMutation) ResetActionplans() {
	m.actionplans = nil
	m.clearedactionplans = false
	m.removedactionplans = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ControlMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ControlMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ControlMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ControlMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ControlMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ControlMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ControlMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *ControlMutation) AddProgramIDs(ids ...string) {
	if m.programs == nil {
		m.programs = make(map[string]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *ControlMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *ControlMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *ControlMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *ControlMutation) RemovedProgramsIDs() (ids []string) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *ControlMutation) ProgramsIDs() (ids []string) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *ControlMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// Where appends a list predicates to the ControlMutation builder.
func (m *ControlMutation) Where(ps ...predicate.Control) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Control, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Control).
func (m *ControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ControlMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, control.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, control.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, control.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, control.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, control.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, control.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, control.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, control.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, control.FieldName)
	}
	if m.description != nil {
		fields = append(fields, control.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, control.FieldStatus)
	}
	if m.control_type != nil {
		fields = append(fields, control.FieldControlType)
	}
	if m.version != nil {
		fields = append(fields, control.FieldVersion)
	}
	if m.control_number != nil {
		fields = append(fields, control.FieldControlNumber)
	}
	if m.family != nil {
		fields = append(fields, control.FieldFamily)
	}
	if m.class != nil {
		fields = append(fields, control.FieldClass)
	}
	if m.source != nil {
		fields = append(fields, control.FieldSource)
	}
	if m.satisfies != nil {
		fields = append(fields, control.FieldSatisfies)
	}
	if m.mapped_frameworks != nil {
		fields = append(fields, control.FieldMappedFrameworks)
	}
	if m.details != nil {
		fields = append(fields, control.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case control.FieldCreatedAt:
		return m.CreatedAt()
	case control.FieldUpdatedAt:
		return m.UpdatedAt()
	case control.FieldCreatedBy:
		return m.CreatedBy()
	case control.FieldUpdatedBy:
		return m.UpdatedBy()
	case control.FieldDeletedAt:
		return m.DeletedAt()
	case control.FieldDeletedBy:
		return m.DeletedBy()
	case control.FieldMappingID:
		return m.MappingID()
	case control.FieldTags:
		return m.Tags()
	case control.FieldName:
		return m.Name()
	case control.FieldDescription:
		return m.Description()
	case control.FieldStatus:
		return m.Status()
	case control.FieldControlType:
		return m.ControlType()
	case control.FieldVersion:
		return m.Version()
	case control.FieldControlNumber:
		return m.ControlNumber()
	case control.FieldFamily:
		return m.Family()
	case control.FieldClass:
		return m.Class()
	case control.FieldSource:
		return m.Source()
	case control.FieldSatisfies:
		return m.Satisfies()
	case control.FieldMappedFrameworks:
		return m.MappedFrameworks()
	case control.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case control.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case control.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case control.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case control.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case control.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case control.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case control.FieldMappingID:
		return m.OldMappingID(ctx)
	case control.FieldTags:
		return m.OldTags(ctx)
	case control.FieldName:
		return m.OldName(ctx)
	case control.FieldDescription:
		return m.OldDescription(ctx)
	case control.FieldStatus:
		return m.OldStatus(ctx)
	case control.FieldControlType:
		return m.OldControlType(ctx)
	case control.FieldVersion:
		return m.OldVersion(ctx)
	case control.FieldControlNumber:
		return m.OldControlNumber(ctx)
	case control.FieldFamily:
		return m.OldFamily(ctx)
	case control.FieldClass:
		return m.OldClass(ctx)
	case control.FieldSource:
		return m.OldSource(ctx)
	case control.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case control.FieldMappedFrameworks:
		return m.OldMappedFrameworks(ctx)
	case control.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Control field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case control.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case control.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case control.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case control.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case control.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case control.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case control.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case control.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case control.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case control.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case control.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case control.FieldControlType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlType(v)
		return nil
	case control.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case control.FieldControlNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlNumber(v)
		return nil
	case control.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case control.FieldClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case control.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case control.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case control.FieldMappedFrameworks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappedFrameworks(v)
		return nil
	case control.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Control field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Control numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(control.FieldCreatedAt) {
		fields = append(fields, control.FieldCreatedAt)
	}
	if m.FieldCleared(control.FieldUpdatedAt) {
		fields = append(fields, control.FieldUpdatedAt)
	}
	if m.FieldCleared(control.FieldCreatedBy) {
		fields = append(fields, control.FieldCreatedBy)
	}
	if m.FieldCleared(control.FieldUpdatedBy) {
		fields = append(fields, control.FieldUpdatedBy)
	}
	if m.FieldCleared(control.FieldDeletedAt) {
		fields = append(fields, control.FieldDeletedAt)
	}
	if m.FieldCleared(control.FieldDeletedBy) {
		fields = append(fields, control.FieldDeletedBy)
	}
	if m.FieldCleared(control.FieldTags) {
		fields = append(fields, control.FieldTags)
	}
	if m.FieldCleared(control.FieldDescription) {
		fields = append(fields, control.FieldDescription)
	}
	if m.FieldCleared(control.FieldStatus) {
		fields = append(fields, control.FieldStatus)
	}
	if m.FieldCleared(control.FieldControlType) {
		fields = append(fields, control.FieldControlType)
	}
	if m.FieldCleared(control.FieldVersion) {
		fields = append(fields, control.FieldVersion)
	}
	if m.FieldCleared(control.FieldControlNumber) {
		fields = append(fields, control.FieldControlNumber)
	}
	if m.FieldCleared(control.FieldFamily) {
		fields = append(fields, control.FieldFamily)
	}
	if m.FieldCleared(control.FieldClass) {
		fields = append(fields, control.FieldClass)
	}
	if m.FieldCleared(control.FieldSource) {
		fields = append(fields, control.FieldSource)
	}
	if m.FieldCleared(control.FieldSatisfies) {
		fields = append(fields, control.FieldSatisfies)
	}
	if m.FieldCleared(control.FieldMappedFrameworks) {
		fields = append(fields, control.FieldMappedFrameworks)
	}
	if m.FieldCleared(control.FieldDetails) {
		fields = append(fields, control.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ControlMutation) ClearField(name string) error {
	switch name {
	case control.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case control.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case control.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case control.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case control.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case control.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case control.FieldTags:
		m.ClearTags()
		return nil
	case control.FieldDescription:
		m.ClearDescription()
		return nil
	case control.FieldStatus:
		m.ClearStatus()
		return nil
	case control.FieldControlType:
		m.ClearControlType()
		return nil
	case control.FieldVersion:
		m.ClearVersion()
		return nil
	case control.FieldControlNumber:
		m.ClearControlNumber()
		return nil
	case control.FieldFamily:
		m.ClearFamily()
		return nil
	case control.FieldClass:
		m.ClearClass()
		return nil
	case control.FieldSource:
		m.ClearSource()
		return nil
	case control.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case control.FieldMappedFrameworks:
		m.ClearMappedFrameworks()
		return nil
	case control.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Control nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ControlMutation) ResetField(name string) error {
	switch name {
	case control.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case control.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case control.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case control.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case control.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case control.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case control.FieldMappingID:
		m.ResetMappingID()
		return nil
	case control.FieldTags:
		m.ResetTags()
		return nil
	case control.FieldName:
		m.ResetName()
		return nil
	case control.FieldDescription:
		m.ResetDescription()
		return nil
	case control.FieldStatus:
		m.ResetStatus()
		return nil
	case control.FieldControlType:
		m.ResetControlType()
		return nil
	case control.FieldVersion:
		m.ResetVersion()
		return nil
	case control.FieldControlNumber:
		m.ResetControlNumber()
		return nil
	case control.FieldFamily:
		m.ResetFamily()
		return nil
	case control.FieldClass:
		m.ResetClass()
		return nil
	case control.FieldSource:
		m.ResetSource()
		return nil
	case control.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case control.FieldMappedFrameworks:
		m.ResetMappedFrameworks()
		return nil
	case control.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Control field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.procedures != nil {
		edges = append(edges, control.EdgeProcedures)
	}
	if m.subcontrols != nil {
		edges = append(edges, control.EdgeSubcontrols)
	}
	if m.controlobjectives != nil {
		edges = append(edges, control.EdgeControlobjectives)
	}
	if m.standard != nil {
		edges = append(edges, control.EdgeStandard)
	}
	if m.narratives != nil {
		edges = append(edges, control.EdgeNarratives)
	}
	if m.risks != nil {
		edges = append(edges, control.EdgeRisks)
	}
	if m.actionplans != nil {
		edges = append(edges, control.EdgeActionplans)
	}
	if m.tasks != nil {
		edges = append(edges, control.EdgeTasks)
	}
	if m.programs != nil {
		edges = append(edges, control.EdgePrograms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case control.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.procedures))
		for id := range m.procedures {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.subcontrols))
		for id := range m.subcontrols {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeControlobjectives:
		ids := make([]ent.Value, 0, len(m.controlobjectives))
		for id := range m.controlobjectives {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeStandard:
		ids := make([]ent.Value, 0, len(m.standard))
		for id := range m.standard {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.narratives))
		for id := range m.narratives {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeRisks:
		ids := make([]ent.Value, 0, len(m.risks))
		for id := range m.risks {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.actionplans))
		for id := range m.actionplans {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case control.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedprocedures != nil {
		edges = append(edges, control.EdgeProcedures)
	}
	if m.removedsubcontrols != nil {
		edges = append(edges, control.EdgeSubcontrols)
	}
	if m.removedcontrolobjectives != nil {
		edges = append(edges, control.EdgeControlobjectives)
	}
	if m.removedstandard != nil {
		edges = append(edges, control.EdgeStandard)
	}
	if m.removednarratives != nil {
		edges = append(edges, control.EdgeNarratives)
	}
	if m.removedrisks != nil {
		edges = append(edges, control.EdgeRisks)
	}
	if m.removedactionplans != nil {
		edges = append(edges, control.EdgeActionplans)
	}
	if m.removedtasks != nil {
		edges = append(edges, control.EdgeTasks)
	}
	if m.removedprograms != nil {
		edges = append(edges, control.EdgePrograms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ControlMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case control.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.removedprocedures))
		for id := range m.removedprocedures {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.removedsubcontrols))
		for id := range m.removedsubcontrols {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeControlobjectives:
		ids := make([]ent.Value, 0, len(m.removedcontrolobjectives))
		for id := range m.removedcontrolobjectives {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeStandard:
		ids := make([]ent.Value, 0, len(m.removedstandard))
		for id := range m.removedstandard {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.removednarratives))
		for id := range m.removednarratives {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeRisks:
		ids := make([]ent.Value, 0, len(m.removedrisks))
		for id := range m.removedrisks {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.removedactionplans))
		for id := range m.removedactionplans {
			ids = append(ids, id)
		}
		return ids
	case control.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case control.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedprocedures {
		edges = append(edges, control.EdgeProcedures)
	}
	if m.clearedsubcontrols {
		edges = append(edges, control.EdgeSubcontrols)
	}
	if m.clearedcontrolobjectives {
		edges = append(edges, control.EdgeControlobjectives)
	}
	if m.clearedstandard {
		edges = append(edges, control.EdgeStandard)
	}
	if m.clearednarratives {
		edges = append(edges, control.EdgeNarratives)
	}
	if m.clearedrisks {
		edges = append(edges, control.EdgeRisks)
	}
	if m.clearedactionplans {
		edges = append(edges, control.EdgeActionplans)
	}
	if m.clearedtasks {
		edges = append(edges, control.EdgeTasks)
	}
	if m.clearedprograms {
		edges = append(edges, control.EdgePrograms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ControlMutation) EdgeCleared(name string) bool {
	switch name {
	case control.EdgeProcedures:
		return m.clearedprocedures
	case control.EdgeSubcontrols:
		return m.clearedsubcontrols
	case control.EdgeControlobjectives:
		return m.clearedcontrolobjectives
	case control.EdgeStandard:
		return m.clearedstandard
	case control.EdgeNarratives:
		return m.clearednarratives
	case control.EdgeRisks:
		return m.clearedrisks
	case control.EdgeActionplans:
		return m.clearedactionplans
	case control.EdgeTasks:
		return m.clearedtasks
	case control.EdgePrograms:
		return m.clearedprograms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ControlMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Control unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ControlMutation) ResetEdge(name string) error {
	switch name {
	case control.EdgeProcedures:
		m.ResetProcedures()
		return nil
	case control.EdgeSubcontrols:
		m.ResetSubcontrols()
		return nil
	case control.EdgeControlobjectives:
		m.ResetControlobjectives()
		return nil
	case control.EdgeStandard:
		m.ResetStandard()
		return nil
	case control.EdgeNarratives:
		m.ResetNarratives()
		return nil
	case control.EdgeRisks:
		m.ResetRisks()
		return nil
	case control.EdgeActionplans:
		m.ResetActionplans()
		return nil
	case control.EdgeTasks:
		m.ResetTasks()
		return nil
	case control.EdgePrograms:
		m.ResetPrograms()
		return nil
	}
	return fmt.Errorf("unknown Control edge %s", name)
}

// ControlHistoryMutation represents an operation that mutates the ControlHistory nodes in the graph.
type ControlHistoryMutation struct {
	config
	op                Op
	typ               string
	id                *string
	history_time      *time.Time
	ref               *string
	operation         *history.OpType
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	deleted_at        *time.Time
	deleted_by        *string
	mapping_id        *string
	tags              *[]string
	appendtags        []string
	name              *string
	description       *string
	status            *string
	control_type      *string
	version           *string
	control_number    *string
	family            *string
	class             *string
	source            *string
	satisfies         *string
	mapped_frameworks *string
	details           *map[string]interface{}
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ControlHistory, error)
	predicates        []predicate.ControlHistory
}

var _ ent.Mutation = (*ControlHistoryMutation)(nil)

// controlhistoryOption allows management of the mutation configuration using functional options.
type controlhistoryOption func(*ControlHistoryMutation)

// newControlHistoryMutation creates new mutation for the ControlHistory entity.
func newControlHistoryMutation(c config, op Op, opts ...controlhistoryOption) *ControlHistoryMutation {
	m := &ControlHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeControlHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withControlHistoryID sets the ID field of the mutation.
func withControlHistoryID(id string) controlhistoryOption {
	return func(m *ControlHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ControlHistory
		)
		m.oldValue = func(ctx context.Context) (*ControlHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ControlHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withControlHistory sets the old ControlHistory of the mutation.
func withControlHistory(node *ControlHistory) controlhistoryOption {
	return func(m *ControlHistoryMutation) {
		m.oldValue = func(context.Context) (*ControlHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ControlHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ControlHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ControlHistory entities.
func (m *ControlHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ControlHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ControlHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ControlHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ControlHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ControlHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ControlHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ControlHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ControlHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ControlHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[controlhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ControlHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ControlHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, controlhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ControlHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ControlHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ControlHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ControlHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ControlHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ControlHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[controlhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ControlHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ControlHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, controlhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ControlHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ControlHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ControlHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[controlhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ControlHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ControlHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, controlhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ControlHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ControlHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ControlHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[controlhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ControlHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ControlHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, controlhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ControlHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ControlHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ControlHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[controlhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ControlHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ControlHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, controlhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ControlHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ControlHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ControlHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[controlhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ControlHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ControlHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, controlhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ControlHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ControlHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ControlHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[controlhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ControlHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ControlHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, controlhistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ControlHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ControlHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ControlHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *ControlHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ControlHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ControlHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ControlHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ControlHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[controlhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ControlHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ControlHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, controlhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *ControlHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ControlHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ControlHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ControlHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ControlHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ControlHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[controlhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ControlHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ControlHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, controlhistory.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ControlHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ControlHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ControlHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[controlhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ControlHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ControlHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, controlhistory.FieldStatus)
}

// SetControlType sets the "control_type" field.
func (m *ControlHistoryMutation) SetControlType(s string) {
	m.control_type = &s
}

// ControlType returns the value of the "control_type" field in the mutation.
func (m *ControlHistoryMutation) ControlType() (r string, exists bool) {
	v := m.control_type
	if v == nil {
		return
	}
	return *v, true
}

// OldControlType returns the old "control_type" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldControlType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlType: %w", err)
	}
	return oldValue.ControlType, nil
}

// ClearControlType clears the value of the "control_type" field.
func (m *ControlHistoryMutation) ClearControlType() {
	m.control_type = nil
	m.clearedFields[controlhistory.FieldControlType] = struct{}{}
}

// ControlTypeCleared returns if the "control_type" field was cleared in this mutation.
func (m *ControlHistoryMutation) ControlTypeCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldControlType]
	return ok
}

// ResetControlType resets all changes to the "control_type" field.
func (m *ControlHistoryMutation) ResetControlType() {
	m.control_type = nil
	delete(m.clearedFields, controlhistory.FieldControlType)
}

// SetVersion sets the "version" field.
func (m *ControlHistoryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ControlHistoryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ControlHistoryMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[controlhistory.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ControlHistoryMutation) VersionCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ControlHistoryMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, controlhistory.FieldVersion)
}

// SetControlNumber sets the "control_number" field.
func (m *ControlHistoryMutation) SetControlNumber(s string) {
	m.control_number = &s
}

// ControlNumber returns the value of the "control_number" field in the mutation.
func (m *ControlHistoryMutation) ControlNumber() (r string, exists bool) {
	v := m.control_number
	if v == nil {
		return
	}
	return *v, true
}

// OldControlNumber returns the old "control_number" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldControlNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlNumber: %w", err)
	}
	return oldValue.ControlNumber, nil
}

// ClearControlNumber clears the value of the "control_number" field.
func (m *ControlHistoryMutation) ClearControlNumber() {
	m.control_number = nil
	m.clearedFields[controlhistory.FieldControlNumber] = struct{}{}
}

// ControlNumberCleared returns if the "control_number" field was cleared in this mutation.
func (m *ControlHistoryMutation) ControlNumberCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldControlNumber]
	return ok
}

// ResetControlNumber resets all changes to the "control_number" field.
func (m *ControlHistoryMutation) ResetControlNumber() {
	m.control_number = nil
	delete(m.clearedFields, controlhistory.FieldControlNumber)
}

// SetFamily sets the "family" field.
func (m *ControlHistoryMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *ControlHistoryMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ClearFamily clears the value of the "family" field.
func (m *ControlHistoryMutation) ClearFamily() {
	m.family = nil
	m.clearedFields[controlhistory.FieldFamily] = struct{}{}
}

// FamilyCleared returns if the "family" field was cleared in this mutation.
func (m *ControlHistoryMutation) FamilyCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldFamily]
	return ok
}

// ResetFamily resets all changes to the "family" field.
func (m *ControlHistoryMutation) ResetFamily() {
	m.family = nil
	delete(m.clearedFields, controlhistory.FieldFamily)
}

// SetClass sets the "class" field.
func (m *ControlHistoryMutation) SetClass(s string) {
	m.class = &s
}

// Class returns the value of the "class" field in the mutation.
func (m *ControlHistoryMutation) Class() (r string, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ClearClass clears the value of the "class" field.
func (m *ControlHistoryMutation) ClearClass() {
	m.class = nil
	m.clearedFields[controlhistory.FieldClass] = struct{}{}
}

// ClassCleared returns if the "class" field was cleared in this mutation.
func (m *ControlHistoryMutation) ClassCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldClass]
	return ok
}

// ResetClass resets all changes to the "class" field.
func (m *ControlHistoryMutation) ResetClass() {
	m.class = nil
	delete(m.clearedFields, controlhistory.FieldClass)
}

// SetSource sets the "source" field.
func (m *ControlHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ControlHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ControlHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[controlhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ControlHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ControlHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, controlhistory.FieldSource)
}

// SetSatisfies sets the "satisfies" field.
func (m *ControlHistoryMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *ControlHistoryMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *ControlHistoryMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[controlhistory.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *ControlHistoryMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *ControlHistoryMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, controlhistory.FieldSatisfies)
}

// SetMappedFrameworks sets the "mapped_frameworks" field.
func (m *ControlHistoryMutation) SetMappedFrameworks(s string) {
	m.mapped_frameworks = &s
}

// MappedFrameworks returns the value of the "mapped_frameworks" field in the mutation.
func (m *ControlHistoryMutation) MappedFrameworks() (r string, exists bool) {
	v := m.mapped_frameworks
	if v == nil {
		return
	}
	return *v, true
}

// OldMappedFrameworks returns the old "mapped_frameworks" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldMappedFrameworks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappedFrameworks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappedFrameworks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappedFrameworks: %w", err)
	}
	return oldValue.MappedFrameworks, nil
}

// ClearMappedFrameworks clears the value of the "mapped_frameworks" field.
func (m *ControlHistoryMutation) ClearMappedFrameworks() {
	m.mapped_frameworks = nil
	m.clearedFields[controlhistory.FieldMappedFrameworks] = struct{}{}
}

// MappedFrameworksCleared returns if the "mapped_frameworks" field was cleared in this mutation.
func (m *ControlHistoryMutation) MappedFrameworksCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldMappedFrameworks]
	return ok
}

// ResetMappedFrameworks resets all changes to the "mapped_frameworks" field.
func (m *ControlHistoryMutation) ResetMappedFrameworks() {
	m.mapped_frameworks = nil
	delete(m.clearedFields, controlhistory.FieldMappedFrameworks)
}

// SetDetails sets the "details" field.
func (m *ControlHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *ControlHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ControlHistory entity.
// If the ControlHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ControlHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[controlhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ControlHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[controlhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ControlHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, controlhistory.FieldDetails)
}

// Where appends a list predicates to the ControlHistoryMutation builder.
func (m *ControlHistoryMutation) Where(ps ...predicate.ControlHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ControlHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ControlHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ControlHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ControlHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ControlHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ControlHistory).
func (m *ControlHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ControlHistoryMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.history_time != nil {
		fields = append(fields, controlhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, controlhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, controlhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, controlhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, controlhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, controlhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, controlhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, controlhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, controlhistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, controlhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, controlhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, controlhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, controlhistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, controlhistory.FieldStatus)
	}
	if m.control_type != nil {
		fields = append(fields, controlhistory.FieldControlType)
	}
	if m.version != nil {
		fields = append(fields, controlhistory.FieldVersion)
	}
	if m.control_number != nil {
		fields = append(fields, controlhistory.FieldControlNumber)
	}
	if m.family != nil {
		fields = append(fields, controlhistory.FieldFamily)
	}
	if m.class != nil {
		fields = append(fields, controlhistory.FieldClass)
	}
	if m.source != nil {
		fields = append(fields, controlhistory.FieldSource)
	}
	if m.satisfies != nil {
		fields = append(fields, controlhistory.FieldSatisfies)
	}
	if m.mapped_frameworks != nil {
		fields = append(fields, controlhistory.FieldMappedFrameworks)
	}
	if m.details != nil {
		fields = append(fields, controlhistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ControlHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case controlhistory.FieldHistoryTime:
		return m.HistoryTime()
	case controlhistory.FieldRef:
		return m.Ref()
	case controlhistory.FieldOperation:
		return m.Operation()
	case controlhistory.FieldCreatedAt:
		return m.CreatedAt()
	case controlhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case controlhistory.FieldCreatedBy:
		return m.CreatedBy()
	case controlhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case controlhistory.FieldDeletedAt:
		return m.DeletedAt()
	case controlhistory.FieldDeletedBy:
		return m.DeletedBy()
	case controlhistory.FieldMappingID:
		return m.MappingID()
	case controlhistory.FieldTags:
		return m.Tags()
	case controlhistory.FieldName:
		return m.Name()
	case controlhistory.FieldDescription:
		return m.Description()
	case controlhistory.FieldStatus:
		return m.Status()
	case controlhistory.FieldControlType:
		return m.ControlType()
	case controlhistory.FieldVersion:
		return m.Version()
	case controlhistory.FieldControlNumber:
		return m.ControlNumber()
	case controlhistory.FieldFamily:
		return m.Family()
	case controlhistory.FieldClass:
		return m.Class()
	case controlhistory.FieldSource:
		return m.Source()
	case controlhistory.FieldSatisfies:
		return m.Satisfies()
	case controlhistory.FieldMappedFrameworks:
		return m.MappedFrameworks()
	case controlhistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ControlHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case controlhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case controlhistory.FieldRef:
		return m.OldRef(ctx)
	case controlhistory.FieldOperation:
		return m.OldOperation(ctx)
	case controlhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case controlhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case controlhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case controlhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case controlhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case controlhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case controlhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case controlhistory.FieldTags:
		return m.OldTags(ctx)
	case controlhistory.FieldName:
		return m.OldName(ctx)
	case controlhistory.FieldDescription:
		return m.OldDescription(ctx)
	case controlhistory.FieldStatus:
		return m.OldStatus(ctx)
	case controlhistory.FieldControlType:
		return m.OldControlType(ctx)
	case controlhistory.FieldVersion:
		return m.OldVersion(ctx)
	case controlhistory.FieldControlNumber:
		return m.OldControlNumber(ctx)
	case controlhistory.FieldFamily:
		return m.OldFamily(ctx)
	case controlhistory.FieldClass:
		return m.OldClass(ctx)
	case controlhistory.FieldSource:
		return m.OldSource(ctx)
	case controlhistory.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case controlhistory.FieldMappedFrameworks:
		return m.OldMappedFrameworks(ctx)
	case controlhistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown ControlHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case controlhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case controlhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case controlhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case controlhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case controlhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case controlhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case controlhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case controlhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case controlhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case controlhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case controlhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case controlhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case controlhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case controlhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case controlhistory.FieldControlType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlType(v)
		return nil
	case controlhistory.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case controlhistory.FieldControlNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlNumber(v)
		return nil
	case controlhistory.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case controlhistory.FieldClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case controlhistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case controlhistory.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case controlhistory.FieldMappedFrameworks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappedFrameworks(v)
		return nil
	case controlhistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown ControlHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ControlHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ControlHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ControlHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ControlHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(controlhistory.FieldRef) {
		fields = append(fields, controlhistory.FieldRef)
	}
	if m.FieldCleared(controlhistory.FieldCreatedAt) {
		fields = append(fields, controlhistory.FieldCreatedAt)
	}
	if m.FieldCleared(controlhistory.FieldUpdatedAt) {
		fields = append(fields, controlhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(controlhistory.FieldCreatedBy) {
		fields = append(fields, controlhistory.FieldCreatedBy)
	}
	if m.FieldCleared(controlhistory.FieldUpdatedBy) {
		fields = append(fields, controlhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(controlhistory.FieldDeletedAt) {
		fields = append(fields, controlhistory.FieldDeletedAt)
	}
	if m.FieldCleared(controlhistory.FieldDeletedBy) {
		fields = append(fields, controlhistory.FieldDeletedBy)
	}
	if m.FieldCleared(controlhistory.FieldTags) {
		fields = append(fields, controlhistory.FieldTags)
	}
	if m.FieldCleared(controlhistory.FieldDescription) {
		fields = append(fields, controlhistory.FieldDescription)
	}
	if m.FieldCleared(controlhistory.FieldStatus) {
		fields = append(fields, controlhistory.FieldStatus)
	}
	if m.FieldCleared(controlhistory.FieldControlType) {
		fields = append(fields, controlhistory.FieldControlType)
	}
	if m.FieldCleared(controlhistory.FieldVersion) {
		fields = append(fields, controlhistory.FieldVersion)
	}
	if m.FieldCleared(controlhistory.FieldControlNumber) {
		fields = append(fields, controlhistory.FieldControlNumber)
	}
	if m.FieldCleared(controlhistory.FieldFamily) {
		fields = append(fields, controlhistory.FieldFamily)
	}
	if m.FieldCleared(controlhistory.FieldClass) {
		fields = append(fields, controlhistory.FieldClass)
	}
	if m.FieldCleared(controlhistory.FieldSource) {
		fields = append(fields, controlhistory.FieldSource)
	}
	if m.FieldCleared(controlhistory.FieldSatisfies) {
		fields = append(fields, controlhistory.FieldSatisfies)
	}
	if m.FieldCleared(controlhistory.FieldMappedFrameworks) {
		fields = append(fields, controlhistory.FieldMappedFrameworks)
	}
	if m.FieldCleared(controlhistory.FieldDetails) {
		fields = append(fields, controlhistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ControlHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ControlHistoryMutation) ClearField(name string) error {
	switch name {
	case controlhistory.FieldRef:
		m.ClearRef()
		return nil
	case controlhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case controlhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case controlhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case controlhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case controlhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case controlhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case controlhistory.FieldTags:
		m.ClearTags()
		return nil
	case controlhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case controlhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case controlhistory.FieldControlType:
		m.ClearControlType()
		return nil
	case controlhistory.FieldVersion:
		m.ClearVersion()
		return nil
	case controlhistory.FieldControlNumber:
		m.ClearControlNumber()
		return nil
	case controlhistory.FieldFamily:
		m.ClearFamily()
		return nil
	case controlhistory.FieldClass:
		m.ClearClass()
		return nil
	case controlhistory.FieldSource:
		m.ClearSource()
		return nil
	case controlhistory.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case controlhistory.FieldMappedFrameworks:
		m.ClearMappedFrameworks()
		return nil
	case controlhistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown ControlHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ControlHistoryMutation) ResetField(name string) error {
	switch name {
	case controlhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case controlhistory.FieldRef:
		m.ResetRef()
		return nil
	case controlhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case controlhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case controlhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case controlhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case controlhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case controlhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case controlhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case controlhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case controlhistory.FieldTags:
		m.ResetTags()
		return nil
	case controlhistory.FieldName:
		m.ResetName()
		return nil
	case controlhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case controlhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case controlhistory.FieldControlType:
		m.ResetControlType()
		return nil
	case controlhistory.FieldVersion:
		m.ResetVersion()
		return nil
	case controlhistory.FieldControlNumber:
		m.ResetControlNumber()
		return nil
	case controlhistory.FieldFamily:
		m.ResetFamily()
		return nil
	case controlhistory.FieldClass:
		m.ResetClass()
		return nil
	case controlhistory.FieldSource:
		m.ResetSource()
		return nil
	case controlhistory.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case controlhistory.FieldMappedFrameworks:
		m.ResetMappedFrameworks()
		return nil
	case controlhistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown ControlHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ControlHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ControlHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ControlHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ControlHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ControlHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ControlHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ControlHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ControlHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ControlHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ControlHistory edge %s", name)
}

// ControlObjectiveMutation represents an operation that mutates the ControlObjective nodes in the graph.
type ControlObjectiveMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	deleted_at             *time.Time
	deleted_by             *string
	mapping_id             *string
	tags                   *[]string
	appendtags             []string
	name                   *string
	description            *string
	status                 *string
	control_objective_type *string
	version                *string
	control_number         *string
	family                 *string
	class                  *string
	source                 *string
	mapped_frameworks      *string
	details                *map[string]interface{}
	clearedFields          map[string]struct{}
	policy                 map[string]struct{}
	removedpolicy          map[string]struct{}
	clearedpolicy          bool
	controls               map[string]struct{}
	removedcontrols        map[string]struct{}
	clearedcontrols        bool
	procedures             map[string]struct{}
	removedprocedures      map[string]struct{}
	clearedprocedures      bool
	risks                  map[string]struct{}
	removedrisks           map[string]struct{}
	clearedrisks           bool
	subcontrols            map[string]struct{}
	removedsubcontrols     map[string]struct{}
	clearedsubcontrols     bool
	standard               map[string]struct{}
	removedstandard        map[string]struct{}
	clearedstandard        bool
	narratives             map[string]struct{}
	removednarratives      map[string]struct{}
	clearednarratives      bool
	tasks                  map[string]struct{}
	removedtasks           map[string]struct{}
	clearedtasks           bool
	programs               map[string]struct{}
	removedprograms        map[string]struct{}
	clearedprograms        bool
	done                   bool
	oldValue               func(context.Context) (*ControlObjective, error)
	predicates             []predicate.ControlObjective
}

var _ ent.Mutation = (*ControlObjectiveMutation)(nil)

// controlobjectiveOption allows management of the mutation configuration using functional options.
type controlobjectiveOption func(*ControlObjectiveMutation)

// newControlObjectiveMutation creates new mutation for the ControlObjective entity.
func newControlObjectiveMutation(c config, op Op, opts ...controlobjectiveOption) *ControlObjectiveMutation {
	m := &ControlObjectiveMutation{
		config:        c,
		op:            op,
		typ:           TypeControlObjective,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withControlObjectiveID sets the ID field of the mutation.
func withControlObjectiveID(id string) controlobjectiveOption {
	return func(m *ControlObjectiveMutation) {
		var (
			err   error
			once  sync.Once
			value *ControlObjective
		)
		m.oldValue = func(ctx context.Context) (*ControlObjective, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ControlObjective.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withControlObjective sets the old ControlObjective of the mutation.
func withControlObjective(node *ControlObjective) controlobjectiveOption {
	return func(m *ControlObjectiveMutation) {
		m.oldValue = func(context.Context) (*ControlObjective, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ControlObjectiveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ControlObjectiveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ControlObjective entities.
func (m *ControlObjectiveMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ControlObjectiveMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ControlObjectiveMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ControlObjective.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ControlObjectiveMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ControlObjectiveMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ControlObjectiveMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[controlobjective.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ControlObjectiveMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ControlObjectiveMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, controlobjective.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ControlObjectiveMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ControlObjectiveMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ControlObjectiveMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[controlobjective.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ControlObjectiveMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ControlObjectiveMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, controlobjective.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ControlObjectiveMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ControlObjectiveMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ControlObjectiveMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[controlobjective.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ControlObjectiveMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ControlObjectiveMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, controlobjective.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ControlObjectiveMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ControlObjectiveMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ControlObjectiveMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[controlobjective.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ControlObjectiveMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ControlObjectiveMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, controlobjective.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ControlObjectiveMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ControlObjectiveMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ControlObjectiveMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[controlobjective.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ControlObjectiveMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ControlObjectiveMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, controlobjective.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ControlObjectiveMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ControlObjectiveMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ControlObjectiveMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[controlobjective.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ControlObjectiveMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ControlObjectiveMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, controlobjective.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ControlObjectiveMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ControlObjectiveMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ControlObjectiveMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *ControlObjectiveMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ControlObjectiveMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ControlObjectiveMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ControlObjectiveMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ControlObjectiveMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[controlobjective.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ControlObjectiveMutation) TagsCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ControlObjectiveMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, controlobjective.FieldTags)
}

// SetName sets the "name" field.
func (m *ControlObjectiveMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ControlObjectiveMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ControlObjectiveMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ControlObjectiveMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ControlObjectiveMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ControlObjectiveMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[controlobjective.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ControlObjectiveMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ControlObjectiveMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, controlobjective.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ControlObjectiveMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ControlObjectiveMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ControlObjectiveMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[controlobjective.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ControlObjectiveMutation) StatusCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ControlObjectiveMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, controlobjective.FieldStatus)
}

// SetControlObjectiveType sets the "control_objective_type" field.
func (m *ControlObjectiveMutation) SetControlObjectiveType(s string) {
	m.control_objective_type = &s
}

// ControlObjectiveType returns the value of the "control_objective_type" field in the mutation.
func (m *ControlObjectiveMutation) ControlObjectiveType() (r string, exists bool) {
	v := m.control_objective_type
	if v == nil {
		return
	}
	return *v, true
}

// OldControlObjectiveType returns the old "control_objective_type" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldControlObjectiveType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlObjectiveType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlObjectiveType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlObjectiveType: %w", err)
	}
	return oldValue.ControlObjectiveType, nil
}

// ClearControlObjectiveType clears the value of the "control_objective_type" field.
func (m *ControlObjectiveMutation) ClearControlObjectiveType() {
	m.control_objective_type = nil
	m.clearedFields[controlobjective.FieldControlObjectiveType] = struct{}{}
}

// ControlObjectiveTypeCleared returns if the "control_objective_type" field was cleared in this mutation.
func (m *ControlObjectiveMutation) ControlObjectiveTypeCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldControlObjectiveType]
	return ok
}

// ResetControlObjectiveType resets all changes to the "control_objective_type" field.
func (m *ControlObjectiveMutation) ResetControlObjectiveType() {
	m.control_objective_type = nil
	delete(m.clearedFields, controlobjective.FieldControlObjectiveType)
}

// SetVersion sets the "version" field.
func (m *ControlObjectiveMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ControlObjectiveMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ControlObjectiveMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[controlobjective.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ControlObjectiveMutation) VersionCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ControlObjectiveMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, controlobjective.FieldVersion)
}

// SetControlNumber sets the "control_number" field.
func (m *ControlObjectiveMutation) SetControlNumber(s string) {
	m.control_number = &s
}

// ControlNumber returns the value of the "control_number" field in the mutation.
func (m *ControlObjectiveMutation) ControlNumber() (r string, exists bool) {
	v := m.control_number
	if v == nil {
		return
	}
	return *v, true
}

// OldControlNumber returns the old "control_number" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldControlNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlNumber: %w", err)
	}
	return oldValue.ControlNumber, nil
}

// ClearControlNumber clears the value of the "control_number" field.
func (m *ControlObjectiveMutation) ClearControlNumber() {
	m.control_number = nil
	m.clearedFields[controlobjective.FieldControlNumber] = struct{}{}
}

// ControlNumberCleared returns if the "control_number" field was cleared in this mutation.
func (m *ControlObjectiveMutation) ControlNumberCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldControlNumber]
	return ok
}

// ResetControlNumber resets all changes to the "control_number" field.
func (m *ControlObjectiveMutation) ResetControlNumber() {
	m.control_number = nil
	delete(m.clearedFields, controlobjective.FieldControlNumber)
}

// SetFamily sets the "family" field.
func (m *ControlObjectiveMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *ControlObjectiveMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ClearFamily clears the value of the "family" field.
func (m *ControlObjectiveMutation) ClearFamily() {
	m.family = nil
	m.clearedFields[controlobjective.FieldFamily] = struct{}{}
}

// FamilyCleared returns if the "family" field was cleared in this mutation.
func (m *ControlObjectiveMutation) FamilyCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldFamily]
	return ok
}

// ResetFamily resets all changes to the "family" field.
func (m *ControlObjectiveMutation) ResetFamily() {
	m.family = nil
	delete(m.clearedFields, controlobjective.FieldFamily)
}

// SetClass sets the "class" field.
func (m *ControlObjectiveMutation) SetClass(s string) {
	m.class = &s
}

// Class returns the value of the "class" field in the mutation.
func (m *ControlObjectiveMutation) Class() (r string, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ClearClass clears the value of the "class" field.
func (m *ControlObjectiveMutation) ClearClass() {
	m.class = nil
	m.clearedFields[controlobjective.FieldClass] = struct{}{}
}

// ClassCleared returns if the "class" field was cleared in this mutation.
func (m *ControlObjectiveMutation) ClassCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldClass]
	return ok
}

// ResetClass resets all changes to the "class" field.
func (m *ControlObjectiveMutation) ResetClass() {
	m.class = nil
	delete(m.clearedFields, controlobjective.FieldClass)
}

// SetSource sets the "source" field.
func (m *ControlObjectiveMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ControlObjectiveMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ControlObjectiveMutation) ClearSource() {
	m.source = nil
	m.clearedFields[controlobjective.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ControlObjectiveMutation) SourceCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ControlObjectiveMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, controlobjective.FieldSource)
}

// SetMappedFrameworks sets the "mapped_frameworks" field.
func (m *ControlObjectiveMutation) SetMappedFrameworks(s string) {
	m.mapped_frameworks = &s
}

// MappedFrameworks returns the value of the "mapped_frameworks" field in the mutation.
func (m *ControlObjectiveMutation) MappedFrameworks() (r string, exists bool) {
	v := m.mapped_frameworks
	if v == nil {
		return
	}
	return *v, true
}

// OldMappedFrameworks returns the old "mapped_frameworks" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldMappedFrameworks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappedFrameworks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappedFrameworks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappedFrameworks: %w", err)
	}
	return oldValue.MappedFrameworks, nil
}

// ClearMappedFrameworks clears the value of the "mapped_frameworks" field.
func (m *ControlObjectiveMutation) ClearMappedFrameworks() {
	m.mapped_frameworks = nil
	m.clearedFields[controlobjective.FieldMappedFrameworks] = struct{}{}
}

// MappedFrameworksCleared returns if the "mapped_frameworks" field was cleared in this mutation.
func (m *ControlObjectiveMutation) MappedFrameworksCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldMappedFrameworks]
	return ok
}

// ResetMappedFrameworks resets all changes to the "mapped_frameworks" field.
func (m *ControlObjectiveMutation) ResetMappedFrameworks() {
	m.mapped_frameworks = nil
	delete(m.clearedFields, controlobjective.FieldMappedFrameworks)
}

// SetDetails sets the "details" field.
func (m *ControlObjectiveMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *ControlObjectiveMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ControlObjective entity.
// If the ControlObjective object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ControlObjectiveMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[controlobjective.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ControlObjectiveMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[controlobjective.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ControlObjectiveMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, controlobjective.FieldDetails)
}

// AddPolicyIDs adds the "policy" edge to the InternalPolicy entity by ids.
func (m *ControlObjectiveMutation) AddPolicyIDs(ids ...string) {
	if m.policy == nil {
		m.policy = make(map[string]struct{})
	}
	for i := range ids {
		m.policy[ids[i]] = struct{}{}
	}
}

// ClearPolicy clears the "policy" edge to the InternalPolicy entity.
func (m *ControlObjectiveMutation) ClearPolicy() {
	m.clearedpolicy = true
}

// PolicyCleared reports if the "policy" edge to the InternalPolicy entity was cleared.
func (m *ControlObjectiveMutation) PolicyCleared() bool {
	return m.clearedpolicy
}

// RemovePolicyIDs removes the "policy" edge to the InternalPolicy entity by IDs.
func (m *ControlObjectiveMutation) RemovePolicyIDs(ids ...string) {
	if m.removedpolicy == nil {
		m.removedpolicy = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.policy, ids[i])
		m.removedpolicy[ids[i]] = struct{}{}
	}
}

// RemovedPolicy returns the removed IDs of the "policy" edge to the InternalPolicy entity.
func (m *ControlObjectiveMutation) RemovedPolicyIDs() (ids []string) {
	for id := range m.removedpolicy {
		ids = append(ids, id)
	}
	return
}

// PolicyIDs returns the "policy" edge IDs in the mutation.
func (m *ControlObjectiveMutation) PolicyIDs() (ids []string) {
	for id := range m.policy {
		ids = append(ids, id)
	}
	return
}

// ResetPolicy resets all changes to the "policy" edge.
func (m *ControlObjectiveMutation) ResetPolicy() {
	m.policy = nil
	m.clearedpolicy = false
	m.removedpolicy = nil
}

// AddControlIDs adds the "controls" edge to the Control entity by ids.
func (m *ControlObjectiveMutation) AddControlIDs(ids ...string) {
	if m.controls == nil {
		m.controls = make(map[string]struct{})
	}
	for i := range ids {
		m.controls[ids[i]] = struct{}{}
	}
}

// ClearControls clears the "controls" edge to the Control entity.
func (m *ControlObjectiveMutation) ClearControls() {
	m.clearedcontrols = true
}

// ControlsCleared reports if the "controls" edge to the Control entity was cleared.
func (m *ControlObjectiveMutation) ControlsCleared() bool {
	return m.clearedcontrols
}

// RemoveControlIDs removes the "controls" edge to the Control entity by IDs.
func (m *ControlObjectiveMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrols == nil {
		m.removedcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controls, ids[i])
		m.removedcontrols[ids[i]] = struct{}{}
	}
}

// RemovedControls returns the removed IDs of the "controls" edge to the Control entity.
func (m *ControlObjectiveMutation) RemovedControlsIDs() (ids []string) {
	for id := range m.removedcontrols {
		ids = append(ids, id)
	}
	return
}

// ControlsIDs returns the "controls" edge IDs in the mutation.
func (m *ControlObjectiveMutation) ControlsIDs() (ids []string) {
	for id := range m.controls {
		ids = append(ids, id)
	}
	return
}

// ResetControls resets all changes to the "controls" edge.
func (m *ControlObjectiveMutation) ResetControls() {
	m.controls = nil
	m.clearedcontrols = false
	m.removedcontrols = nil
}

// AddProcedureIDs adds the "procedures" edge to the Procedure entity by ids.
func (m *ControlObjectiveMutation) AddProcedureIDs(ids ...string) {
	if m.procedures == nil {
		m.procedures = make(map[string]struct{})
	}
	for i := range ids {
		m.procedures[ids[i]] = struct{}{}
	}
}

// ClearProcedures clears the "procedures" edge to the Procedure entity.
func (m *ControlObjectiveMutation) ClearProcedures() {
	m.clearedprocedures = true
}

// ProceduresCleared reports if the "procedures" edge to the Procedure entity was cleared.
func (m *ControlObjectiveMutation) ProceduresCleared() bool {
	return m.clearedprocedures
}

// RemoveProcedureIDs removes the "procedures" edge to the Procedure entity by IDs.
func (m *ControlObjectiveMutation) RemoveProcedureIDs(ids ...string) {
	if m.removedprocedures == nil {
		m.removedprocedures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.procedures, ids[i])
		m.removedprocedures[ids[i]] = struct{}{}
	}
}

// RemovedProcedures returns the removed IDs of the "procedures" edge to the Procedure entity.
func (m *ControlObjectiveMutation) RemovedProceduresIDs() (ids []string) {
	for id := range m.removedprocedures {
		ids = append(ids, id)
	}
	return
}

// ProceduresIDs returns the "procedures" edge IDs in the mutation.
func (m *ControlObjectiveMutation) ProceduresIDs() (ids []string) {
	for id := range m.procedures {
		ids = append(ids, id)
	}
	return
}

// ResetProcedures resets all changes to the "procedures" edge.
func (m *ControlObjectiveMutation) ResetProcedures() {
	m.procedures = nil
	m.clearedprocedures = false
	m.removedprocedures = nil
}

// AddRiskIDs adds the "risks" edge to the Risk entity by ids.
func (m *ControlObjectiveMutation) AddRiskIDs(ids ...string) {
	if m.risks == nil {
		m.risks = make(map[string]struct{})
	}
	for i := range ids {
		m.risks[ids[i]] = struct{}{}
	}
}

// ClearRisks clears the "risks" edge to the Risk entity.
func (m *ControlObjectiveMutation) ClearRisks() {
	m.clearedrisks = true
}

// RisksCleared reports if the "risks" edge to the Risk entity was cleared.
func (m *ControlObjectiveMutation) RisksCleared() bool {
	return m.clearedrisks
}

// RemoveRiskIDs removes the "risks" edge to the Risk entity by IDs.
func (m *ControlObjectiveMutation) RemoveRiskIDs(ids ...string) {
	if m.removedrisks == nil {
		m.removedrisks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.risks, ids[i])
		m.removedrisks[ids[i]] = struct{}{}
	}
}

// RemovedRisks returns the removed IDs of the "risks" edge to the Risk entity.
func (m *ControlObjectiveMutation) RemovedRisksIDs() (ids []string) {
	for id := range m.removedrisks {
		ids = append(ids, id)
	}
	return
}

// RisksIDs returns the "risks" edge IDs in the mutation.
func (m *ControlObjectiveMutation) RisksIDs() (ids []string) {
	for id := range m.risks {
		ids = append(ids, id)
	}
	return
}

// ResetRisks resets all changes to the "risks" edge.
func (m *ControlObjectiveMutation) ResetRisks() {
	m.risks = nil
	m.clearedrisks = false
	m.removedrisks = nil
}

// AddSubcontrolIDs adds the "subcontrols" edge to the Subcontrol entity by ids.
func (m *ControlObjectiveMutation) AddSubcontrolIDs(ids ...string) {
	if m.subcontrols == nil {
		m.subcontrols = make(map[string]struct{})
	}
	for i := range ids {
		m.subcontrols[ids[i]] = struct{}{}
	}
}

// ClearSubcontrols clears the "subcontrols" edge to the Subcontrol entity.
func (m *ControlObjectiveMutation) ClearSubcontrols() {
	m.clearedsubcontrols = true
}

// SubcontrolsCleared reports if the "subcontrols" edge to the Subcontrol entity was cleared.
func (m *ControlObjectiveMutation) SubcontrolsCleared() bool {
	return m.clearedsubcontrols
}

// RemoveSubcontrolIDs removes the "subcontrols" edge to the Subcontrol entity by IDs.
func (m *ControlObjectiveMutation) RemoveSubcontrolIDs(ids ...string) {
	if m.removedsubcontrols == nil {
		m.removedsubcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subcontrols, ids[i])
		m.removedsubcontrols[ids[i]] = struct{}{}
	}
}

// RemovedSubcontrols returns the removed IDs of the "subcontrols" edge to the Subcontrol entity.
func (m *ControlObjectiveMutation) RemovedSubcontrolsIDs() (ids []string) {
	for id := range m.removedsubcontrols {
		ids = append(ids, id)
	}
	return
}

// SubcontrolsIDs returns the "subcontrols" edge IDs in the mutation.
func (m *ControlObjectiveMutation) SubcontrolsIDs() (ids []string) {
	for id := range m.subcontrols {
		ids = append(ids, id)
	}
	return
}

// ResetSubcontrols resets all changes to the "subcontrols" edge.
func (m *ControlObjectiveMutation) ResetSubcontrols() {
	m.subcontrols = nil
	m.clearedsubcontrols = false
	m.removedsubcontrols = nil
}

// AddStandardIDs adds the "standard" edge to the Standard entity by ids.
func (m *ControlObjectiveMutation) AddStandardIDs(ids ...string) {
	if m.standard == nil {
		m.standard = make(map[string]struct{})
	}
	for i := range ids {
		m.standard[ids[i]] = struct{}{}
	}
}

// ClearStandard clears the "standard" edge to the Standard entity.
func (m *ControlObjectiveMutation) ClearStandard() {
	m.clearedstandard = true
}

// StandardCleared reports if the "standard" edge to the Standard entity was cleared.
func (m *ControlObjectiveMutation) StandardCleared() bool {
	return m.clearedstandard
}

// RemoveStandardIDs removes the "standard" edge to the Standard entity by IDs.
func (m *ControlObjectiveMutation) RemoveStandardIDs(ids ...string) {
	if m.removedstandard == nil {
		m.removedstandard = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.standard, ids[i])
		m.removedstandard[ids[i]] = struct{}{}
	}
}

// RemovedStandard returns the removed IDs of the "standard" edge to the Standard entity.
func (m *ControlObjectiveMutation) RemovedStandardIDs() (ids []string) {
	for id := range m.removedstandard {
		ids = append(ids, id)
	}
	return
}

// StandardIDs returns the "standard" edge IDs in the mutation.
func (m *ControlObjectiveMutation) StandardIDs() (ids []string) {
	for id := range m.standard {
		ids = append(ids, id)
	}
	return
}

// ResetStandard resets all changes to the "standard" edge.
func (m *ControlObjectiveMutation) ResetStandard() {
	m.standard = nil
	m.clearedstandard = false
	m.removedstandard = nil
}

// AddNarrativeIDs adds the "narratives" edge to the Narrative entity by ids.
func (m *ControlObjectiveMutation) AddNarrativeIDs(ids ...string) {
	if m.narratives == nil {
		m.narratives = make(map[string]struct{})
	}
	for i := range ids {
		m.narratives[ids[i]] = struct{}{}
	}
}

// ClearNarratives clears the "narratives" edge to the Narrative entity.
func (m *ControlObjectiveMutation) ClearNarratives() {
	m.clearednarratives = true
}

// NarrativesCleared reports if the "narratives" edge to the Narrative entity was cleared.
func (m *ControlObjectiveMutation) NarrativesCleared() bool {
	return m.clearednarratives
}

// RemoveNarrativeIDs removes the "narratives" edge to the Narrative entity by IDs.
func (m *ControlObjectiveMutation) RemoveNarrativeIDs(ids ...string) {
	if m.removednarratives == nil {
		m.removednarratives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.narratives, ids[i])
		m.removednarratives[ids[i]] = struct{}{}
	}
}

// RemovedNarratives returns the removed IDs of the "narratives" edge to the Narrative entity.
func (m *ControlObjectiveMutation) RemovedNarrativesIDs() (ids []string) {
	for id := range m.removednarratives {
		ids = append(ids, id)
	}
	return
}

// NarrativesIDs returns the "narratives" edge IDs in the mutation.
func (m *ControlObjectiveMutation) NarrativesIDs() (ids []string) {
	for id := range m.narratives {
		ids = append(ids, id)
	}
	return
}

// ResetNarratives resets all changes to the "narratives" edge.
func (m *ControlObjectiveMutation) ResetNarratives() {
	m.narratives = nil
	m.clearednarratives = false
	m.removednarratives = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ControlObjectiveMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ControlObjectiveMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ControlObjectiveMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ControlObjectiveMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ControlObjectiveMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ControlObjectiveMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ControlObjectiveMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *ControlObjectiveMutation) AddProgramIDs(ids ...string) {
	if m.programs == nil {
		m.programs = make(map[string]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *ControlObjectiveMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *ControlObjectiveMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *ControlObjectiveMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *ControlObjectiveMutation) RemovedProgramsIDs() (ids []string) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *ControlObjectiveMutation) ProgramsIDs() (ids []string) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *ControlObjectiveMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// Where appends a list predicates to the ControlObjectiveMutation builder.
func (m *ControlObjectiveMutation) Where(ps ...predicate.ControlObjective) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ControlObjectiveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ControlObjectiveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ControlObjective, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ControlObjectiveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ControlObjectiveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ControlObjective).
func (m *ControlObjectiveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ControlObjectiveMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, controlobjective.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, controlobjective.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, controlobjective.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, controlobjective.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, controlobjective.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, controlobjective.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, controlobjective.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, controlobjective.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, controlobjective.FieldName)
	}
	if m.description != nil {
		fields = append(fields, controlobjective.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, controlobjective.FieldStatus)
	}
	if m.control_objective_type != nil {
		fields = append(fields, controlobjective.FieldControlObjectiveType)
	}
	if m.version != nil {
		fields = append(fields, controlobjective.FieldVersion)
	}
	if m.control_number != nil {
		fields = append(fields, controlobjective.FieldControlNumber)
	}
	if m.family != nil {
		fields = append(fields, controlobjective.FieldFamily)
	}
	if m.class != nil {
		fields = append(fields, controlobjective.FieldClass)
	}
	if m.source != nil {
		fields = append(fields, controlobjective.FieldSource)
	}
	if m.mapped_frameworks != nil {
		fields = append(fields, controlobjective.FieldMappedFrameworks)
	}
	if m.details != nil {
		fields = append(fields, controlobjective.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ControlObjectiveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case controlobjective.FieldCreatedAt:
		return m.CreatedAt()
	case controlobjective.FieldUpdatedAt:
		return m.UpdatedAt()
	case controlobjective.FieldCreatedBy:
		return m.CreatedBy()
	case controlobjective.FieldUpdatedBy:
		return m.UpdatedBy()
	case controlobjective.FieldDeletedAt:
		return m.DeletedAt()
	case controlobjective.FieldDeletedBy:
		return m.DeletedBy()
	case controlobjective.FieldMappingID:
		return m.MappingID()
	case controlobjective.FieldTags:
		return m.Tags()
	case controlobjective.FieldName:
		return m.Name()
	case controlobjective.FieldDescription:
		return m.Description()
	case controlobjective.FieldStatus:
		return m.Status()
	case controlobjective.FieldControlObjectiveType:
		return m.ControlObjectiveType()
	case controlobjective.FieldVersion:
		return m.Version()
	case controlobjective.FieldControlNumber:
		return m.ControlNumber()
	case controlobjective.FieldFamily:
		return m.Family()
	case controlobjective.FieldClass:
		return m.Class()
	case controlobjective.FieldSource:
		return m.Source()
	case controlobjective.FieldMappedFrameworks:
		return m.MappedFrameworks()
	case controlobjective.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ControlObjectiveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case controlobjective.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case controlobjective.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case controlobjective.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case controlobjective.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case controlobjective.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case controlobjective.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case controlobjective.FieldMappingID:
		return m.OldMappingID(ctx)
	case controlobjective.FieldTags:
		return m.OldTags(ctx)
	case controlobjective.FieldName:
		return m.OldName(ctx)
	case controlobjective.FieldDescription:
		return m.OldDescription(ctx)
	case controlobjective.FieldStatus:
		return m.OldStatus(ctx)
	case controlobjective.FieldControlObjectiveType:
		return m.OldControlObjectiveType(ctx)
	case controlobjective.FieldVersion:
		return m.OldVersion(ctx)
	case controlobjective.FieldControlNumber:
		return m.OldControlNumber(ctx)
	case controlobjective.FieldFamily:
		return m.OldFamily(ctx)
	case controlobjective.FieldClass:
		return m.OldClass(ctx)
	case controlobjective.FieldSource:
		return m.OldSource(ctx)
	case controlobjective.FieldMappedFrameworks:
		return m.OldMappedFrameworks(ctx)
	case controlobjective.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown ControlObjective field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlObjectiveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case controlobjective.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case controlobjective.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case controlobjective.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case controlobjective.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case controlobjective.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case controlobjective.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case controlobjective.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case controlobjective.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case controlobjective.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case controlobjective.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case controlobjective.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case controlobjective.FieldControlObjectiveType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlObjectiveType(v)
		return nil
	case controlobjective.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case controlobjective.FieldControlNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlNumber(v)
		return nil
	case controlobjective.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case controlobjective.FieldClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case controlobjective.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case controlobjective.FieldMappedFrameworks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappedFrameworks(v)
		return nil
	case controlobjective.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown ControlObjective field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ControlObjectiveMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ControlObjectiveMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlObjectiveMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ControlObjective numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ControlObjectiveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(controlobjective.FieldCreatedAt) {
		fields = append(fields, controlobjective.FieldCreatedAt)
	}
	if m.FieldCleared(controlobjective.FieldUpdatedAt) {
		fields = append(fields, controlobjective.FieldUpdatedAt)
	}
	if m.FieldCleared(controlobjective.FieldCreatedBy) {
		fields = append(fields, controlobjective.FieldCreatedBy)
	}
	if m.FieldCleared(controlobjective.FieldUpdatedBy) {
		fields = append(fields, controlobjective.FieldUpdatedBy)
	}
	if m.FieldCleared(controlobjective.FieldDeletedAt) {
		fields = append(fields, controlobjective.FieldDeletedAt)
	}
	if m.FieldCleared(controlobjective.FieldDeletedBy) {
		fields = append(fields, controlobjective.FieldDeletedBy)
	}
	if m.FieldCleared(controlobjective.FieldTags) {
		fields = append(fields, controlobjective.FieldTags)
	}
	if m.FieldCleared(controlobjective.FieldDescription) {
		fields = append(fields, controlobjective.FieldDescription)
	}
	if m.FieldCleared(controlobjective.FieldStatus) {
		fields = append(fields, controlobjective.FieldStatus)
	}
	if m.FieldCleared(controlobjective.FieldControlObjectiveType) {
		fields = append(fields, controlobjective.FieldControlObjectiveType)
	}
	if m.FieldCleared(controlobjective.FieldVersion) {
		fields = append(fields, controlobjective.FieldVersion)
	}
	if m.FieldCleared(controlobjective.FieldControlNumber) {
		fields = append(fields, controlobjective.FieldControlNumber)
	}
	if m.FieldCleared(controlobjective.FieldFamily) {
		fields = append(fields, controlobjective.FieldFamily)
	}
	if m.FieldCleared(controlobjective.FieldClass) {
		fields = append(fields, controlobjective.FieldClass)
	}
	if m.FieldCleared(controlobjective.FieldSource) {
		fields = append(fields, controlobjective.FieldSource)
	}
	if m.FieldCleared(controlobjective.FieldMappedFrameworks) {
		fields = append(fields, controlobjective.FieldMappedFrameworks)
	}
	if m.FieldCleared(controlobjective.FieldDetails) {
		fields = append(fields, controlobjective.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ControlObjectiveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ControlObjectiveMutation) ClearField(name string) error {
	switch name {
	case controlobjective.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case controlobjective.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case controlobjective.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case controlobjective.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case controlobjective.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case controlobjective.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case controlobjective.FieldTags:
		m.ClearTags()
		return nil
	case controlobjective.FieldDescription:
		m.ClearDescription()
		return nil
	case controlobjective.FieldStatus:
		m.ClearStatus()
		return nil
	case controlobjective.FieldControlObjectiveType:
		m.ClearControlObjectiveType()
		return nil
	case controlobjective.FieldVersion:
		m.ClearVersion()
		return nil
	case controlobjective.FieldControlNumber:
		m.ClearControlNumber()
		return nil
	case controlobjective.FieldFamily:
		m.ClearFamily()
		return nil
	case controlobjective.FieldClass:
		m.ClearClass()
		return nil
	case controlobjective.FieldSource:
		m.ClearSource()
		return nil
	case controlobjective.FieldMappedFrameworks:
		m.ClearMappedFrameworks()
		return nil
	case controlobjective.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown ControlObjective nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ControlObjectiveMutation) ResetField(name string) error {
	switch name {
	case controlobjective.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case controlobjective.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case controlobjective.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case controlobjective.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case controlobjective.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case controlobjective.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case controlobjective.FieldMappingID:
		m.ResetMappingID()
		return nil
	case controlobjective.FieldTags:
		m.ResetTags()
		return nil
	case controlobjective.FieldName:
		m.ResetName()
		return nil
	case controlobjective.FieldDescription:
		m.ResetDescription()
		return nil
	case controlobjective.FieldStatus:
		m.ResetStatus()
		return nil
	case controlobjective.FieldControlObjectiveType:
		m.ResetControlObjectiveType()
		return nil
	case controlobjective.FieldVersion:
		m.ResetVersion()
		return nil
	case controlobjective.FieldControlNumber:
		m.ResetControlNumber()
		return nil
	case controlobjective.FieldFamily:
		m.ResetFamily()
		return nil
	case controlobjective.FieldClass:
		m.ResetClass()
		return nil
	case controlobjective.FieldSource:
		m.ResetSource()
		return nil
	case controlobjective.FieldMappedFrameworks:
		m.ResetMappedFrameworks()
		return nil
	case controlobjective.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown ControlObjective field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ControlObjectiveMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.policy != nil {
		edges = append(edges, controlobjective.EdgePolicy)
	}
	if m.controls != nil {
		edges = append(edges, controlobjective.EdgeControls)
	}
	if m.procedures != nil {
		edges = append(edges, controlobjective.EdgeProcedures)
	}
	if m.risks != nil {
		edges = append(edges, controlobjective.EdgeRisks)
	}
	if m.subcontrols != nil {
		edges = append(edges, controlobjective.EdgeSubcontrols)
	}
	if m.standard != nil {
		edges = append(edges, controlobjective.EdgeStandard)
	}
	if m.narratives != nil {
		edges = append(edges, controlobjective.EdgeNarratives)
	}
	if m.tasks != nil {
		edges = append(edges, controlobjective.EdgeTasks)
	}
	if m.programs != nil {
		edges = append(edges, controlobjective.EdgePrograms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ControlObjectiveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case controlobjective.EdgePolicy:
		ids := make([]ent.Value, 0, len(m.policy))
		for id := range m.policy {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeControls:
		ids := make([]ent.Value, 0, len(m.controls))
		for id := range m.controls {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.procedures))
		for id := range m.procedures {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeRisks:
		ids := make([]ent.Value, 0, len(m.risks))
		for id := range m.risks {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.subcontrols))
		for id := range m.subcontrols {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeStandard:
		ids := make([]ent.Value, 0, len(m.standard))
		for id := range m.standard {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.narratives))
		for id := range m.narratives {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ControlObjectiveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedpolicy != nil {
		edges = append(edges, controlobjective.EdgePolicy)
	}
	if m.removedcontrols != nil {
		edges = append(edges, controlobjective.EdgeControls)
	}
	if m.removedprocedures != nil {
		edges = append(edges, controlobjective.EdgeProcedures)
	}
	if m.removedrisks != nil {
		edges = append(edges, controlobjective.EdgeRisks)
	}
	if m.removedsubcontrols != nil {
		edges = append(edges, controlobjective.EdgeSubcontrols)
	}
	if m.removedstandard != nil {
		edges = append(edges, controlobjective.EdgeStandard)
	}
	if m.removednarratives != nil {
		edges = append(edges, controlobjective.EdgeNarratives)
	}
	if m.removedtasks != nil {
		edges = append(edges, controlobjective.EdgeTasks)
	}
	if m.removedprograms != nil {
		edges = append(edges, controlobjective.EdgePrograms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ControlObjectiveMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case controlobjective.EdgePolicy:
		ids := make([]ent.Value, 0, len(m.removedpolicy))
		for id := range m.removedpolicy {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeControls:
		ids := make([]ent.Value, 0, len(m.removedcontrols))
		for id := range m.removedcontrols {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.removedprocedures))
		for id := range m.removedprocedures {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeRisks:
		ids := make([]ent.Value, 0, len(m.removedrisks))
		for id := range m.removedrisks {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.removedsubcontrols))
		for id := range m.removedsubcontrols {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeStandard:
		ids := make([]ent.Value, 0, len(m.removedstandard))
		for id := range m.removedstandard {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.removednarratives))
		for id := range m.removednarratives {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case controlobjective.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ControlObjectiveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedpolicy {
		edges = append(edges, controlobjective.EdgePolicy)
	}
	if m.clearedcontrols {
		edges = append(edges, controlobjective.EdgeControls)
	}
	if m.clearedprocedures {
		edges = append(edges, controlobjective.EdgeProcedures)
	}
	if m.clearedrisks {
		edges = append(edges, controlobjective.EdgeRisks)
	}
	if m.clearedsubcontrols {
		edges = append(edges, controlobjective.EdgeSubcontrols)
	}
	if m.clearedstandard {
		edges = append(edges, controlobjective.EdgeStandard)
	}
	if m.clearednarratives {
		edges = append(edges, controlobjective.EdgeNarratives)
	}
	if m.clearedtasks {
		edges = append(edges, controlobjective.EdgeTasks)
	}
	if m.clearedprograms {
		edges = append(edges, controlobjective.EdgePrograms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ControlObjectiveMutation) EdgeCleared(name string) bool {
	switch name {
	case controlobjective.EdgePolicy:
		return m.clearedpolicy
	case controlobjective.EdgeControls:
		return m.clearedcontrols
	case controlobjective.EdgeProcedures:
		return m.clearedprocedures
	case controlobjective.EdgeRisks:
		return m.clearedrisks
	case controlobjective.EdgeSubcontrols:
		return m.clearedsubcontrols
	case controlobjective.EdgeStandard:
		return m.clearedstandard
	case controlobjective.EdgeNarratives:
		return m.clearednarratives
	case controlobjective.EdgeTasks:
		return m.clearedtasks
	case controlobjective.EdgePrograms:
		return m.clearedprograms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ControlObjectiveMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ControlObjective unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ControlObjectiveMutation) ResetEdge(name string) error {
	switch name {
	case controlobjective.EdgePolicy:
		m.ResetPolicy()
		return nil
	case controlobjective.EdgeControls:
		m.ResetControls()
		return nil
	case controlobjective.EdgeProcedures:
		m.ResetProcedures()
		return nil
	case controlobjective.EdgeRisks:
		m.ResetRisks()
		return nil
	case controlobjective.EdgeSubcontrols:
		m.ResetSubcontrols()
		return nil
	case controlobjective.EdgeStandard:
		m.ResetStandard()
		return nil
	case controlobjective.EdgeNarratives:
		m.ResetNarratives()
		return nil
	case controlobjective.EdgeTasks:
		m.ResetTasks()
		return nil
	case controlobjective.EdgePrograms:
		m.ResetPrograms()
		return nil
	}
	return fmt.Errorf("unknown ControlObjective edge %s", name)
}

// ControlObjectiveHistoryMutation represents an operation that mutates the ControlObjectiveHistory nodes in the graph.
type ControlObjectiveHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	history_time           *time.Time
	ref                    *string
	operation              *history.OpType
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	deleted_at             *time.Time
	deleted_by             *string
	mapping_id             *string
	tags                   *[]string
	appendtags             []string
	name                   *string
	description            *string
	status                 *string
	control_objective_type *string
	version                *string
	control_number         *string
	family                 *string
	class                  *string
	source                 *string
	mapped_frameworks      *string
	details                *map[string]interface{}
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ControlObjectiveHistory, error)
	predicates             []predicate.ControlObjectiveHistory
}

var _ ent.Mutation = (*ControlObjectiveHistoryMutation)(nil)

// controlobjectivehistoryOption allows management of the mutation configuration using functional options.
type controlobjectivehistoryOption func(*ControlObjectiveHistoryMutation)

// newControlObjectiveHistoryMutation creates new mutation for the ControlObjectiveHistory entity.
func newControlObjectiveHistoryMutation(c config, op Op, opts ...controlobjectivehistoryOption) *ControlObjectiveHistoryMutation {
	m := &ControlObjectiveHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeControlObjectiveHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withControlObjectiveHistoryID sets the ID field of the mutation.
func withControlObjectiveHistoryID(id string) controlobjectivehistoryOption {
	return func(m *ControlObjectiveHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ControlObjectiveHistory
		)
		m.oldValue = func(ctx context.Context) (*ControlObjectiveHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ControlObjectiveHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withControlObjectiveHistory sets the old ControlObjectiveHistory of the mutation.
func withControlObjectiveHistory(node *ControlObjectiveHistory) controlobjectivehistoryOption {
	return func(m *ControlObjectiveHistoryMutation) {
		m.oldValue = func(context.Context) (*ControlObjectiveHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ControlObjectiveHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ControlObjectiveHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ControlObjectiveHistory entities.
func (m *ControlObjectiveHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ControlObjectiveHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ControlObjectiveHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ControlObjectiveHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ControlObjectiveHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ControlObjectiveHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ControlObjectiveHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ControlObjectiveHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ControlObjectiveHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[controlobjectivehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ControlObjectiveHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, controlobjectivehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ControlObjectiveHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ControlObjectiveHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ControlObjectiveHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ControlObjectiveHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ControlObjectiveHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[controlobjectivehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ControlObjectiveHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, controlobjectivehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ControlObjectiveHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ControlObjectiveHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ControlObjectiveHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[controlobjectivehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ControlObjectiveHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, controlobjectivehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ControlObjectiveHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ControlObjectiveHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ControlObjectiveHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[controlobjectivehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ControlObjectiveHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, controlobjectivehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ControlObjectiveHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ControlObjectiveHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ControlObjectiveHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[controlobjectivehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ControlObjectiveHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, controlobjectivehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ControlObjectiveHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ControlObjectiveHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ControlObjectiveHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[controlobjectivehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ControlObjectiveHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, controlobjectivehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ControlObjectiveHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ControlObjectiveHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ControlObjectiveHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[controlobjectivehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ControlObjectiveHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, controlobjectivehistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ControlObjectiveHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ControlObjectiveHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ControlObjectiveHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *ControlObjectiveHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ControlObjectiveHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ControlObjectiveHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ControlObjectiveHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[controlobjectivehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ControlObjectiveHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, controlobjectivehistory.FieldTags)
}

// SetName sets the "name" field.
func (m *ControlObjectiveHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ControlObjectiveHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ControlObjectiveHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ControlObjectiveHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[controlobjectivehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ControlObjectiveHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, controlobjectivehistory.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ControlObjectiveHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ControlObjectiveHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[controlobjectivehistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ControlObjectiveHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, controlobjectivehistory.FieldStatus)
}

// SetControlObjectiveType sets the "control_objective_type" field.
func (m *ControlObjectiveHistoryMutation) SetControlObjectiveType(s string) {
	m.control_objective_type = &s
}

// ControlObjectiveType returns the value of the "control_objective_type" field in the mutation.
func (m *ControlObjectiveHistoryMutation) ControlObjectiveType() (r string, exists bool) {
	v := m.control_objective_type
	if v == nil {
		return
	}
	return *v, true
}

// OldControlObjectiveType returns the old "control_objective_type" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldControlObjectiveType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlObjectiveType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlObjectiveType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlObjectiveType: %w", err)
	}
	return oldValue.ControlObjectiveType, nil
}

// ClearControlObjectiveType clears the value of the "control_objective_type" field.
func (m *ControlObjectiveHistoryMutation) ClearControlObjectiveType() {
	m.control_objective_type = nil
	m.clearedFields[controlobjectivehistory.FieldControlObjectiveType] = struct{}{}
}

// ControlObjectiveTypeCleared returns if the "control_objective_type" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) ControlObjectiveTypeCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldControlObjectiveType]
	return ok
}

// ResetControlObjectiveType resets all changes to the "control_objective_type" field.
func (m *ControlObjectiveHistoryMutation) ResetControlObjectiveType() {
	m.control_objective_type = nil
	delete(m.clearedFields, controlobjectivehistory.FieldControlObjectiveType)
}

// SetVersion sets the "version" field.
func (m *ControlObjectiveHistoryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ControlObjectiveHistoryMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[controlobjectivehistory.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) VersionCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ControlObjectiveHistoryMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, controlobjectivehistory.FieldVersion)
}

// SetControlNumber sets the "control_number" field.
func (m *ControlObjectiveHistoryMutation) SetControlNumber(s string) {
	m.control_number = &s
}

// ControlNumber returns the value of the "control_number" field in the mutation.
func (m *ControlObjectiveHistoryMutation) ControlNumber() (r string, exists bool) {
	v := m.control_number
	if v == nil {
		return
	}
	return *v, true
}

// OldControlNumber returns the old "control_number" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldControlNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldControlNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldControlNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldControlNumber: %w", err)
	}
	return oldValue.ControlNumber, nil
}

// ClearControlNumber clears the value of the "control_number" field.
func (m *ControlObjectiveHistoryMutation) ClearControlNumber() {
	m.control_number = nil
	m.clearedFields[controlobjectivehistory.FieldControlNumber] = struct{}{}
}

// ControlNumberCleared returns if the "control_number" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) ControlNumberCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldControlNumber]
	return ok
}

// ResetControlNumber resets all changes to the "control_number" field.
func (m *ControlObjectiveHistoryMutation) ResetControlNumber() {
	m.control_number = nil
	delete(m.clearedFields, controlobjectivehistory.FieldControlNumber)
}

// SetFamily sets the "family" field.
func (m *ControlObjectiveHistoryMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ClearFamily clears the value of the "family" field.
func (m *ControlObjectiveHistoryMutation) ClearFamily() {
	m.family = nil
	m.clearedFields[controlobjectivehistory.FieldFamily] = struct{}{}
}

// FamilyCleared returns if the "family" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) FamilyCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldFamily]
	return ok
}

// ResetFamily resets all changes to the "family" field.
func (m *ControlObjectiveHistoryMutation) ResetFamily() {
	m.family = nil
	delete(m.clearedFields, controlobjectivehistory.FieldFamily)
}

// SetClass sets the "class" field.
func (m *ControlObjectiveHistoryMutation) SetClass(s string) {
	m.class = &s
}

// Class returns the value of the "class" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Class() (r string, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ClearClass clears the value of the "class" field.
func (m *ControlObjectiveHistoryMutation) ClearClass() {
	m.class = nil
	m.clearedFields[controlobjectivehistory.FieldClass] = struct{}{}
}

// ClassCleared returns if the "class" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) ClassCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldClass]
	return ok
}

// ResetClass resets all changes to the "class" field.
func (m *ControlObjectiveHistoryMutation) ResetClass() {
	m.class = nil
	delete(m.clearedFields, controlobjectivehistory.FieldClass)
}

// SetSource sets the "source" field.
func (m *ControlObjectiveHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ControlObjectiveHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[controlobjectivehistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ControlObjectiveHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, controlobjectivehistory.FieldSource)
}

// SetMappedFrameworks sets the "mapped_frameworks" field.
func (m *ControlObjectiveHistoryMutation) SetMappedFrameworks(s string) {
	m.mapped_frameworks = &s
}

// MappedFrameworks returns the value of the "mapped_frameworks" field in the mutation.
func (m *ControlObjectiveHistoryMutation) MappedFrameworks() (r string, exists bool) {
	v := m.mapped_frameworks
	if v == nil {
		return
	}
	return *v, true
}

// OldMappedFrameworks returns the old "mapped_frameworks" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldMappedFrameworks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappedFrameworks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappedFrameworks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappedFrameworks: %w", err)
	}
	return oldValue.MappedFrameworks, nil
}

// ClearMappedFrameworks clears the value of the "mapped_frameworks" field.
func (m *ControlObjectiveHistoryMutation) ClearMappedFrameworks() {
	m.mapped_frameworks = nil
	m.clearedFields[controlobjectivehistory.FieldMappedFrameworks] = struct{}{}
}

// MappedFrameworksCleared returns if the "mapped_frameworks" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) MappedFrameworksCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldMappedFrameworks]
	return ok
}

// ResetMappedFrameworks resets all changes to the "mapped_frameworks" field.
func (m *ControlObjectiveHistoryMutation) ResetMappedFrameworks() {
	m.mapped_frameworks = nil
	delete(m.clearedFields, controlobjectivehistory.FieldMappedFrameworks)
}

// SetDetails sets the "details" field.
func (m *ControlObjectiveHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *ControlObjectiveHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ControlObjectiveHistory entity.
// If the ControlObjectiveHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ControlObjectiveHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ControlObjectiveHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[controlobjectivehistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[controlobjectivehistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ControlObjectiveHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, controlobjectivehistory.FieldDetails)
}

// Where appends a list predicates to the ControlObjectiveHistoryMutation builder.
func (m *ControlObjectiveHistoryMutation) Where(ps ...predicate.ControlObjectiveHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ControlObjectiveHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ControlObjectiveHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ControlObjectiveHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ControlObjectiveHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ControlObjectiveHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ControlObjectiveHistory).
func (m *ControlObjectiveHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ControlObjectiveHistoryMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.history_time != nil {
		fields = append(fields, controlobjectivehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, controlobjectivehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, controlobjectivehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, controlobjectivehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, controlobjectivehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, controlobjectivehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, controlobjectivehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, controlobjectivehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, controlobjectivehistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, controlobjectivehistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, controlobjectivehistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, controlobjectivehistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, controlobjectivehistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, controlobjectivehistory.FieldStatus)
	}
	if m.control_objective_type != nil {
		fields = append(fields, controlobjectivehistory.FieldControlObjectiveType)
	}
	if m.version != nil {
		fields = append(fields, controlobjectivehistory.FieldVersion)
	}
	if m.control_number != nil {
		fields = append(fields, controlobjectivehistory.FieldControlNumber)
	}
	if m.family != nil {
		fields = append(fields, controlobjectivehistory.FieldFamily)
	}
	if m.class != nil {
		fields = append(fields, controlobjectivehistory.FieldClass)
	}
	if m.source != nil {
		fields = append(fields, controlobjectivehistory.FieldSource)
	}
	if m.mapped_frameworks != nil {
		fields = append(fields, controlobjectivehistory.FieldMappedFrameworks)
	}
	if m.details != nil {
		fields = append(fields, controlobjectivehistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ControlObjectiveHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case controlobjectivehistory.FieldHistoryTime:
		return m.HistoryTime()
	case controlobjectivehistory.FieldRef:
		return m.Ref()
	case controlobjectivehistory.FieldOperation:
		return m.Operation()
	case controlobjectivehistory.FieldCreatedAt:
		return m.CreatedAt()
	case controlobjectivehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case controlobjectivehistory.FieldCreatedBy:
		return m.CreatedBy()
	case controlobjectivehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case controlobjectivehistory.FieldDeletedAt:
		return m.DeletedAt()
	case controlobjectivehistory.FieldDeletedBy:
		return m.DeletedBy()
	case controlobjectivehistory.FieldMappingID:
		return m.MappingID()
	case controlobjectivehistory.FieldTags:
		return m.Tags()
	case controlobjectivehistory.FieldName:
		return m.Name()
	case controlobjectivehistory.FieldDescription:
		return m.Description()
	case controlobjectivehistory.FieldStatus:
		return m.Status()
	case controlobjectivehistory.FieldControlObjectiveType:
		return m.ControlObjectiveType()
	case controlobjectivehistory.FieldVersion:
		return m.Version()
	case controlobjectivehistory.FieldControlNumber:
		return m.ControlNumber()
	case controlobjectivehistory.FieldFamily:
		return m.Family()
	case controlobjectivehistory.FieldClass:
		return m.Class()
	case controlobjectivehistory.FieldSource:
		return m.Source()
	case controlobjectivehistory.FieldMappedFrameworks:
		return m.MappedFrameworks()
	case controlobjectivehistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ControlObjectiveHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case controlobjectivehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case controlobjectivehistory.FieldRef:
		return m.OldRef(ctx)
	case controlobjectivehistory.FieldOperation:
		return m.OldOperation(ctx)
	case controlobjectivehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case controlobjectivehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case controlobjectivehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case controlobjectivehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case controlobjectivehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case controlobjectivehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case controlobjectivehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case controlobjectivehistory.FieldTags:
		return m.OldTags(ctx)
	case controlobjectivehistory.FieldName:
		return m.OldName(ctx)
	case controlobjectivehistory.FieldDescription:
		return m.OldDescription(ctx)
	case controlobjectivehistory.FieldStatus:
		return m.OldStatus(ctx)
	case controlobjectivehistory.FieldControlObjectiveType:
		return m.OldControlObjectiveType(ctx)
	case controlobjectivehistory.FieldVersion:
		return m.OldVersion(ctx)
	case controlobjectivehistory.FieldControlNumber:
		return m.OldControlNumber(ctx)
	case controlobjectivehistory.FieldFamily:
		return m.OldFamily(ctx)
	case controlobjectivehistory.FieldClass:
		return m.OldClass(ctx)
	case controlobjectivehistory.FieldSource:
		return m.OldSource(ctx)
	case controlobjectivehistory.FieldMappedFrameworks:
		return m.OldMappedFrameworks(ctx)
	case controlobjectivehistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown ControlObjectiveHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlObjectiveHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case controlobjectivehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case controlobjectivehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case controlobjectivehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case controlobjectivehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case controlobjectivehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case controlobjectivehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case controlobjectivehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case controlobjectivehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case controlobjectivehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case controlobjectivehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case controlobjectivehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case controlobjectivehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case controlobjectivehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case controlobjectivehistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case controlobjectivehistory.FieldControlObjectiveType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlObjectiveType(v)
		return nil
	case controlobjectivehistory.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case controlobjectivehistory.FieldControlNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetControlNumber(v)
		return nil
	case controlobjectivehistory.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case controlobjectivehistory.FieldClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case controlobjectivehistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case controlobjectivehistory.FieldMappedFrameworks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappedFrameworks(v)
		return nil
	case controlobjectivehistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown ControlObjectiveHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ControlObjectiveHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ControlObjectiveHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ControlObjectiveHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ControlObjectiveHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ControlObjectiveHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(controlobjectivehistory.FieldRef) {
		fields = append(fields, controlobjectivehistory.FieldRef)
	}
	if m.FieldCleared(controlobjectivehistory.FieldCreatedAt) {
		fields = append(fields, controlobjectivehistory.FieldCreatedAt)
	}
	if m.FieldCleared(controlobjectivehistory.FieldUpdatedAt) {
		fields = append(fields, controlobjectivehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(controlobjectivehistory.FieldCreatedBy) {
		fields = append(fields, controlobjectivehistory.FieldCreatedBy)
	}
	if m.FieldCleared(controlobjectivehistory.FieldUpdatedBy) {
		fields = append(fields, controlobjectivehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(controlobjectivehistory.FieldDeletedAt) {
		fields = append(fields, controlobjectivehistory.FieldDeletedAt)
	}
	if m.FieldCleared(controlobjectivehistory.FieldDeletedBy) {
		fields = append(fields, controlobjectivehistory.FieldDeletedBy)
	}
	if m.FieldCleared(controlobjectivehistory.FieldTags) {
		fields = append(fields, controlobjectivehistory.FieldTags)
	}
	if m.FieldCleared(controlobjectivehistory.FieldDescription) {
		fields = append(fields, controlobjectivehistory.FieldDescription)
	}
	if m.FieldCleared(controlobjectivehistory.FieldStatus) {
		fields = append(fields, controlobjectivehistory.FieldStatus)
	}
	if m.FieldCleared(controlobjectivehistory.FieldControlObjectiveType) {
		fields = append(fields, controlobjectivehistory.FieldControlObjectiveType)
	}
	if m.FieldCleared(controlobjectivehistory.FieldVersion) {
		fields = append(fields, controlobjectivehistory.FieldVersion)
	}
	if m.FieldCleared(controlobjectivehistory.FieldControlNumber) {
		fields = append(fields, controlobjectivehistory.FieldControlNumber)
	}
	if m.FieldCleared(controlobjectivehistory.FieldFamily) {
		fields = append(fields, controlobjectivehistory.FieldFamily)
	}
	if m.FieldCleared(controlobjectivehistory.FieldClass) {
		fields = append(fields, controlobjectivehistory.FieldClass)
	}
	if m.FieldCleared(controlobjectivehistory.FieldSource) {
		fields = append(fields, controlobjectivehistory.FieldSource)
	}
	if m.FieldCleared(controlobjectivehistory.FieldMappedFrameworks) {
		fields = append(fields, controlobjectivehistory.FieldMappedFrameworks)
	}
	if m.FieldCleared(controlobjectivehistory.FieldDetails) {
		fields = append(fields, controlobjectivehistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ControlObjectiveHistoryMutation) ClearField(name string) error {
	switch name {
	case controlobjectivehistory.FieldRef:
		m.ClearRef()
		return nil
	case controlobjectivehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case controlobjectivehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case controlobjectivehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case controlobjectivehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case controlobjectivehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case controlobjectivehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case controlobjectivehistory.FieldTags:
		m.ClearTags()
		return nil
	case controlobjectivehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case controlobjectivehistory.FieldStatus:
		m.ClearStatus()
		return nil
	case controlobjectivehistory.FieldControlObjectiveType:
		m.ClearControlObjectiveType()
		return nil
	case controlobjectivehistory.FieldVersion:
		m.ClearVersion()
		return nil
	case controlobjectivehistory.FieldControlNumber:
		m.ClearControlNumber()
		return nil
	case controlobjectivehistory.FieldFamily:
		m.ClearFamily()
		return nil
	case controlobjectivehistory.FieldClass:
		m.ClearClass()
		return nil
	case controlobjectivehistory.FieldSource:
		m.ClearSource()
		return nil
	case controlobjectivehistory.FieldMappedFrameworks:
		m.ClearMappedFrameworks()
		return nil
	case controlobjectivehistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown ControlObjectiveHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ControlObjectiveHistoryMutation) ResetField(name string) error {
	switch name {
	case controlobjectivehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case controlobjectivehistory.FieldRef:
		m.ResetRef()
		return nil
	case controlobjectivehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case controlobjectivehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case controlobjectivehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case controlobjectivehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case controlobjectivehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case controlobjectivehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case controlobjectivehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case controlobjectivehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case controlobjectivehistory.FieldTags:
		m.ResetTags()
		return nil
	case controlobjectivehistory.FieldName:
		m.ResetName()
		return nil
	case controlobjectivehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case controlobjectivehistory.FieldStatus:
		m.ResetStatus()
		return nil
	case controlobjectivehistory.FieldControlObjectiveType:
		m.ResetControlObjectiveType()
		return nil
	case controlobjectivehistory.FieldVersion:
		m.ResetVersion()
		return nil
	case controlobjectivehistory.FieldControlNumber:
		m.ResetControlNumber()
		return nil
	case controlobjectivehistory.FieldFamily:
		m.ResetFamily()
		return nil
	case controlobjectivehistory.FieldClass:
		m.ResetClass()
		return nil
	case controlobjectivehistory.FieldSource:
		m.ResetSource()
		return nil
	case controlobjectivehistory.FieldMappedFrameworks:
		m.ResetMappedFrameworks()
		return nil
	case controlobjectivehistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown ControlObjectiveHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ControlObjectiveHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ControlObjectiveHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ControlObjectiveHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ControlObjectiveHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ControlObjectiveHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ControlObjectiveHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ControlObjectiveHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ControlObjectiveHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ControlObjectiveHistory edge %s", name)
}

// DocumentDataMutation represents an operation that mutates the DocumentData nodes in the graph.
type DocumentDataMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	mapping_id      *string
	tags            *[]string
	appendtags      []string
	deleted_at      *time.Time
	deleted_by      *string
	data            *customtypes.JSONObject
	clearedFields   map[string]struct{}
	owner           *string
	clearedowner    bool
	template        *string
	clearedtemplate bool
	entity          map[string]struct{}
	removedentity   map[string]struct{}
	clearedentity   bool
	files           map[string]struct{}
	removedfiles    map[string]struct{}
	clearedfiles    bool
	done            bool
	oldValue        func(context.Context) (*DocumentData, error)
	predicates      []predicate.DocumentData
}

var _ ent.Mutation = (*DocumentDataMutation)(nil)

// documentdataOption allows management of the mutation configuration using functional options.
type documentdataOption func(*DocumentDataMutation)

// newDocumentDataMutation creates new mutation for the DocumentData entity.
func newDocumentDataMutation(c config, op Op, opts ...documentdataOption) *DocumentDataMutation {
	m := &DocumentDataMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentDataID sets the ID field of the mutation.
func withDocumentDataID(id string) documentdataOption {
	return func(m *DocumentDataMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentData
		)
		m.oldValue = func(ctx context.Context) (*DocumentData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentData sets the old DocumentData of the mutation.
func withDocumentData(node *DocumentData) documentdataOption {
	return func(m *DocumentDataMutation) {
		m.oldValue = func(context.Context) (*DocumentData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentData entities.
func (m *DocumentDataMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentDataMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentDataMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DocumentDataMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[documentdata.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DocumentDataMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[documentdata.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentDataMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, documentdata.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DocumentDataMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[documentdata.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DocumentDataMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[documentdata.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, documentdata.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DocumentDataMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DocumentDataMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DocumentDataMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[documentdata.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DocumentDataMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[documentdata.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DocumentDataMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, documentdata.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DocumentDataMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DocumentDataMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DocumentDataMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[documentdata.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DocumentDataMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[documentdata.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DocumentDataMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, documentdata.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *DocumentDataMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *DocumentDataMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *DocumentDataMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *DocumentDataMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DocumentDataMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *DocumentDataMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *DocumentDataMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *DocumentDataMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[documentdata.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *DocumentDataMutation) TagsCleared() bool {
	_, ok := m.clearedFields[documentdata.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *DocumentDataMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, documentdata.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DocumentDataMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DocumentDataMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DocumentDataMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[documentdata.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DocumentDataMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[documentdata.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DocumentDataMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, documentdata.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DocumentDataMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DocumentDataMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DocumentDataMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[documentdata.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DocumentDataMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[documentdata.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DocumentDataMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, documentdata.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *DocumentDataMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DocumentDataMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *DocumentDataMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[documentdata.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *DocumentDataMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[documentdata.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DocumentDataMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, documentdata.FieldOwnerID)
}

// SetTemplateID sets the "template_id" field.
func (m *DocumentDataMutation) SetTemplateID(s string) {
	m.template = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *DocumentDataMutation) TemplateID() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *DocumentDataMutation) ResetTemplateID() {
	m.template = nil
}

// SetData sets the "data" field.
func (m *DocumentDataMutation) SetData(co customtypes.JSONObject) {
	m.data = &co
}

// Data returns the value of the "data" field in the mutation.
func (m *DocumentDataMutation) Data() (r customtypes.JSONObject, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the DocumentData entity.
// If the DocumentData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataMutation) OldData(ctx context.Context) (v customtypes.JSONObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *DocumentDataMutation) ResetData() {
	m.data = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *DocumentDataMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[documentdata.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *DocumentDataMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DocumentDataMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DocumentDataMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearTemplate clears the "template" edge to the Template entity.
func (m *DocumentDataMutation) ClearTemplate() {
	m.clearedtemplate = true
	m.clearedFields[documentdata.FieldTemplateID] = struct{}{}
}

// TemplateCleared reports if the "template" edge to the Template entity was cleared.
func (m *DocumentDataMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *DocumentDataMutation) TemplateIDs() (ids []string) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *DocumentDataMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// AddEntityIDs adds the "entity" edge to the Entity entity by ids.
func (m *DocumentDataMutation) AddEntityIDs(ids ...string) {
	if m.entity == nil {
		m.entity = make(map[string]struct{})
	}
	for i := range ids {
		m.entity[ids[i]] = struct{}{}
	}
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *DocumentDataMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *DocumentDataMutation) EntityCleared() bool {
	return m.clearedentity
}

// RemoveEntityIDs removes the "entity" edge to the Entity entity by IDs.
func (m *DocumentDataMutation) RemoveEntityIDs(ids ...string) {
	if m.removedentity == nil {
		m.removedentity = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entity, ids[i])
		m.removedentity[ids[i]] = struct{}{}
	}
}

// RemovedEntity returns the removed IDs of the "entity" edge to the Entity entity.
func (m *DocumentDataMutation) RemovedEntityIDs() (ids []string) {
	for id := range m.removedentity {
		ids = append(ids, id)
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
func (m *DocumentDataMutation) EntityIDs() (ids []string) {
	for id := range m.entity {
		ids = append(ids, id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *DocumentDataMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
	m.removedentity = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *DocumentDataMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *DocumentDataMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *DocumentDataMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *DocumentDataMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *DocumentDataMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *DocumentDataMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *DocumentDataMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the DocumentDataMutation builder.
func (m *DocumentDataMutation) Where(ps ...predicate.DocumentData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentData).
func (m *DocumentDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentDataMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, documentdata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, documentdata.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, documentdata.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, documentdata.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, documentdata.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, documentdata.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, documentdata.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, documentdata.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, documentdata.FieldOwnerID)
	}
	if m.template != nil {
		fields = append(fields, documentdata.FieldTemplateID)
	}
	if m.data != nil {
		fields = append(fields, documentdata.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentdata.FieldCreatedAt:
		return m.CreatedAt()
	case documentdata.FieldUpdatedAt:
		return m.UpdatedAt()
	case documentdata.FieldCreatedBy:
		return m.CreatedBy()
	case documentdata.FieldUpdatedBy:
		return m.UpdatedBy()
	case documentdata.FieldMappingID:
		return m.MappingID()
	case documentdata.FieldTags:
		return m.Tags()
	case documentdata.FieldDeletedAt:
		return m.DeletedAt()
	case documentdata.FieldDeletedBy:
		return m.DeletedBy()
	case documentdata.FieldOwnerID:
		return m.OwnerID()
	case documentdata.FieldTemplateID:
		return m.TemplateID()
	case documentdata.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentdata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case documentdata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case documentdata.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case documentdata.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case documentdata.FieldMappingID:
		return m.OldMappingID(ctx)
	case documentdata.FieldTags:
		return m.OldTags(ctx)
	case documentdata.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case documentdata.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case documentdata.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case documentdata.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case documentdata.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentdata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case documentdata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case documentdata.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case documentdata.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case documentdata.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case documentdata.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case documentdata.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case documentdata.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case documentdata.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case documentdata.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case documentdata.FieldData:
		v, ok := value.(customtypes.JSONObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documentdata.FieldCreatedAt) {
		fields = append(fields, documentdata.FieldCreatedAt)
	}
	if m.FieldCleared(documentdata.FieldUpdatedAt) {
		fields = append(fields, documentdata.FieldUpdatedAt)
	}
	if m.FieldCleared(documentdata.FieldCreatedBy) {
		fields = append(fields, documentdata.FieldCreatedBy)
	}
	if m.FieldCleared(documentdata.FieldUpdatedBy) {
		fields = append(fields, documentdata.FieldUpdatedBy)
	}
	if m.FieldCleared(documentdata.FieldTags) {
		fields = append(fields, documentdata.FieldTags)
	}
	if m.FieldCleared(documentdata.FieldDeletedAt) {
		fields = append(fields, documentdata.FieldDeletedAt)
	}
	if m.FieldCleared(documentdata.FieldDeletedBy) {
		fields = append(fields, documentdata.FieldDeletedBy)
	}
	if m.FieldCleared(documentdata.FieldOwnerID) {
		fields = append(fields, documentdata.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentDataMutation) ClearField(name string) error {
	switch name {
	case documentdata.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case documentdata.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case documentdata.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case documentdata.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case documentdata.FieldTags:
		m.ClearTags()
		return nil
	case documentdata.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case documentdata.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case documentdata.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown DocumentData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentDataMutation) ResetField(name string) error {
	switch name {
	case documentdata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case documentdata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case documentdata.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case documentdata.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case documentdata.FieldMappingID:
		m.ResetMappingID()
		return nil
	case documentdata.FieldTags:
		m.ResetTags()
		return nil
	case documentdata.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case documentdata.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case documentdata.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case documentdata.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case documentdata.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown DocumentData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, documentdata.EdgeOwner)
	}
	if m.template != nil {
		edges = append(edges, documentdata.EdgeTemplate)
	}
	if m.entity != nil {
		edges = append(edges, documentdata.EdgeEntity)
	}
	if m.files != nil {
		edges = append(edges, documentdata.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documentdata.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case documentdata.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case documentdata.EdgeEntity:
		ids := make([]ent.Value, 0, len(m.entity))
		for id := range m.entity {
			ids = append(ids, id)
		}
		return ids
	case documentdata.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedentity != nil {
		edges = append(edges, documentdata.EdgeEntity)
	}
	if m.removedfiles != nil {
		edges = append(edges, documentdata.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case documentdata.EdgeEntity:
		ids := make([]ent.Value, 0, len(m.removedentity))
		for id := range m.removedentity {
			ids = append(ids, id)
		}
		return ids
	case documentdata.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, documentdata.EdgeOwner)
	}
	if m.clearedtemplate {
		edges = append(edges, documentdata.EdgeTemplate)
	}
	if m.clearedentity {
		edges = append(edges, documentdata.EdgeEntity)
	}
	if m.clearedfiles {
		edges = append(edges, documentdata.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentDataMutation) EdgeCleared(name string) bool {
	switch name {
	case documentdata.EdgeOwner:
		return m.clearedowner
	case documentdata.EdgeTemplate:
		return m.clearedtemplate
	case documentdata.EdgeEntity:
		return m.clearedentity
	case documentdata.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentDataMutation) ClearEdge(name string) error {
	switch name {
	case documentdata.EdgeOwner:
		m.ClearOwner()
		return nil
	case documentdata.EdgeTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown DocumentData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentDataMutation) ResetEdge(name string) error {
	switch name {
	case documentdata.EdgeOwner:
		m.ResetOwner()
		return nil
	case documentdata.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case documentdata.EdgeEntity:
		m.ResetEntity()
		return nil
	case documentdata.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown DocumentData edge %s", name)
}

// DocumentDataHistoryMutation represents an operation that mutates the DocumentDataHistory nodes in the graph.
type DocumentDataHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	deleted_at    *time.Time
	deleted_by    *string
	owner_id      *string
	template_id   *string
	data          *customtypes.JSONObject
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DocumentDataHistory, error)
	predicates    []predicate.DocumentDataHistory
}

var _ ent.Mutation = (*DocumentDataHistoryMutation)(nil)

// documentdatahistoryOption allows management of the mutation configuration using functional options.
type documentdatahistoryOption func(*DocumentDataHistoryMutation)

// newDocumentDataHistoryMutation creates new mutation for the DocumentDataHistory entity.
func newDocumentDataHistoryMutation(c config, op Op, opts ...documentdatahistoryOption) *DocumentDataHistoryMutation {
	m := &DocumentDataHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentDataHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentDataHistoryID sets the ID field of the mutation.
func withDocumentDataHistoryID(id string) documentdatahistoryOption {
	return func(m *DocumentDataHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentDataHistory
		)
		m.oldValue = func(ctx context.Context) (*DocumentDataHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentDataHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentDataHistory sets the old DocumentDataHistory of the mutation.
func withDocumentDataHistory(node *DocumentDataHistory) documentdatahistoryOption {
	return func(m *DocumentDataHistoryMutation) {
		m.oldValue = func(context.Context) (*DocumentDataHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentDataHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentDataHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentDataHistory entities.
func (m *DocumentDataHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentDataHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentDataHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentDataHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *DocumentDataHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *DocumentDataHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *DocumentDataHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *DocumentDataHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *DocumentDataHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *DocumentDataHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[documentdatahistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *DocumentDataHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, documentdatahistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *DocumentDataHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *DocumentDataHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *DocumentDataHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentDataHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentDataHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DocumentDataHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[documentdatahistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentDataHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, documentdatahistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentDataHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentDataHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DocumentDataHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[documentdatahistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentDataHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, documentdatahistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *DocumentDataHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DocumentDataHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DocumentDataHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[documentdatahistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DocumentDataHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, documentdatahistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DocumentDataHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DocumentDataHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DocumentDataHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[documentdatahistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DocumentDataHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, documentdatahistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *DocumentDataHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *DocumentDataHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *DocumentDataHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *DocumentDataHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DocumentDataHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *DocumentDataHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *DocumentDataHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *DocumentDataHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[documentdatahistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *DocumentDataHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, documentdatahistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DocumentDataHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DocumentDataHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DocumentDataHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[documentdatahistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DocumentDataHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, documentdatahistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *DocumentDataHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *DocumentDataHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *DocumentDataHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[documentdatahistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *DocumentDataHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, documentdatahistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *DocumentDataHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *DocumentDataHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *DocumentDataHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[documentdatahistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *DocumentDataHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[documentdatahistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *DocumentDataHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, documentdatahistory.FieldOwnerID)
}

// SetTemplateID sets the "template_id" field.
func (m *DocumentDataHistoryMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *DocumentDataHistoryMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *DocumentDataHistoryMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetData sets the "data" field.
func (m *DocumentDataHistoryMutation) SetData(co customtypes.JSONObject) {
	m.data = &co
}

// Data returns the value of the "data" field in the mutation.
func (m *DocumentDataHistoryMutation) Data() (r customtypes.JSONObject, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the DocumentDataHistory entity.
// If the DocumentDataHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentDataHistoryMutation) OldData(ctx context.Context) (v customtypes.JSONObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *DocumentDataHistoryMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the DocumentDataHistoryMutation builder.
func (m *DocumentDataHistoryMutation) Where(ps ...predicate.DocumentDataHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentDataHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentDataHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentDataHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentDataHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentDataHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentDataHistory).
func (m *DocumentDataHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentDataHistoryMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.history_time != nil {
		fields = append(fields, documentdatahistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, documentdatahistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, documentdatahistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, documentdatahistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, documentdatahistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, documentdatahistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, documentdatahistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, documentdatahistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, documentdatahistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, documentdatahistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, documentdatahistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, documentdatahistory.FieldOwnerID)
	}
	if m.template_id != nil {
		fields = append(fields, documentdatahistory.FieldTemplateID)
	}
	if m.data != nil {
		fields = append(fields, documentdatahistory.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentDataHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentdatahistory.FieldHistoryTime:
		return m.HistoryTime()
	case documentdatahistory.FieldRef:
		return m.Ref()
	case documentdatahistory.FieldOperation:
		return m.Operation()
	case documentdatahistory.FieldCreatedAt:
		return m.CreatedAt()
	case documentdatahistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case documentdatahistory.FieldCreatedBy:
		return m.CreatedBy()
	case documentdatahistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case documentdatahistory.FieldMappingID:
		return m.MappingID()
	case documentdatahistory.FieldTags:
		return m.Tags()
	case documentdatahistory.FieldDeletedAt:
		return m.DeletedAt()
	case documentdatahistory.FieldDeletedBy:
		return m.DeletedBy()
	case documentdatahistory.FieldOwnerID:
		return m.OwnerID()
	case documentdatahistory.FieldTemplateID:
		return m.TemplateID()
	case documentdatahistory.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentDataHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentdatahistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case documentdatahistory.FieldRef:
		return m.OldRef(ctx)
	case documentdatahistory.FieldOperation:
		return m.OldOperation(ctx)
	case documentdatahistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case documentdatahistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case documentdatahistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case documentdatahistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case documentdatahistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case documentdatahistory.FieldTags:
		return m.OldTags(ctx)
	case documentdatahistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case documentdatahistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case documentdatahistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case documentdatahistory.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case documentdatahistory.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentDataHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentDataHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentdatahistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case documentdatahistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case documentdatahistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case documentdatahistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case documentdatahistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case documentdatahistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case documentdatahistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case documentdatahistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case documentdatahistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case documentdatahistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case documentdatahistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case documentdatahistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case documentdatahistory.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case documentdatahistory.FieldData:
		v, ok := value.(customtypes.JSONObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentDataHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentDataHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentDataHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentDataHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentDataHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentDataHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documentdatahistory.FieldRef) {
		fields = append(fields, documentdatahistory.FieldRef)
	}
	if m.FieldCleared(documentdatahistory.FieldCreatedAt) {
		fields = append(fields, documentdatahistory.FieldCreatedAt)
	}
	if m.FieldCleared(documentdatahistory.FieldUpdatedAt) {
		fields = append(fields, documentdatahistory.FieldUpdatedAt)
	}
	if m.FieldCleared(documentdatahistory.FieldCreatedBy) {
		fields = append(fields, documentdatahistory.FieldCreatedBy)
	}
	if m.FieldCleared(documentdatahistory.FieldUpdatedBy) {
		fields = append(fields, documentdatahistory.FieldUpdatedBy)
	}
	if m.FieldCleared(documentdatahistory.FieldTags) {
		fields = append(fields, documentdatahistory.FieldTags)
	}
	if m.FieldCleared(documentdatahistory.FieldDeletedAt) {
		fields = append(fields, documentdatahistory.FieldDeletedAt)
	}
	if m.FieldCleared(documentdatahistory.FieldDeletedBy) {
		fields = append(fields, documentdatahistory.FieldDeletedBy)
	}
	if m.FieldCleared(documentdatahistory.FieldOwnerID) {
		fields = append(fields, documentdatahistory.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentDataHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentDataHistoryMutation) ClearField(name string) error {
	switch name {
	case documentdatahistory.FieldRef:
		m.ClearRef()
		return nil
	case documentdatahistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case documentdatahistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case documentdatahistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case documentdatahistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case documentdatahistory.FieldTags:
		m.ClearTags()
		return nil
	case documentdatahistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case documentdatahistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case documentdatahistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown DocumentDataHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentDataHistoryMutation) ResetField(name string) error {
	switch name {
	case documentdatahistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case documentdatahistory.FieldRef:
		m.ResetRef()
		return nil
	case documentdatahistory.FieldOperation:
		m.ResetOperation()
		return nil
	case documentdatahistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case documentdatahistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case documentdatahistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case documentdatahistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case documentdatahistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case documentdatahistory.FieldTags:
		m.ResetTags()
		return nil
	case documentdatahistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case documentdatahistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case documentdatahistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case documentdatahistory.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case documentdatahistory.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown DocumentDataHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentDataHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentDataHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentDataHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentDataHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentDataHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentDataHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentDataHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DocumentDataHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentDataHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DocumentDataHistory edge %s", name)
}

// EmailVerificationTokenMutation represents an operation that mutates the EmailVerificationToken nodes in the graph.
type EmailVerificationTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	token         *string
	ttl           *time.Time
	email         *string
	secret        *[]byte
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*EmailVerificationToken, error)
	predicates    []predicate.EmailVerificationToken
}

var _ ent.Mutation = (*EmailVerificationTokenMutation)(nil)

// emailverificationtokenOption allows management of the mutation configuration using functional options.
type emailverificationtokenOption func(*EmailVerificationTokenMutation)

// newEmailVerificationTokenMutation creates new mutation for the EmailVerificationToken entity.
func newEmailVerificationTokenMutation(c config, op Op, opts ...emailverificationtokenOption) *EmailVerificationTokenMutation {
	m := &EmailVerificationTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailVerificationToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailVerificationTokenID sets the ID field of the mutation.
func withEmailVerificationTokenID(id string) emailverificationtokenOption {
	return func(m *EmailVerificationTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailVerificationToken
		)
		m.oldValue = func(ctx context.Context) (*EmailVerificationToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailVerificationToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailVerificationToken sets the old EmailVerificationToken of the mutation.
func withEmailVerificationToken(node *EmailVerificationToken) emailverificationtokenOption {
	return func(m *EmailVerificationTokenMutation) {
		m.oldValue = func(context.Context) (*EmailVerificationToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailVerificationTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailVerificationTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailVerificationToken entities.
func (m *EmailVerificationTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailVerificationTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailVerificationTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailVerificationToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailVerificationTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailVerificationTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EmailVerificationTokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[emailverificationtoken.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailVerificationTokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, emailverificationtoken.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailVerificationTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailVerificationTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EmailVerificationTokenMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[emailverificationtoken.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailVerificationTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, emailverificationtoken.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EmailVerificationTokenMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EmailVerificationTokenMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EmailVerificationTokenMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[emailverificationtoken.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EmailVerificationTokenMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, emailverificationtoken.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EmailVerificationTokenMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EmailVerificationTokenMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EmailVerificationTokenMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[emailverificationtoken.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EmailVerificationTokenMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, emailverificationtoken.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EmailVerificationTokenMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EmailVerificationTokenMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EmailVerificationTokenMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmailVerificationTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmailVerificationTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmailVerificationTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[emailverificationtoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmailVerificationTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, emailverificationtoken.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EmailVerificationTokenMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EmailVerificationTokenMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EmailVerificationTokenMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[emailverificationtoken.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EmailVerificationTokenMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, emailverificationtoken.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *EmailVerificationTokenMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EmailVerificationTokenMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EmailVerificationTokenMutation) ResetOwnerID() {
	m.owner = nil
}

// SetToken sets the "token" field.
func (m *EmailVerificationTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *EmailVerificationTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *EmailVerificationTokenMutation) ResetToken() {
	m.token = nil
}

// SetTTL sets the "ttl" field.
func (m *EmailVerificationTokenMutation) SetTTL(t time.Time) {
	m.ttl = &t
}

// TTL returns the value of the "ttl" field in the mutation.
func (m *EmailVerificationTokenMutation) TTL() (r time.Time, exists bool) {
	v := m.ttl
	if v == nil {
		return
	}
	return *v, true
}

// OldTTL returns the old "ttl" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldTTL(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTTL: %w", err)
	}
	return oldValue.TTL, nil
}

// ResetTTL resets all changes to the "ttl" field.
func (m *EmailVerificationTokenMutation) ResetTTL() {
	m.ttl = nil
}

// SetEmail sets the "email" field.
func (m *EmailVerificationTokenMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmailVerificationTokenMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmailVerificationTokenMutation) ResetEmail() {
	m.email = nil
}

// SetSecret sets the "secret" field.
func (m *EmailVerificationTokenMutation) SetSecret(b []byte) {
	m.secret = &b
}

// Secret returns the value of the "secret" field in the mutation.
func (m *EmailVerificationTokenMutation) Secret() (r []byte, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldSecret(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *EmailVerificationTokenMutation) ResetSecret() {
	m.secret = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *EmailVerificationTokenMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[emailverificationtoken.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *EmailVerificationTokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *EmailVerificationTokenMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *EmailVerificationTokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the EmailVerificationTokenMutation builder.
func (m *EmailVerificationTokenMutation) Where(ps ...predicate.EmailVerificationToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailVerificationTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailVerificationTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailVerificationToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailVerificationTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailVerificationTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailVerificationToken).
func (m *EmailVerificationTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailVerificationTokenMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, emailverificationtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailverificationtoken.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, emailverificationtoken.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, emailverificationtoken.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, emailverificationtoken.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, emailverificationtoken.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, emailverificationtoken.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, emailverificationtoken.FieldOwnerID)
	}
	if m.token != nil {
		fields = append(fields, emailverificationtoken.FieldToken)
	}
	if m.ttl != nil {
		fields = append(fields, emailverificationtoken.FieldTTL)
	}
	if m.email != nil {
		fields = append(fields, emailverificationtoken.FieldEmail)
	}
	if m.secret != nil {
		fields = append(fields, emailverificationtoken.FieldSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailVerificationTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		return m.CreatedAt()
	case emailverificationtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailverificationtoken.FieldCreatedBy:
		return m.CreatedBy()
	case emailverificationtoken.FieldUpdatedBy:
		return m.UpdatedBy()
	case emailverificationtoken.FieldMappingID:
		return m.MappingID()
	case emailverificationtoken.FieldDeletedAt:
		return m.DeletedAt()
	case emailverificationtoken.FieldDeletedBy:
		return m.DeletedBy()
	case emailverificationtoken.FieldOwnerID:
		return m.OwnerID()
	case emailverificationtoken.FieldToken:
		return m.Token()
	case emailverificationtoken.FieldTTL:
		return m.TTL()
	case emailverificationtoken.FieldEmail:
		return m.Email()
	case emailverificationtoken.FieldSecret:
		return m.Secret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailVerificationTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailverificationtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailverificationtoken.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case emailverificationtoken.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case emailverificationtoken.FieldMappingID:
		return m.OldMappingID(ctx)
	case emailverificationtoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case emailverificationtoken.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case emailverificationtoken.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case emailverificationtoken.FieldToken:
		return m.OldToken(ctx)
	case emailverificationtoken.FieldTTL:
		return m.OldTTL(ctx)
	case emailverificationtoken.FieldEmail:
		return m.OldEmail(ctx)
	case emailverificationtoken.FieldSecret:
		return m.OldSecret(ctx)
	}
	return nil, fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailVerificationTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailverificationtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailverificationtoken.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case emailverificationtoken.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case emailverificationtoken.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case emailverificationtoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case emailverificationtoken.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case emailverificationtoken.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case emailverificationtoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case emailverificationtoken.FieldTTL:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTTL(v)
		return nil
	case emailverificationtoken.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case emailverificationtoken.FieldSecret:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailVerificationTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailVerificationTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailVerificationTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailVerificationToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailVerificationTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailverificationtoken.FieldCreatedAt) {
		fields = append(fields, emailverificationtoken.FieldCreatedAt)
	}
	if m.FieldCleared(emailverificationtoken.FieldUpdatedAt) {
		fields = append(fields, emailverificationtoken.FieldUpdatedAt)
	}
	if m.FieldCleared(emailverificationtoken.FieldCreatedBy) {
		fields = append(fields, emailverificationtoken.FieldCreatedBy)
	}
	if m.FieldCleared(emailverificationtoken.FieldUpdatedBy) {
		fields = append(fields, emailverificationtoken.FieldUpdatedBy)
	}
	if m.FieldCleared(emailverificationtoken.FieldDeletedAt) {
		fields = append(fields, emailverificationtoken.FieldDeletedAt)
	}
	if m.FieldCleared(emailverificationtoken.FieldDeletedBy) {
		fields = append(fields, emailverificationtoken.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailVerificationTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailVerificationTokenMutation) ClearField(name string) error {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case emailverificationtoken.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case emailverificationtoken.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case emailverificationtoken.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case emailverificationtoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case emailverificationtoken.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailVerificationTokenMutation) ResetField(name string) error {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailverificationtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailverificationtoken.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case emailverificationtoken.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case emailverificationtoken.FieldMappingID:
		m.ResetMappingID()
		return nil
	case emailverificationtoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case emailverificationtoken.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case emailverificationtoken.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case emailverificationtoken.FieldToken:
		m.ResetToken()
		return nil
	case emailverificationtoken.FieldTTL:
		m.ResetTTL()
		return nil
	case emailverificationtoken.FieldEmail:
		m.ResetEmail()
		return nil
	case emailverificationtoken.FieldSecret:
		m.ResetSecret()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailVerificationTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, emailverificationtoken.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailVerificationTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailverificationtoken.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailVerificationTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailVerificationTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailVerificationTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, emailverificationtoken.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailVerificationTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case emailverificationtoken.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailVerificationTokenMutation) ClearEdge(name string) error {
	switch name {
	case emailverificationtoken.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailVerificationTokenMutation) ResetEdge(name string) error {
	switch name {
	case emailverificationtoken.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken edge %s", name)
}

// EntitlementMutation represents an operation that mutates the Entitlement nodes in the graph.
type EntitlementMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	mapping_id               *string
	tags                     *[]string
	appendtags               []string
	deleted_at               *time.Time
	deleted_by               *string
	external_customer_id     *string
	external_subscription_id *string
	expires                  *bool
	expires_at               *time.Time
	cancelled                *bool
	clearedFields            map[string]struct{}
	owner                    *string
	clearedowner             bool
	plan                     *string
	clearedplan              bool
	organization             *string
	clearedorganization      bool
	events                   map[string]struct{}
	removedevents            map[string]struct{}
	clearedevents            bool
	done                     bool
	oldValue                 func(context.Context) (*Entitlement, error)
	predicates               []predicate.Entitlement
}

var _ ent.Mutation = (*EntitlementMutation)(nil)

// entitlementOption allows management of the mutation configuration using functional options.
type entitlementOption func(*EntitlementMutation)

// newEntitlementMutation creates new mutation for the Entitlement entity.
func newEntitlementMutation(c config, op Op, opts ...entitlementOption) *EntitlementMutation {
	m := &EntitlementMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementID sets the ID field of the mutation.
func withEntitlementID(id string) entitlementOption {
	return func(m *EntitlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Entitlement
		)
		m.oldValue = func(ctx context.Context) (*Entitlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entitlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlement sets the old Entitlement of the mutation.
func withEntitlement(node *Entitlement) entitlementOption {
	return func(m *EntitlementMutation) {
		m.oldValue = func(context.Context) (*Entitlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entitlement entities.
func (m *EntitlementMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entitlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntitlementMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitlement.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntitlementMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitlement.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntitlementMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitlement.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntitlementMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitlement.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntitlementMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntitlementMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntitlementMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitlement.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntitlementMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntitlementMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitlement.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntitlementMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntitlementMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntitlementMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitlement.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntitlementMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntitlementMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitlement.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntitlementMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntitlementMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntitlementMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *EntitlementMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntitlementMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntitlementMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntitlementMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntitlementMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitlement.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntitlementMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntitlementMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitlement.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlement.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntitlementMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntitlementMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntitlementMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitlement.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntitlementMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntitlementMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitlement.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntitlementMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntitlementMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntitlementMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[entitlement.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntitlementMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntitlementMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, entitlement.FieldOwnerID)
}

// SetPlanID sets the "plan_id" field.
func (m *EntitlementMutation) SetPlanID(s string) {
	m.plan = &s
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *EntitlementMutation) PlanID() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldPlanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *EntitlementMutation) ResetPlanID() {
	m.plan = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *EntitlementMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EntitlementMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EntitlementMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetExternalCustomerID sets the "external_customer_id" field.
func (m *EntitlementMutation) SetExternalCustomerID(s string) {
	m.external_customer_id = &s
}

// ExternalCustomerID returns the value of the "external_customer_id" field in the mutation.
func (m *EntitlementMutation) ExternalCustomerID() (r string, exists bool) {
	v := m.external_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalCustomerID returns the old "external_customer_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldExternalCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalCustomerID: %w", err)
	}
	return oldValue.ExternalCustomerID, nil
}

// ClearExternalCustomerID clears the value of the "external_customer_id" field.
func (m *EntitlementMutation) ClearExternalCustomerID() {
	m.external_customer_id = nil
	m.clearedFields[entitlement.FieldExternalCustomerID] = struct{}{}
}

// ExternalCustomerIDCleared returns if the "external_customer_id" field was cleared in this mutation.
func (m *EntitlementMutation) ExternalCustomerIDCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldExternalCustomerID]
	return ok
}

// ResetExternalCustomerID resets all changes to the "external_customer_id" field.
func (m *EntitlementMutation) ResetExternalCustomerID() {
	m.external_customer_id = nil
	delete(m.clearedFields, entitlement.FieldExternalCustomerID)
}

// SetExternalSubscriptionID sets the "external_subscription_id" field.
func (m *EntitlementMutation) SetExternalSubscriptionID(s string) {
	m.external_subscription_id = &s
}

// ExternalSubscriptionID returns the value of the "external_subscription_id" field in the mutation.
func (m *EntitlementMutation) ExternalSubscriptionID() (r string, exists bool) {
	v := m.external_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalSubscriptionID returns the old "external_subscription_id" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldExternalSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalSubscriptionID: %w", err)
	}
	return oldValue.ExternalSubscriptionID, nil
}

// ClearExternalSubscriptionID clears the value of the "external_subscription_id" field.
func (m *EntitlementMutation) ClearExternalSubscriptionID() {
	m.external_subscription_id = nil
	m.clearedFields[entitlement.FieldExternalSubscriptionID] = struct{}{}
}

// ExternalSubscriptionIDCleared returns if the "external_subscription_id" field was cleared in this mutation.
func (m *EntitlementMutation) ExternalSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldExternalSubscriptionID]
	return ok
}

// ResetExternalSubscriptionID resets all changes to the "external_subscription_id" field.
func (m *EntitlementMutation) ResetExternalSubscriptionID() {
	m.external_subscription_id = nil
	delete(m.clearedFields, entitlement.FieldExternalSubscriptionID)
}

// SetExpires sets the "expires" field.
func (m *EntitlementMutation) SetExpires(b bool) {
	m.expires = &b
}

// Expires returns the value of the "expires" field in the mutation.
func (m *EntitlementMutation) Expires() (r bool, exists bool) {
	v := m.expires
	if v == nil {
		return
	}
	return *v, true
}

// OldExpires returns the old "expires" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldExpires(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpires: %w", err)
	}
	return oldValue.Expires, nil
}

// ResetExpires resets all changes to the "expires" field.
func (m *EntitlementMutation) ResetExpires() {
	m.expires = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *EntitlementMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *EntitlementMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *EntitlementMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[entitlement.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *EntitlementMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[entitlement.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *EntitlementMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, entitlement.FieldExpiresAt)
}

// SetCancelled sets the "cancelled" field.
func (m *EntitlementMutation) SetCancelled(b bool) {
	m.cancelled = &b
}

// Cancelled returns the value of the "cancelled" field in the mutation.
func (m *EntitlementMutation) Cancelled() (r bool, exists bool) {
	v := m.cancelled
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelled returns the old "cancelled" field's value of the Entitlement entity.
// If the Entitlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementMutation) OldCancelled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelled: %w", err)
	}
	return oldValue.Cancelled, nil
}

// ResetCancelled resets all changes to the "cancelled" field.
func (m *EntitlementMutation) ResetCancelled() {
	m.cancelled = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *EntitlementMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[entitlement.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *EntitlementMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *EntitlementMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearPlan clears the "plan" edge to the EntitlementPlan entity.
func (m *EntitlementMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[entitlement.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the EntitlementPlan entity was cleared.
func (m *EntitlementMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *EntitlementMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EntitlementMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[entitlement.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EntitlementMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EntitlementMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EntitlementMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *EntitlementMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *EntitlementMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *EntitlementMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *EntitlementMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *EntitlementMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *EntitlementMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *EntitlementMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the EntitlementMutation builder.
func (m *EntitlementMutation) Where(ps ...predicate.Entitlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entitlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entitlement).
func (m *EntitlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, entitlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlement.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitlement.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitlement.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entitlement.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, entitlement.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitlement.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, entitlement.FieldOwnerID)
	}
	if m.plan != nil {
		fields = append(fields, entitlement.FieldPlanID)
	}
	if m.organization != nil {
		fields = append(fields, entitlement.FieldOrganizationID)
	}
	if m.external_customer_id != nil {
		fields = append(fields, entitlement.FieldExternalCustomerID)
	}
	if m.external_subscription_id != nil {
		fields = append(fields, entitlement.FieldExternalSubscriptionID)
	}
	if m.expires != nil {
		fields = append(fields, entitlement.FieldExpires)
	}
	if m.expires_at != nil {
		fields = append(fields, entitlement.FieldExpiresAt)
	}
	if m.cancelled != nil {
		fields = append(fields, entitlement.FieldCancelled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlement.FieldCreatedAt:
		return m.CreatedAt()
	case entitlement.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlement.FieldCreatedBy:
		return m.CreatedBy()
	case entitlement.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitlement.FieldMappingID:
		return m.MappingID()
	case entitlement.FieldTags:
		return m.Tags()
	case entitlement.FieldDeletedAt:
		return m.DeletedAt()
	case entitlement.FieldDeletedBy:
		return m.DeletedBy()
	case entitlement.FieldOwnerID:
		return m.OwnerID()
	case entitlement.FieldPlanID:
		return m.PlanID()
	case entitlement.FieldOrganizationID:
		return m.OrganizationID()
	case entitlement.FieldExternalCustomerID:
		return m.ExternalCustomerID()
	case entitlement.FieldExternalSubscriptionID:
		return m.ExternalSubscriptionID()
	case entitlement.FieldExpires:
		return m.Expires()
	case entitlement.FieldExpiresAt:
		return m.ExpiresAt()
	case entitlement.FieldCancelled:
		return m.Cancelled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlement.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitlement.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitlement.FieldMappingID:
		return m.OldMappingID(ctx)
	case entitlement.FieldTags:
		return m.OldTags(ctx)
	case entitlement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlement.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitlement.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitlement.FieldPlanID:
		return m.OldPlanID(ctx)
	case entitlement.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case entitlement.FieldExternalCustomerID:
		return m.OldExternalCustomerID(ctx)
	case entitlement.FieldExternalSubscriptionID:
		return m.OldExternalSubscriptionID(ctx)
	case entitlement.FieldExpires:
		return m.OldExpires(ctx)
	case entitlement.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case entitlement.FieldCancelled:
		return m.OldCancelled(ctx)
	}
	return nil, fmt.Errorf("unknown Entitlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlement.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitlement.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitlement.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entitlement.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitlement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlement.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitlement.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitlement.FieldPlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case entitlement.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case entitlement.FieldExternalCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalCustomerID(v)
		return nil
	case entitlement.FieldExternalSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalSubscriptionID(v)
		return nil
	case entitlement.FieldExpires:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpires(v)
		return nil
	case entitlement.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case entitlement.FieldCancelled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelled(v)
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Entitlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlement.FieldCreatedAt) {
		fields = append(fields, entitlement.FieldCreatedAt)
	}
	if m.FieldCleared(entitlement.FieldUpdatedAt) {
		fields = append(fields, entitlement.FieldUpdatedAt)
	}
	if m.FieldCleared(entitlement.FieldCreatedBy) {
		fields = append(fields, entitlement.FieldCreatedBy)
	}
	if m.FieldCleared(entitlement.FieldUpdatedBy) {
		fields = append(fields, entitlement.FieldUpdatedBy)
	}
	if m.FieldCleared(entitlement.FieldTags) {
		fields = append(fields, entitlement.FieldTags)
	}
	if m.FieldCleared(entitlement.FieldDeletedAt) {
		fields = append(fields, entitlement.FieldDeletedAt)
	}
	if m.FieldCleared(entitlement.FieldDeletedBy) {
		fields = append(fields, entitlement.FieldDeletedBy)
	}
	if m.FieldCleared(entitlement.FieldOwnerID) {
		fields = append(fields, entitlement.FieldOwnerID)
	}
	if m.FieldCleared(entitlement.FieldExternalCustomerID) {
		fields = append(fields, entitlement.FieldExternalCustomerID)
	}
	if m.FieldCleared(entitlement.FieldExternalSubscriptionID) {
		fields = append(fields, entitlement.FieldExternalSubscriptionID)
	}
	if m.FieldCleared(entitlement.FieldExpiresAt) {
		fields = append(fields, entitlement.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementMutation) ClearField(name string) error {
	switch name {
	case entitlement.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitlement.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitlement.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitlement.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitlement.FieldTags:
		m.ClearTags()
		return nil
	case entitlement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlement.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitlement.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entitlement.FieldExternalCustomerID:
		m.ClearExternalCustomerID()
		return nil
	case entitlement.FieldExternalSubscriptionID:
		m.ClearExternalSubscriptionID()
		return nil
	case entitlement.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Entitlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementMutation) ResetField(name string) error {
	switch name {
	case entitlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlement.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitlement.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitlement.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entitlement.FieldTags:
		m.ResetTags()
		return nil
	case entitlement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlement.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitlement.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitlement.FieldPlanID:
		m.ResetPlanID()
		return nil
	case entitlement.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case entitlement.FieldExternalCustomerID:
		m.ResetExternalCustomerID()
		return nil
	case entitlement.FieldExternalSubscriptionID:
		m.ResetExternalSubscriptionID()
		return nil
	case entitlement.FieldExpires:
		m.ResetExpires()
		return nil
	case entitlement.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case entitlement.FieldCancelled:
		m.ResetCancelled()
		return nil
	}
	return fmt.Errorf("unknown Entitlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, entitlement.EdgeOwner)
	}
	if m.plan != nil {
		edges = append(edges, entitlement.EdgePlan)
	}
	if m.organization != nil {
		edges = append(edges, entitlement.EdgeOrganization)
	}
	if m.events != nil {
		edges = append(edges, entitlement.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case entitlement.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case entitlement.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case entitlement.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedevents != nil {
		edges = append(edges, entitlement.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlement.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, entitlement.EdgeOwner)
	}
	if m.clearedplan {
		edges = append(edges, entitlement.EdgePlan)
	}
	if m.clearedorganization {
		edges = append(edges, entitlement.EdgeOrganization)
	}
	if m.clearedevents {
		edges = append(edges, entitlement.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlement.EdgeOwner:
		return m.clearedowner
	case entitlement.EdgePlan:
		return m.clearedplan
	case entitlement.EdgeOrganization:
		return m.clearedorganization
	case entitlement.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementMutation) ClearEdge(name string) error {
	switch name {
	case entitlement.EdgeOwner:
		m.ClearOwner()
		return nil
	case entitlement.EdgePlan:
		m.ClearPlan()
		return nil
	case entitlement.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Entitlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementMutation) ResetEdge(name string) error {
	switch name {
	case entitlement.EdgeOwner:
		m.ResetOwner()
		return nil
	case entitlement.EdgePlan:
		m.ResetPlan()
		return nil
	case entitlement.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case entitlement.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Entitlement edge %s", name)
}

// EntitlementHistoryMutation represents an operation that mutates the EntitlementHistory nodes in the graph.
type EntitlementHistoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	history_time             *time.Time
	ref                      *string
	operation                *history.OpType
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	mapping_id               *string
	tags                     *[]string
	appendtags               []string
	deleted_at               *time.Time
	deleted_by               *string
	owner_id                 *string
	plan_id                  *string
	organization_id          *string
	external_customer_id     *string
	external_subscription_id *string
	expires                  *bool
	expires_at               *time.Time
	cancelled                *bool
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*EntitlementHistory, error)
	predicates               []predicate.EntitlementHistory
}

var _ ent.Mutation = (*EntitlementHistoryMutation)(nil)

// entitlementhistoryOption allows management of the mutation configuration using functional options.
type entitlementhistoryOption func(*EntitlementHistoryMutation)

// newEntitlementHistoryMutation creates new mutation for the EntitlementHistory entity.
func newEntitlementHistoryMutation(c config, op Op, opts ...entitlementhistoryOption) *EntitlementHistoryMutation {
	m := &EntitlementHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlementHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementHistoryID sets the ID field of the mutation.
func withEntitlementHistoryID(id string) entitlementhistoryOption {
	return func(m *EntitlementHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EntitlementHistory
		)
		m.oldValue = func(ctx context.Context) (*EntitlementHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntitlementHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlementHistory sets the old EntitlementHistory of the mutation.
func withEntitlementHistory(node *EntitlementHistory) entitlementhistoryOption {
	return func(m *EntitlementHistoryMutation) {
		m.oldValue = func(context.Context) (*EntitlementHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntitlementHistory entities.
func (m *EntitlementHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntitlementHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EntitlementHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EntitlementHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EntitlementHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EntitlementHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EntitlementHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EntitlementHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[entitlementhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EntitlementHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, entitlementhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EntitlementHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EntitlementHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EntitlementHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntitlementHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitlementhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitlementhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntitlementHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitlementhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitlementhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntitlementHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntitlementHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntitlementHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitlementhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntitlementHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitlementhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntitlementHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntitlementHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntitlementHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitlementhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntitlementHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitlementhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntitlementHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntitlementHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntitlementHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *EntitlementHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntitlementHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntitlementHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntitlementHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntitlementHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitlementhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntitlementHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitlementhistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlementhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlementhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntitlementHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntitlementHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntitlementHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitlementhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntitlementHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitlementhistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntitlementHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntitlementHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntitlementHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[entitlementhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntitlementHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, entitlementhistory.FieldOwnerID)
}

// SetPlanID sets the "plan_id" field.
func (m *EntitlementHistoryMutation) SetPlanID(s string) {
	m.plan_id = &s
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *EntitlementHistoryMutation) PlanID() (r string, exists bool) {
	v := m.plan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldPlanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *EntitlementHistoryMutation) ResetPlanID() {
	m.plan_id = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *EntitlementHistoryMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EntitlementHistoryMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EntitlementHistoryMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetExternalCustomerID sets the "external_customer_id" field.
func (m *EntitlementHistoryMutation) SetExternalCustomerID(s string) {
	m.external_customer_id = &s
}

// ExternalCustomerID returns the value of the "external_customer_id" field in the mutation.
func (m *EntitlementHistoryMutation) ExternalCustomerID() (r string, exists bool) {
	v := m.external_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalCustomerID returns the old "external_customer_id" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldExternalCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalCustomerID: %w", err)
	}
	return oldValue.ExternalCustomerID, nil
}

// ClearExternalCustomerID clears the value of the "external_customer_id" field.
func (m *EntitlementHistoryMutation) ClearExternalCustomerID() {
	m.external_customer_id = nil
	m.clearedFields[entitlementhistory.FieldExternalCustomerID] = struct{}{}
}

// ExternalCustomerIDCleared returns if the "external_customer_id" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) ExternalCustomerIDCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldExternalCustomerID]
	return ok
}

// ResetExternalCustomerID resets all changes to the "external_customer_id" field.
func (m *EntitlementHistoryMutation) ResetExternalCustomerID() {
	m.external_customer_id = nil
	delete(m.clearedFields, entitlementhistory.FieldExternalCustomerID)
}

// SetExternalSubscriptionID sets the "external_subscription_id" field.
func (m *EntitlementHistoryMutation) SetExternalSubscriptionID(s string) {
	m.external_subscription_id = &s
}

// ExternalSubscriptionID returns the value of the "external_subscription_id" field in the mutation.
func (m *EntitlementHistoryMutation) ExternalSubscriptionID() (r string, exists bool) {
	v := m.external_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalSubscriptionID returns the old "external_subscription_id" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldExternalSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalSubscriptionID: %w", err)
	}
	return oldValue.ExternalSubscriptionID, nil
}

// ClearExternalSubscriptionID clears the value of the "external_subscription_id" field.
func (m *EntitlementHistoryMutation) ClearExternalSubscriptionID() {
	m.external_subscription_id = nil
	m.clearedFields[entitlementhistory.FieldExternalSubscriptionID] = struct{}{}
}

// ExternalSubscriptionIDCleared returns if the "external_subscription_id" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) ExternalSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldExternalSubscriptionID]
	return ok
}

// ResetExternalSubscriptionID resets all changes to the "external_subscription_id" field.
func (m *EntitlementHistoryMutation) ResetExternalSubscriptionID() {
	m.external_subscription_id = nil
	delete(m.clearedFields, entitlementhistory.FieldExternalSubscriptionID)
}

// SetExpires sets the "expires" field.
func (m *EntitlementHistoryMutation) SetExpires(b bool) {
	m.expires = &b
}

// Expires returns the value of the "expires" field in the mutation.
func (m *EntitlementHistoryMutation) Expires() (r bool, exists bool) {
	v := m.expires
	if v == nil {
		return
	}
	return *v, true
}

// OldExpires returns the old "expires" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldExpires(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpires: %w", err)
	}
	return oldValue.Expires, nil
}

// ResetExpires resets all changes to the "expires" field.
func (m *EntitlementHistoryMutation) ResetExpires() {
	m.expires = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *EntitlementHistoryMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *EntitlementHistoryMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *EntitlementHistoryMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[entitlementhistory.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *EntitlementHistoryMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[entitlementhistory.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *EntitlementHistoryMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, entitlementhistory.FieldExpiresAt)
}

// SetCancelled sets the "cancelled" field.
func (m *EntitlementHistoryMutation) SetCancelled(b bool) {
	m.cancelled = &b
}

// Cancelled returns the value of the "cancelled" field in the mutation.
func (m *EntitlementHistoryMutation) Cancelled() (r bool, exists bool) {
	v := m.cancelled
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelled returns the old "cancelled" field's value of the EntitlementHistory entity.
// If the EntitlementHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementHistoryMutation) OldCancelled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelled: %w", err)
	}
	return oldValue.Cancelled, nil
}

// ResetCancelled resets all changes to the "cancelled" field.
func (m *EntitlementHistoryMutation) ResetCancelled() {
	m.cancelled = nil
}

// Where appends a list predicates to the EntitlementHistoryMutation builder.
func (m *EntitlementHistoryMutation) Where(ps ...predicate.EntitlementHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntitlementHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntitlementHistory).
func (m *EntitlementHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, entitlementhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, entitlementhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, entitlementhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, entitlementhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlementhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitlementhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitlementhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entitlementhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, entitlementhistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlementhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitlementhistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, entitlementhistory.FieldOwnerID)
	}
	if m.plan_id != nil {
		fields = append(fields, entitlementhistory.FieldPlanID)
	}
	if m.organization_id != nil {
		fields = append(fields, entitlementhistory.FieldOrganizationID)
	}
	if m.external_customer_id != nil {
		fields = append(fields, entitlementhistory.FieldExternalCustomerID)
	}
	if m.external_subscription_id != nil {
		fields = append(fields, entitlementhistory.FieldExternalSubscriptionID)
	}
	if m.expires != nil {
		fields = append(fields, entitlementhistory.FieldExpires)
	}
	if m.expires_at != nil {
		fields = append(fields, entitlementhistory.FieldExpiresAt)
	}
	if m.cancelled != nil {
		fields = append(fields, entitlementhistory.FieldCancelled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlementhistory.FieldHistoryTime:
		return m.HistoryTime()
	case entitlementhistory.FieldRef:
		return m.Ref()
	case entitlementhistory.FieldOperation:
		return m.Operation()
	case entitlementhistory.FieldCreatedAt:
		return m.CreatedAt()
	case entitlementhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlementhistory.FieldCreatedBy:
		return m.CreatedBy()
	case entitlementhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitlementhistory.FieldMappingID:
		return m.MappingID()
	case entitlementhistory.FieldTags:
		return m.Tags()
	case entitlementhistory.FieldDeletedAt:
		return m.DeletedAt()
	case entitlementhistory.FieldDeletedBy:
		return m.DeletedBy()
	case entitlementhistory.FieldOwnerID:
		return m.OwnerID()
	case entitlementhistory.FieldPlanID:
		return m.PlanID()
	case entitlementhistory.FieldOrganizationID:
		return m.OrganizationID()
	case entitlementhistory.FieldExternalCustomerID:
		return m.ExternalCustomerID()
	case entitlementhistory.FieldExternalSubscriptionID:
		return m.ExternalSubscriptionID()
	case entitlementhistory.FieldExpires:
		return m.Expires()
	case entitlementhistory.FieldExpiresAt:
		return m.ExpiresAt()
	case entitlementhistory.FieldCancelled:
		return m.Cancelled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlementhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case entitlementhistory.FieldRef:
		return m.OldRef(ctx)
	case entitlementhistory.FieldOperation:
		return m.OldOperation(ctx)
	case entitlementhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlementhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlementhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitlementhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitlementhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case entitlementhistory.FieldTags:
		return m.OldTags(ctx)
	case entitlementhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlementhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitlementhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitlementhistory.FieldPlanID:
		return m.OldPlanID(ctx)
	case entitlementhistory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case entitlementhistory.FieldExternalCustomerID:
		return m.OldExternalCustomerID(ctx)
	case entitlementhistory.FieldExternalSubscriptionID:
		return m.OldExternalSubscriptionID(ctx)
	case entitlementhistory.FieldExpires:
		return m.OldExpires(ctx)
	case entitlementhistory.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case entitlementhistory.FieldCancelled:
		return m.OldCancelled(ctx)
	}
	return nil, fmt.Errorf("unknown EntitlementHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlementhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case entitlementhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case entitlementhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case entitlementhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlementhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlementhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitlementhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitlementhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entitlementhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitlementhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlementhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitlementhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitlementhistory.FieldPlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case entitlementhistory.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case entitlementhistory.FieldExternalCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalCustomerID(v)
		return nil
	case entitlementhistory.FieldExternalSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalSubscriptionID(v)
		return nil
	case entitlementhistory.FieldExpires:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpires(v)
		return nil
	case entitlementhistory.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case entitlementhistory.FieldCancelled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelled(v)
		return nil
	}
	return fmt.Errorf("unknown EntitlementHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntitlementHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlementhistory.FieldRef) {
		fields = append(fields, entitlementhistory.FieldRef)
	}
	if m.FieldCleared(entitlementhistory.FieldCreatedAt) {
		fields = append(fields, entitlementhistory.FieldCreatedAt)
	}
	if m.FieldCleared(entitlementhistory.FieldUpdatedAt) {
		fields = append(fields, entitlementhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(entitlementhistory.FieldCreatedBy) {
		fields = append(fields, entitlementhistory.FieldCreatedBy)
	}
	if m.FieldCleared(entitlementhistory.FieldUpdatedBy) {
		fields = append(fields, entitlementhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(entitlementhistory.FieldTags) {
		fields = append(fields, entitlementhistory.FieldTags)
	}
	if m.FieldCleared(entitlementhistory.FieldDeletedAt) {
		fields = append(fields, entitlementhistory.FieldDeletedAt)
	}
	if m.FieldCleared(entitlementhistory.FieldDeletedBy) {
		fields = append(fields, entitlementhistory.FieldDeletedBy)
	}
	if m.FieldCleared(entitlementhistory.FieldOwnerID) {
		fields = append(fields, entitlementhistory.FieldOwnerID)
	}
	if m.FieldCleared(entitlementhistory.FieldExternalCustomerID) {
		fields = append(fields, entitlementhistory.FieldExternalCustomerID)
	}
	if m.FieldCleared(entitlementhistory.FieldExternalSubscriptionID) {
		fields = append(fields, entitlementhistory.FieldExternalSubscriptionID)
	}
	if m.FieldCleared(entitlementhistory.FieldExpiresAt) {
		fields = append(fields, entitlementhistory.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementHistoryMutation) ClearField(name string) error {
	switch name {
	case entitlementhistory.FieldRef:
		m.ClearRef()
		return nil
	case entitlementhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitlementhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitlementhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitlementhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitlementhistory.FieldTags:
		m.ClearTags()
		return nil
	case entitlementhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlementhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitlementhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entitlementhistory.FieldExternalCustomerID:
		m.ClearExternalCustomerID()
		return nil
	case entitlementhistory.FieldExternalSubscriptionID:
		m.ClearExternalSubscriptionID()
		return nil
	case entitlementhistory.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown EntitlementHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementHistoryMutation) ResetField(name string) error {
	switch name {
	case entitlementhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case entitlementhistory.FieldRef:
		m.ResetRef()
		return nil
	case entitlementhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case entitlementhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlementhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlementhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitlementhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitlementhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entitlementhistory.FieldTags:
		m.ResetTags()
		return nil
	case entitlementhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlementhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitlementhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitlementhistory.FieldPlanID:
		m.ResetPlanID()
		return nil
	case entitlementhistory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case entitlementhistory.FieldExternalCustomerID:
		m.ResetExternalCustomerID()
		return nil
	case entitlementhistory.FieldExternalSubscriptionID:
		m.ResetExternalSubscriptionID()
		return nil
	case entitlementhistory.FieldExpires:
		m.ResetExpires()
		return nil
	case entitlementhistory.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case entitlementhistory.FieldCancelled:
		m.ResetCancelled()
		return nil
	}
	return fmt.Errorf("unknown EntitlementHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EntitlementHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EntitlementHistory edge %s", name)
}

// EntitlementPlanMutation represents an operation that mutates the EntitlementPlan nodes in the graph.
type EntitlementPlanMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	mapping_id           *string
	deleted_at           *time.Time
	deleted_by           *string
	tags                 *[]string
	appendtags           []string
	display_name         *string
	name                 *string
	description          *string
	version              *string
	metadata             *map[string]interface{}
	clearedFields        map[string]struct{}
	owner                *string
	clearedowner         bool
	entitlements         map[string]struct{}
	removedentitlements  map[string]struct{}
	clearedentitlements  bool
	base_features        map[string]struct{}
	removedbase_features map[string]struct{}
	clearedbase_features bool
	events               map[string]struct{}
	removedevents        map[string]struct{}
	clearedevents        bool
	features             map[string]struct{}
	removedfeatures      map[string]struct{}
	clearedfeatures      bool
	done                 bool
	oldValue             func(context.Context) (*EntitlementPlan, error)
	predicates           []predicate.EntitlementPlan
}

var _ ent.Mutation = (*EntitlementPlanMutation)(nil)

// entitlementplanOption allows management of the mutation configuration using functional options.
type entitlementplanOption func(*EntitlementPlanMutation)

// newEntitlementPlanMutation creates new mutation for the EntitlementPlan entity.
func newEntitlementPlanMutation(c config, op Op, opts ...entitlementplanOption) *EntitlementPlanMutation {
	m := &EntitlementPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlementPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementPlanID sets the ID field of the mutation.
func withEntitlementPlanID(id string) entitlementplanOption {
	return func(m *EntitlementPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *EntitlementPlan
		)
		m.oldValue = func(ctx context.Context) (*EntitlementPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntitlementPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlementPlan sets the old EntitlementPlan of the mutation.
func withEntitlementPlan(node *EntitlementPlan) entitlementplanOption {
	return func(m *EntitlementPlanMutation) {
		m.oldValue = func(context.Context) (*EntitlementPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntitlementPlan entities.
func (m *EntitlementPlanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementPlanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementPlanMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntitlementPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementPlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementPlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntitlementPlanMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitlementplan.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntitlementPlanMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementPlanMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitlementplan.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementPlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementPlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntitlementPlanMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitlementplan.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntitlementPlanMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitlementplan.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntitlementPlanMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntitlementPlanMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntitlementPlanMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitlementplan.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntitlementPlanMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntitlementPlanMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitlementplan.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntitlementPlanMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntitlementPlanMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntitlementPlanMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitlementplan.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntitlementPlanMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntitlementPlanMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitlementplan.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntitlementPlanMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntitlementPlanMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntitlementPlanMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementPlanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementPlanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementPlanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlementplan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementPlanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementPlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlementplan.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntitlementPlanMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntitlementPlanMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntitlementPlanMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitlementplan.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntitlementPlanMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntitlementPlanMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitlementplan.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntitlementPlanMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntitlementPlanMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntitlementPlanMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntitlementPlanMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntitlementPlanMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitlementplan.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntitlementPlanMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntitlementPlanMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitlementplan.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntitlementPlanMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntitlementPlanMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntitlementPlanMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[entitlementplan.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntitlementPlanMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntitlementPlanMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, entitlementplan.FieldOwnerID)
}

// SetDisplayName sets the "display_name" field.
func (m *EntitlementPlanMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *EntitlementPlanMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *EntitlementPlanMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[entitlementplan.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *EntitlementPlanMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *EntitlementPlanMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, entitlementplan.FieldDisplayName)
}

// SetName sets the "name" field.
func (m *EntitlementPlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntitlementPlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntitlementPlanMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EntitlementPlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntitlementPlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntitlementPlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entitlementplan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntitlementPlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntitlementPlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entitlementplan.FieldDescription)
}

// SetVersion sets the "version" field.
func (m *EntitlementPlanMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *EntitlementPlanMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *EntitlementPlanMutation) ResetVersion() {
	m.version = nil
}

// SetMetadata sets the "metadata" field.
func (m *EntitlementPlanMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EntitlementPlanMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the EntitlementPlan entity.
// If the EntitlementPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EntitlementPlanMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[entitlementplan.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EntitlementPlanMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[entitlementplan.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EntitlementPlanMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, entitlementplan.FieldMetadata)
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *EntitlementPlanMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[entitlementplan.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *EntitlementPlanMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *EntitlementPlanMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *EntitlementPlanMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddEntitlementIDs adds the "entitlements" edge to the Entitlement entity by ids.
func (m *EntitlementPlanMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlements == nil {
		m.entitlements = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlements[ids[i]] = struct{}{}
	}
}

// ClearEntitlements clears the "entitlements" edge to the Entitlement entity.
func (m *EntitlementPlanMutation) ClearEntitlements() {
	m.clearedentitlements = true
}

// EntitlementsCleared reports if the "entitlements" edge to the Entitlement entity was cleared.
func (m *EntitlementPlanMutation) EntitlementsCleared() bool {
	return m.clearedentitlements
}

// RemoveEntitlementIDs removes the "entitlements" edge to the Entitlement entity by IDs.
func (m *EntitlementPlanMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlements == nil {
		m.removedentitlements = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlements, ids[i])
		m.removedentitlements[ids[i]] = struct{}{}
	}
}

// RemovedEntitlements returns the removed IDs of the "entitlements" edge to the Entitlement entity.
func (m *EntitlementPlanMutation) RemovedEntitlementsIDs() (ids []string) {
	for id := range m.removedentitlements {
		ids = append(ids, id)
	}
	return
}

// EntitlementsIDs returns the "entitlements" edge IDs in the mutation.
func (m *EntitlementPlanMutation) EntitlementsIDs() (ids []string) {
	for id := range m.entitlements {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlements resets all changes to the "entitlements" edge.
func (m *EntitlementPlanMutation) ResetEntitlements() {
	m.entitlements = nil
	m.clearedentitlements = false
	m.removedentitlements = nil
}

// AddBaseFeatureIDs adds the "base_features" edge to the Feature entity by ids.
func (m *EntitlementPlanMutation) AddBaseFeatureIDs(ids ...string) {
	if m.base_features == nil {
		m.base_features = make(map[string]struct{})
	}
	for i := range ids {
		m.base_features[ids[i]] = struct{}{}
	}
}

// ClearBaseFeatures clears the "base_features" edge to the Feature entity.
func (m *EntitlementPlanMutation) ClearBaseFeatures() {
	m.clearedbase_features = true
}

// BaseFeaturesCleared reports if the "base_features" edge to the Feature entity was cleared.
func (m *EntitlementPlanMutation) BaseFeaturesCleared() bool {
	return m.clearedbase_features
}

// RemoveBaseFeatureIDs removes the "base_features" edge to the Feature entity by IDs.
func (m *EntitlementPlanMutation) RemoveBaseFeatureIDs(ids ...string) {
	if m.removedbase_features == nil {
		m.removedbase_features = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.base_features, ids[i])
		m.removedbase_features[ids[i]] = struct{}{}
	}
}

// RemovedBaseFeatures returns the removed IDs of the "base_features" edge to the Feature entity.
func (m *EntitlementPlanMutation) RemovedBaseFeaturesIDs() (ids []string) {
	for id := range m.removedbase_features {
		ids = append(ids, id)
	}
	return
}

// BaseFeaturesIDs returns the "base_features" edge IDs in the mutation.
func (m *EntitlementPlanMutation) BaseFeaturesIDs() (ids []string) {
	for id := range m.base_features {
		ids = append(ids, id)
	}
	return
}

// ResetBaseFeatures resets all changes to the "base_features" edge.
func (m *EntitlementPlanMutation) ResetBaseFeatures() {
	m.base_features = nil
	m.clearedbase_features = false
	m.removedbase_features = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *EntitlementPlanMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *EntitlementPlanMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *EntitlementPlanMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *EntitlementPlanMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *EntitlementPlanMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *EntitlementPlanMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *EntitlementPlanMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddFeatureIDs adds the "features" edge to the EntitlementPlanFeature entity by ids.
func (m *EntitlementPlanMutation) AddFeatureIDs(ids ...string) {
	if m.features == nil {
		m.features = make(map[string]struct{})
	}
	for i := range ids {
		m.features[ids[i]] = struct{}{}
	}
}

// ClearFeatures clears the "features" edge to the EntitlementPlanFeature entity.
func (m *EntitlementPlanMutation) ClearFeatures() {
	m.clearedfeatures = true
}

// FeaturesCleared reports if the "features" edge to the EntitlementPlanFeature entity was cleared.
func (m *EntitlementPlanMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// RemoveFeatureIDs removes the "features" edge to the EntitlementPlanFeature entity by IDs.
func (m *EntitlementPlanMutation) RemoveFeatureIDs(ids ...string) {
	if m.removedfeatures == nil {
		m.removedfeatures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.features, ids[i])
		m.removedfeatures[ids[i]] = struct{}{}
	}
}

// RemovedFeatures returns the removed IDs of the "features" edge to the EntitlementPlanFeature entity.
func (m *EntitlementPlanMutation) RemovedFeaturesIDs() (ids []string) {
	for id := range m.removedfeatures {
		ids = append(ids, id)
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
func (m *EntitlementPlanMutation) FeaturesIDs() (ids []string) {
	for id := range m.features {
		ids = append(ids, id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *EntitlementPlanMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
	m.removedfeatures = nil
}

// Where appends a list predicates to the EntitlementPlanMutation builder.
func (m *EntitlementPlanMutation) Where(ps ...predicate.EntitlementPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntitlementPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntitlementPlan).
func (m *EntitlementPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementPlanMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, entitlementplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlementplan.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitlementplan.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitlementplan.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entitlementplan.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlementplan.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitlementplan.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entitlementplan.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, entitlementplan.FieldOwnerID)
	}
	if m.display_name != nil {
		fields = append(fields, entitlementplan.FieldDisplayName)
	}
	if m.name != nil {
		fields = append(fields, entitlementplan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, entitlementplan.FieldDescription)
	}
	if m.version != nil {
		fields = append(fields, entitlementplan.FieldVersion)
	}
	if m.metadata != nil {
		fields = append(fields, entitlementplan.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlementplan.FieldCreatedAt:
		return m.CreatedAt()
	case entitlementplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlementplan.FieldCreatedBy:
		return m.CreatedBy()
	case entitlementplan.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitlementplan.FieldMappingID:
		return m.MappingID()
	case entitlementplan.FieldDeletedAt:
		return m.DeletedAt()
	case entitlementplan.FieldDeletedBy:
		return m.DeletedBy()
	case entitlementplan.FieldTags:
		return m.Tags()
	case entitlementplan.FieldOwnerID:
		return m.OwnerID()
	case entitlementplan.FieldDisplayName:
		return m.DisplayName()
	case entitlementplan.FieldName:
		return m.Name()
	case entitlementplan.FieldDescription:
		return m.Description()
	case entitlementplan.FieldVersion:
		return m.Version()
	case entitlementplan.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlementplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlementplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlementplan.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitlementplan.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitlementplan.FieldMappingID:
		return m.OldMappingID(ctx)
	case entitlementplan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlementplan.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitlementplan.FieldTags:
		return m.OldTags(ctx)
	case entitlementplan.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitlementplan.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case entitlementplan.FieldName:
		return m.OldName(ctx)
	case entitlementplan.FieldDescription:
		return m.OldDescription(ctx)
	case entitlementplan.FieldVersion:
		return m.OldVersion(ctx)
	case entitlementplan.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown EntitlementPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlementplan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlementplan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlementplan.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitlementplan.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitlementplan.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entitlementplan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlementplan.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitlementplan.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitlementplan.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitlementplan.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case entitlementplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entitlementplan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entitlementplan.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case entitlementplan.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementPlanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementPlanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntitlementPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlementplan.FieldCreatedAt) {
		fields = append(fields, entitlementplan.FieldCreatedAt)
	}
	if m.FieldCleared(entitlementplan.FieldUpdatedAt) {
		fields = append(fields, entitlementplan.FieldUpdatedAt)
	}
	if m.FieldCleared(entitlementplan.FieldCreatedBy) {
		fields = append(fields, entitlementplan.FieldCreatedBy)
	}
	if m.FieldCleared(entitlementplan.FieldUpdatedBy) {
		fields = append(fields, entitlementplan.FieldUpdatedBy)
	}
	if m.FieldCleared(entitlementplan.FieldDeletedAt) {
		fields = append(fields, entitlementplan.FieldDeletedAt)
	}
	if m.FieldCleared(entitlementplan.FieldDeletedBy) {
		fields = append(fields, entitlementplan.FieldDeletedBy)
	}
	if m.FieldCleared(entitlementplan.FieldTags) {
		fields = append(fields, entitlementplan.FieldTags)
	}
	if m.FieldCleared(entitlementplan.FieldOwnerID) {
		fields = append(fields, entitlementplan.FieldOwnerID)
	}
	if m.FieldCleared(entitlementplan.FieldDisplayName) {
		fields = append(fields, entitlementplan.FieldDisplayName)
	}
	if m.FieldCleared(entitlementplan.FieldDescription) {
		fields = append(fields, entitlementplan.FieldDescription)
	}
	if m.FieldCleared(entitlementplan.FieldMetadata) {
		fields = append(fields, entitlementplan.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementPlanMutation) ClearField(name string) error {
	switch name {
	case entitlementplan.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitlementplan.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitlementplan.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitlementplan.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitlementplan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlementplan.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitlementplan.FieldTags:
		m.ClearTags()
		return nil
	case entitlementplan.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entitlementplan.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case entitlementplan.FieldDescription:
		m.ClearDescription()
		return nil
	case entitlementplan.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementPlanMutation) ResetField(name string) error {
	switch name {
	case entitlementplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlementplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlementplan.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitlementplan.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitlementplan.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entitlementplan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlementplan.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitlementplan.FieldTags:
		m.ResetTags()
		return nil
	case entitlementplan.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitlementplan.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case entitlementplan.FieldName:
		m.ResetName()
		return nil
	case entitlementplan.FieldDescription:
		m.ResetDescription()
		return nil
	case entitlementplan.FieldVersion:
		m.ResetVersion()
		return nil
	case entitlementplan.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, entitlementplan.EdgeOwner)
	}
	if m.entitlements != nil {
		edges = append(edges, entitlementplan.EdgeEntitlements)
	}
	if m.base_features != nil {
		edges = append(edges, entitlementplan.EdgeBaseFeatures)
	}
	if m.events != nil {
		edges = append(edges, entitlementplan.EdgeEvents)
	}
	if m.features != nil {
		edges = append(edges, entitlementplan.EdgeFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlementplan.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case entitlementplan.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.entitlements))
		for id := range m.entitlements {
			ids = append(ids, id)
		}
		return ids
	case entitlementplan.EdgeBaseFeatures:
		ids := make([]ent.Value, 0, len(m.base_features))
		for id := range m.base_features {
			ids = append(ids, id)
		}
		return ids
	case entitlementplan.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case entitlementplan.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.features))
		for id := range m.features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedentitlements != nil {
		edges = append(edges, entitlementplan.EdgeEntitlements)
	}
	if m.removedbase_features != nil {
		edges = append(edges, entitlementplan.EdgeBaseFeatures)
	}
	if m.removedevents != nil {
		edges = append(edges, entitlementplan.EdgeEvents)
	}
	if m.removedfeatures != nil {
		edges = append(edges, entitlementplan.EdgeFeatures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlementplan.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.removedentitlements))
		for id := range m.removedentitlements {
			ids = append(ids, id)
		}
		return ids
	case entitlementplan.EdgeBaseFeatures:
		ids := make([]ent.Value, 0, len(m.removedbase_features))
		for id := range m.removedbase_features {
			ids = append(ids, id)
		}
		return ids
	case entitlementplan.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case entitlementplan.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.removedfeatures))
		for id := range m.removedfeatures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, entitlementplan.EdgeOwner)
	}
	if m.clearedentitlements {
		edges = append(edges, entitlementplan.EdgeEntitlements)
	}
	if m.clearedbase_features {
		edges = append(edges, entitlementplan.EdgeBaseFeatures)
	}
	if m.clearedevents {
		edges = append(edges, entitlementplan.EdgeEvents)
	}
	if m.clearedfeatures {
		edges = append(edges, entitlementplan.EdgeFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlementplan.EdgeOwner:
		return m.clearedowner
	case entitlementplan.EdgeEntitlements:
		return m.clearedentitlements
	case entitlementplan.EdgeBaseFeatures:
		return m.clearedbase_features
	case entitlementplan.EdgeEvents:
		return m.clearedevents
	case entitlementplan.EdgeFeatures:
		return m.clearedfeatures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementPlanMutation) ClearEdge(name string) error {
	switch name {
	case entitlementplan.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementPlanMutation) ResetEdge(name string) error {
	switch name {
	case entitlementplan.EdgeOwner:
		m.ResetOwner()
		return nil
	case entitlementplan.EdgeEntitlements:
		m.ResetEntitlements()
		return nil
	case entitlementplan.EdgeBaseFeatures:
		m.ResetBaseFeatures()
		return nil
	case entitlementplan.EdgeEvents:
		m.ResetEvents()
		return nil
	case entitlementplan.EdgeFeatures:
		m.ResetFeatures()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlan edge %s", name)
}

// EntitlementPlanFeatureMutation represents an operation that mutates the EntitlementPlanFeature nodes in the graph.
type EntitlementPlanFeatureMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	mapping_id     *string
	deleted_at     *time.Time
	deleted_by     *string
	tags           *[]string
	appendtags     []string
	metadata       *map[string]interface{}
	clearedFields  map[string]struct{}
	owner          *string
	clearedowner   bool
	plan           *string
	clearedplan    bool
	feature        *string
	clearedfeature bool
	events         map[string]struct{}
	removedevents  map[string]struct{}
	clearedevents  bool
	done           bool
	oldValue       func(context.Context) (*EntitlementPlanFeature, error)
	predicates     []predicate.EntitlementPlanFeature
}

var _ ent.Mutation = (*EntitlementPlanFeatureMutation)(nil)

// entitlementplanfeatureOption allows management of the mutation configuration using functional options.
type entitlementplanfeatureOption func(*EntitlementPlanFeatureMutation)

// newEntitlementPlanFeatureMutation creates new mutation for the EntitlementPlanFeature entity.
func newEntitlementPlanFeatureMutation(c config, op Op, opts ...entitlementplanfeatureOption) *EntitlementPlanFeatureMutation {
	m := &EntitlementPlanFeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlementPlanFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementPlanFeatureID sets the ID field of the mutation.
func withEntitlementPlanFeatureID(id string) entitlementplanfeatureOption {
	return func(m *EntitlementPlanFeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *EntitlementPlanFeature
		)
		m.oldValue = func(ctx context.Context) (*EntitlementPlanFeature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntitlementPlanFeature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlementPlanFeature sets the old EntitlementPlanFeature of the mutation.
func withEntitlementPlanFeature(node *EntitlementPlanFeature) entitlementplanfeatureOption {
	return func(m *EntitlementPlanFeatureMutation) {
		m.oldValue = func(context.Context) (*EntitlementPlanFeature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementPlanFeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementPlanFeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntitlementPlanFeature entities.
func (m *EntitlementPlanFeatureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementPlanFeatureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementPlanFeatureMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntitlementPlanFeature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementPlanFeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementPlanFeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntitlementPlanFeatureMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitlementplanfeature.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementPlanFeatureMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitlementplanfeature.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementPlanFeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementPlanFeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntitlementPlanFeatureMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitlementplanfeature.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementPlanFeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitlementplanfeature.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntitlementPlanFeatureMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntitlementPlanFeatureMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntitlementPlanFeatureMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitlementplanfeature.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntitlementPlanFeatureMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitlementplanfeature.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntitlementPlanFeatureMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntitlementPlanFeatureMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntitlementPlanFeatureMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitlementplanfeature.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntitlementPlanFeatureMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitlementplanfeature.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntitlementPlanFeatureMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntitlementPlanFeatureMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntitlementPlanFeatureMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementPlanFeatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementPlanFeatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementPlanFeatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlementplanfeature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementPlanFeatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlementplanfeature.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntitlementPlanFeatureMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntitlementPlanFeatureMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntitlementPlanFeatureMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitlementplanfeature.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntitlementPlanFeatureMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitlementplanfeature.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntitlementPlanFeatureMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntitlementPlanFeatureMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntitlementPlanFeatureMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntitlementPlanFeatureMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntitlementPlanFeatureMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitlementplanfeature.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntitlementPlanFeatureMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitlementplanfeature.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntitlementPlanFeatureMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntitlementPlanFeatureMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntitlementPlanFeatureMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[entitlementplanfeature.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntitlementPlanFeatureMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, entitlementplanfeature.FieldOwnerID)
}

// SetMetadata sets the "metadata" field.
func (m *EntitlementPlanFeatureMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EntitlementPlanFeatureMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EntitlementPlanFeatureMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[entitlementplanfeature.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeature.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EntitlementPlanFeatureMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, entitlementplanfeature.FieldMetadata)
}

// SetPlanID sets the "plan_id" field.
func (m *EntitlementPlanFeatureMutation) SetPlanID(s string) {
	m.plan = &s
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *EntitlementPlanFeatureMutation) PlanID() (r string, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldPlanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *EntitlementPlanFeatureMutation) ResetPlanID() {
	m.plan = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *EntitlementPlanFeatureMutation) SetFeatureID(s string) {
	m.feature = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *EntitlementPlanFeatureMutation) FeatureID() (r string, exists bool) {
	v := m.feature
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the EntitlementPlanFeature entity.
// If the EntitlementPlanFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *EntitlementPlanFeatureMutation) ResetFeatureID() {
	m.feature = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *EntitlementPlanFeatureMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[entitlementplanfeature.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *EntitlementPlanFeatureMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *EntitlementPlanFeatureMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *EntitlementPlanFeatureMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearPlan clears the "plan" edge to the EntitlementPlan entity.
func (m *EntitlementPlanFeatureMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[entitlementplanfeature.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the EntitlementPlan entity was cleared.
func (m *EntitlementPlanFeatureMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *EntitlementPlanFeatureMutation) PlanIDs() (ids []string) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *EntitlementPlanFeatureMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearFeature clears the "feature" edge to the Feature entity.
func (m *EntitlementPlanFeatureMutation) ClearFeature() {
	m.clearedfeature = true
	m.clearedFields[entitlementplanfeature.FieldFeatureID] = struct{}{}
}

// FeatureCleared reports if the "feature" edge to the Feature entity was cleared.
func (m *EntitlementPlanFeatureMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureID instead. It exists only for internal usage by the builders.
func (m *EntitlementPlanFeatureMutation) FeatureIDs() (ids []string) {
	if id := m.feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *EntitlementPlanFeatureMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *EntitlementPlanFeatureMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *EntitlementPlanFeatureMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *EntitlementPlanFeatureMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *EntitlementPlanFeatureMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *EntitlementPlanFeatureMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *EntitlementPlanFeatureMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *EntitlementPlanFeatureMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the EntitlementPlanFeatureMutation builder.
func (m *EntitlementPlanFeatureMutation) Where(ps ...predicate.EntitlementPlanFeature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementPlanFeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementPlanFeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntitlementPlanFeature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementPlanFeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementPlanFeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntitlementPlanFeature).
func (m *EntitlementPlanFeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementPlanFeatureMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, entitlementplanfeature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlementplanfeature.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitlementplanfeature.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitlementplanfeature.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entitlementplanfeature.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlementplanfeature.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitlementplanfeature.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entitlementplanfeature.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, entitlementplanfeature.FieldOwnerID)
	}
	if m.metadata != nil {
		fields = append(fields, entitlementplanfeature.FieldMetadata)
	}
	if m.plan != nil {
		fields = append(fields, entitlementplanfeature.FieldPlanID)
	}
	if m.feature != nil {
		fields = append(fields, entitlementplanfeature.FieldFeatureID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementPlanFeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlementplanfeature.FieldCreatedAt:
		return m.CreatedAt()
	case entitlementplanfeature.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlementplanfeature.FieldCreatedBy:
		return m.CreatedBy()
	case entitlementplanfeature.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitlementplanfeature.FieldMappingID:
		return m.MappingID()
	case entitlementplanfeature.FieldDeletedAt:
		return m.DeletedAt()
	case entitlementplanfeature.FieldDeletedBy:
		return m.DeletedBy()
	case entitlementplanfeature.FieldTags:
		return m.Tags()
	case entitlementplanfeature.FieldOwnerID:
		return m.OwnerID()
	case entitlementplanfeature.FieldMetadata:
		return m.Metadata()
	case entitlementplanfeature.FieldPlanID:
		return m.PlanID()
	case entitlementplanfeature.FieldFeatureID:
		return m.FeatureID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementPlanFeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlementplanfeature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlementplanfeature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlementplanfeature.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitlementplanfeature.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitlementplanfeature.FieldMappingID:
		return m.OldMappingID(ctx)
	case entitlementplanfeature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlementplanfeature.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitlementplanfeature.FieldTags:
		return m.OldTags(ctx)
	case entitlementplanfeature.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitlementplanfeature.FieldMetadata:
		return m.OldMetadata(ctx)
	case entitlementplanfeature.FieldPlanID:
		return m.OldPlanID(ctx)
	case entitlementplanfeature.FieldFeatureID:
		return m.OldFeatureID(ctx)
	}
	return nil, fmt.Errorf("unknown EntitlementPlanFeature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementPlanFeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlementplanfeature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlementplanfeature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlementplanfeature.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitlementplanfeature.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitlementplanfeature.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entitlementplanfeature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlementplanfeature.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitlementplanfeature.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitlementplanfeature.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitlementplanfeature.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case entitlementplanfeature.FieldPlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case entitlementplanfeature.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanFeature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementPlanFeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementPlanFeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementPlanFeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntitlementPlanFeature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementPlanFeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlementplanfeature.FieldCreatedAt) {
		fields = append(fields, entitlementplanfeature.FieldCreatedAt)
	}
	if m.FieldCleared(entitlementplanfeature.FieldUpdatedAt) {
		fields = append(fields, entitlementplanfeature.FieldUpdatedAt)
	}
	if m.FieldCleared(entitlementplanfeature.FieldCreatedBy) {
		fields = append(fields, entitlementplanfeature.FieldCreatedBy)
	}
	if m.FieldCleared(entitlementplanfeature.FieldUpdatedBy) {
		fields = append(fields, entitlementplanfeature.FieldUpdatedBy)
	}
	if m.FieldCleared(entitlementplanfeature.FieldDeletedAt) {
		fields = append(fields, entitlementplanfeature.FieldDeletedAt)
	}
	if m.FieldCleared(entitlementplanfeature.FieldDeletedBy) {
		fields = append(fields, entitlementplanfeature.FieldDeletedBy)
	}
	if m.FieldCleared(entitlementplanfeature.FieldTags) {
		fields = append(fields, entitlementplanfeature.FieldTags)
	}
	if m.FieldCleared(entitlementplanfeature.FieldOwnerID) {
		fields = append(fields, entitlementplanfeature.FieldOwnerID)
	}
	if m.FieldCleared(entitlementplanfeature.FieldMetadata) {
		fields = append(fields, entitlementplanfeature.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementPlanFeatureMutation) ClearField(name string) error {
	switch name {
	case entitlementplanfeature.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitlementplanfeature.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitlementplanfeature.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitlementplanfeature.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitlementplanfeature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlementplanfeature.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitlementplanfeature.FieldTags:
		m.ClearTags()
		return nil
	case entitlementplanfeature.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entitlementplanfeature.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanFeature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementPlanFeatureMutation) ResetField(name string) error {
	switch name {
	case entitlementplanfeature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlementplanfeature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlementplanfeature.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitlementplanfeature.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitlementplanfeature.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entitlementplanfeature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlementplanfeature.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitlementplanfeature.FieldTags:
		m.ResetTags()
		return nil
	case entitlementplanfeature.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitlementplanfeature.FieldMetadata:
		m.ResetMetadata()
		return nil
	case entitlementplanfeature.FieldPlanID:
		m.ResetPlanID()
		return nil
	case entitlementplanfeature.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanFeature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementPlanFeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, entitlementplanfeature.EdgeOwner)
	}
	if m.plan != nil {
		edges = append(edges, entitlementplanfeature.EdgePlan)
	}
	if m.feature != nil {
		edges = append(edges, entitlementplanfeature.EdgeFeature)
	}
	if m.events != nil {
		edges = append(edges, entitlementplanfeature.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementPlanFeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitlementplanfeature.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case entitlementplanfeature.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case entitlementplanfeature.EdgeFeature:
		if id := m.feature; id != nil {
			return []ent.Value{*id}
		}
	case entitlementplanfeature.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementPlanFeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedevents != nil {
		edges = append(edges, entitlementplanfeature.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementPlanFeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitlementplanfeature.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, entitlementplanfeature.EdgeOwner)
	}
	if m.clearedplan {
		edges = append(edges, entitlementplanfeature.EdgePlan)
	}
	if m.clearedfeature {
		edges = append(edges, entitlementplanfeature.EdgeFeature)
	}
	if m.clearedevents {
		edges = append(edges, entitlementplanfeature.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementPlanFeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case entitlementplanfeature.EdgeOwner:
		return m.clearedowner
	case entitlementplanfeature.EdgePlan:
		return m.clearedplan
	case entitlementplanfeature.EdgeFeature:
		return m.clearedfeature
	case entitlementplanfeature.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementPlanFeatureMutation) ClearEdge(name string) error {
	switch name {
	case entitlementplanfeature.EdgeOwner:
		m.ClearOwner()
		return nil
	case entitlementplanfeature.EdgePlan:
		m.ClearPlan()
		return nil
	case entitlementplanfeature.EdgeFeature:
		m.ClearFeature()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanFeature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementPlanFeatureMutation) ResetEdge(name string) error {
	switch name {
	case entitlementplanfeature.EdgeOwner:
		m.ResetOwner()
		return nil
	case entitlementplanfeature.EdgePlan:
		m.ResetPlan()
		return nil
	case entitlementplanfeature.EdgeFeature:
		m.ResetFeature()
		return nil
	case entitlementplanfeature.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanFeature edge %s", name)
}

// EntitlementPlanFeatureHistoryMutation represents an operation that mutates the EntitlementPlanFeatureHistory nodes in the graph.
type EntitlementPlanFeatureHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	metadata      *map[string]interface{}
	plan_id       *string
	feature_id    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EntitlementPlanFeatureHistory, error)
	predicates    []predicate.EntitlementPlanFeatureHistory
}

var _ ent.Mutation = (*EntitlementPlanFeatureHistoryMutation)(nil)

// entitlementplanfeaturehistoryOption allows management of the mutation configuration using functional options.
type entitlementplanfeaturehistoryOption func(*EntitlementPlanFeatureHistoryMutation)

// newEntitlementPlanFeatureHistoryMutation creates new mutation for the EntitlementPlanFeatureHistory entity.
func newEntitlementPlanFeatureHistoryMutation(c config, op Op, opts ...entitlementplanfeaturehistoryOption) *EntitlementPlanFeatureHistoryMutation {
	m := &EntitlementPlanFeatureHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlementPlanFeatureHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementPlanFeatureHistoryID sets the ID field of the mutation.
func withEntitlementPlanFeatureHistoryID(id string) entitlementplanfeaturehistoryOption {
	return func(m *EntitlementPlanFeatureHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EntitlementPlanFeatureHistory
		)
		m.oldValue = func(ctx context.Context) (*EntitlementPlanFeatureHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntitlementPlanFeatureHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlementPlanFeatureHistory sets the old EntitlementPlanFeatureHistory of the mutation.
func withEntitlementPlanFeatureHistory(node *EntitlementPlanFeatureHistory) entitlementplanfeaturehistoryOption {
	return func(m *EntitlementPlanFeatureHistoryMutation) {
		m.oldValue = func(context.Context) (*EntitlementPlanFeatureHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementPlanFeatureHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementPlanFeatureHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntitlementPlanFeatureHistory entities.
func (m *EntitlementPlanFeatureHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementPlanFeatureHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntitlementPlanFeatureHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntitlementPlanFeatureHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldOwnerID)
}

// SetMetadata sets the "metadata" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EntitlementPlanFeatureHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[entitlementplanfeaturehistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[entitlementplanfeaturehistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, entitlementplanfeaturehistory.FieldMetadata)
}

// SetPlanID sets the "plan_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetPlanID(s string) {
	m.plan_id = &s
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) PlanID() (r string, exists bool) {
	v := m.plan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldPlanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetPlanID() {
	m.plan_id = nil
}

// SetFeatureID sets the "feature_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) SetFeatureID(s string) {
	m.feature_id = &s
}

// FeatureID returns the value of the "feature_id" field in the mutation.
func (m *EntitlementPlanFeatureHistoryMutation) FeatureID() (r string, exists bool) {
	v := m.feature_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureID returns the old "feature_id" field's value of the EntitlementPlanFeatureHistory entity.
// If the EntitlementPlanFeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanFeatureHistoryMutation) OldFeatureID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureID: %w", err)
	}
	return oldValue.FeatureID, nil
}

// ResetFeatureID resets all changes to the "feature_id" field.
func (m *EntitlementPlanFeatureHistoryMutation) ResetFeatureID() {
	m.feature_id = nil
}

// Where appends a list predicates to the EntitlementPlanFeatureHistoryMutation builder.
func (m *EntitlementPlanFeatureHistoryMutation) Where(ps ...predicate.EntitlementPlanFeatureHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementPlanFeatureHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementPlanFeatureHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntitlementPlanFeatureHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementPlanFeatureHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementPlanFeatureHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntitlementPlanFeatureHistory).
func (m *EntitlementPlanFeatureHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementPlanFeatureHistoryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.history_time != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldOwnerID)
	}
	if m.metadata != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldMetadata)
	}
	if m.plan_id != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldPlanID)
	}
	if m.feature_id != nil {
		fields = append(fields, entitlementplanfeaturehistory.FieldFeatureID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementPlanFeatureHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlementplanfeaturehistory.FieldHistoryTime:
		return m.HistoryTime()
	case entitlementplanfeaturehistory.FieldRef:
		return m.Ref()
	case entitlementplanfeaturehistory.FieldOperation:
		return m.Operation()
	case entitlementplanfeaturehistory.FieldCreatedAt:
		return m.CreatedAt()
	case entitlementplanfeaturehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlementplanfeaturehistory.FieldCreatedBy:
		return m.CreatedBy()
	case entitlementplanfeaturehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitlementplanfeaturehistory.FieldMappingID:
		return m.MappingID()
	case entitlementplanfeaturehistory.FieldDeletedAt:
		return m.DeletedAt()
	case entitlementplanfeaturehistory.FieldDeletedBy:
		return m.DeletedBy()
	case entitlementplanfeaturehistory.FieldTags:
		return m.Tags()
	case entitlementplanfeaturehistory.FieldOwnerID:
		return m.OwnerID()
	case entitlementplanfeaturehistory.FieldMetadata:
		return m.Metadata()
	case entitlementplanfeaturehistory.FieldPlanID:
		return m.PlanID()
	case entitlementplanfeaturehistory.FieldFeatureID:
		return m.FeatureID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementPlanFeatureHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlementplanfeaturehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case entitlementplanfeaturehistory.FieldRef:
		return m.OldRef(ctx)
	case entitlementplanfeaturehistory.FieldOperation:
		return m.OldOperation(ctx)
	case entitlementplanfeaturehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlementplanfeaturehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlementplanfeaturehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitlementplanfeaturehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitlementplanfeaturehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case entitlementplanfeaturehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlementplanfeaturehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitlementplanfeaturehistory.FieldTags:
		return m.OldTags(ctx)
	case entitlementplanfeaturehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitlementplanfeaturehistory.FieldMetadata:
		return m.OldMetadata(ctx)
	case entitlementplanfeaturehistory.FieldPlanID:
		return m.OldPlanID(ctx)
	case entitlementplanfeaturehistory.FieldFeatureID:
		return m.OldFeatureID(ctx)
	}
	return nil, fmt.Errorf("unknown EntitlementPlanFeatureHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementPlanFeatureHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlementplanfeaturehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case entitlementplanfeaturehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case entitlementplanfeaturehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case entitlementplanfeaturehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlementplanfeaturehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlementplanfeaturehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitlementplanfeaturehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitlementplanfeaturehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entitlementplanfeaturehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlementplanfeaturehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitlementplanfeaturehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitlementplanfeaturehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitlementplanfeaturehistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case entitlementplanfeaturehistory.FieldPlanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case entitlementplanfeaturehistory.FieldFeatureID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureID(v)
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanFeatureHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementPlanFeatureHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementPlanFeatureHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntitlementPlanFeatureHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementPlanFeatureHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlementplanfeaturehistory.FieldRef) {
		fields = append(fields, entitlementplanfeaturehistory.FieldRef)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldCreatedAt) {
		fields = append(fields, entitlementplanfeaturehistory.FieldCreatedAt)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldUpdatedAt) {
		fields = append(fields, entitlementplanfeaturehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldCreatedBy) {
		fields = append(fields, entitlementplanfeaturehistory.FieldCreatedBy)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldUpdatedBy) {
		fields = append(fields, entitlementplanfeaturehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldDeletedAt) {
		fields = append(fields, entitlementplanfeaturehistory.FieldDeletedAt)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldDeletedBy) {
		fields = append(fields, entitlementplanfeaturehistory.FieldDeletedBy)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldTags) {
		fields = append(fields, entitlementplanfeaturehistory.FieldTags)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldOwnerID) {
		fields = append(fields, entitlementplanfeaturehistory.FieldOwnerID)
	}
	if m.FieldCleared(entitlementplanfeaturehistory.FieldMetadata) {
		fields = append(fields, entitlementplanfeaturehistory.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementPlanFeatureHistoryMutation) ClearField(name string) error {
	switch name {
	case entitlementplanfeaturehistory.FieldRef:
		m.ClearRef()
		return nil
	case entitlementplanfeaturehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitlementplanfeaturehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitlementplanfeaturehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitlementplanfeaturehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitlementplanfeaturehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlementplanfeaturehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitlementplanfeaturehistory.FieldTags:
		m.ClearTags()
		return nil
	case entitlementplanfeaturehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entitlementplanfeaturehistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanFeatureHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementPlanFeatureHistoryMutation) ResetField(name string) error {
	switch name {
	case entitlementplanfeaturehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case entitlementplanfeaturehistory.FieldRef:
		m.ResetRef()
		return nil
	case entitlementplanfeaturehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case entitlementplanfeaturehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlementplanfeaturehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlementplanfeaturehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitlementplanfeaturehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitlementplanfeaturehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entitlementplanfeaturehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlementplanfeaturehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitlementplanfeaturehistory.FieldTags:
		m.ResetTags()
		return nil
	case entitlementplanfeaturehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitlementplanfeaturehistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	case entitlementplanfeaturehistory.FieldPlanID:
		m.ResetPlanID()
		return nil
	case entitlementplanfeaturehistory.FieldFeatureID:
		m.ResetFeatureID()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanFeatureHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementPlanFeatureHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementPlanFeatureHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EntitlementPlanFeatureHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementPlanFeatureHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EntitlementPlanFeatureHistory edge %s", name)
}

// EntitlementPlanHistoryMutation represents an operation that mutates the EntitlementPlanHistory nodes in the graph.
type EntitlementPlanHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	display_name  *string
	name          *string
	description   *string
	version       *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EntitlementPlanHistory, error)
	predicates    []predicate.EntitlementPlanHistory
}

var _ ent.Mutation = (*EntitlementPlanHistoryMutation)(nil)

// entitlementplanhistoryOption allows management of the mutation configuration using functional options.
type entitlementplanhistoryOption func(*EntitlementPlanHistoryMutation)

// newEntitlementPlanHistoryMutation creates new mutation for the EntitlementPlanHistory entity.
func newEntitlementPlanHistoryMutation(c config, op Op, opts ...entitlementplanhistoryOption) *EntitlementPlanHistoryMutation {
	m := &EntitlementPlanHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitlementPlanHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitlementPlanHistoryID sets the ID field of the mutation.
func withEntitlementPlanHistoryID(id string) entitlementplanhistoryOption {
	return func(m *EntitlementPlanHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EntitlementPlanHistory
		)
		m.oldValue = func(ctx context.Context) (*EntitlementPlanHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntitlementPlanHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitlementPlanHistory sets the old EntitlementPlanHistory of the mutation.
func withEntitlementPlanHistory(node *EntitlementPlanHistory) entitlementplanhistoryOption {
	return func(m *EntitlementPlanHistoryMutation) {
		m.oldValue = func(context.Context) (*EntitlementPlanHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitlementPlanHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitlementPlanHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntitlementPlanHistory entities.
func (m *EntitlementPlanHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitlementPlanHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitlementPlanHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntitlementPlanHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EntitlementPlanHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EntitlementPlanHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EntitlementPlanHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EntitlementPlanHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EntitlementPlanHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EntitlementPlanHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[entitlementplanhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EntitlementPlanHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, entitlementplanhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EntitlementPlanHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EntitlementPlanHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EntitlementPlanHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitlementPlanHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitlementPlanHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntitlementPlanHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitlementplanhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitlementPlanHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitlementplanhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitlementPlanHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitlementPlanHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntitlementPlanHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitlementplanhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitlementPlanHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitlementplanhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntitlementPlanHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntitlementPlanHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntitlementPlanHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitlementplanhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntitlementPlanHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitlementplanhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntitlementPlanHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntitlementPlanHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntitlementPlanHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitlementplanhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntitlementPlanHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitlementplanhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntitlementPlanHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntitlementPlanHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntitlementPlanHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitlementPlanHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitlementPlanHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitlementPlanHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitlementplanhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitlementPlanHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitlementplanhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntitlementPlanHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntitlementPlanHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntitlementPlanHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitlementplanhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntitlementPlanHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitlementplanhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntitlementPlanHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntitlementPlanHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntitlementPlanHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntitlementPlanHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntitlementPlanHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitlementplanhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntitlementPlanHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitlementplanhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntitlementPlanHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntitlementPlanHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntitlementPlanHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[entitlementplanhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntitlementPlanHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, entitlementplanhistory.FieldOwnerID)
}

// SetDisplayName sets the "display_name" field.
func (m *EntitlementPlanHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *EntitlementPlanHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *EntitlementPlanHistoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[entitlementplanhistory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *EntitlementPlanHistoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, entitlementplanhistory.FieldDisplayName)
}

// SetName sets the "name" field.
func (m *EntitlementPlanHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntitlementPlanHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntitlementPlanHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EntitlementPlanHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntitlementPlanHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntitlementPlanHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entitlementplanhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntitlementPlanHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entitlementplanhistory.FieldDescription)
}

// SetVersion sets the "version" field.
func (m *EntitlementPlanHistoryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *EntitlementPlanHistoryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *EntitlementPlanHistoryMutation) ResetVersion() {
	m.version = nil
}

// SetMetadata sets the "metadata" field.
func (m *EntitlementPlanHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EntitlementPlanHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the EntitlementPlanHistory entity.
// If the EntitlementPlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitlementPlanHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EntitlementPlanHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[entitlementplanhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[entitlementplanhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EntitlementPlanHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, entitlementplanhistory.FieldMetadata)
}

// Where appends a list predicates to the EntitlementPlanHistoryMutation builder.
func (m *EntitlementPlanHistoryMutation) Where(ps ...predicate.EntitlementPlanHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntitlementPlanHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntitlementPlanHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntitlementPlanHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntitlementPlanHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntitlementPlanHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntitlementPlanHistory).
func (m *EntitlementPlanHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitlementPlanHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, entitlementplanhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, entitlementplanhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, entitlementplanhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, entitlementplanhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitlementplanhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitlementplanhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitlementplanhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entitlementplanhistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitlementplanhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitlementplanhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entitlementplanhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, entitlementplanhistory.FieldOwnerID)
	}
	if m.display_name != nil {
		fields = append(fields, entitlementplanhistory.FieldDisplayName)
	}
	if m.name != nil {
		fields = append(fields, entitlementplanhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, entitlementplanhistory.FieldDescription)
	}
	if m.version != nil {
		fields = append(fields, entitlementplanhistory.FieldVersion)
	}
	if m.metadata != nil {
		fields = append(fields, entitlementplanhistory.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitlementPlanHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitlementplanhistory.FieldHistoryTime:
		return m.HistoryTime()
	case entitlementplanhistory.FieldRef:
		return m.Ref()
	case entitlementplanhistory.FieldOperation:
		return m.Operation()
	case entitlementplanhistory.FieldCreatedAt:
		return m.CreatedAt()
	case entitlementplanhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitlementplanhistory.FieldCreatedBy:
		return m.CreatedBy()
	case entitlementplanhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitlementplanhistory.FieldMappingID:
		return m.MappingID()
	case entitlementplanhistory.FieldDeletedAt:
		return m.DeletedAt()
	case entitlementplanhistory.FieldDeletedBy:
		return m.DeletedBy()
	case entitlementplanhistory.FieldTags:
		return m.Tags()
	case entitlementplanhistory.FieldOwnerID:
		return m.OwnerID()
	case entitlementplanhistory.FieldDisplayName:
		return m.DisplayName()
	case entitlementplanhistory.FieldName:
		return m.Name()
	case entitlementplanhistory.FieldDescription:
		return m.Description()
	case entitlementplanhistory.FieldVersion:
		return m.Version()
	case entitlementplanhistory.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitlementPlanHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitlementplanhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case entitlementplanhistory.FieldRef:
		return m.OldRef(ctx)
	case entitlementplanhistory.FieldOperation:
		return m.OldOperation(ctx)
	case entitlementplanhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitlementplanhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitlementplanhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitlementplanhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitlementplanhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case entitlementplanhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitlementplanhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitlementplanhistory.FieldTags:
		return m.OldTags(ctx)
	case entitlementplanhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitlementplanhistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case entitlementplanhistory.FieldName:
		return m.OldName(ctx)
	case entitlementplanhistory.FieldDescription:
		return m.OldDescription(ctx)
	case entitlementplanhistory.FieldVersion:
		return m.OldVersion(ctx)
	case entitlementplanhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown EntitlementPlanHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementPlanHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitlementplanhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case entitlementplanhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case entitlementplanhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case entitlementplanhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitlementplanhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitlementplanhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitlementplanhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitlementplanhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entitlementplanhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitlementplanhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitlementplanhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitlementplanhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitlementplanhistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case entitlementplanhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entitlementplanhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entitlementplanhistory.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case entitlementplanhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitlementPlanHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitlementPlanHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitlementPlanHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntitlementPlanHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitlementPlanHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitlementplanhistory.FieldRef) {
		fields = append(fields, entitlementplanhistory.FieldRef)
	}
	if m.FieldCleared(entitlementplanhistory.FieldCreatedAt) {
		fields = append(fields, entitlementplanhistory.FieldCreatedAt)
	}
	if m.FieldCleared(entitlementplanhistory.FieldUpdatedAt) {
		fields = append(fields, entitlementplanhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(entitlementplanhistory.FieldCreatedBy) {
		fields = append(fields, entitlementplanhistory.FieldCreatedBy)
	}
	if m.FieldCleared(entitlementplanhistory.FieldUpdatedBy) {
		fields = append(fields, entitlementplanhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(entitlementplanhistory.FieldDeletedAt) {
		fields = append(fields, entitlementplanhistory.FieldDeletedAt)
	}
	if m.FieldCleared(entitlementplanhistory.FieldDeletedBy) {
		fields = append(fields, entitlementplanhistory.FieldDeletedBy)
	}
	if m.FieldCleared(entitlementplanhistory.FieldTags) {
		fields = append(fields, entitlementplanhistory.FieldTags)
	}
	if m.FieldCleared(entitlementplanhistory.FieldOwnerID) {
		fields = append(fields, entitlementplanhistory.FieldOwnerID)
	}
	if m.FieldCleared(entitlementplanhistory.FieldDisplayName) {
		fields = append(fields, entitlementplanhistory.FieldDisplayName)
	}
	if m.FieldCleared(entitlementplanhistory.FieldDescription) {
		fields = append(fields, entitlementplanhistory.FieldDescription)
	}
	if m.FieldCleared(entitlementplanhistory.FieldMetadata) {
		fields = append(fields, entitlementplanhistory.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitlementPlanHistoryMutation) ClearField(name string) error {
	switch name {
	case entitlementplanhistory.FieldRef:
		m.ClearRef()
		return nil
	case entitlementplanhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitlementplanhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitlementplanhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitlementplanhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitlementplanhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitlementplanhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitlementplanhistory.FieldTags:
		m.ClearTags()
		return nil
	case entitlementplanhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entitlementplanhistory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case entitlementplanhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case entitlementplanhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitlementPlanHistoryMutation) ResetField(name string) error {
	switch name {
	case entitlementplanhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case entitlementplanhistory.FieldRef:
		m.ResetRef()
		return nil
	case entitlementplanhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case entitlementplanhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitlementplanhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitlementplanhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitlementplanhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitlementplanhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entitlementplanhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitlementplanhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitlementplanhistory.FieldTags:
		m.ResetTags()
		return nil
	case entitlementplanhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitlementplanhistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case entitlementplanhistory.FieldName:
		m.ResetName()
		return nil
	case entitlementplanhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case entitlementplanhistory.FieldVersion:
		m.ResetVersion()
		return nil
	case entitlementplanhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown EntitlementPlanHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitlementPlanHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitlementPlanHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitlementPlanHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitlementPlanHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitlementPlanHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitlementPlanHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EntitlementPlanHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitlementPlanHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EntitlementPlanHistory edge %s", name)
}

// EntityMutation represents an operation that mutates the Entity nodes in the graph.
type EntityMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	mapping_id         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	name               *string
	display_name       *string
	description        *string
	domains            *[]string
	appenddomains      []string
	status             *string
	clearedFields      map[string]struct{}
	owner              *string
	clearedowner       bool
	contacts           map[string]struct{}
	removedcontacts    map[string]struct{}
	clearedcontacts    bool
	documents          map[string]struct{}
	removeddocuments   map[string]struct{}
	cleareddocuments   bool
	notes              map[string]struct{}
	removednotes       map[string]struct{}
	clearednotes       bool
	files              map[string]struct{}
	removedfiles       map[string]struct{}
	clearedfiles       bool
	entity_type        *string
	clearedentity_type bool
	done               bool
	oldValue           func(context.Context) (*Entity, error)
	predicates         []predicate.Entity
}

var _ ent.Mutation = (*EntityMutation)(nil)

// entityOption allows management of the mutation configuration using functional options.
type entityOption func(*EntityMutation)

// newEntityMutation creates new mutation for the Entity entity.
func newEntityMutation(c config, op Op, opts ...entityOption) *EntityMutation {
	m := &EntityMutation{
		config:        c,
		op:            op,
		typ:           TypeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityID sets the ID field of the mutation.
func withEntityID(id string) entityOption {
	return func(m *EntityMutation) {
		var (
			err   error
			once  sync.Once
			value *Entity
		)
		m.oldValue = func(ctx context.Context) (*Entity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntity sets the old Entity of the mutation.
func withEntity(node *Entity) entityOption {
	return func(m *EntityMutation) {
		m.oldValue = func(context.Context) (*Entity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Entity entities.
func (m *EntityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntityMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entity.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntityMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entity.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entity.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntityMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entity.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntityMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entity.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entity.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entity.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entity.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entity.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntityMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntityMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntityMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entity.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntityMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entity.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntityMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entity.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntityMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntityMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntityMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entity.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntityMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntityMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntityMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entity.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntityMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entity.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntityMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entity.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntityMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntityMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntityMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntityMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntityMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entity.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntityMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entity.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntityMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entity.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntityMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntityMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntityMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[entity.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntityMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entity.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntityMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, entity.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *EntityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EntityMutation) ClearName() {
	m.name = nil
	m.clearedFields[entity.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EntityMutation) NameCleared() bool {
	_, ok := m.clearedFields[entity.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EntityMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, entity.FieldName)
}

// SetDisplayName sets the "display_name" field.
func (m *EntityMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *EntityMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *EntityMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[entity.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *EntityMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[entity.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *EntityMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, entity.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *EntityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entity.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entity.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entity.FieldDescription)
}

// SetDomains sets the "domains" field.
func (m *EntityMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *EntityMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *EntityMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *EntityMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *EntityMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[entity.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *EntityMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[entity.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *EntityMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, entity.FieldDomains)
}

// SetEntityTypeID sets the "entity_type_id" field.
func (m *EntityMutation) SetEntityTypeID(s string) {
	m.entity_type = &s
}

// EntityTypeID returns the value of the "entity_type_id" field in the mutation.
func (m *EntityMutation) EntityTypeID() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityTypeID returns the old "entity_type_id" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldEntityTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityTypeID: %w", err)
	}
	return oldValue.EntityTypeID, nil
}

// ClearEntityTypeID clears the value of the "entity_type_id" field.
func (m *EntityMutation) ClearEntityTypeID() {
	m.entity_type = nil
	m.clearedFields[entity.FieldEntityTypeID] = struct{}{}
}

// EntityTypeIDCleared returns if the "entity_type_id" field was cleared in this mutation.
func (m *EntityMutation) EntityTypeIDCleared() bool {
	_, ok := m.clearedFields[entity.FieldEntityTypeID]
	return ok
}

// ResetEntityTypeID resets all changes to the "entity_type_id" field.
func (m *EntityMutation) ResetEntityTypeID() {
	m.entity_type = nil
	delete(m.clearedFields, entity.FieldEntityTypeID)
}

// SetStatus sets the "status" field.
func (m *EntityMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EntityMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EntityMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[entity.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EntityMutation) StatusCleared() bool {
	_, ok := m.clearedFields[entity.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EntityMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, entity.FieldStatus)
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *EntityMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[entity.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *EntityMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *EntityMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddContactIDs adds the "contacts" edge to the Contact entity by ids.
func (m *EntityMutation) AddContactIDs(ids ...string) {
	if m.contacts == nil {
		m.contacts = make(map[string]struct{})
	}
	for i := range ids {
		m.contacts[ids[i]] = struct{}{}
	}
}

// ClearContacts clears the "contacts" edge to the Contact entity.
func (m *EntityMutation) ClearContacts() {
	m.clearedcontacts = true
}

// ContactsCleared reports if the "contacts" edge to the Contact entity was cleared.
func (m *EntityMutation) ContactsCleared() bool {
	return m.clearedcontacts
}

// RemoveContactIDs removes the "contacts" edge to the Contact entity by IDs.
func (m *EntityMutation) RemoveContactIDs(ids ...string) {
	if m.removedcontacts == nil {
		m.removedcontacts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.contacts, ids[i])
		m.removedcontacts[ids[i]] = struct{}{}
	}
}

// RemovedContacts returns the removed IDs of the "contacts" edge to the Contact entity.
func (m *EntityMutation) RemovedContactsIDs() (ids []string) {
	for id := range m.removedcontacts {
		ids = append(ids, id)
	}
	return
}

// ContactsIDs returns the "contacts" edge IDs in the mutation.
func (m *EntityMutation) ContactsIDs() (ids []string) {
	for id := range m.contacts {
		ids = append(ids, id)
	}
	return
}

// ResetContacts resets all changes to the "contacts" edge.
func (m *EntityMutation) ResetContacts() {
	m.contacts = nil
	m.clearedcontacts = false
	m.removedcontacts = nil
}

// AddDocumentIDs adds the "documents" edge to the DocumentData entity by ids.
func (m *EntityMutation) AddDocumentIDs(ids ...string) {
	if m.documents == nil {
		m.documents = make(map[string]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the DocumentData entity.
func (m *EntityMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the DocumentData entity was cleared.
func (m *EntityMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the DocumentData entity by IDs.
func (m *EntityMutation) RemoveDocumentIDs(ids ...string) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the DocumentData entity.
func (m *EntityMutation) RemovedDocumentsIDs() (ids []string) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *EntityMutation) DocumentsIDs() (ids []string) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *EntityMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddNoteIDs adds the "notes" edge to the Note entity by ids.
func (m *EntityMutation) AddNoteIDs(ids ...string) {
	if m.notes == nil {
		m.notes = make(map[string]struct{})
	}
	for i := range ids {
		m.notes[ids[i]] = struct{}{}
	}
}

// ClearNotes clears the "notes" edge to the Note entity.
func (m *EntityMutation) ClearNotes() {
	m.clearednotes = true
}

// NotesCleared reports if the "notes" edge to the Note entity was cleared.
func (m *EntityMutation) NotesCleared() bool {
	return m.clearednotes
}

// RemoveNoteIDs removes the "notes" edge to the Note entity by IDs.
func (m *EntityMutation) RemoveNoteIDs(ids ...string) {
	if m.removednotes == nil {
		m.removednotes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notes, ids[i])
		m.removednotes[ids[i]] = struct{}{}
	}
}

// RemovedNotes returns the removed IDs of the "notes" edge to the Note entity.
func (m *EntityMutation) RemovedNotesIDs() (ids []string) {
	for id := range m.removednotes {
		ids = append(ids, id)
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
func (m *EntityMutation) NotesIDs() (ids []string) {
	for id := range m.notes {
		ids = append(ids, id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *EntityMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
	m.removednotes = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *EntityMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *EntityMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *EntityMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *EntityMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *EntityMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *EntityMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *EntityMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// ClearEntityType clears the "entity_type" edge to the EntityType entity.
func (m *EntityMutation) ClearEntityType() {
	m.clearedentity_type = true
	m.clearedFields[entity.FieldEntityTypeID] = struct{}{}
}

// EntityTypeCleared reports if the "entity_type" edge to the EntityType entity was cleared.
func (m *EntityMutation) EntityTypeCleared() bool {
	return m.EntityTypeIDCleared() || m.clearedentity_type
}

// EntityTypeIDs returns the "entity_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityTypeID instead. It exists only for internal usage by the builders.
func (m *EntityMutation) EntityTypeIDs() (ids []string) {
	if id := m.entity_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntityType resets all changes to the "entity_type" edge.
func (m *EntityMutation) ResetEntityType() {
	m.entity_type = nil
	m.clearedentity_type = false
}

// Where appends a list predicates to the EntityMutation builder.
func (m *EntityMutation) Where(ps ...predicate.Entity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entity).
func (m *EntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, entity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entity.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entity.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entity.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entity.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, entity.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entity.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entity.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, entity.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, entity.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, entity.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, entity.FieldDescription)
	}
	if m.domains != nil {
		fields = append(fields, entity.FieldDomains)
	}
	if m.entity_type != nil {
		fields = append(fields, entity.FieldEntityTypeID)
	}
	if m.status != nil {
		fields = append(fields, entity.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldCreatedAt:
		return m.CreatedAt()
	case entity.FieldUpdatedAt:
		return m.UpdatedAt()
	case entity.FieldCreatedBy:
		return m.CreatedBy()
	case entity.FieldUpdatedBy:
		return m.UpdatedBy()
	case entity.FieldMappingID:
		return m.MappingID()
	case entity.FieldDeletedAt:
		return m.DeletedAt()
	case entity.FieldDeletedBy:
		return m.DeletedBy()
	case entity.FieldTags:
		return m.Tags()
	case entity.FieldOwnerID:
		return m.OwnerID()
	case entity.FieldName:
		return m.Name()
	case entity.FieldDisplayName:
		return m.DisplayName()
	case entity.FieldDescription:
		return m.Description()
	case entity.FieldDomains:
		return m.Domains()
	case entity.FieldEntityTypeID:
		return m.EntityTypeID()
	case entity.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entity.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entity.FieldMappingID:
		return m.OldMappingID(ctx)
	case entity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entity.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entity.FieldTags:
		return m.OldTags(ctx)
	case entity.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entity.FieldName:
		return m.OldName(ctx)
	case entity.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case entity.FieldDescription:
		return m.OldDescription(ctx)
	case entity.FieldDomains:
		return m.OldDomains(ctx)
	case entity.FieldEntityTypeID:
		return m.OldEntityTypeID(ctx)
	case entity.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Entity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entity.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entity.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entity.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entity.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entity.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entity.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entity.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case entity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entity.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case entity.FieldEntityTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityTypeID(v)
		return nil
	case entity.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Entity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entity.FieldCreatedAt) {
		fields = append(fields, entity.FieldCreatedAt)
	}
	if m.FieldCleared(entity.FieldUpdatedAt) {
		fields = append(fields, entity.FieldUpdatedAt)
	}
	if m.FieldCleared(entity.FieldCreatedBy) {
		fields = append(fields, entity.FieldCreatedBy)
	}
	if m.FieldCleared(entity.FieldUpdatedBy) {
		fields = append(fields, entity.FieldUpdatedBy)
	}
	if m.FieldCleared(entity.FieldDeletedAt) {
		fields = append(fields, entity.FieldDeletedAt)
	}
	if m.FieldCleared(entity.FieldDeletedBy) {
		fields = append(fields, entity.FieldDeletedBy)
	}
	if m.FieldCleared(entity.FieldTags) {
		fields = append(fields, entity.FieldTags)
	}
	if m.FieldCleared(entity.FieldOwnerID) {
		fields = append(fields, entity.FieldOwnerID)
	}
	if m.FieldCleared(entity.FieldName) {
		fields = append(fields, entity.FieldName)
	}
	if m.FieldCleared(entity.FieldDisplayName) {
		fields = append(fields, entity.FieldDisplayName)
	}
	if m.FieldCleared(entity.FieldDescription) {
		fields = append(fields, entity.FieldDescription)
	}
	if m.FieldCleared(entity.FieldDomains) {
		fields = append(fields, entity.FieldDomains)
	}
	if m.FieldCleared(entity.FieldEntityTypeID) {
		fields = append(fields, entity.FieldEntityTypeID)
	}
	if m.FieldCleared(entity.FieldStatus) {
		fields = append(fields, entity.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityMutation) ClearField(name string) error {
	switch name {
	case entity.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entity.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entity.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entity.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entity.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entity.FieldTags:
		m.ClearTags()
		return nil
	case entity.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entity.FieldName:
		m.ClearName()
		return nil
	case entity.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case entity.FieldDescription:
		m.ClearDescription()
		return nil
	case entity.FieldDomains:
		m.ClearDomains()
		return nil
	case entity.FieldEntityTypeID:
		m.ClearEntityTypeID()
		return nil
	case entity.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Entity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityMutation) ResetField(name string) error {
	switch name {
	case entity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entity.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entity.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entity.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entity.FieldTags:
		m.ResetTags()
		return nil
	case entity.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entity.FieldName:
		m.ResetName()
		return nil
	case entity.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case entity.FieldDescription:
		m.ResetDescription()
		return nil
	case entity.FieldDomains:
		m.ResetDomains()
		return nil
	case entity.FieldEntityTypeID:
		m.ResetEntityTypeID()
		return nil
	case entity.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.owner != nil {
		edges = append(edges, entity.EdgeOwner)
	}
	if m.contacts != nil {
		edges = append(edges, entity.EdgeContacts)
	}
	if m.documents != nil {
		edges = append(edges, entity.EdgeDocuments)
	}
	if m.notes != nil {
		edges = append(edges, entity.EdgeNotes)
	}
	if m.files != nil {
		edges = append(edges, entity.EdgeFiles)
	}
	if m.entity_type != nil {
		edges = append(edges, entity.EdgeEntityType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case entity.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.contacts))
		for id := range m.contacts {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.notes))
		for id := range m.notes {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeEntityType:
		if id := m.entity_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcontacts != nil {
		edges = append(edges, entity.EdgeContacts)
	}
	if m.removeddocuments != nil {
		edges = append(edges, entity.EdgeDocuments)
	}
	if m.removednotes != nil {
		edges = append(edges, entity.EdgeNotes)
	}
	if m.removedfiles != nil {
		edges = append(edges, entity.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.removedcontacts))
		for id := range m.removedcontacts {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.removednotes))
		for id := range m.removednotes {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedowner {
		edges = append(edges, entity.EdgeOwner)
	}
	if m.clearedcontacts {
		edges = append(edges, entity.EdgeContacts)
	}
	if m.cleareddocuments {
		edges = append(edges, entity.EdgeDocuments)
	}
	if m.clearednotes {
		edges = append(edges, entity.EdgeNotes)
	}
	if m.clearedfiles {
		edges = append(edges, entity.EdgeFiles)
	}
	if m.clearedentity_type {
		edges = append(edges, entity.EdgeEntityType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityMutation) EdgeCleared(name string) bool {
	switch name {
	case entity.EdgeOwner:
		return m.clearedowner
	case entity.EdgeContacts:
		return m.clearedcontacts
	case entity.EdgeDocuments:
		return m.cleareddocuments
	case entity.EdgeNotes:
		return m.clearednotes
	case entity.EdgeFiles:
		return m.clearedfiles
	case entity.EdgeEntityType:
		return m.clearedentity_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityMutation) ClearEdge(name string) error {
	switch name {
	case entity.EdgeOwner:
		m.ClearOwner()
		return nil
	case entity.EdgeEntityType:
		m.ClearEntityType()
		return nil
	}
	return fmt.Errorf("unknown Entity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityMutation) ResetEdge(name string) error {
	switch name {
	case entity.EdgeOwner:
		m.ResetOwner()
		return nil
	case entity.EdgeContacts:
		m.ResetContacts()
		return nil
	case entity.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case entity.EdgeNotes:
		m.ResetNotes()
		return nil
	case entity.EdgeFiles:
		m.ResetFiles()
		return nil
	case entity.EdgeEntityType:
		m.ResetEntityType()
		return nil
	}
	return fmt.Errorf("unknown Entity edge %s", name)
}

// EntityHistoryMutation represents an operation that mutates the EntityHistory nodes in the graph.
type EntityHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *string
	history_time   *time.Time
	ref            *string
	operation      *history.OpType
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	mapping_id     *string
	deleted_at     *time.Time
	deleted_by     *string
	tags           *[]string
	appendtags     []string
	owner_id       *string
	name           *string
	display_name   *string
	description    *string
	domains        *[]string
	appenddomains  []string
	entity_type_id *string
	status         *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*EntityHistory, error)
	predicates     []predicate.EntityHistory
}

var _ ent.Mutation = (*EntityHistoryMutation)(nil)

// entityhistoryOption allows management of the mutation configuration using functional options.
type entityhistoryOption func(*EntityHistoryMutation)

// newEntityHistoryMutation creates new mutation for the EntityHistory entity.
func newEntityHistoryMutation(c config, op Op, opts ...entityhistoryOption) *EntityHistoryMutation {
	m := &EntityHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityHistoryID sets the ID field of the mutation.
func withEntityHistoryID(id string) entityhistoryOption {
	return func(m *EntityHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityHistory
		)
		m.oldValue = func(ctx context.Context) (*EntityHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityHistory sets the old EntityHistory of the mutation.
func withEntityHistory(node *EntityHistory) entityhistoryOption {
	return func(m *EntityHistoryMutation) {
		m.oldValue = func(context.Context) (*EntityHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityHistory entities.
func (m *EntityHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EntityHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EntityHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EntityHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EntityHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EntityHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EntityHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[entityhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EntityHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EntityHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, entityhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EntityHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EntityHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EntityHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntityHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entityhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntityHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entityhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntityHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entityhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntityHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entityhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entityhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entityhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntityHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntityHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntityHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entityhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntityHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntityHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entityhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntityHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntityHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntityHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntityHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntityHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntityHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entityhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntityHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntityHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entityhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntityHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntityHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntityHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entityhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntityHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntityHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entityhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntityHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntityHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntityHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntityHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntityHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entityhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntityHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntityHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entityhistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntityHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntityHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntityHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[entityhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntityHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntityHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, entityhistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *EntityHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EntityHistoryMutation) ClearName() {
	m.name = nil
	m.clearedFields[entityhistory.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EntityHistoryMutation) NameCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EntityHistoryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, entityhistory.FieldName)
}

// SetDisplayName sets the "display_name" field.
func (m *EntityHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *EntityHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *EntityHistoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[entityhistory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *EntityHistoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *EntityHistoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, entityhistory.FieldDisplayName)
}

// SetDescription sets the "description" field.
func (m *EntityHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntityHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EntityHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[entityhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EntityHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EntityHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, entityhistory.FieldDescription)
}

// SetDomains sets the "domains" field.
func (m *EntityHistoryMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *EntityHistoryMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *EntityHistoryMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *EntityHistoryMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *EntityHistoryMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[entityhistory.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *EntityHistoryMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *EntityHistoryMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, entityhistory.FieldDomains)
}

// SetEntityTypeID sets the "entity_type_id" field.
func (m *EntityHistoryMutation) SetEntityTypeID(s string) {
	m.entity_type_id = &s
}

// EntityTypeID returns the value of the "entity_type_id" field in the mutation.
func (m *EntityHistoryMutation) EntityTypeID() (r string, exists bool) {
	v := m.entity_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityTypeID returns the old "entity_type_id" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldEntityTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityTypeID: %w", err)
	}
	return oldValue.EntityTypeID, nil
}

// ClearEntityTypeID clears the value of the "entity_type_id" field.
func (m *EntityHistoryMutation) ClearEntityTypeID() {
	m.entity_type_id = nil
	m.clearedFields[entityhistory.FieldEntityTypeID] = struct{}{}
}

// EntityTypeIDCleared returns if the "entity_type_id" field was cleared in this mutation.
func (m *EntityHistoryMutation) EntityTypeIDCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldEntityTypeID]
	return ok
}

// ResetEntityTypeID resets all changes to the "entity_type_id" field.
func (m *EntityHistoryMutation) ResetEntityTypeID() {
	m.entity_type_id = nil
	delete(m.clearedFields, entityhistory.FieldEntityTypeID)
}

// SetStatus sets the "status" field.
func (m *EntityHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EntityHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EntityHistory entity.
// If the EntityHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EntityHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[entityhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EntityHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[entityhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EntityHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, entityhistory.FieldStatus)
}

// Where appends a list predicates to the EntityHistoryMutation builder.
func (m *EntityHistoryMutation) Where(ps ...predicate.EntityHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntityHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntityHistory).
func (m *EntityHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityHistoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.history_time != nil {
		fields = append(fields, entityhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, entityhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, entityhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, entityhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entityhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entityhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entityhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entityhistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, entityhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entityhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entityhistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, entityhistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, entityhistory.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, entityhistory.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, entityhistory.FieldDescription)
	}
	if m.domains != nil {
		fields = append(fields, entityhistory.FieldDomains)
	}
	if m.entity_type_id != nil {
		fields = append(fields, entityhistory.FieldEntityTypeID)
	}
	if m.status != nil {
		fields = append(fields, entityhistory.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entityhistory.FieldHistoryTime:
		return m.HistoryTime()
	case entityhistory.FieldRef:
		return m.Ref()
	case entityhistory.FieldOperation:
		return m.Operation()
	case entityhistory.FieldCreatedAt:
		return m.CreatedAt()
	case entityhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case entityhistory.FieldCreatedBy:
		return m.CreatedBy()
	case entityhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case entityhistory.FieldMappingID:
		return m.MappingID()
	case entityhistory.FieldDeletedAt:
		return m.DeletedAt()
	case entityhistory.FieldDeletedBy:
		return m.DeletedBy()
	case entityhistory.FieldTags:
		return m.Tags()
	case entityhistory.FieldOwnerID:
		return m.OwnerID()
	case entityhistory.FieldName:
		return m.Name()
	case entityhistory.FieldDisplayName:
		return m.DisplayName()
	case entityhistory.FieldDescription:
		return m.Description()
	case entityhistory.FieldDomains:
		return m.Domains()
	case entityhistory.FieldEntityTypeID:
		return m.EntityTypeID()
	case entityhistory.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entityhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case entityhistory.FieldRef:
		return m.OldRef(ctx)
	case entityhistory.FieldOperation:
		return m.OldOperation(ctx)
	case entityhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entityhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entityhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entityhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entityhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case entityhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entityhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entityhistory.FieldTags:
		return m.OldTags(ctx)
	case entityhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entityhistory.FieldName:
		return m.OldName(ctx)
	case entityhistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case entityhistory.FieldDescription:
		return m.OldDescription(ctx)
	case entityhistory.FieldDomains:
		return m.OldDomains(ctx)
	case entityhistory.FieldEntityTypeID:
		return m.OldEntityTypeID(ctx)
	case entityhistory.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EntityHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entityhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case entityhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case entityhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case entityhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entityhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entityhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entityhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entityhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entityhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entityhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entityhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entityhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entityhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entityhistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case entityhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entityhistory.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case entityhistory.FieldEntityTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityTypeID(v)
		return nil
	case entityhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EntityHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntityHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entityhistory.FieldRef) {
		fields = append(fields, entityhistory.FieldRef)
	}
	if m.FieldCleared(entityhistory.FieldCreatedAt) {
		fields = append(fields, entityhistory.FieldCreatedAt)
	}
	if m.FieldCleared(entityhistory.FieldUpdatedAt) {
		fields = append(fields, entityhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(entityhistory.FieldCreatedBy) {
		fields = append(fields, entityhistory.FieldCreatedBy)
	}
	if m.FieldCleared(entityhistory.FieldUpdatedBy) {
		fields = append(fields, entityhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(entityhistory.FieldDeletedAt) {
		fields = append(fields, entityhistory.FieldDeletedAt)
	}
	if m.FieldCleared(entityhistory.FieldDeletedBy) {
		fields = append(fields, entityhistory.FieldDeletedBy)
	}
	if m.FieldCleared(entityhistory.FieldTags) {
		fields = append(fields, entityhistory.FieldTags)
	}
	if m.FieldCleared(entityhistory.FieldOwnerID) {
		fields = append(fields, entityhistory.FieldOwnerID)
	}
	if m.FieldCleared(entityhistory.FieldName) {
		fields = append(fields, entityhistory.FieldName)
	}
	if m.FieldCleared(entityhistory.FieldDisplayName) {
		fields = append(fields, entityhistory.FieldDisplayName)
	}
	if m.FieldCleared(entityhistory.FieldDescription) {
		fields = append(fields, entityhistory.FieldDescription)
	}
	if m.FieldCleared(entityhistory.FieldDomains) {
		fields = append(fields, entityhistory.FieldDomains)
	}
	if m.FieldCleared(entityhistory.FieldEntityTypeID) {
		fields = append(fields, entityhistory.FieldEntityTypeID)
	}
	if m.FieldCleared(entityhistory.FieldStatus) {
		fields = append(fields, entityhistory.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityHistoryMutation) ClearField(name string) error {
	switch name {
	case entityhistory.FieldRef:
		m.ClearRef()
		return nil
	case entityhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entityhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entityhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entityhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entityhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entityhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entityhistory.FieldTags:
		m.ClearTags()
		return nil
	case entityhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case entityhistory.FieldName:
		m.ClearName()
		return nil
	case entityhistory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case entityhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case entityhistory.FieldDomains:
		m.ClearDomains()
		return nil
	case entityhistory.FieldEntityTypeID:
		m.ClearEntityTypeID()
		return nil
	case entityhistory.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown EntityHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityHistoryMutation) ResetField(name string) error {
	switch name {
	case entityhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case entityhistory.FieldRef:
		m.ResetRef()
		return nil
	case entityhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case entityhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entityhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entityhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entityhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entityhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entityhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entityhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entityhistory.FieldTags:
		m.ResetTags()
		return nil
	case entityhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entityhistory.FieldName:
		m.ResetName()
		return nil
	case entityhistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case entityhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case entityhistory.FieldDomains:
		m.ResetDomains()
		return nil
	case entityhistory.FieldEntityTypeID:
		m.ResetEntityTypeID()
		return nil
	case entityhistory.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown EntityHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EntityHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EntityHistory edge %s", name)
}

// EntityTypeMutation represents an operation that mutates the EntityType nodes in the graph.
type EntityTypeMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	mapping_id      *string
	deleted_at      *time.Time
	deleted_by      *string
	tags            *[]string
	appendtags      []string
	name            *string
	clearedFields   map[string]struct{}
	owner           *string
	clearedowner    bool
	entities        map[string]struct{}
	removedentities map[string]struct{}
	clearedentities bool
	done            bool
	oldValue        func(context.Context) (*EntityType, error)
	predicates      []predicate.EntityType
}

var _ ent.Mutation = (*EntityTypeMutation)(nil)

// entitytypeOption allows management of the mutation configuration using functional options.
type entitytypeOption func(*EntityTypeMutation)

// newEntityTypeMutation creates new mutation for the EntityType entity.
func newEntityTypeMutation(c config, op Op, opts ...entitytypeOption) *EntityTypeMutation {
	m := &EntityTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityTypeID sets the ID field of the mutation.
func withEntityTypeID(id string) entitytypeOption {
	return func(m *EntityTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityType
		)
		m.oldValue = func(ctx context.Context) (*EntityType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityType sets the old EntityType of the mutation.
func withEntityType(node *EntityType) entitytypeOption {
	return func(m *EntityTypeMutation) {
		m.oldValue = func(context.Context) (*EntityType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityType entities.
func (m *EntityTypeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityTypeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityTypeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntityTypeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitytype.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntityTypeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityTypeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitytype.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntityTypeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitytype.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntityTypeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitytype.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityTypeMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityTypeMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityTypeMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitytype.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityTypeMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityTypeMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitytype.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntityTypeMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntityTypeMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntityTypeMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitytype.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntityTypeMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntityTypeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitytype.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntityTypeMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntityTypeMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntityTypeMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntityTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntityTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntityTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitytype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntityTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntityTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitytype.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntityTypeMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntityTypeMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntityTypeMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitytype.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntityTypeMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntityTypeMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitytype.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntityTypeMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntityTypeMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntityTypeMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntityTypeMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntityTypeMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitytype.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntityTypeMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntityTypeMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitytype.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntityTypeMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntityTypeMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntityTypeMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[entitytype.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntityTypeMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitytype.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntityTypeMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, entitytype.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *EntityTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntityType entity.
// If the EntityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntityTypeMutation) ResetName() {
	m.name = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *EntityTypeMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[entitytype.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *EntityTypeMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *EntityTypeMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *EntityTypeMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *EntityTypeMutation) AddEntityIDs(ids ...string) {
	if m.entities == nil {
		m.entities = make(map[string]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *EntityTypeMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *EntityTypeMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *EntityTypeMutation) RemoveEntityIDs(ids ...string) {
	if m.removedentities == nil {
		m.removedentities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *EntityTypeMutation) RemovedEntitiesIDs() (ids []string) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *EntityTypeMutation) EntitiesIDs() (ids []string) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *EntityTypeMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// Where appends a list predicates to the EntityTypeMutation builder.
func (m *EntityTypeMutation) Where(ps ...predicate.EntityType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntityType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntityType).
func (m *EntityTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityTypeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, entitytype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitytype.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitytype.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitytype.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entitytype.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitytype.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitytype.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entitytype.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, entitytype.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, entitytype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitytype.FieldCreatedAt:
		return m.CreatedAt()
	case entitytype.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitytype.FieldCreatedBy:
		return m.CreatedBy()
	case entitytype.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitytype.FieldMappingID:
		return m.MappingID()
	case entitytype.FieldDeletedAt:
		return m.DeletedAt()
	case entitytype.FieldDeletedBy:
		return m.DeletedBy()
	case entitytype.FieldTags:
		return m.Tags()
	case entitytype.FieldOwnerID:
		return m.OwnerID()
	case entitytype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitytype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitytype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitytype.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitytype.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitytype.FieldMappingID:
		return m.OldMappingID(ctx)
	case entitytype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitytype.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitytype.FieldTags:
		return m.OldTags(ctx)
	case entitytype.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitytype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EntityType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitytype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitytype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitytype.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitytype.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitytype.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entitytype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitytype.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitytype.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitytype.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitytype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EntityType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntityType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitytype.FieldCreatedAt) {
		fields = append(fields, entitytype.FieldCreatedAt)
	}
	if m.FieldCleared(entitytype.FieldUpdatedAt) {
		fields = append(fields, entitytype.FieldUpdatedAt)
	}
	if m.FieldCleared(entitytype.FieldCreatedBy) {
		fields = append(fields, entitytype.FieldCreatedBy)
	}
	if m.FieldCleared(entitytype.FieldUpdatedBy) {
		fields = append(fields, entitytype.FieldUpdatedBy)
	}
	if m.FieldCleared(entitytype.FieldDeletedAt) {
		fields = append(fields, entitytype.FieldDeletedAt)
	}
	if m.FieldCleared(entitytype.FieldDeletedBy) {
		fields = append(fields, entitytype.FieldDeletedBy)
	}
	if m.FieldCleared(entitytype.FieldTags) {
		fields = append(fields, entitytype.FieldTags)
	}
	if m.FieldCleared(entitytype.FieldOwnerID) {
		fields = append(fields, entitytype.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityTypeMutation) ClearField(name string) error {
	switch name {
	case entitytype.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitytype.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitytype.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitytype.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitytype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitytype.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitytype.FieldTags:
		m.ClearTags()
		return nil
	case entitytype.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown EntityType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityTypeMutation) ResetField(name string) error {
	switch name {
	case entitytype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitytype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitytype.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitytype.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitytype.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entitytype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitytype.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitytype.FieldTags:
		m.ResetTags()
		return nil
	case entitytype.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitytype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EntityType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, entitytype.EdgeOwner)
	}
	if m.entities != nil {
		edges = append(edges, entitytype.EdgeEntities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitytype.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case entitytype.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedentities != nil {
		edges = append(edges, entitytype.EdgeEntities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entitytype.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, entitytype.EdgeOwner)
	}
	if m.clearedentities {
		edges = append(edges, entitytype.EdgeEntities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case entitytype.EdgeOwner:
		return m.clearedowner
	case entitytype.EdgeEntities:
		return m.clearedentities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityTypeMutation) ClearEdge(name string) error {
	switch name {
	case entitytype.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown EntityType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityTypeMutation) ResetEdge(name string) error {
	switch name {
	case entitytype.EdgeOwner:
		m.ResetOwner()
		return nil
	case entitytype.EdgeEntities:
		m.ResetEntities()
		return nil
	}
	return fmt.Errorf("unknown EntityType edge %s", name)
}

// EntityTypeHistoryMutation represents an operation that mutates the EntityTypeHistory nodes in the graph.
type EntityTypeHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EntityTypeHistory, error)
	predicates    []predicate.EntityTypeHistory
}

var _ ent.Mutation = (*EntityTypeHistoryMutation)(nil)

// entitytypehistoryOption allows management of the mutation configuration using functional options.
type entitytypehistoryOption func(*EntityTypeHistoryMutation)

// newEntityTypeHistoryMutation creates new mutation for the EntityTypeHistory entity.
func newEntityTypeHistoryMutation(c config, op Op, opts ...entitytypehistoryOption) *EntityTypeHistoryMutation {
	m := &EntityTypeHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityTypeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityTypeHistoryID sets the ID field of the mutation.
func withEntityTypeHistoryID(id string) entitytypehistoryOption {
	return func(m *EntityTypeHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityTypeHistory
		)
		m.oldValue = func(ctx context.Context) (*EntityTypeHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityTypeHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityTypeHistory sets the old EntityTypeHistory of the mutation.
func withEntityTypeHistory(node *EntityTypeHistory) entitytypehistoryOption {
	return func(m *EntityTypeHistoryMutation) {
		m.oldValue = func(context.Context) (*EntityTypeHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityTypeHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityTypeHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityTypeHistory entities.
func (m *EntityTypeHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityTypeHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityTypeHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityTypeHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EntityTypeHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EntityTypeHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EntityTypeHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EntityTypeHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EntityTypeHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EntityTypeHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[entitytypehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EntityTypeHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, entitytypehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EntityTypeHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EntityTypeHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EntityTypeHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityTypeHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityTypeHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EntityTypeHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[entitytypehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityTypeHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, entitytypehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityTypeHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityTypeHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntityTypeHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitytypehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityTypeHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitytypehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EntityTypeHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EntityTypeHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EntityTypeHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[entitytypehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EntityTypeHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, entitytypehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EntityTypeHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EntityTypeHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EntityTypeHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[entitytypehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EntityTypeHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, entitytypehistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EntityTypeHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EntityTypeHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EntityTypeHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntityTypeHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntityTypeHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntityTypeHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entitytypehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntityTypeHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entitytypehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *EntityTypeHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *EntityTypeHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *EntityTypeHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[entitytypehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *EntityTypeHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, entitytypehistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *EntityTypeHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EntityTypeHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EntityTypeHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EntityTypeHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EntityTypeHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[entitytypehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EntityTypeHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, entitytypehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *EntityTypeHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *EntityTypeHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *EntityTypeHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[entitytypehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *EntityTypeHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[entitytypehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *EntityTypeHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, entitytypehistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *EntityTypeHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityTypeHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EntityTypeHistory entity.
// If the EntityTypeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityTypeHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntityTypeHistoryMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the EntityTypeHistoryMutation builder.
func (m *EntityTypeHistoryMutation) Where(ps ...predicate.EntityTypeHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityTypeHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityTypeHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EntityTypeHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityTypeHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityTypeHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EntityTypeHistory).
func (m *EntityTypeHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityTypeHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.history_time != nil {
		fields = append(fields, entitytypehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, entitytypehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, entitytypehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, entitytypehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitytypehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, entitytypehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, entitytypehistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, entitytypehistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, entitytypehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, entitytypehistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, entitytypehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, entitytypehistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, entitytypehistory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityTypeHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitytypehistory.FieldHistoryTime:
		return m.HistoryTime()
	case entitytypehistory.FieldRef:
		return m.Ref()
	case entitytypehistory.FieldOperation:
		return m.Operation()
	case entitytypehistory.FieldCreatedAt:
		return m.CreatedAt()
	case entitytypehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case entitytypehistory.FieldCreatedBy:
		return m.CreatedBy()
	case entitytypehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case entitytypehistory.FieldMappingID:
		return m.MappingID()
	case entitytypehistory.FieldDeletedAt:
		return m.DeletedAt()
	case entitytypehistory.FieldDeletedBy:
		return m.DeletedBy()
	case entitytypehistory.FieldTags:
		return m.Tags()
	case entitytypehistory.FieldOwnerID:
		return m.OwnerID()
	case entitytypehistory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityTypeHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitytypehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case entitytypehistory.FieldRef:
		return m.OldRef(ctx)
	case entitytypehistory.FieldOperation:
		return m.OldOperation(ctx)
	case entitytypehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitytypehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entitytypehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case entitytypehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case entitytypehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case entitytypehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entitytypehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case entitytypehistory.FieldTags:
		return m.OldTags(ctx)
	case entitytypehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case entitytypehistory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EntityTypeHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityTypeHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitytypehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case entitytypehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case entitytypehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case entitytypehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitytypehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entitytypehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case entitytypehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case entitytypehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case entitytypehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entitytypehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case entitytypehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case entitytypehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case entitytypehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EntityTypeHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityTypeHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityTypeHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityTypeHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntityTypeHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityTypeHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitytypehistory.FieldRef) {
		fields = append(fields, entitytypehistory.FieldRef)
	}
	if m.FieldCleared(entitytypehistory.FieldCreatedAt) {
		fields = append(fields, entitytypehistory.FieldCreatedAt)
	}
	if m.FieldCleared(entitytypehistory.FieldUpdatedAt) {
		fields = append(fields, entitytypehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(entitytypehistory.FieldCreatedBy) {
		fields = append(fields, entitytypehistory.FieldCreatedBy)
	}
	if m.FieldCleared(entitytypehistory.FieldUpdatedBy) {
		fields = append(fields, entitytypehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(entitytypehistory.FieldDeletedAt) {
		fields = append(fields, entitytypehistory.FieldDeletedAt)
	}
	if m.FieldCleared(entitytypehistory.FieldDeletedBy) {
		fields = append(fields, entitytypehistory.FieldDeletedBy)
	}
	if m.FieldCleared(entitytypehistory.FieldTags) {
		fields = append(fields, entitytypehistory.FieldTags)
	}
	if m.FieldCleared(entitytypehistory.FieldOwnerID) {
		fields = append(fields, entitytypehistory.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityTypeHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityTypeHistoryMutation) ClearField(name string) error {
	switch name {
	case entitytypehistory.FieldRef:
		m.ClearRef()
		return nil
	case entitytypehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case entitytypehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entitytypehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case entitytypehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case entitytypehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entitytypehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case entitytypehistory.FieldTags:
		m.ClearTags()
		return nil
	case entitytypehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown EntityTypeHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityTypeHistoryMutation) ResetField(name string) error {
	switch name {
	case entitytypehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case entitytypehistory.FieldRef:
		m.ResetRef()
		return nil
	case entitytypehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case entitytypehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitytypehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entitytypehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case entitytypehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case entitytypehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case entitytypehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entitytypehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case entitytypehistory.FieldTags:
		m.ResetTags()
		return nil
	case entitytypehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case entitytypehistory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EntityTypeHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityTypeHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityTypeHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityTypeHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityTypeHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityTypeHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityTypeHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityTypeHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EntityTypeHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityTypeHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EntityTypeHistory edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                            Op
	typ                           string
	id                            *string
	created_at                    *time.Time
	updated_at                    *time.Time
	created_by                    *string
	updated_by                    *string
	mapping_id                    *string
	tags                          *[]string
	appendtags                    []string
	event_id                      *string
	correlation_id                *string
	event_type                    *string
	metadata                      *map[string]interface{}
	clearedFields                 map[string]struct{}
	user                          map[string]struct{}
	removeduser                   map[string]struct{}
	cleareduser                   bool
	group                         map[string]struct{}
	removedgroup                  map[string]struct{}
	clearedgroup                  bool
	integration                   map[string]struct{}
	removedintegration            map[string]struct{}
	clearedintegration            bool
	organization                  map[string]struct{}
	removedorganization           map[string]struct{}
	clearedorganization           bool
	invite                        map[string]struct{}
	removedinvite                 map[string]struct{}
	clearedinvite                 bool
	feature                       map[string]struct{}
	removedfeature                map[string]struct{}
	clearedfeature                bool
	entitlementplan               map[string]struct{}
	removedentitlementplan        map[string]struct{}
	clearedentitlementplan        bool
	entitlementplanfeature        map[string]struct{}
	removedentitlementplanfeature map[string]struct{}
	clearedentitlementplanfeature bool
	personal_access_token         map[string]struct{}
	removedpersonal_access_token  map[string]struct{}
	clearedpersonal_access_token  bool
	oauth2token                   map[string]struct{}
	removedoauth2token            map[string]struct{}
	clearedoauth2token            bool
	hush                          map[string]struct{}
	removedhush                   map[string]struct{}
	clearedhush                   bool
	orgmembership                 map[string]struct{}
	removedorgmembership          map[string]struct{}
	clearedorgmembership          bool
	groupmembership               map[string]struct{}
	removedgroupmembership        map[string]struct{}
	clearedgroupmembership        bool
	entitlement                   map[string]struct{}
	removedentitlement            map[string]struct{}
	clearedentitlement            bool
	webhook                       map[string]struct{}
	removedwebhook                map[string]struct{}
	clearedwebhook                bool
	subscriber                    map[string]struct{}
	removedsubscriber             map[string]struct{}
	clearedsubscriber             bool
	file                          map[string]struct{}
	removedfile                   map[string]struct{}
	clearedfile                   bool
	done                          bool
	oldValue                      func(context.Context) (*Event, error)
	predicates                    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id string) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EventMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[event.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EventMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, event.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EventMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[event.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EventMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, event.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EventMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EventMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EventMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[event.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EventMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[event.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EventMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, event.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EventMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EventMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EventMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[event.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EventMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[event.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EventMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, event.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EventMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EventMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EventMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *EventMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EventMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EventMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EventMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EventMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[event.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EventMutation) TagsCleared() bool {
	_, ok := m.clearedFields[event.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EventMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, event.FieldTags)
}

// SetEventID sets the "event_id" field.
func (m *EventMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ClearEventID clears the value of the "event_id" field.
func (m *EventMutation) ClearEventID() {
	m.event_id = nil
	m.clearedFields[event.FieldEventID] = struct{}{}
}

// EventIDCleared returns if the "event_id" field was cleared in this mutation.
func (m *EventMutation) EventIDCleared() bool {
	_, ok := m.clearedFields[event.FieldEventID]
	return ok
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventMutation) ResetEventID() {
	m.event_id = nil
	delete(m.clearedFields, event.FieldEventID)
}

// SetCorrelationID sets the "correlation_id" field.
func (m *EventMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *EventMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCorrelationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *EventMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[event.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *EventMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[event.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *EventMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, event.FieldCorrelationID)
}

// SetEventType sets the "event_type" field.
func (m *EventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *EventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *EventMutation) ResetEventType() {
	m.event_type = nil
}

// SetMetadata sets the "metadata" field.
func (m *EventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[event.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[event.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, event.FieldMetadata)
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *EventMutation) AddUserIDs(ids ...string) {
	if m.user == nil {
		m.user = make(map[string]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *EventMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EventMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *EventMutation) RemoveUserIDs(ids ...string) {
	if m.removeduser == nil {
		m.removeduser = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *EventMutation) RemovedUserIDs() (ids []string) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *EventMutation) UserIDs() (ids []string) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddGroupIDs adds the "group" edge to the Group entity by ids.
func (m *EventMutation) AddGroupIDs(ids ...string) {
	if m.group == nil {
		m.group = make(map[string]struct{})
	}
	for i := range ids {
		m.group[ids[i]] = struct{}{}
	}
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *EventMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *EventMutation) GroupCleared() bool {
	return m.clearedgroup
}

// RemoveGroupIDs removes the "group" edge to the Group entity by IDs.
func (m *EventMutation) RemoveGroupIDs(ids ...string) {
	if m.removedgroup == nil {
		m.removedgroup = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.group, ids[i])
		m.removedgroup[ids[i]] = struct{}{}
	}
}

// RemovedGroup returns the removed IDs of the "group" edge to the Group entity.
func (m *EventMutation) RemovedGroupIDs() (ids []string) {
	for id := range m.removedgroup {
		ids = append(ids, id)
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
func (m *EventMutation) GroupIDs() (ids []string) {
	for id := range m.group {
		ids = append(ids, id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *EventMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
	m.removedgroup = nil
}

// AddIntegrationIDs adds the "integration" edge to the Integration entity by ids.
func (m *EventMutation) AddIntegrationIDs(ids ...string) {
	if m.integration == nil {
		m.integration = make(map[string]struct{})
	}
	for i := range ids {
		m.integration[ids[i]] = struct{}{}
	}
}

// ClearIntegration clears the "integration" edge to the Integration entity.
func (m *EventMutation) ClearIntegration() {
	m.clearedintegration = true
}

// IntegrationCleared reports if the "integration" edge to the Integration entity was cleared.
func (m *EventMutation) IntegrationCleared() bool {
	return m.clearedintegration
}

// RemoveIntegrationIDs removes the "integration" edge to the Integration entity by IDs.
func (m *EventMutation) RemoveIntegrationIDs(ids ...string) {
	if m.removedintegration == nil {
		m.removedintegration = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.integration, ids[i])
		m.removedintegration[ids[i]] = struct{}{}
	}
}

// RemovedIntegration returns the removed IDs of the "integration" edge to the Integration entity.
func (m *EventMutation) RemovedIntegrationIDs() (ids []string) {
	for id := range m.removedintegration {
		ids = append(ids, id)
	}
	return
}

// IntegrationIDs returns the "integration" edge IDs in the mutation.
func (m *EventMutation) IntegrationIDs() (ids []string) {
	for id := range m.integration {
		ids = append(ids, id)
	}
	return
}

// ResetIntegration resets all changes to the "integration" edge.
func (m *EventMutation) ResetIntegration() {
	m.integration = nil
	m.clearedintegration = false
	m.removedintegration = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *EventMutation) AddOrganizationIDs(ids ...string) {
	if m.organization == nil {
		m.organization = make(map[string]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EventMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EventMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *EventMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organization, ids[i])
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *EventMutation) RemovedOrganizationIDs() (ids []string) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *EventMutation) OrganizationIDs() (ids []string) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EventMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// AddInviteIDs adds the "invite" edge to the Invite entity by ids.
func (m *EventMutation) AddInviteIDs(ids ...string) {
	if m.invite == nil {
		m.invite = make(map[string]struct{})
	}
	for i := range ids {
		m.invite[ids[i]] = struct{}{}
	}
}

// ClearInvite clears the "invite" edge to the Invite entity.
func (m *EventMutation) ClearInvite() {
	m.clearedinvite = true
}

// InviteCleared reports if the "invite" edge to the Invite entity was cleared.
func (m *EventMutation) InviteCleared() bool {
	return m.clearedinvite
}

// RemoveInviteIDs removes the "invite" edge to the Invite entity by IDs.
func (m *EventMutation) RemoveInviteIDs(ids ...string) {
	if m.removedinvite == nil {
		m.removedinvite = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.invite, ids[i])
		m.removedinvite[ids[i]] = struct{}{}
	}
}

// RemovedInvite returns the removed IDs of the "invite" edge to the Invite entity.
func (m *EventMutation) RemovedInviteIDs() (ids []string) {
	for id := range m.removedinvite {
		ids = append(ids, id)
	}
	return
}

// InviteIDs returns the "invite" edge IDs in the mutation.
func (m *EventMutation) InviteIDs() (ids []string) {
	for id := range m.invite {
		ids = append(ids, id)
	}
	return
}

// ResetInvite resets all changes to the "invite" edge.
func (m *EventMutation) ResetInvite() {
	m.invite = nil
	m.clearedinvite = false
	m.removedinvite = nil
}

// AddFeatureIDs adds the "feature" edge to the Feature entity by ids.
func (m *EventMutation) AddFeatureIDs(ids ...string) {
	if m.feature == nil {
		m.feature = make(map[string]struct{})
	}
	for i := range ids {
		m.feature[ids[i]] = struct{}{}
	}
}

// ClearFeature clears the "feature" edge to the Feature entity.
func (m *EventMutation) ClearFeature() {
	m.clearedfeature = true
}

// FeatureCleared reports if the "feature" edge to the Feature entity was cleared.
func (m *EventMutation) FeatureCleared() bool {
	return m.clearedfeature
}

// RemoveFeatureIDs removes the "feature" edge to the Feature entity by IDs.
func (m *EventMutation) RemoveFeatureIDs(ids ...string) {
	if m.removedfeature == nil {
		m.removedfeature = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.feature, ids[i])
		m.removedfeature[ids[i]] = struct{}{}
	}
}

// RemovedFeature returns the removed IDs of the "feature" edge to the Feature entity.
func (m *EventMutation) RemovedFeatureIDs() (ids []string) {
	for id := range m.removedfeature {
		ids = append(ids, id)
	}
	return
}

// FeatureIDs returns the "feature" edge IDs in the mutation.
func (m *EventMutation) FeatureIDs() (ids []string) {
	for id := range m.feature {
		ids = append(ids, id)
	}
	return
}

// ResetFeature resets all changes to the "feature" edge.
func (m *EventMutation) ResetFeature() {
	m.feature = nil
	m.clearedfeature = false
	m.removedfeature = nil
}

// AddEntitlementplanIDs adds the "entitlementplan" edge to the EntitlementPlan entity by ids.
func (m *EventMutation) AddEntitlementplanIDs(ids ...string) {
	if m.entitlementplan == nil {
		m.entitlementplan = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlementplan[ids[i]] = struct{}{}
	}
}

// ClearEntitlementplan clears the "entitlementplan" edge to the EntitlementPlan entity.
func (m *EventMutation) ClearEntitlementplan() {
	m.clearedentitlementplan = true
}

// EntitlementplanCleared reports if the "entitlementplan" edge to the EntitlementPlan entity was cleared.
func (m *EventMutation) EntitlementplanCleared() bool {
	return m.clearedentitlementplan
}

// RemoveEntitlementplanIDs removes the "entitlementplan" edge to the EntitlementPlan entity by IDs.
func (m *EventMutation) RemoveEntitlementplanIDs(ids ...string) {
	if m.removedentitlementplan == nil {
		m.removedentitlementplan = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlementplan, ids[i])
		m.removedentitlementplan[ids[i]] = struct{}{}
	}
}

// RemovedEntitlementplan returns the removed IDs of the "entitlementplan" edge to the EntitlementPlan entity.
func (m *EventMutation) RemovedEntitlementplanIDs() (ids []string) {
	for id := range m.removedentitlementplan {
		ids = append(ids, id)
	}
	return
}

// EntitlementplanIDs returns the "entitlementplan" edge IDs in the mutation.
func (m *EventMutation) EntitlementplanIDs() (ids []string) {
	for id := range m.entitlementplan {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlementplan resets all changes to the "entitlementplan" edge.
func (m *EventMutation) ResetEntitlementplan() {
	m.entitlementplan = nil
	m.clearedentitlementplan = false
	m.removedentitlementplan = nil
}

// AddEntitlementplanfeatureIDs adds the "entitlementplanfeature" edge to the EntitlementPlanFeature entity by ids.
func (m *EventMutation) AddEntitlementplanfeatureIDs(ids ...string) {
	if m.entitlementplanfeature == nil {
		m.entitlementplanfeature = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlementplanfeature[ids[i]] = struct{}{}
	}
}

// ClearEntitlementplanfeature clears the "entitlementplanfeature" edge to the EntitlementPlanFeature entity.
func (m *EventMutation) ClearEntitlementplanfeature() {
	m.clearedentitlementplanfeature = true
}

// EntitlementplanfeatureCleared reports if the "entitlementplanfeature" edge to the EntitlementPlanFeature entity was cleared.
func (m *EventMutation) EntitlementplanfeatureCleared() bool {
	return m.clearedentitlementplanfeature
}

// RemoveEntitlementplanfeatureIDs removes the "entitlementplanfeature" edge to the EntitlementPlanFeature entity by IDs.
func (m *EventMutation) RemoveEntitlementplanfeatureIDs(ids ...string) {
	if m.removedentitlementplanfeature == nil {
		m.removedentitlementplanfeature = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlementplanfeature, ids[i])
		m.removedentitlementplanfeature[ids[i]] = struct{}{}
	}
}

// RemovedEntitlementplanfeature returns the removed IDs of the "entitlementplanfeature" edge to the EntitlementPlanFeature entity.
func (m *EventMutation) RemovedEntitlementplanfeatureIDs() (ids []string) {
	for id := range m.removedentitlementplanfeature {
		ids = append(ids, id)
	}
	return
}

// EntitlementplanfeatureIDs returns the "entitlementplanfeature" edge IDs in the mutation.
func (m *EventMutation) EntitlementplanfeatureIDs() (ids []string) {
	for id := range m.entitlementplanfeature {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlementplanfeature resets all changes to the "entitlementplanfeature" edge.
func (m *EventMutation) ResetEntitlementplanfeature() {
	m.entitlementplanfeature = nil
	m.clearedentitlementplanfeature = false
	m.removedentitlementplanfeature = nil
}

// AddPersonalAccessTokenIDs adds the "personal_access_token" edge to the PersonalAccessToken entity by ids.
func (m *EventMutation) AddPersonalAccessTokenIDs(ids ...string) {
	if m.personal_access_token == nil {
		m.personal_access_token = make(map[string]struct{})
	}
	for i := range ids {
		m.personal_access_token[ids[i]] = struct{}{}
	}
}

// ClearPersonalAccessToken clears the "personal_access_token" edge to the PersonalAccessToken entity.
func (m *EventMutation) ClearPersonalAccessToken() {
	m.clearedpersonal_access_token = true
}

// PersonalAccessTokenCleared reports if the "personal_access_token" edge to the PersonalAccessToken entity was cleared.
func (m *EventMutation) PersonalAccessTokenCleared() bool {
	return m.clearedpersonal_access_token
}

// RemovePersonalAccessTokenIDs removes the "personal_access_token" edge to the PersonalAccessToken entity by IDs.
func (m *EventMutation) RemovePersonalAccessTokenIDs(ids ...string) {
	if m.removedpersonal_access_token == nil {
		m.removedpersonal_access_token = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.personal_access_token, ids[i])
		m.removedpersonal_access_token[ids[i]] = struct{}{}
	}
}

// RemovedPersonalAccessToken returns the removed IDs of the "personal_access_token" edge to the PersonalAccessToken entity.
func (m *EventMutation) RemovedPersonalAccessTokenIDs() (ids []string) {
	for id := range m.removedpersonal_access_token {
		ids = append(ids, id)
	}
	return
}

// PersonalAccessTokenIDs returns the "personal_access_token" edge IDs in the mutation.
func (m *EventMutation) PersonalAccessTokenIDs() (ids []string) {
	for id := range m.personal_access_token {
		ids = append(ids, id)
	}
	return
}

// ResetPersonalAccessToken resets all changes to the "personal_access_token" edge.
func (m *EventMutation) ResetPersonalAccessToken() {
	m.personal_access_token = nil
	m.clearedpersonal_access_token = false
	m.removedpersonal_access_token = nil
}

// AddOauth2tokenIDs adds the "oauth2token" edge to the OhAuthTooToken entity by ids.
func (m *EventMutation) AddOauth2tokenIDs(ids ...string) {
	if m.oauth2token == nil {
		m.oauth2token = make(map[string]struct{})
	}
	for i := range ids {
		m.oauth2token[ids[i]] = struct{}{}
	}
}

// ClearOauth2token clears the "oauth2token" edge to the OhAuthTooToken entity.
func (m *EventMutation) ClearOauth2token() {
	m.clearedoauth2token = true
}

// Oauth2tokenCleared reports if the "oauth2token" edge to the OhAuthTooToken entity was cleared.
func (m *EventMutation) Oauth2tokenCleared() bool {
	return m.clearedoauth2token
}

// RemoveOauth2tokenIDs removes the "oauth2token" edge to the OhAuthTooToken entity by IDs.
func (m *EventMutation) RemoveOauth2tokenIDs(ids ...string) {
	if m.removedoauth2token == nil {
		m.removedoauth2token = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.oauth2token, ids[i])
		m.removedoauth2token[ids[i]] = struct{}{}
	}
}

// RemovedOauth2token returns the removed IDs of the "oauth2token" edge to the OhAuthTooToken entity.
func (m *EventMutation) RemovedOauth2tokenIDs() (ids []string) {
	for id := range m.removedoauth2token {
		ids = append(ids, id)
	}
	return
}

// Oauth2tokenIDs returns the "oauth2token" edge IDs in the mutation.
func (m *EventMutation) Oauth2tokenIDs() (ids []string) {
	for id := range m.oauth2token {
		ids = append(ids, id)
	}
	return
}

// ResetOauth2token resets all changes to the "oauth2token" edge.
func (m *EventMutation) ResetOauth2token() {
	m.oauth2token = nil
	m.clearedoauth2token = false
	m.removedoauth2token = nil
}

// AddHushIDs adds the "hush" edge to the Hush entity by ids.
func (m *EventMutation) AddHushIDs(ids ...string) {
	if m.hush == nil {
		m.hush = make(map[string]struct{})
	}
	for i := range ids {
		m.hush[ids[i]] = struct{}{}
	}
}

// ClearHush clears the "hush" edge to the Hush entity.
func (m *EventMutation) ClearHush() {
	m.clearedhush = true
}

// HushCleared reports if the "hush" edge to the Hush entity was cleared.
func (m *EventMutation) HushCleared() bool {
	return m.clearedhush
}

// RemoveHushIDs removes the "hush" edge to the Hush entity by IDs.
func (m *EventMutation) RemoveHushIDs(ids ...string) {
	if m.removedhush == nil {
		m.removedhush = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hush, ids[i])
		m.removedhush[ids[i]] = struct{}{}
	}
}

// RemovedHush returns the removed IDs of the "hush" edge to the Hush entity.
func (m *EventMutation) RemovedHushIDs() (ids []string) {
	for id := range m.removedhush {
		ids = append(ids, id)
	}
	return
}

// HushIDs returns the "hush" edge IDs in the mutation.
func (m *EventMutation) HushIDs() (ids []string) {
	for id := range m.hush {
		ids = append(ids, id)
	}
	return
}

// ResetHush resets all changes to the "hush" edge.
func (m *EventMutation) ResetHush() {
	m.hush = nil
	m.clearedhush = false
	m.removedhush = nil
}

// AddOrgmembershipIDs adds the "orgmembership" edge to the OrgMembership entity by ids.
func (m *EventMutation) AddOrgmembershipIDs(ids ...string) {
	if m.orgmembership == nil {
		m.orgmembership = make(map[string]struct{})
	}
	for i := range ids {
		m.orgmembership[ids[i]] = struct{}{}
	}
}

// ClearOrgmembership clears the "orgmembership" edge to the OrgMembership entity.
func (m *EventMutation) ClearOrgmembership() {
	m.clearedorgmembership = true
}

// OrgmembershipCleared reports if the "orgmembership" edge to the OrgMembership entity was cleared.
func (m *EventMutation) OrgmembershipCleared() bool {
	return m.clearedorgmembership
}

// RemoveOrgmembershipIDs removes the "orgmembership" edge to the OrgMembership entity by IDs.
func (m *EventMutation) RemoveOrgmembershipIDs(ids ...string) {
	if m.removedorgmembership == nil {
		m.removedorgmembership = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.orgmembership, ids[i])
		m.removedorgmembership[ids[i]] = struct{}{}
	}
}

// RemovedOrgmembership returns the removed IDs of the "orgmembership" edge to the OrgMembership entity.
func (m *EventMutation) RemovedOrgmembershipIDs() (ids []string) {
	for id := range m.removedorgmembership {
		ids = append(ids, id)
	}
	return
}

// OrgmembershipIDs returns the "orgmembership" edge IDs in the mutation.
func (m *EventMutation) OrgmembershipIDs() (ids []string) {
	for id := range m.orgmembership {
		ids = append(ids, id)
	}
	return
}

// ResetOrgmembership resets all changes to the "orgmembership" edge.
func (m *EventMutation) ResetOrgmembership() {
	m.orgmembership = nil
	m.clearedorgmembership = false
	m.removedorgmembership = nil
}

// AddGroupmembershipIDs adds the "groupmembership" edge to the GroupMembership entity by ids.
func (m *EventMutation) AddGroupmembershipIDs(ids ...string) {
	if m.groupmembership == nil {
		m.groupmembership = make(map[string]struct{})
	}
	for i := range ids {
		m.groupmembership[ids[i]] = struct{}{}
	}
}

// ClearGroupmembership clears the "groupmembership" edge to the GroupMembership entity.
func (m *EventMutation) ClearGroupmembership() {
	m.clearedgroupmembership = true
}

// GroupmembershipCleared reports if the "groupmembership" edge to the GroupMembership entity was cleared.
func (m *EventMutation) GroupmembershipCleared() bool {
	return m.clearedgroupmembership
}

// RemoveGroupmembershipIDs removes the "groupmembership" edge to the GroupMembership entity by IDs.
func (m *EventMutation) RemoveGroupmembershipIDs(ids ...string) {
	if m.removedgroupmembership == nil {
		m.removedgroupmembership = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.groupmembership, ids[i])
		m.removedgroupmembership[ids[i]] = struct{}{}
	}
}

// RemovedGroupmembership returns the removed IDs of the "groupmembership" edge to the GroupMembership entity.
func (m *EventMutation) RemovedGroupmembershipIDs() (ids []string) {
	for id := range m.removedgroupmembership {
		ids = append(ids, id)
	}
	return
}

// GroupmembershipIDs returns the "groupmembership" edge IDs in the mutation.
func (m *EventMutation) GroupmembershipIDs() (ids []string) {
	for id := range m.groupmembership {
		ids = append(ids, id)
	}
	return
}

// ResetGroupmembership resets all changes to the "groupmembership" edge.
func (m *EventMutation) ResetGroupmembership() {
	m.groupmembership = nil
	m.clearedgroupmembership = false
	m.removedgroupmembership = nil
}

// AddEntitlementIDs adds the "entitlement" edge to the Entitlement entity by ids.
func (m *EventMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlement == nil {
		m.entitlement = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlement[ids[i]] = struct{}{}
	}
}

// ClearEntitlement clears the "entitlement" edge to the Entitlement entity.
func (m *EventMutation) ClearEntitlement() {
	m.clearedentitlement = true
}

// EntitlementCleared reports if the "entitlement" edge to the Entitlement entity was cleared.
func (m *EventMutation) EntitlementCleared() bool {
	return m.clearedentitlement
}

// RemoveEntitlementIDs removes the "entitlement" edge to the Entitlement entity by IDs.
func (m *EventMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlement == nil {
		m.removedentitlement = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlement, ids[i])
		m.removedentitlement[ids[i]] = struct{}{}
	}
}

// RemovedEntitlement returns the removed IDs of the "entitlement" edge to the Entitlement entity.
func (m *EventMutation) RemovedEntitlementIDs() (ids []string) {
	for id := range m.removedentitlement {
		ids = append(ids, id)
	}
	return
}

// EntitlementIDs returns the "entitlement" edge IDs in the mutation.
func (m *EventMutation) EntitlementIDs() (ids []string) {
	for id := range m.entitlement {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlement resets all changes to the "entitlement" edge.
func (m *EventMutation) ResetEntitlement() {
	m.entitlement = nil
	m.clearedentitlement = false
	m.removedentitlement = nil
}

// AddWebhookIDs adds the "webhook" edge to the Webhook entity by ids.
func (m *EventMutation) AddWebhookIDs(ids ...string) {
	if m.webhook == nil {
		m.webhook = make(map[string]struct{})
	}
	for i := range ids {
		m.webhook[ids[i]] = struct{}{}
	}
}

// ClearWebhook clears the "webhook" edge to the Webhook entity.
func (m *EventMutation) ClearWebhook() {
	m.clearedwebhook = true
}

// WebhookCleared reports if the "webhook" edge to the Webhook entity was cleared.
func (m *EventMutation) WebhookCleared() bool {
	return m.clearedwebhook
}

// RemoveWebhookIDs removes the "webhook" edge to the Webhook entity by IDs.
func (m *EventMutation) RemoveWebhookIDs(ids ...string) {
	if m.removedwebhook == nil {
		m.removedwebhook = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.webhook, ids[i])
		m.removedwebhook[ids[i]] = struct{}{}
	}
}

// RemovedWebhook returns the removed IDs of the "webhook" edge to the Webhook entity.
func (m *EventMutation) RemovedWebhookIDs() (ids []string) {
	for id := range m.removedwebhook {
		ids = append(ids, id)
	}
	return
}

// WebhookIDs returns the "webhook" edge IDs in the mutation.
func (m *EventMutation) WebhookIDs() (ids []string) {
	for id := range m.webhook {
		ids = append(ids, id)
	}
	return
}

// ResetWebhook resets all changes to the "webhook" edge.
func (m *EventMutation) ResetWebhook() {
	m.webhook = nil
	m.clearedwebhook = false
	m.removedwebhook = nil
}

// AddSubscriberIDs adds the "subscriber" edge to the Subscriber entity by ids.
func (m *EventMutation) AddSubscriberIDs(ids ...string) {
	if m.subscriber == nil {
		m.subscriber = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriber[ids[i]] = struct{}{}
	}
}

// ClearSubscriber clears the "subscriber" edge to the Subscriber entity.
func (m *EventMutation) ClearSubscriber() {
	m.clearedsubscriber = true
}

// SubscriberCleared reports if the "subscriber" edge to the Subscriber entity was cleared.
func (m *EventMutation) SubscriberCleared() bool {
	return m.clearedsubscriber
}

// RemoveSubscriberIDs removes the "subscriber" edge to the Subscriber entity by IDs.
func (m *EventMutation) RemoveSubscriberIDs(ids ...string) {
	if m.removedsubscriber == nil {
		m.removedsubscriber = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriber, ids[i])
		m.removedsubscriber[ids[i]] = struct{}{}
	}
}

// RemovedSubscriber returns the removed IDs of the "subscriber" edge to the Subscriber entity.
func (m *EventMutation) RemovedSubscriberIDs() (ids []string) {
	for id := range m.removedsubscriber {
		ids = append(ids, id)
	}
	return
}

// SubscriberIDs returns the "subscriber" edge IDs in the mutation.
func (m *EventMutation) SubscriberIDs() (ids []string) {
	for id := range m.subscriber {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriber resets all changes to the "subscriber" edge.
func (m *EventMutation) ResetSubscriber() {
	m.subscriber = nil
	m.clearedsubscriber = false
	m.removedsubscriber = nil
}

// AddFileIDs adds the "file" edge to the File entity by ids.
func (m *EventMutation) AddFileIDs(ids ...string) {
	if m.file == nil {
		m.file = make(map[string]struct{})
	}
	for i := range ids {
		m.file[ids[i]] = struct{}{}
	}
}

// ClearFile clears the "file" edge to the File entity.
func (m *EventMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *EventMutation) FileCleared() bool {
	return m.clearedfile
}

// RemoveFileIDs removes the "file" edge to the File entity by IDs.
func (m *EventMutation) RemoveFileIDs(ids ...string) {
	if m.removedfile == nil {
		m.removedfile = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.file, ids[i])
		m.removedfile[ids[i]] = struct{}{}
	}
}

// RemovedFile returns the removed IDs of the "file" edge to the File entity.
func (m *EventMutation) RemovedFileIDs() (ids []string) {
	for id := range m.removedfile {
		ids = append(ids, id)
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
func (m *EventMutation) FileIDs() (ids []string) {
	for id := range m.file {
		ids = append(ids, id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *EventMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
	m.removedfile = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, event.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, event.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, event.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, event.FieldTags)
	}
	if m.event_id != nil {
		fields = append(fields, event.FieldEventID)
	}
	if m.correlation_id != nil {
		fields = append(fields, event.FieldCorrelationID)
	}
	if m.event_type != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.metadata != nil {
		fields = append(fields, event.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldCreatedBy:
		return m.CreatedBy()
	case event.FieldUpdatedBy:
		return m.UpdatedBy()
	case event.FieldMappingID:
		return m.MappingID()
	case event.FieldTags:
		return m.Tags()
	case event.FieldEventID:
		return m.EventID()
	case event.FieldCorrelationID:
		return m.CorrelationID()
	case event.FieldEventType:
		return m.EventType()
	case event.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case event.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case event.FieldMappingID:
		return m.OldMappingID(ctx)
	case event.FieldTags:
		return m.OldTags(ctx)
	case event.FieldEventID:
		return m.OldEventID(ctx)
	case event.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case event.FieldEventType:
		return m.OldEventType(ctx)
	case event.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case event.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case event.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case event.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case event.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case event.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case event.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case event.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldCreatedAt) {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.FieldCleared(event.FieldUpdatedAt) {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.FieldCleared(event.FieldCreatedBy) {
		fields = append(fields, event.FieldCreatedBy)
	}
	if m.FieldCleared(event.FieldUpdatedBy) {
		fields = append(fields, event.FieldUpdatedBy)
	}
	if m.FieldCleared(event.FieldTags) {
		fields = append(fields, event.FieldTags)
	}
	if m.FieldCleared(event.FieldEventID) {
		fields = append(fields, event.FieldEventID)
	}
	if m.FieldCleared(event.FieldCorrelationID) {
		fields = append(fields, event.FieldCorrelationID)
	}
	if m.FieldCleared(event.FieldMetadata) {
		fields = append(fields, event.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case event.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case event.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case event.FieldTags:
		m.ClearTags()
		return nil
	case event.FieldEventID:
		m.ClearEventID()
		return nil
	case event.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case event.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case event.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case event.FieldMappingID:
		m.ResetMappingID()
		return nil
	case event.FieldTags:
		m.ResetTags()
		return nil
	case event.FieldEventID:
		m.ResetEventID()
		return nil
	case event.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case event.FieldEventType:
		m.ResetEventType()
		return nil
	case event.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.user != nil {
		edges = append(edges, event.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, event.EdgeGroup)
	}
	if m.integration != nil {
		edges = append(edges, event.EdgeIntegration)
	}
	if m.organization != nil {
		edges = append(edges, event.EdgeOrganization)
	}
	if m.invite != nil {
		edges = append(edges, event.EdgeInvite)
	}
	if m.feature != nil {
		edges = append(edges, event.EdgeFeature)
	}
	if m.entitlementplan != nil {
		edges = append(edges, event.EdgeEntitlementplan)
	}
	if m.entitlementplanfeature != nil {
		edges = append(edges, event.EdgeEntitlementplanfeature)
	}
	if m.personal_access_token != nil {
		edges = append(edges, event.EdgePersonalAccessToken)
	}
	if m.oauth2token != nil {
		edges = append(edges, event.EdgeOauth2token)
	}
	if m.hush != nil {
		edges = append(edges, event.EdgeHush)
	}
	if m.orgmembership != nil {
		edges = append(edges, event.EdgeOrgmembership)
	}
	if m.groupmembership != nil {
		edges = append(edges, event.EdgeGroupmembership)
	}
	if m.entitlement != nil {
		edges = append(edges, event.EdgeEntitlement)
	}
	if m.webhook != nil {
		edges = append(edges, event.EdgeWebhook)
	}
	if m.subscriber != nil {
		edges = append(edges, event.EdgeSubscriber)
	}
	if m.file != nil {
		edges = append(edges, event.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.group))
		for id := range m.group {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeIntegration:
		ids := make([]ent.Value, 0, len(m.integration))
		for id := range m.integration {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeInvite:
		ids := make([]ent.Value, 0, len(m.invite))
		for id := range m.invite {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeFeature:
		ids := make([]ent.Value, 0, len(m.feature))
		for id := range m.feature {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEntitlementplan:
		ids := make([]ent.Value, 0, len(m.entitlementplan))
		for id := range m.entitlementplan {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEntitlementplanfeature:
		ids := make([]ent.Value, 0, len(m.entitlementplanfeature))
		for id := range m.entitlementplanfeature {
			ids = append(ids, id)
		}
		return ids
	case event.EdgePersonalAccessToken:
		ids := make([]ent.Value, 0, len(m.personal_access_token))
		for id := range m.personal_access_token {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeOauth2token:
		ids := make([]ent.Value, 0, len(m.oauth2token))
		for id := range m.oauth2token {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeHush:
		ids := make([]ent.Value, 0, len(m.hush))
		for id := range m.hush {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeOrgmembership:
		ids := make([]ent.Value, 0, len(m.orgmembership))
		for id := range m.orgmembership {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeGroupmembership:
		ids := make([]ent.Value, 0, len(m.groupmembership))
		for id := range m.groupmembership {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.entitlement))
		for id := range m.entitlement {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeWebhook:
		ids := make([]ent.Value, 0, len(m.webhook))
		for id := range m.webhook {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeSubscriber:
		ids := make([]ent.Value, 0, len(m.subscriber))
		for id := range m.subscriber {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeFile:
		ids := make([]ent.Value, 0, len(m.file))
		for id := range m.file {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removeduser != nil {
		edges = append(edges, event.EdgeUser)
	}
	if m.removedgroup != nil {
		edges = append(edges, event.EdgeGroup)
	}
	if m.removedintegration != nil {
		edges = append(edges, event.EdgeIntegration)
	}
	if m.removedorganization != nil {
		edges = append(edges, event.EdgeOrganization)
	}
	if m.removedinvite != nil {
		edges = append(edges, event.EdgeInvite)
	}
	if m.removedfeature != nil {
		edges = append(edges, event.EdgeFeature)
	}
	if m.removedentitlementplan != nil {
		edges = append(edges, event.EdgeEntitlementplan)
	}
	if m.removedentitlementplanfeature != nil {
		edges = append(edges, event.EdgeEntitlementplanfeature)
	}
	if m.removedpersonal_access_token != nil {
		edges = append(edges, event.EdgePersonalAccessToken)
	}
	if m.removedoauth2token != nil {
		edges = append(edges, event.EdgeOauth2token)
	}
	if m.removedhush != nil {
		edges = append(edges, event.EdgeHush)
	}
	if m.removedorgmembership != nil {
		edges = append(edges, event.EdgeOrgmembership)
	}
	if m.removedgroupmembership != nil {
		edges = append(edges, event.EdgeGroupmembership)
	}
	if m.removedentitlement != nil {
		edges = append(edges, event.EdgeEntitlement)
	}
	if m.removedwebhook != nil {
		edges = append(edges, event.EdgeWebhook)
	}
	if m.removedsubscriber != nil {
		edges = append(edges, event.EdgeSubscriber)
	}
	if m.removedfile != nil {
		edges = append(edges, event.EdgeFile)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.removedgroup))
		for id := range m.removedgroup {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeIntegration:
		ids := make([]ent.Value, 0, len(m.removedintegration))
		for id := range m.removedintegration {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeInvite:
		ids := make([]ent.Value, 0, len(m.removedinvite))
		for id := range m.removedinvite {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeFeature:
		ids := make([]ent.Value, 0, len(m.removedfeature))
		for id := range m.removedfeature {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEntitlementplan:
		ids := make([]ent.Value, 0, len(m.removedentitlementplan))
		for id := range m.removedentitlementplan {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEntitlementplanfeature:
		ids := make([]ent.Value, 0, len(m.removedentitlementplanfeature))
		for id := range m.removedentitlementplanfeature {
			ids = append(ids, id)
		}
		return ids
	case event.EdgePersonalAccessToken:
		ids := make([]ent.Value, 0, len(m.removedpersonal_access_token))
		for id := range m.removedpersonal_access_token {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeOauth2token:
		ids := make([]ent.Value, 0, len(m.removedoauth2token))
		for id := range m.removedoauth2token {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeHush:
		ids := make([]ent.Value, 0, len(m.removedhush))
		for id := range m.removedhush {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeOrgmembership:
		ids := make([]ent.Value, 0, len(m.removedorgmembership))
		for id := range m.removedorgmembership {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeGroupmembership:
		ids := make([]ent.Value, 0, len(m.removedgroupmembership))
		for id := range m.removedgroupmembership {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeEntitlement:
		ids := make([]ent.Value, 0, len(m.removedentitlement))
		for id := range m.removedentitlement {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeWebhook:
		ids := make([]ent.Value, 0, len(m.removedwebhook))
		for id := range m.removedwebhook {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeSubscriber:
		ids := make([]ent.Value, 0, len(m.removedsubscriber))
		for id := range m.removedsubscriber {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeFile:
		ids := make([]ent.Value, 0, len(m.removedfile))
		for id := range m.removedfile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.cleareduser {
		edges = append(edges, event.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, event.EdgeGroup)
	}
	if m.clearedintegration {
		edges = append(edges, event.EdgeIntegration)
	}
	if m.clearedorganization {
		edges = append(edges, event.EdgeOrganization)
	}
	if m.clearedinvite {
		edges = append(edges, event.EdgeInvite)
	}
	if m.clearedfeature {
		edges = append(edges, event.EdgeFeature)
	}
	if m.clearedentitlementplan {
		edges = append(edges, event.EdgeEntitlementplan)
	}
	if m.clearedentitlementplanfeature {
		edges = append(edges, event.EdgeEntitlementplanfeature)
	}
	if m.clearedpersonal_access_token {
		edges = append(edges, event.EdgePersonalAccessToken)
	}
	if m.clearedoauth2token {
		edges = append(edges, event.EdgeOauth2token)
	}
	if m.clearedhush {
		edges = append(edges, event.EdgeHush)
	}
	if m.clearedorgmembership {
		edges = append(edges, event.EdgeOrgmembership)
	}
	if m.clearedgroupmembership {
		edges = append(edges, event.EdgeGroupmembership)
	}
	if m.clearedentitlement {
		edges = append(edges, event.EdgeEntitlement)
	}
	if m.clearedwebhook {
		edges = append(edges, event.EdgeWebhook)
	}
	if m.clearedsubscriber {
		edges = append(edges, event.EdgeSubscriber)
	}
	if m.clearedfile {
		edges = append(edges, event.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeUser:
		return m.cleareduser
	case event.EdgeGroup:
		return m.clearedgroup
	case event.EdgeIntegration:
		return m.clearedintegration
	case event.EdgeOrganization:
		return m.clearedorganization
	case event.EdgeInvite:
		return m.clearedinvite
	case event.EdgeFeature:
		return m.clearedfeature
	case event.EdgeEntitlementplan:
		return m.clearedentitlementplan
	case event.EdgeEntitlementplanfeature:
		return m.clearedentitlementplanfeature
	case event.EdgePersonalAccessToken:
		return m.clearedpersonal_access_token
	case event.EdgeOauth2token:
		return m.clearedoauth2token
	case event.EdgeHush:
		return m.clearedhush
	case event.EdgeOrgmembership:
		return m.clearedorgmembership
	case event.EdgeGroupmembership:
		return m.clearedgroupmembership
	case event.EdgeEntitlement:
		return m.clearedentitlement
	case event.EdgeWebhook:
		return m.clearedwebhook
	case event.EdgeSubscriber:
		return m.clearedsubscriber
	case event.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeUser:
		m.ResetUser()
		return nil
	case event.EdgeGroup:
		m.ResetGroup()
		return nil
	case event.EdgeIntegration:
		m.ResetIntegration()
		return nil
	case event.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case event.EdgeInvite:
		m.ResetInvite()
		return nil
	case event.EdgeFeature:
		m.ResetFeature()
		return nil
	case event.EdgeEntitlementplan:
		m.ResetEntitlementplan()
		return nil
	case event.EdgeEntitlementplanfeature:
		m.ResetEntitlementplanfeature()
		return nil
	case event.EdgePersonalAccessToken:
		m.ResetPersonalAccessToken()
		return nil
	case event.EdgeOauth2token:
		m.ResetOauth2token()
		return nil
	case event.EdgeHush:
		m.ResetHush()
		return nil
	case event.EdgeOrgmembership:
		m.ResetOrgmembership()
		return nil
	case event.EdgeGroupmembership:
		m.ResetGroupmembership()
		return nil
	case event.EdgeEntitlement:
		m.ResetEntitlement()
		return nil
	case event.EdgeWebhook:
		m.ResetWebhook()
		return nil
	case event.EdgeSubscriber:
		m.ResetSubscriber()
		return nil
	case event.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventHistoryMutation represents an operation that mutates the EventHistory nodes in the graph.
type EventHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *string
	history_time   *time.Time
	ref            *string
	operation      *history.OpType
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	mapping_id     *string
	tags           *[]string
	appendtags     []string
	event_id       *string
	correlation_id *string
	event_type     *string
	metadata       *map[string]interface{}
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*EventHistory, error)
	predicates     []predicate.EventHistory
}

var _ ent.Mutation = (*EventHistoryMutation)(nil)

// eventhistoryOption allows management of the mutation configuration using functional options.
type eventhistoryOption func(*EventHistoryMutation)

// newEventHistoryMutation creates new mutation for the EventHistory entity.
func newEventHistoryMutation(c config, op Op, opts ...eventhistoryOption) *EventHistoryMutation {
	m := &EventHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeEventHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventHistoryID sets the ID field of the mutation.
func withEventHistoryID(id string) eventhistoryOption {
	return func(m *EventHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *EventHistory
		)
		m.oldValue = func(ctx context.Context) (*EventHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventHistory sets the old EventHistory of the mutation.
func withEventHistory(node *EventHistory) eventhistoryOption {
	return func(m *EventHistoryMutation) {
		m.oldValue = func(context.Context) (*EventHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventHistory entities.
func (m *EventHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *EventHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *EventHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *EventHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *EventHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *EventHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *EventHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[eventhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *EventHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *EventHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, eventhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *EventHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *EventHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *EventHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EventHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[eventhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EventHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, eventhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EventHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[eventhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EventHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, eventhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *EventHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EventHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EventHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[eventhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EventHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EventHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, eventhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EventHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EventHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *EventHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[eventhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *EventHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EventHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, eventhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *EventHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *EventHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *EventHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *EventHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EventHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EventHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EventHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EventHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[eventhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EventHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EventHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, eventhistory.FieldTags)
}

// SetEventID sets the "event_id" field.
func (m *EventHistoryMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventHistoryMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ClearEventID clears the value of the "event_id" field.
func (m *EventHistoryMutation) ClearEventID() {
	m.event_id = nil
	m.clearedFields[eventhistory.FieldEventID] = struct{}{}
}

// EventIDCleared returns if the "event_id" field was cleared in this mutation.
func (m *EventHistoryMutation) EventIDCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldEventID]
	return ok
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventHistoryMutation) ResetEventID() {
	m.event_id = nil
	delete(m.clearedFields, eventhistory.FieldEventID)
}

// SetCorrelationID sets the "correlation_id" field.
func (m *EventHistoryMutation) SetCorrelationID(s string) {
	m.correlation_id = &s
}

// CorrelationID returns the value of the "correlation_id" field in the mutation.
func (m *EventHistoryMutation) CorrelationID() (r string, exists bool) {
	v := m.correlation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelationID returns the old "correlation_id" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldCorrelationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelationID: %w", err)
	}
	return oldValue.CorrelationID, nil
}

// ClearCorrelationID clears the value of the "correlation_id" field.
func (m *EventHistoryMutation) ClearCorrelationID() {
	m.correlation_id = nil
	m.clearedFields[eventhistory.FieldCorrelationID] = struct{}{}
}

// CorrelationIDCleared returns if the "correlation_id" field was cleared in this mutation.
func (m *EventHistoryMutation) CorrelationIDCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldCorrelationID]
	return ok
}

// ResetCorrelationID resets all changes to the "correlation_id" field.
func (m *EventHistoryMutation) ResetCorrelationID() {
	m.correlation_id = nil
	delete(m.clearedFields, eventhistory.FieldCorrelationID)
}

// SetEventType sets the "event_type" field.
func (m *EventHistoryMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *EventHistoryMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *EventHistoryMutation) ResetEventType() {
	m.event_type = nil
}

// SetMetadata sets the "metadata" field.
func (m *EventHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *EventHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the EventHistory entity.
// If the EventHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *EventHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[eventhistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *EventHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[eventhistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *EventHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, eventhistory.FieldMetadata)
}

// Where appends a list predicates to the EventHistoryMutation builder.
func (m *EventHistoryMutation) Where(ps ...predicate.EventHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventHistory).
func (m *EventHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.history_time != nil {
		fields = append(fields, eventhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, eventhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, eventhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, eventhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, eventhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, eventhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, eventhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, eventhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, eventhistory.FieldTags)
	}
	if m.event_id != nil {
		fields = append(fields, eventhistory.FieldEventID)
	}
	if m.correlation_id != nil {
		fields = append(fields, eventhistory.FieldCorrelationID)
	}
	if m.event_type != nil {
		fields = append(fields, eventhistory.FieldEventType)
	}
	if m.metadata != nil {
		fields = append(fields, eventhistory.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventhistory.FieldHistoryTime:
		return m.HistoryTime()
	case eventhistory.FieldRef:
		return m.Ref()
	case eventhistory.FieldOperation:
		return m.Operation()
	case eventhistory.FieldCreatedAt:
		return m.CreatedAt()
	case eventhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case eventhistory.FieldCreatedBy:
		return m.CreatedBy()
	case eventhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case eventhistory.FieldMappingID:
		return m.MappingID()
	case eventhistory.FieldTags:
		return m.Tags()
	case eventhistory.FieldEventID:
		return m.EventID()
	case eventhistory.FieldCorrelationID:
		return m.CorrelationID()
	case eventhistory.FieldEventType:
		return m.EventType()
	case eventhistory.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case eventhistory.FieldRef:
		return m.OldRef(ctx)
	case eventhistory.FieldOperation:
		return m.OldOperation(ctx)
	case eventhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case eventhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case eventhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case eventhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case eventhistory.FieldTags:
		return m.OldTags(ctx)
	case eventhistory.FieldEventID:
		return m.OldEventID(ctx)
	case eventhistory.FieldCorrelationID:
		return m.OldCorrelationID(ctx)
	case eventhistory.FieldEventType:
		return m.OldEventType(ctx)
	case eventhistory.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown EventHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case eventhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case eventhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case eventhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case eventhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case eventhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case eventhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case eventhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case eventhistory.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case eventhistory.FieldCorrelationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelationID(v)
		return nil
	case eventhistory.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case eventhistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown EventHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventhistory.FieldRef) {
		fields = append(fields, eventhistory.FieldRef)
	}
	if m.FieldCleared(eventhistory.FieldCreatedAt) {
		fields = append(fields, eventhistory.FieldCreatedAt)
	}
	if m.FieldCleared(eventhistory.FieldUpdatedAt) {
		fields = append(fields, eventhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(eventhistory.FieldCreatedBy) {
		fields = append(fields, eventhistory.FieldCreatedBy)
	}
	if m.FieldCleared(eventhistory.FieldUpdatedBy) {
		fields = append(fields, eventhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(eventhistory.FieldTags) {
		fields = append(fields, eventhistory.FieldTags)
	}
	if m.FieldCleared(eventhistory.FieldEventID) {
		fields = append(fields, eventhistory.FieldEventID)
	}
	if m.FieldCleared(eventhistory.FieldCorrelationID) {
		fields = append(fields, eventhistory.FieldCorrelationID)
	}
	if m.FieldCleared(eventhistory.FieldMetadata) {
		fields = append(fields, eventhistory.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventHistoryMutation) ClearField(name string) error {
	switch name {
	case eventhistory.FieldRef:
		m.ClearRef()
		return nil
	case eventhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case eventhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case eventhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case eventhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case eventhistory.FieldTags:
		m.ClearTags()
		return nil
	case eventhistory.FieldEventID:
		m.ClearEventID()
		return nil
	case eventhistory.FieldCorrelationID:
		m.ClearCorrelationID()
		return nil
	case eventhistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown EventHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventHistoryMutation) ResetField(name string) error {
	switch name {
	case eventhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case eventhistory.FieldRef:
		m.ResetRef()
		return nil
	case eventhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case eventhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case eventhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case eventhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case eventhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case eventhistory.FieldTags:
		m.ResetTags()
		return nil
	case eventhistory.FieldEventID:
		m.ResetEventID()
		return nil
	case eventhistory.FieldCorrelationID:
		m.ResetCorrelationID()
		return nil
	case eventhistory.FieldEventType:
		m.ResetEventType()
		return nil
	case eventhistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown EventHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EventHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EventHistory edge %s", name)
}

// FeatureMutation represents an operation that mutates the Feature nodes in the graph.
type FeatureMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	deleted_at      *time.Time
	deleted_by      *string
	mapping_id      *string
	tags            *[]string
	appendtags      []string
	name            *string
	display_name    *string
	enabled         *bool
	description     *string
	metadata        *map[string]interface{}
	clearedFields   map[string]struct{}
	owner           *string
	clearedowner    bool
	plans           map[string]struct{}
	removedplans    map[string]struct{}
	clearedplans    bool
	events          map[string]struct{}
	removedevents   map[string]struct{}
	clearedevents   bool
	features        map[string]struct{}
	removedfeatures map[string]struct{}
	clearedfeatures bool
	done            bool
	oldValue        func(context.Context) (*Feature, error)
	predicates      []predicate.Feature
}

var _ ent.Mutation = (*FeatureMutation)(nil)

// featureOption allows management of the mutation configuration using functional options.
type featureOption func(*FeatureMutation)

// newFeatureMutation creates new mutation for the Feature entity.
func newFeatureMutation(c config, op Op, opts ...featureOption) *FeatureMutation {
	m := &FeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureID sets the ID field of the mutation.
func withFeatureID(id string) featureOption {
	return func(m *FeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *Feature
		)
		m.oldValue = func(ctx context.Context) (*Feature, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeature sets the old Feature of the mutation.
func withFeature(node *Feature) featureOption {
	return func(m *FeatureMutation) {
		m.oldValue = func(context.Context) (*Feature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feature entities.
func (m *FeatureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feature.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FeatureMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[feature.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FeatureMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, feature.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FeatureMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[feature.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FeatureMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, feature.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FeatureMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FeatureMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FeatureMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[feature.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FeatureMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[feature.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FeatureMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, feature.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FeatureMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FeatureMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FeatureMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[feature.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FeatureMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[feature.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FeatureMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, feature.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[feature.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[feature.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, feature.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FeatureMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FeatureMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FeatureMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[feature.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FeatureMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[feature.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FeatureMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, feature.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *FeatureMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *FeatureMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *FeatureMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *FeatureMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FeatureMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *FeatureMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *FeatureMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *FeatureMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[feature.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *FeatureMutation) TagsCleared() bool {
	_, ok := m.clearedFields[feature.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *FeatureMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, feature.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *FeatureMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *FeatureMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *FeatureMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[feature.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *FeatureMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[feature.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *FeatureMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, feature.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *FeatureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *FeatureMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *FeatureMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *FeatureMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[feature.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *FeatureMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[feature.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *FeatureMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, feature.FieldDisplayName)
}

// SetEnabled sets the "enabled" field.
func (m *FeatureMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FeatureMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FeatureMutation) ResetEnabled() {
	m.enabled = nil
}

// SetDescription sets the "description" field.
func (m *FeatureMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeatureMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeatureMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feature.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeatureMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feature.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeatureMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feature.FieldDescription)
}

// SetMetadata sets the "metadata" field.
func (m *FeatureMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FeatureMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Feature entity.
// If the Feature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FeatureMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[feature.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FeatureMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[feature.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FeatureMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, feature.FieldMetadata)
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *FeatureMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[feature.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *FeatureMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeatureMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeatureMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddPlanIDs adds the "plans" edge to the EntitlementPlan entity by ids.
func (m *FeatureMutation) AddPlanIDs(ids ...string) {
	if m.plans == nil {
		m.plans = make(map[string]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the EntitlementPlan entity.
func (m *FeatureMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the EntitlementPlan entity was cleared.
func (m *FeatureMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the EntitlementPlan entity by IDs.
func (m *FeatureMutation) RemovePlanIDs(ids ...string) {
	if m.removedplans == nil {
		m.removedplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the EntitlementPlan entity.
func (m *FeatureMutation) RemovedPlansIDs() (ids []string) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *FeatureMutation) PlansIDs() (ids []string) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *FeatureMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *FeatureMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *FeatureMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *FeatureMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *FeatureMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *FeatureMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *FeatureMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *FeatureMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddFeatureIDs adds the "features" edge to the EntitlementPlanFeature entity by ids.
func (m *FeatureMutation) AddFeatureIDs(ids ...string) {
	if m.features == nil {
		m.features = make(map[string]struct{})
	}
	for i := range ids {
		m.features[ids[i]] = struct{}{}
	}
}

// ClearFeatures clears the "features" edge to the EntitlementPlanFeature entity.
func (m *FeatureMutation) ClearFeatures() {
	m.clearedfeatures = true
}

// FeaturesCleared reports if the "features" edge to the EntitlementPlanFeature entity was cleared.
func (m *FeatureMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// RemoveFeatureIDs removes the "features" edge to the EntitlementPlanFeature entity by IDs.
func (m *FeatureMutation) RemoveFeatureIDs(ids ...string) {
	if m.removedfeatures == nil {
		m.removedfeatures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.features, ids[i])
		m.removedfeatures[ids[i]] = struct{}{}
	}
}

// RemovedFeatures returns the removed IDs of the "features" edge to the EntitlementPlanFeature entity.
func (m *FeatureMutation) RemovedFeaturesIDs() (ids []string) {
	for id := range m.removedfeatures {
		ids = append(ids, id)
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
func (m *FeatureMutation) FeaturesIDs() (ids []string) {
	for id := range m.features {
		ids = append(ids, id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *FeatureMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
	m.removedfeatures = nil
}

// Where appends a list predicates to the FeatureMutation builder.
func (m *FeatureMutation) Where(ps ...predicate.Feature) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feature, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feature).
func (m *FeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, feature.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feature.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, feature.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, feature.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, feature.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, feature.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, feature.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, feature.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, feature.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, feature.FieldDisplayName)
	}
	if m.enabled != nil {
		fields = append(fields, feature.FieldEnabled)
	}
	if m.description != nil {
		fields = append(fields, feature.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, feature.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feature.FieldCreatedAt:
		return m.CreatedAt()
	case feature.FieldUpdatedAt:
		return m.UpdatedAt()
	case feature.FieldCreatedBy:
		return m.CreatedBy()
	case feature.FieldUpdatedBy:
		return m.UpdatedBy()
	case feature.FieldDeletedAt:
		return m.DeletedAt()
	case feature.FieldDeletedBy:
		return m.DeletedBy()
	case feature.FieldMappingID:
		return m.MappingID()
	case feature.FieldTags:
		return m.Tags()
	case feature.FieldOwnerID:
		return m.OwnerID()
	case feature.FieldName:
		return m.Name()
	case feature.FieldDisplayName:
		return m.DisplayName()
	case feature.FieldEnabled:
		return m.Enabled()
	case feature.FieldDescription:
		return m.Description()
	case feature.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feature.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feature.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feature.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case feature.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case feature.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case feature.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case feature.FieldMappingID:
		return m.OldMappingID(ctx)
	case feature.FieldTags:
		return m.OldTags(ctx)
	case feature.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case feature.FieldName:
		return m.OldName(ctx)
	case feature.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case feature.FieldEnabled:
		return m.OldEnabled(ctx)
	case feature.FieldDescription:
		return m.OldDescription(ctx)
	case feature.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Feature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feature.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feature.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feature.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case feature.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case feature.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case feature.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case feature.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case feature.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case feature.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case feature.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feature.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case feature.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case feature.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feature.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feature.FieldCreatedAt) {
		fields = append(fields, feature.FieldCreatedAt)
	}
	if m.FieldCleared(feature.FieldUpdatedAt) {
		fields = append(fields, feature.FieldUpdatedAt)
	}
	if m.FieldCleared(feature.FieldCreatedBy) {
		fields = append(fields, feature.FieldCreatedBy)
	}
	if m.FieldCleared(feature.FieldUpdatedBy) {
		fields = append(fields, feature.FieldUpdatedBy)
	}
	if m.FieldCleared(feature.FieldDeletedAt) {
		fields = append(fields, feature.FieldDeletedAt)
	}
	if m.FieldCleared(feature.FieldDeletedBy) {
		fields = append(fields, feature.FieldDeletedBy)
	}
	if m.FieldCleared(feature.FieldTags) {
		fields = append(fields, feature.FieldTags)
	}
	if m.FieldCleared(feature.FieldOwnerID) {
		fields = append(fields, feature.FieldOwnerID)
	}
	if m.FieldCleared(feature.FieldDisplayName) {
		fields = append(fields, feature.FieldDisplayName)
	}
	if m.FieldCleared(feature.FieldDescription) {
		fields = append(fields, feature.FieldDescription)
	}
	if m.FieldCleared(feature.FieldMetadata) {
		fields = append(fields, feature.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureMutation) ClearField(name string) error {
	switch name {
	case feature.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case feature.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case feature.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case feature.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case feature.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case feature.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case feature.FieldTags:
		m.ClearTags()
		return nil
	case feature.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case feature.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case feature.FieldDescription:
		m.ClearDescription()
		return nil
	case feature.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Feature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureMutation) ResetField(name string) error {
	switch name {
	case feature.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feature.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feature.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case feature.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case feature.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case feature.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case feature.FieldMappingID:
		m.ResetMappingID()
		return nil
	case feature.FieldTags:
		m.ResetTags()
		return nil
	case feature.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case feature.FieldName:
		m.ResetName()
		return nil
	case feature.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case feature.FieldEnabled:
		m.ResetEnabled()
		return nil
	case feature.FieldDescription:
		m.ResetDescription()
		return nil
	case feature.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Feature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, feature.EdgeOwner)
	}
	if m.plans != nil {
		edges = append(edges, feature.EdgePlans)
	}
	if m.events != nil {
		edges = append(edges, feature.EdgeEvents)
	}
	if m.features != nil {
		edges = append(edges, feature.EdgeFeatures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case feature.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.features))
		for id := range m.features {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedplans != nil {
		edges = append(edges, feature.EdgePlans)
	}
	if m.removedevents != nil {
		edges = append(edges, feature.EdgeEvents)
	}
	if m.removedfeatures != nil {
		edges = append(edges, feature.EdgeFeatures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feature.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case feature.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.removedfeatures))
		for id := range m.removedfeatures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, feature.EdgeOwner)
	}
	if m.clearedplans {
		edges = append(edges, feature.EdgePlans)
	}
	if m.clearedevents {
		edges = append(edges, feature.EdgeEvents)
	}
	if m.clearedfeatures {
		edges = append(edges, feature.EdgeFeatures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case feature.EdgeOwner:
		return m.clearedowner
	case feature.EdgePlans:
		return m.clearedplans
	case feature.EdgeEvents:
		return m.clearedevents
	case feature.EdgeFeatures:
		return m.clearedfeatures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureMutation) ClearEdge(name string) error {
	switch name {
	case feature.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Feature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureMutation) ResetEdge(name string) error {
	switch name {
	case feature.EdgeOwner:
		m.ResetOwner()
		return nil
	case feature.EdgePlans:
		m.ResetPlans()
		return nil
	case feature.EdgeEvents:
		m.ResetEvents()
		return nil
	case feature.EdgeFeatures:
		m.ResetFeatures()
		return nil
	}
	return fmt.Errorf("unknown Feature edge %s", name)
}

// FeatureHistoryMutation represents an operation that mutates the FeatureHistory nodes in the graph.
type FeatureHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	name          *string
	display_name  *string
	enabled       *bool
	description   *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FeatureHistory, error)
	predicates    []predicate.FeatureHistory
}

var _ ent.Mutation = (*FeatureHistoryMutation)(nil)

// featurehistoryOption allows management of the mutation configuration using functional options.
type featurehistoryOption func(*FeatureHistoryMutation)

// newFeatureHistoryMutation creates new mutation for the FeatureHistory entity.
func newFeatureHistoryMutation(c config, op Op, opts ...featurehistoryOption) *FeatureHistoryMutation {
	m := &FeatureHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureHistoryID sets the ID field of the mutation.
func withFeatureHistoryID(id string) featurehistoryOption {
	return func(m *FeatureHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureHistory
		)
		m.oldValue = func(ctx context.Context) (*FeatureHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureHistory sets the old FeatureHistory of the mutation.
func withFeatureHistory(node *FeatureHistory) featurehistoryOption {
	return func(m *FeatureHistoryMutation) {
		m.oldValue = func(context.Context) (*FeatureHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureHistory entities.
func (m *FeatureHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *FeatureHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *FeatureHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *FeatureHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *FeatureHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *FeatureHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *FeatureHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[featurehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *FeatureHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *FeatureHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, featurehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *FeatureHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *FeatureHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *FeatureHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FeatureHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[featurehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FeatureHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, featurehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FeatureHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[featurehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FeatureHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, featurehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FeatureHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FeatureHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FeatureHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[featurehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FeatureHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FeatureHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, featurehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FeatureHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FeatureHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FeatureHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[featurehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FeatureHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FeatureHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, featurehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[featurehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, featurehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FeatureHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FeatureHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FeatureHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[featurehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FeatureHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FeatureHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, featurehistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *FeatureHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *FeatureHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *FeatureHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *FeatureHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FeatureHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *FeatureHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *FeatureHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *FeatureHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[featurehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *FeatureHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *FeatureHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, featurehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *FeatureHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *FeatureHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *FeatureHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[featurehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *FeatureHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *FeatureHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, featurehistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *FeatureHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureHistoryMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *FeatureHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *FeatureHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *FeatureHistoryMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[featurehistory.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *FeatureHistoryMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *FeatureHistoryMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, featurehistory.FieldDisplayName)
}

// SetEnabled sets the "enabled" field.
func (m *FeatureHistoryMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *FeatureHistoryMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *FeatureHistoryMutation) ResetEnabled() {
	m.enabled = nil
}

// SetDescription sets the "description" field.
func (m *FeatureHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeatureHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeatureHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[featurehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeatureHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeatureHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, featurehistory.FieldDescription)
}

// SetMetadata sets the "metadata" field.
func (m *FeatureHistoryMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *FeatureHistoryMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the FeatureHistory entity.
// If the FeatureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureHistoryMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *FeatureHistoryMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[featurehistory.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *FeatureHistoryMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[featurehistory.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *FeatureHistoryMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, featurehistory.FieldMetadata)
}

// Where appends a list predicates to the FeatureHistoryMutation builder.
func (m *FeatureHistoryMutation) Where(ps ...predicate.FeatureHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureHistory).
func (m *FeatureHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, featurehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, featurehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, featurehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, featurehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, featurehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, featurehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, featurehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, featurehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, featurehistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, featurehistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, featurehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, featurehistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, featurehistory.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, featurehistory.FieldDisplayName)
	}
	if m.enabled != nil {
		fields = append(fields, featurehistory.FieldEnabled)
	}
	if m.description != nil {
		fields = append(fields, featurehistory.FieldDescription)
	}
	if m.metadata != nil {
		fields = append(fields, featurehistory.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featurehistory.FieldHistoryTime:
		return m.HistoryTime()
	case featurehistory.FieldRef:
		return m.Ref()
	case featurehistory.FieldOperation:
		return m.Operation()
	case featurehistory.FieldCreatedAt:
		return m.CreatedAt()
	case featurehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case featurehistory.FieldCreatedBy:
		return m.CreatedBy()
	case featurehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case featurehistory.FieldDeletedAt:
		return m.DeletedAt()
	case featurehistory.FieldDeletedBy:
		return m.DeletedBy()
	case featurehistory.FieldMappingID:
		return m.MappingID()
	case featurehistory.FieldTags:
		return m.Tags()
	case featurehistory.FieldOwnerID:
		return m.OwnerID()
	case featurehistory.FieldName:
		return m.Name()
	case featurehistory.FieldDisplayName:
		return m.DisplayName()
	case featurehistory.FieldEnabled:
		return m.Enabled()
	case featurehistory.FieldDescription:
		return m.Description()
	case featurehistory.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featurehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case featurehistory.FieldRef:
		return m.OldRef(ctx)
	case featurehistory.FieldOperation:
		return m.OldOperation(ctx)
	case featurehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featurehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case featurehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case featurehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case featurehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case featurehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case featurehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case featurehistory.FieldTags:
		return m.OldTags(ctx)
	case featurehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case featurehistory.FieldName:
		return m.OldName(ctx)
	case featurehistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case featurehistory.FieldEnabled:
		return m.OldEnabled(ctx)
	case featurehistory.FieldDescription:
		return m.OldDescription(ctx)
	case featurehistory.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featurehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case featurehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case featurehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case featurehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featurehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case featurehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case featurehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case featurehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case featurehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case featurehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case featurehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case featurehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case featurehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case featurehistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case featurehistory.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case featurehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case featurehistory.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featurehistory.FieldRef) {
		fields = append(fields, featurehistory.FieldRef)
	}
	if m.FieldCleared(featurehistory.FieldCreatedAt) {
		fields = append(fields, featurehistory.FieldCreatedAt)
	}
	if m.FieldCleared(featurehistory.FieldUpdatedAt) {
		fields = append(fields, featurehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(featurehistory.FieldCreatedBy) {
		fields = append(fields, featurehistory.FieldCreatedBy)
	}
	if m.FieldCleared(featurehistory.FieldUpdatedBy) {
		fields = append(fields, featurehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(featurehistory.FieldDeletedAt) {
		fields = append(fields, featurehistory.FieldDeletedAt)
	}
	if m.FieldCleared(featurehistory.FieldDeletedBy) {
		fields = append(fields, featurehistory.FieldDeletedBy)
	}
	if m.FieldCleared(featurehistory.FieldTags) {
		fields = append(fields, featurehistory.FieldTags)
	}
	if m.FieldCleared(featurehistory.FieldOwnerID) {
		fields = append(fields, featurehistory.FieldOwnerID)
	}
	if m.FieldCleared(featurehistory.FieldDisplayName) {
		fields = append(fields, featurehistory.FieldDisplayName)
	}
	if m.FieldCleared(featurehistory.FieldDescription) {
		fields = append(fields, featurehistory.FieldDescription)
	}
	if m.FieldCleared(featurehistory.FieldMetadata) {
		fields = append(fields, featurehistory.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureHistoryMutation) ClearField(name string) error {
	switch name {
	case featurehistory.FieldRef:
		m.ClearRef()
		return nil
	case featurehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case featurehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case featurehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case featurehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case featurehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case featurehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case featurehistory.FieldTags:
		m.ClearTags()
		return nil
	case featurehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case featurehistory.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case featurehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case featurehistory.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown FeatureHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureHistoryMutation) ResetField(name string) error {
	switch name {
	case featurehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case featurehistory.FieldRef:
		m.ResetRef()
		return nil
	case featurehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case featurehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featurehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case featurehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case featurehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case featurehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case featurehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case featurehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case featurehistory.FieldTags:
		m.ResetTags()
		return nil
	case featurehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case featurehistory.FieldName:
		m.ResetName()
		return nil
	case featurehistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case featurehistory.FieldEnabled:
		m.ResetEnabled()
		return nil
	case featurehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case featurehistory.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown FeatureHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FeatureHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FeatureHistory edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	created_at                 *time.Time
	updated_at                 *time.Time
	created_by                 *string
	updated_by                 *string
	deleted_at                 *time.Time
	deleted_by                 *string
	mapping_id                 *string
	tags                       *[]string
	appendtags                 []string
	provided_file_name         *string
	provided_file_extension    *string
	provided_file_size         *int64
	addprovided_file_size      *int64
	persisted_file_size        *int64
	addpersisted_file_size     *int64
	detected_mime_type         *string
	md5_hash                   *string
	detected_content_type      *string
	store_key                  *string
	category_type              *string
	uri                        *string
	storage_scheme             *string
	storage_volume             *string
	storage_path               *string
	file_contents              *[]byte
	clearedFields              map[string]struct{}
	user                       map[string]struct{}
	removeduser                map[string]struct{}
	cleareduser                bool
	organization               map[string]struct{}
	removedorganization        map[string]struct{}
	clearedorganization        bool
	group                      map[string]struct{}
	removedgroup               map[string]struct{}
	clearedgroup               bool
	contact                    map[string]struct{}
	removedcontact             map[string]struct{}
	clearedcontact             bool
	entity                     map[string]struct{}
	removedentity              map[string]struct{}
	clearedentity              bool
	usersetting                map[string]struct{}
	removedusersetting         map[string]struct{}
	clearedusersetting         bool
	organizationsetting        map[string]struct{}
	removedorganizationsetting map[string]struct{}
	clearedorganizationsetting bool
	template                   map[string]struct{}
	removedtemplate            map[string]struct{}
	clearedtemplate            bool
	documentdata               map[string]struct{}
	removeddocumentdata        map[string]struct{}
	cleareddocumentdata        bool
	events                     map[string]struct{}
	removedevents              map[string]struct{}
	clearedevents              bool
	program                    map[string]struct{}
	removedprogram             map[string]struct{}
	clearedprogram             bool
	done                       bool
	oldValue                   func(context.Context) (*File, error)
	predicates                 []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id string) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FileMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[file.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FileMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, file.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[file.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, file.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FileMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FileMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FileMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[file.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FileMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[file.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FileMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, file.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FileMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FileMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FileMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[file.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[file.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FileMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, file.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FileMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FileMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FileMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[file.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FileMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FileMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, file.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *FileMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *FileMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *FileMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *FileMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *FileMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *FileMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *FileMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[file.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *FileMutation) TagsCleared() bool {
	_, ok := m.clearedFields[file.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *FileMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, file.FieldTags)
}

// SetProvidedFileName sets the "provided_file_name" field.
func (m *FileMutation) SetProvidedFileName(s string) {
	m.provided_file_name = &s
}

// ProvidedFileName returns the value of the "provided_file_name" field in the mutation.
func (m *FileMutation) ProvidedFileName() (r string, exists bool) {
	v := m.provided_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileName returns the old "provided_file_name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldProvidedFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileName: %w", err)
	}
	return oldValue.ProvidedFileName, nil
}

// ResetProvidedFileName resets all changes to the "provided_file_name" field.
func (m *FileMutation) ResetProvidedFileName() {
	m.provided_file_name = nil
}

// SetProvidedFileExtension sets the "provided_file_extension" field.
func (m *FileMutation) SetProvidedFileExtension(s string) {
	m.provided_file_extension = &s
}

// ProvidedFileExtension returns the value of the "provided_file_extension" field in the mutation.
func (m *FileMutation) ProvidedFileExtension() (r string, exists bool) {
	v := m.provided_file_extension
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileExtension returns the old "provided_file_extension" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldProvidedFileExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileExtension: %w", err)
	}
	return oldValue.ProvidedFileExtension, nil
}

// ResetProvidedFileExtension resets all changes to the "provided_file_extension" field.
func (m *FileMutation) ResetProvidedFileExtension() {
	m.provided_file_extension = nil
}

// SetProvidedFileSize sets the "provided_file_size" field.
func (m *FileMutation) SetProvidedFileSize(i int64) {
	m.provided_file_size = &i
	m.addprovided_file_size = nil
}

// ProvidedFileSize returns the value of the "provided_file_size" field in the mutation.
func (m *FileMutation) ProvidedFileSize() (r int64, exists bool) {
	v := m.provided_file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileSize returns the old "provided_file_size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldProvidedFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileSize: %w", err)
	}
	return oldValue.ProvidedFileSize, nil
}

// AddProvidedFileSize adds i to the "provided_file_size" field.
func (m *FileMutation) AddProvidedFileSize(i int64) {
	if m.addprovided_file_size != nil {
		*m.addprovided_file_size += i
	} else {
		m.addprovided_file_size = &i
	}
}

// AddedProvidedFileSize returns the value that was added to the "provided_file_size" field in this mutation.
func (m *FileMutation) AddedProvidedFileSize() (r int64, exists bool) {
	v := m.addprovided_file_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearProvidedFileSize clears the value of the "provided_file_size" field.
func (m *FileMutation) ClearProvidedFileSize() {
	m.provided_file_size = nil
	m.addprovided_file_size = nil
	m.clearedFields[file.FieldProvidedFileSize] = struct{}{}
}

// ProvidedFileSizeCleared returns if the "provided_file_size" field was cleared in this mutation.
func (m *FileMutation) ProvidedFileSizeCleared() bool {
	_, ok := m.clearedFields[file.FieldProvidedFileSize]
	return ok
}

// ResetProvidedFileSize resets all changes to the "provided_file_size" field.
func (m *FileMutation) ResetProvidedFileSize() {
	m.provided_file_size = nil
	m.addprovided_file_size = nil
	delete(m.clearedFields, file.FieldProvidedFileSize)
}

// SetPersistedFileSize sets the "persisted_file_size" field.
func (m *FileMutation) SetPersistedFileSize(i int64) {
	m.persisted_file_size = &i
	m.addpersisted_file_size = nil
}

// PersistedFileSize returns the value of the "persisted_file_size" field in the mutation.
func (m *FileMutation) PersistedFileSize() (r int64, exists bool) {
	v := m.persisted_file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPersistedFileSize returns the old "persisted_file_size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPersistedFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersistedFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersistedFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersistedFileSize: %w", err)
	}
	return oldValue.PersistedFileSize, nil
}

// AddPersistedFileSize adds i to the "persisted_file_size" field.
func (m *FileMutation) AddPersistedFileSize(i int64) {
	if m.addpersisted_file_size != nil {
		*m.addpersisted_file_size += i
	} else {
		m.addpersisted_file_size = &i
	}
}

// AddedPersistedFileSize returns the value that was added to the "persisted_file_size" field in this mutation.
func (m *FileMutation) AddedPersistedFileSize() (r int64, exists bool) {
	v := m.addpersisted_file_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearPersistedFileSize clears the value of the "persisted_file_size" field.
func (m *FileMutation) ClearPersistedFileSize() {
	m.persisted_file_size = nil
	m.addpersisted_file_size = nil
	m.clearedFields[file.FieldPersistedFileSize] = struct{}{}
}

// PersistedFileSizeCleared returns if the "persisted_file_size" field was cleared in this mutation.
func (m *FileMutation) PersistedFileSizeCleared() bool {
	_, ok := m.clearedFields[file.FieldPersistedFileSize]
	return ok
}

// ResetPersistedFileSize resets all changes to the "persisted_file_size" field.
func (m *FileMutation) ResetPersistedFileSize() {
	m.persisted_file_size = nil
	m.addpersisted_file_size = nil
	delete(m.clearedFields, file.FieldPersistedFileSize)
}

// SetDetectedMimeType sets the "detected_mime_type" field.
func (m *FileMutation) SetDetectedMimeType(s string) {
	m.detected_mime_type = &s
}

// DetectedMimeType returns the value of the "detected_mime_type" field in the mutation.
func (m *FileMutation) DetectedMimeType() (r string, exists bool) {
	v := m.detected_mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedMimeType returns the old "detected_mime_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDetectedMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedMimeType: %w", err)
	}
	return oldValue.DetectedMimeType, nil
}

// ClearDetectedMimeType clears the value of the "detected_mime_type" field.
func (m *FileMutation) ClearDetectedMimeType() {
	m.detected_mime_type = nil
	m.clearedFields[file.FieldDetectedMimeType] = struct{}{}
}

// DetectedMimeTypeCleared returns if the "detected_mime_type" field was cleared in this mutation.
func (m *FileMutation) DetectedMimeTypeCleared() bool {
	_, ok := m.clearedFields[file.FieldDetectedMimeType]
	return ok
}

// ResetDetectedMimeType resets all changes to the "detected_mime_type" field.
func (m *FileMutation) ResetDetectedMimeType() {
	m.detected_mime_type = nil
	delete(m.clearedFields, file.FieldDetectedMimeType)
}

// SetMd5Hash sets the "md5_hash" field.
func (m *FileMutation) SetMd5Hash(s string) {
	m.md5_hash = &s
}

// Md5Hash returns the value of the "md5_hash" field in the mutation.
func (m *FileMutation) Md5Hash() (r string, exists bool) {
	v := m.md5_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5Hash returns the old "md5_hash" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMd5Hash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5Hash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5Hash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5Hash: %w", err)
	}
	return oldValue.Md5Hash, nil
}

// ClearMd5Hash clears the value of the "md5_hash" field.
func (m *FileMutation) ClearMd5Hash() {
	m.md5_hash = nil
	m.clearedFields[file.FieldMd5Hash] = struct{}{}
}

// Md5HashCleared returns if the "md5_hash" field was cleared in this mutation.
func (m *FileMutation) Md5HashCleared() bool {
	_, ok := m.clearedFields[file.FieldMd5Hash]
	return ok
}

// ResetMd5Hash resets all changes to the "md5_hash" field.
func (m *FileMutation) ResetMd5Hash() {
	m.md5_hash = nil
	delete(m.clearedFields, file.FieldMd5Hash)
}

// SetDetectedContentType sets the "detected_content_type" field.
func (m *FileMutation) SetDetectedContentType(s string) {
	m.detected_content_type = &s
}

// DetectedContentType returns the value of the "detected_content_type" field in the mutation.
func (m *FileMutation) DetectedContentType() (r string, exists bool) {
	v := m.detected_content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedContentType returns the old "detected_content_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDetectedContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedContentType: %w", err)
	}
	return oldValue.DetectedContentType, nil
}

// ResetDetectedContentType resets all changes to the "detected_content_type" field.
func (m *FileMutation) ResetDetectedContentType() {
	m.detected_content_type = nil
}

// SetStoreKey sets the "store_key" field.
func (m *FileMutation) SetStoreKey(s string) {
	m.store_key = &s
}

// StoreKey returns the value of the "store_key" field in the mutation.
func (m *FileMutation) StoreKey() (r string, exists bool) {
	v := m.store_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreKey returns the old "store_key" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStoreKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreKey: %w", err)
	}
	return oldValue.StoreKey, nil
}

// ClearStoreKey clears the value of the "store_key" field.
func (m *FileMutation) ClearStoreKey() {
	m.store_key = nil
	m.clearedFields[file.FieldStoreKey] = struct{}{}
}

// StoreKeyCleared returns if the "store_key" field was cleared in this mutation.
func (m *FileMutation) StoreKeyCleared() bool {
	_, ok := m.clearedFields[file.FieldStoreKey]
	return ok
}

// ResetStoreKey resets all changes to the "store_key" field.
func (m *FileMutation) ResetStoreKey() {
	m.store_key = nil
	delete(m.clearedFields, file.FieldStoreKey)
}

// SetCategoryType sets the "category_type" field.
func (m *FileMutation) SetCategoryType(s string) {
	m.category_type = &s
}

// CategoryType returns the value of the "category_type" field in the mutation.
func (m *FileMutation) CategoryType() (r string, exists bool) {
	v := m.category_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryType returns the old "category_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCategoryType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryType: %w", err)
	}
	return oldValue.CategoryType, nil
}

// ClearCategoryType clears the value of the "category_type" field.
func (m *FileMutation) ClearCategoryType() {
	m.category_type = nil
	m.clearedFields[file.FieldCategoryType] = struct{}{}
}

// CategoryTypeCleared returns if the "category_type" field was cleared in this mutation.
func (m *FileMutation) CategoryTypeCleared() bool {
	_, ok := m.clearedFields[file.FieldCategoryType]
	return ok
}

// ResetCategoryType resets all changes to the "category_type" field.
func (m *FileMutation) ResetCategoryType() {
	m.category_type = nil
	delete(m.clearedFields, file.FieldCategoryType)
}

// SetURI sets the "uri" field.
func (m *FileMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *FileMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ClearURI clears the value of the "uri" field.
func (m *FileMutation) ClearURI() {
	m.uri = nil
	m.clearedFields[file.FieldURI] = struct{}{}
}

// URICleared returns if the "uri" field was cleared in this mutation.
func (m *FileMutation) URICleared() bool {
	_, ok := m.clearedFields[file.FieldURI]
	return ok
}

// ResetURI resets all changes to the "uri" field.
func (m *FileMutation) ResetURI() {
	m.uri = nil
	delete(m.clearedFields, file.FieldURI)
}

// SetStorageScheme sets the "storage_scheme" field.
func (m *FileMutation) SetStorageScheme(s string) {
	m.storage_scheme = &s
}

// StorageScheme returns the value of the "storage_scheme" field in the mutation.
func (m *FileMutation) StorageScheme() (r string, exists bool) {
	v := m.storage_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageScheme returns the old "storage_scheme" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStorageScheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageScheme: %w", err)
	}
	return oldValue.StorageScheme, nil
}

// ClearStorageScheme clears the value of the "storage_scheme" field.
func (m *FileMutation) ClearStorageScheme() {
	m.storage_scheme = nil
	m.clearedFields[file.FieldStorageScheme] = struct{}{}
}

// StorageSchemeCleared returns if the "storage_scheme" field was cleared in this mutation.
func (m *FileMutation) StorageSchemeCleared() bool {
	_, ok := m.clearedFields[file.FieldStorageScheme]
	return ok
}

// ResetStorageScheme resets all changes to the "storage_scheme" field.
func (m *FileMutation) ResetStorageScheme() {
	m.storage_scheme = nil
	delete(m.clearedFields, file.FieldStorageScheme)
}

// SetStorageVolume sets the "storage_volume" field.
func (m *FileMutation) SetStorageVolume(s string) {
	m.storage_volume = &s
}

// StorageVolume returns the value of the "storage_volume" field in the mutation.
func (m *FileMutation) StorageVolume() (r string, exists bool) {
	v := m.storage_volume
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageVolume returns the old "storage_volume" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStorageVolume(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageVolume: %w", err)
	}
	return oldValue.StorageVolume, nil
}

// ClearStorageVolume clears the value of the "storage_volume" field.
func (m *FileMutation) ClearStorageVolume() {
	m.storage_volume = nil
	m.clearedFields[file.FieldStorageVolume] = struct{}{}
}

// StorageVolumeCleared returns if the "storage_volume" field was cleared in this mutation.
func (m *FileMutation) StorageVolumeCleared() bool {
	_, ok := m.clearedFields[file.FieldStorageVolume]
	return ok
}

// ResetStorageVolume resets all changes to the "storage_volume" field.
func (m *FileMutation) ResetStorageVolume() {
	m.storage_volume = nil
	delete(m.clearedFields, file.FieldStorageVolume)
}

// SetStoragePath sets the "storage_path" field.
func (m *FileMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *FileMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ClearStoragePath clears the value of the "storage_path" field.
func (m *FileMutation) ClearStoragePath() {
	m.storage_path = nil
	m.clearedFields[file.FieldStoragePath] = struct{}{}
}

// StoragePathCleared returns if the "storage_path" field was cleared in this mutation.
func (m *FileMutation) StoragePathCleared() bool {
	_, ok := m.clearedFields[file.FieldStoragePath]
	return ok
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *FileMutation) ResetStoragePath() {
	m.storage_path = nil
	delete(m.clearedFields, file.FieldStoragePath)
}

// SetFileContents sets the "file_contents" field.
func (m *FileMutation) SetFileContents(b []byte) {
	m.file_contents = &b
}

// FileContents returns the value of the "file_contents" field in the mutation.
func (m *FileMutation) FileContents() (r []byte, exists bool) {
	v := m.file_contents
	if v == nil {
		return
	}
	return *v, true
}

// OldFileContents returns the old "file_contents" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFileContents(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileContents: %w", err)
	}
	return oldValue.FileContents, nil
}

// ClearFileContents clears the value of the "file_contents" field.
func (m *FileMutation) ClearFileContents() {
	m.file_contents = nil
	m.clearedFields[file.FieldFileContents] = struct{}{}
}

// FileContentsCleared returns if the "file_contents" field was cleared in this mutation.
func (m *FileMutation) FileContentsCleared() bool {
	_, ok := m.clearedFields[file.FieldFileContents]
	return ok
}

// ResetFileContents resets all changes to the "file_contents" field.
func (m *FileMutation) ResetFileContents() {
	m.file_contents = nil
	delete(m.clearedFields, file.FieldFileContents)
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *FileMutation) AddUserIDs(ids ...string) {
	if m.user == nil {
		m.user = make(map[string]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *FileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FileMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *FileMutation) RemoveUserIDs(ids ...string) {
	if m.removeduser == nil {
		m.removeduser = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *FileMutation) RemovedUserIDs() (ids []string) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *FileMutation) UserIDs() (ids []string) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *FileMutation) AddOrganizationIDs(ids ...string) {
	if m.organization == nil {
		m.organization = make(map[string]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *FileMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *FileMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *FileMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organization, ids[i])
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *FileMutation) RemovedOrganizationIDs() (ids []string) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *FileMutation) OrganizationIDs() (ids []string) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *FileMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// AddGroupIDs adds the "group" edge to the Group entity by ids.
func (m *FileMutation) AddGroupIDs(ids ...string) {
	if m.group == nil {
		m.group = make(map[string]struct{})
	}
	for i := range ids {
		m.group[ids[i]] = struct{}{}
	}
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *FileMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *FileMutation) GroupCleared() bool {
	return m.clearedgroup
}

// RemoveGroupIDs removes the "group" edge to the Group entity by IDs.
func (m *FileMutation) RemoveGroupIDs(ids ...string) {
	if m.removedgroup == nil {
		m.removedgroup = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.group, ids[i])
		m.removedgroup[ids[i]] = struct{}{}
	}
}

// RemovedGroup returns the removed IDs of the "group" edge to the Group entity.
func (m *FileMutation) RemovedGroupIDs() (ids []string) {
	for id := range m.removedgroup {
		ids = append(ids, id)
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
func (m *FileMutation) GroupIDs() (ids []string) {
	for id := range m.group {
		ids = append(ids, id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *FileMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
	m.removedgroup = nil
}

// AddContactIDs adds the "contact" edge to the Contact entity by ids.
func (m *FileMutation) AddContactIDs(ids ...string) {
	if m.contact == nil {
		m.contact = make(map[string]struct{})
	}
	for i := range ids {
		m.contact[ids[i]] = struct{}{}
	}
}

// ClearContact clears the "contact" edge to the Contact entity.
func (m *FileMutation) ClearContact() {
	m.clearedcontact = true
}

// ContactCleared reports if the "contact" edge to the Contact entity was cleared.
func (m *FileMutation) ContactCleared() bool {
	return m.clearedcontact
}

// RemoveContactIDs removes the "contact" edge to the Contact entity by IDs.
func (m *FileMutation) RemoveContactIDs(ids ...string) {
	if m.removedcontact == nil {
		m.removedcontact = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.contact, ids[i])
		m.removedcontact[ids[i]] = struct{}{}
	}
}

// RemovedContact returns the removed IDs of the "contact" edge to the Contact entity.
func (m *FileMutation) RemovedContactIDs() (ids []string) {
	for id := range m.removedcontact {
		ids = append(ids, id)
	}
	return
}

// ContactIDs returns the "contact" edge IDs in the mutation.
func (m *FileMutation) ContactIDs() (ids []string) {
	for id := range m.contact {
		ids = append(ids, id)
	}
	return
}

// ResetContact resets all changes to the "contact" edge.
func (m *FileMutation) ResetContact() {
	m.contact = nil
	m.clearedcontact = false
	m.removedcontact = nil
}

// AddEntityIDs adds the "entity" edge to the Entity entity by ids.
func (m *FileMutation) AddEntityIDs(ids ...string) {
	if m.entity == nil {
		m.entity = make(map[string]struct{})
	}
	for i := range ids {
		m.entity[ids[i]] = struct{}{}
	}
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *FileMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *FileMutation) EntityCleared() bool {
	return m.clearedentity
}

// RemoveEntityIDs removes the "entity" edge to the Entity entity by IDs.
func (m *FileMutation) RemoveEntityIDs(ids ...string) {
	if m.removedentity == nil {
		m.removedentity = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entity, ids[i])
		m.removedentity[ids[i]] = struct{}{}
	}
}

// RemovedEntity returns the removed IDs of the "entity" edge to the Entity entity.
func (m *FileMutation) RemovedEntityIDs() (ids []string) {
	for id := range m.removedentity {
		ids = append(ids, id)
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
func (m *FileMutation) EntityIDs() (ids []string) {
	for id := range m.entity {
		ids = append(ids, id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *FileMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
	m.removedentity = nil
}

// AddUsersettingIDs adds the "usersetting" edge to the UserSetting entity by ids.
func (m *FileMutation) AddUsersettingIDs(ids ...string) {
	if m.usersetting == nil {
		m.usersetting = make(map[string]struct{})
	}
	for i := range ids {
		m.usersetting[ids[i]] = struct{}{}
	}
}

// ClearUsersetting clears the "usersetting" edge to the UserSetting entity.
func (m *FileMutation) ClearUsersetting() {
	m.clearedusersetting = true
}

// UsersettingCleared reports if the "usersetting" edge to the UserSetting entity was cleared.
func (m *FileMutation) UsersettingCleared() bool {
	return m.clearedusersetting
}

// RemoveUsersettingIDs removes the "usersetting" edge to the UserSetting entity by IDs.
func (m *FileMutation) RemoveUsersettingIDs(ids ...string) {
	if m.removedusersetting == nil {
		m.removedusersetting = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.usersetting, ids[i])
		m.removedusersetting[ids[i]] = struct{}{}
	}
}

// RemovedUsersetting returns the removed IDs of the "usersetting" edge to the UserSetting entity.
func (m *FileMutation) RemovedUsersettingIDs() (ids []string) {
	for id := range m.removedusersetting {
		ids = append(ids, id)
	}
	return
}

// UsersettingIDs returns the "usersetting" edge IDs in the mutation.
func (m *FileMutation) UsersettingIDs() (ids []string) {
	for id := range m.usersetting {
		ids = append(ids, id)
	}
	return
}

// ResetUsersetting resets all changes to the "usersetting" edge.
func (m *FileMutation) ResetUsersetting() {
	m.usersetting = nil
	m.clearedusersetting = false
	m.removedusersetting = nil
}

// AddOrganizationsettingIDs adds the "organizationsetting" edge to the OrganizationSetting entity by ids.
func (m *FileMutation) AddOrganizationsettingIDs(ids ...string) {
	if m.organizationsetting == nil {
		m.organizationsetting = make(map[string]struct{})
	}
	for i := range ids {
		m.organizationsetting[ids[i]] = struct{}{}
	}
}

// ClearOrganizationsetting clears the "organizationsetting" edge to the OrganizationSetting entity.
func (m *FileMutation) ClearOrganizationsetting() {
	m.clearedorganizationsetting = true
}

// OrganizationsettingCleared reports if the "organizationsetting" edge to the OrganizationSetting entity was cleared.
func (m *FileMutation) OrganizationsettingCleared() bool {
	return m.clearedorganizationsetting
}

// RemoveOrganizationsettingIDs removes the "organizationsetting" edge to the OrganizationSetting entity by IDs.
func (m *FileMutation) RemoveOrganizationsettingIDs(ids ...string) {
	if m.removedorganizationsetting == nil {
		m.removedorganizationsetting = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organizationsetting, ids[i])
		m.removedorganizationsetting[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationsetting returns the removed IDs of the "organizationsetting" edge to the OrganizationSetting entity.
func (m *FileMutation) RemovedOrganizationsettingIDs() (ids []string) {
	for id := range m.removedorganizationsetting {
		ids = append(ids, id)
	}
	return
}

// OrganizationsettingIDs returns the "organizationsetting" edge IDs in the mutation.
func (m *FileMutation) OrganizationsettingIDs() (ids []string) {
	for id := range m.organizationsetting {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationsetting resets all changes to the "organizationsetting" edge.
func (m *FileMutation) ResetOrganizationsetting() {
	m.organizationsetting = nil
	m.clearedorganizationsetting = false
	m.removedorganizationsetting = nil
}

// AddTemplateIDs adds the "template" edge to the Template entity by ids.
func (m *FileMutation) AddTemplateIDs(ids ...string) {
	if m.template == nil {
		m.template = make(map[string]struct{})
	}
	for i := range ids {
		m.template[ids[i]] = struct{}{}
	}
}

// ClearTemplate clears the "template" edge to the Template entity.
func (m *FileMutation) ClearTemplate() {
	m.clearedtemplate = true
}

// TemplateCleared reports if the "template" edge to the Template entity was cleared.
func (m *FileMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// RemoveTemplateIDs removes the "template" edge to the Template entity by IDs.
func (m *FileMutation) RemoveTemplateIDs(ids ...string) {
	if m.removedtemplate == nil {
		m.removedtemplate = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.template, ids[i])
		m.removedtemplate[ids[i]] = struct{}{}
	}
}

// RemovedTemplate returns the removed IDs of the "template" edge to the Template entity.
func (m *FileMutation) RemovedTemplateIDs() (ids []string) {
	for id := range m.removedtemplate {
		ids = append(ids, id)
	}
	return
}

// TemplateIDs returns the "template" edge IDs in the mutation.
func (m *FileMutation) TemplateIDs() (ids []string) {
	for id := range m.template {
		ids = append(ids, id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *FileMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
	m.removedtemplate = nil
}

// AddDocumentdatumIDs adds the "documentdata" edge to the DocumentData entity by ids.
func (m *FileMutation) AddDocumentdatumIDs(ids ...string) {
	if m.documentdata == nil {
		m.documentdata = make(map[string]struct{})
	}
	for i := range ids {
		m.documentdata[ids[i]] = struct{}{}
	}
}

// ClearDocumentdata clears the "documentdata" edge to the DocumentData entity.
func (m *FileMutation) ClearDocumentdata() {
	m.cleareddocumentdata = true
}

// DocumentdataCleared reports if the "documentdata" edge to the DocumentData entity was cleared.
func (m *FileMutation) DocumentdataCleared() bool {
	return m.cleareddocumentdata
}

// RemoveDocumentdatumIDs removes the "documentdata" edge to the DocumentData entity by IDs.
func (m *FileMutation) RemoveDocumentdatumIDs(ids ...string) {
	if m.removeddocumentdata == nil {
		m.removeddocumentdata = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.documentdata, ids[i])
		m.removeddocumentdata[ids[i]] = struct{}{}
	}
}

// RemovedDocumentdata returns the removed IDs of the "documentdata" edge to the DocumentData entity.
func (m *FileMutation) RemovedDocumentdataIDs() (ids []string) {
	for id := range m.removeddocumentdata {
		ids = append(ids, id)
	}
	return
}

// DocumentdataIDs returns the "documentdata" edge IDs in the mutation.
func (m *FileMutation) DocumentdataIDs() (ids []string) {
	for id := range m.documentdata {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentdata resets all changes to the "documentdata" edge.
func (m *FileMutation) ResetDocumentdata() {
	m.documentdata = nil
	m.cleareddocumentdata = false
	m.removeddocumentdata = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *FileMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *FileMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *FileMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *FileMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *FileMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *FileMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *FileMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddProgramIDs adds the "program" edge to the Program entity by ids.
func (m *FileMutation) AddProgramIDs(ids ...string) {
	if m.program == nil {
		m.program = make(map[string]struct{})
	}
	for i := range ids {
		m.program[ids[i]] = struct{}{}
	}
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *FileMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *FileMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// RemoveProgramIDs removes the "program" edge to the Program entity by IDs.
func (m *FileMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprogram == nil {
		m.removedprogram = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.program, ids[i])
		m.removedprogram[ids[i]] = struct{}{}
	}
}

// RemovedProgram returns the removed IDs of the "program" edge to the Program entity.
func (m *FileMutation) RemovedProgramIDs() (ids []string) {
	for id := range m.removedprogram {
		ids = append(ids, id)
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
func (m *FileMutation) ProgramIDs() (ids []string) {
	for id := range m.program {
		ids = append(ids, id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *FileMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
	m.removedprogram = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, file.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, file.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, file.FieldTags)
	}
	if m.provided_file_name != nil {
		fields = append(fields, file.FieldProvidedFileName)
	}
	if m.provided_file_extension != nil {
		fields = append(fields, file.FieldProvidedFileExtension)
	}
	if m.provided_file_size != nil {
		fields = append(fields, file.FieldProvidedFileSize)
	}
	if m.persisted_file_size != nil {
		fields = append(fields, file.FieldPersistedFileSize)
	}
	if m.detected_mime_type != nil {
		fields = append(fields, file.FieldDetectedMimeType)
	}
	if m.md5_hash != nil {
		fields = append(fields, file.FieldMd5Hash)
	}
	if m.detected_content_type != nil {
		fields = append(fields, file.FieldDetectedContentType)
	}
	if m.store_key != nil {
		fields = append(fields, file.FieldStoreKey)
	}
	if m.category_type != nil {
		fields = append(fields, file.FieldCategoryType)
	}
	if m.uri != nil {
		fields = append(fields, file.FieldURI)
	}
	if m.storage_scheme != nil {
		fields = append(fields, file.FieldStorageScheme)
	}
	if m.storage_volume != nil {
		fields = append(fields, file.FieldStorageVolume)
	}
	if m.storage_path != nil {
		fields = append(fields, file.FieldStoragePath)
	}
	if m.file_contents != nil {
		fields = append(fields, file.FieldFileContents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldCreatedBy:
		return m.CreatedBy()
	case file.FieldUpdatedBy:
		return m.UpdatedBy()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldDeletedBy:
		return m.DeletedBy()
	case file.FieldMappingID:
		return m.MappingID()
	case file.FieldTags:
		return m.Tags()
	case file.FieldProvidedFileName:
		return m.ProvidedFileName()
	case file.FieldProvidedFileExtension:
		return m.ProvidedFileExtension()
	case file.FieldProvidedFileSize:
		return m.ProvidedFileSize()
	case file.FieldPersistedFileSize:
		return m.PersistedFileSize()
	case file.FieldDetectedMimeType:
		return m.DetectedMimeType()
	case file.FieldMd5Hash:
		return m.Md5Hash()
	case file.FieldDetectedContentType:
		return m.DetectedContentType()
	case file.FieldStoreKey:
		return m.StoreKey()
	case file.FieldCategoryType:
		return m.CategoryType()
	case file.FieldURI:
		return m.URI()
	case file.FieldStorageScheme:
		return m.StorageScheme()
	case file.FieldStorageVolume:
		return m.StorageVolume()
	case file.FieldStoragePath:
		return m.StoragePath()
	case file.FieldFileContents:
		return m.FileContents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case file.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case file.FieldMappingID:
		return m.OldMappingID(ctx)
	case file.FieldTags:
		return m.OldTags(ctx)
	case file.FieldProvidedFileName:
		return m.OldProvidedFileName(ctx)
	case file.FieldProvidedFileExtension:
		return m.OldProvidedFileExtension(ctx)
	case file.FieldProvidedFileSize:
		return m.OldProvidedFileSize(ctx)
	case file.FieldPersistedFileSize:
		return m.OldPersistedFileSize(ctx)
	case file.FieldDetectedMimeType:
		return m.OldDetectedMimeType(ctx)
	case file.FieldMd5Hash:
		return m.OldMd5Hash(ctx)
	case file.FieldDetectedContentType:
		return m.OldDetectedContentType(ctx)
	case file.FieldStoreKey:
		return m.OldStoreKey(ctx)
	case file.FieldCategoryType:
		return m.OldCategoryType(ctx)
	case file.FieldURI:
		return m.OldURI(ctx)
	case file.FieldStorageScheme:
		return m.OldStorageScheme(ctx)
	case file.FieldStorageVolume:
		return m.OldStorageVolume(ctx)
	case file.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case file.FieldFileContents:
		return m.OldFileContents(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case file.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case file.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case file.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case file.FieldProvidedFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileName(v)
		return nil
	case file.FieldProvidedFileExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileExtension(v)
		return nil
	case file.FieldProvidedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileSize(v)
		return nil
	case file.FieldPersistedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersistedFileSize(v)
		return nil
	case file.FieldDetectedMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedMimeType(v)
		return nil
	case file.FieldMd5Hash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5Hash(v)
		return nil
	case file.FieldDetectedContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedContentType(v)
		return nil
	case file.FieldStoreKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreKey(v)
		return nil
	case file.FieldCategoryType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryType(v)
		return nil
	case file.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case file.FieldStorageScheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageScheme(v)
		return nil
	case file.FieldStorageVolume:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageVolume(v)
		return nil
	case file.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case file.FieldFileContents:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileContents(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addprovided_file_size != nil {
		fields = append(fields, file.FieldProvidedFileSize)
	}
	if m.addpersisted_file_size != nil {
		fields = append(fields, file.FieldPersistedFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldProvidedFileSize:
		return m.AddedProvidedFileSize()
	case file.FieldPersistedFileSize:
		return m.AddedPersistedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldProvidedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvidedFileSize(v)
		return nil
	case file.FieldPersistedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPersistedFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldCreatedAt) {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.FieldCleared(file.FieldUpdatedAt) {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.FieldCleared(file.FieldCreatedBy) {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.FieldCleared(file.FieldUpdatedBy) {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.FieldCleared(file.FieldDeletedBy) {
		fields = append(fields, file.FieldDeletedBy)
	}
	if m.FieldCleared(file.FieldTags) {
		fields = append(fields, file.FieldTags)
	}
	if m.FieldCleared(file.FieldProvidedFileSize) {
		fields = append(fields, file.FieldProvidedFileSize)
	}
	if m.FieldCleared(file.FieldPersistedFileSize) {
		fields = append(fields, file.FieldPersistedFileSize)
	}
	if m.FieldCleared(file.FieldDetectedMimeType) {
		fields = append(fields, file.FieldDetectedMimeType)
	}
	if m.FieldCleared(file.FieldMd5Hash) {
		fields = append(fields, file.FieldMd5Hash)
	}
	if m.FieldCleared(file.FieldStoreKey) {
		fields = append(fields, file.FieldStoreKey)
	}
	if m.FieldCleared(file.FieldCategoryType) {
		fields = append(fields, file.FieldCategoryType)
	}
	if m.FieldCleared(file.FieldURI) {
		fields = append(fields, file.FieldURI)
	}
	if m.FieldCleared(file.FieldStorageScheme) {
		fields = append(fields, file.FieldStorageScheme)
	}
	if m.FieldCleared(file.FieldStorageVolume) {
		fields = append(fields, file.FieldStorageVolume)
	}
	if m.FieldCleared(file.FieldStoragePath) {
		fields = append(fields, file.FieldStoragePath)
	}
	if m.FieldCleared(file.FieldFileContents) {
		fields = append(fields, file.FieldFileContents)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case file.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case file.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case file.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case file.FieldTags:
		m.ClearTags()
		return nil
	case file.FieldProvidedFileSize:
		m.ClearProvidedFileSize()
		return nil
	case file.FieldPersistedFileSize:
		m.ClearPersistedFileSize()
		return nil
	case file.FieldDetectedMimeType:
		m.ClearDetectedMimeType()
		return nil
	case file.FieldMd5Hash:
		m.ClearMd5Hash()
		return nil
	case file.FieldStoreKey:
		m.ClearStoreKey()
		return nil
	case file.FieldCategoryType:
		m.ClearCategoryType()
		return nil
	case file.FieldURI:
		m.ClearURI()
		return nil
	case file.FieldStorageScheme:
		m.ClearStorageScheme()
		return nil
	case file.FieldStorageVolume:
		m.ClearStorageVolume()
		return nil
	case file.FieldStoragePath:
		m.ClearStoragePath()
		return nil
	case file.FieldFileContents:
		m.ClearFileContents()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case file.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case file.FieldMappingID:
		m.ResetMappingID()
		return nil
	case file.FieldTags:
		m.ResetTags()
		return nil
	case file.FieldProvidedFileName:
		m.ResetProvidedFileName()
		return nil
	case file.FieldProvidedFileExtension:
		m.ResetProvidedFileExtension()
		return nil
	case file.FieldProvidedFileSize:
		m.ResetProvidedFileSize()
		return nil
	case file.FieldPersistedFileSize:
		m.ResetPersistedFileSize()
		return nil
	case file.FieldDetectedMimeType:
		m.ResetDetectedMimeType()
		return nil
	case file.FieldMd5Hash:
		m.ResetMd5Hash()
		return nil
	case file.FieldDetectedContentType:
		m.ResetDetectedContentType()
		return nil
	case file.FieldStoreKey:
		m.ResetStoreKey()
		return nil
	case file.FieldCategoryType:
		m.ResetCategoryType()
		return nil
	case file.FieldURI:
		m.ResetURI()
		return nil
	case file.FieldStorageScheme:
		m.ResetStorageScheme()
		return nil
	case file.FieldStorageVolume:
		m.ResetStorageVolume()
		return nil
	case file.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case file.FieldFileContents:
		m.ResetFileContents()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.user != nil {
		edges = append(edges, file.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, file.EdgeOrganization)
	}
	if m.group != nil {
		edges = append(edges, file.EdgeGroup)
	}
	if m.contact != nil {
		edges = append(edges, file.EdgeContact)
	}
	if m.entity != nil {
		edges = append(edges, file.EdgeEntity)
	}
	if m.usersetting != nil {
		edges = append(edges, file.EdgeUsersetting)
	}
	if m.organizationsetting != nil {
		edges = append(edges, file.EdgeOrganizationsetting)
	}
	if m.template != nil {
		edges = append(edges, file.EdgeTemplate)
	}
	if m.documentdata != nil {
		edges = append(edges, file.EdgeDocumentdata)
	}
	if m.events != nil {
		edges = append(edges, file.EdgeEvents)
	}
	if m.program != nil {
		edges = append(edges, file.EdgeProgram)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.group))
		for id := range m.group {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeContact:
		ids := make([]ent.Value, 0, len(m.contact))
		for id := range m.contact {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeEntity:
		ids := make([]ent.Value, 0, len(m.entity))
		for id := range m.entity {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeUsersetting:
		ids := make([]ent.Value, 0, len(m.usersetting))
		for id := range m.usersetting {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeOrganizationsetting:
		ids := make([]ent.Value, 0, len(m.organizationsetting))
		for id := range m.organizationsetting {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeTemplate:
		ids := make([]ent.Value, 0, len(m.template))
		for id := range m.template {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeDocumentdata:
		ids := make([]ent.Value, 0, len(m.documentdata))
		for id := range m.documentdata {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.program))
		for id := range m.program {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removeduser != nil {
		edges = append(edges, file.EdgeUser)
	}
	if m.removedorganization != nil {
		edges = append(edges, file.EdgeOrganization)
	}
	if m.removedgroup != nil {
		edges = append(edges, file.EdgeGroup)
	}
	if m.removedcontact != nil {
		edges = append(edges, file.EdgeContact)
	}
	if m.removedentity != nil {
		edges = append(edges, file.EdgeEntity)
	}
	if m.removedusersetting != nil {
		edges = append(edges, file.EdgeUsersetting)
	}
	if m.removedorganizationsetting != nil {
		edges = append(edges, file.EdgeOrganizationsetting)
	}
	if m.removedtemplate != nil {
		edges = append(edges, file.EdgeTemplate)
	}
	if m.removeddocumentdata != nil {
		edges = append(edges, file.EdgeDocumentdata)
	}
	if m.removedevents != nil {
		edges = append(edges, file.EdgeEvents)
	}
	if m.removedprogram != nil {
		edges = append(edges, file.EdgeProgram)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.removedgroup))
		for id := range m.removedgroup {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeContact:
		ids := make([]ent.Value, 0, len(m.removedcontact))
		for id := range m.removedcontact {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeEntity:
		ids := make([]ent.Value, 0, len(m.removedentity))
		for id := range m.removedentity {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeUsersetting:
		ids := make([]ent.Value, 0, len(m.removedusersetting))
		for id := range m.removedusersetting {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeOrganizationsetting:
		ids := make([]ent.Value, 0, len(m.removedorganizationsetting))
		for id := range m.removedorganizationsetting {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeTemplate:
		ids := make([]ent.Value, 0, len(m.removedtemplate))
		for id := range m.removedtemplate {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeDocumentdata:
		ids := make([]ent.Value, 0, len(m.removeddocumentdata))
		for id := range m.removeddocumentdata {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.removedprogram))
		for id := range m.removedprogram {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.cleareduser {
		edges = append(edges, file.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, file.EdgeOrganization)
	}
	if m.clearedgroup {
		edges = append(edges, file.EdgeGroup)
	}
	if m.clearedcontact {
		edges = append(edges, file.EdgeContact)
	}
	if m.clearedentity {
		edges = append(edges, file.EdgeEntity)
	}
	if m.clearedusersetting {
		edges = append(edges, file.EdgeUsersetting)
	}
	if m.clearedorganizationsetting {
		edges = append(edges, file.EdgeOrganizationsetting)
	}
	if m.clearedtemplate {
		edges = append(edges, file.EdgeTemplate)
	}
	if m.cleareddocumentdata {
		edges = append(edges, file.EdgeDocumentdata)
	}
	if m.clearedevents {
		edges = append(edges, file.EdgeEvents)
	}
	if m.clearedprogram {
		edges = append(edges, file.EdgeProgram)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeUser:
		return m.cleareduser
	case file.EdgeOrganization:
		return m.clearedorganization
	case file.EdgeGroup:
		return m.clearedgroup
	case file.EdgeContact:
		return m.clearedcontact
	case file.EdgeEntity:
		return m.clearedentity
	case file.EdgeUsersetting:
		return m.clearedusersetting
	case file.EdgeOrganizationsetting:
		return m.clearedorganizationsetting
	case file.EdgeTemplate:
		return m.clearedtemplate
	case file.EdgeDocumentdata:
		return m.cleareddocumentdata
	case file.EdgeEvents:
		return m.clearedevents
	case file.EdgeProgram:
		return m.clearedprogram
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeUser:
		m.ResetUser()
		return nil
	case file.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case file.EdgeGroup:
		m.ResetGroup()
		return nil
	case file.EdgeContact:
		m.ResetContact()
		return nil
	case file.EdgeEntity:
		m.ResetEntity()
		return nil
	case file.EdgeUsersetting:
		m.ResetUsersetting()
		return nil
	case file.EdgeOrganizationsetting:
		m.ResetOrganizationsetting()
		return nil
	case file.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case file.EdgeDocumentdata:
		m.ResetDocumentdata()
		return nil
	case file.EdgeEvents:
		m.ResetEvents()
		return nil
	case file.EdgeProgram:
		m.ResetProgram()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FileHistoryMutation represents an operation that mutates the FileHistory nodes in the graph.
type FileHistoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	history_time            *time.Time
	ref                     *string
	operation               *history.OpType
	created_at              *time.Time
	updated_at              *time.Time
	created_by              *string
	updated_by              *string
	deleted_at              *time.Time
	deleted_by              *string
	mapping_id              *string
	tags                    *[]string
	appendtags              []string
	provided_file_name      *string
	provided_file_extension *string
	provided_file_size      *int64
	addprovided_file_size   *int64
	persisted_file_size     *int64
	addpersisted_file_size  *int64
	detected_mime_type      *string
	md5_hash                *string
	detected_content_type   *string
	store_key               *string
	category_type           *string
	uri                     *string
	storage_scheme          *string
	storage_volume          *string
	storage_path            *string
	file_contents           *[]byte
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*FileHistory, error)
	predicates              []predicate.FileHistory
}

var _ ent.Mutation = (*FileHistoryMutation)(nil)

// filehistoryOption allows management of the mutation configuration using functional options.
type filehistoryOption func(*FileHistoryMutation)

// newFileHistoryMutation creates new mutation for the FileHistory entity.
func newFileHistoryMutation(c config, op Op, opts ...filehistoryOption) *FileHistoryMutation {
	m := &FileHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeFileHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileHistoryID sets the ID field of the mutation.
func withFileHistoryID(id string) filehistoryOption {
	return func(m *FileHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *FileHistory
		)
		m.oldValue = func(ctx context.Context) (*FileHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileHistory sets the old FileHistory of the mutation.
func withFileHistory(node *FileHistory) filehistoryOption {
	return func(m *FileHistoryMutation) {
		m.oldValue = func(context.Context) (*FileHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileHistory entities.
func (m *FileHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *FileHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *FileHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *FileHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *FileHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *FileHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *FileHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[filehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *FileHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *FileHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, filehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *FileHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *FileHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *FileHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FileHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[filehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FileHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, filehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FileHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[filehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FileHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, filehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *FileHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FileHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FileHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[filehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FileHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FileHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, filehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FileHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FileHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FileHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[filehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FileHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FileHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, filehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[filehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, filehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FileHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FileHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FileHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[filehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FileHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FileHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, filehistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *FileHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *FileHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *FileHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *FileHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *FileHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *FileHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *FileHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[filehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *FileHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *FileHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, filehistory.FieldTags)
}

// SetProvidedFileName sets the "provided_file_name" field.
func (m *FileHistoryMutation) SetProvidedFileName(s string) {
	m.provided_file_name = &s
}

// ProvidedFileName returns the value of the "provided_file_name" field in the mutation.
func (m *FileHistoryMutation) ProvidedFileName() (r string, exists bool) {
	v := m.provided_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileName returns the old "provided_file_name" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldProvidedFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileName: %w", err)
	}
	return oldValue.ProvidedFileName, nil
}

// ResetProvidedFileName resets all changes to the "provided_file_name" field.
func (m *FileHistoryMutation) ResetProvidedFileName() {
	m.provided_file_name = nil
}

// SetProvidedFileExtension sets the "provided_file_extension" field.
func (m *FileHistoryMutation) SetProvidedFileExtension(s string) {
	m.provided_file_extension = &s
}

// ProvidedFileExtension returns the value of the "provided_file_extension" field in the mutation.
func (m *FileHistoryMutation) ProvidedFileExtension() (r string, exists bool) {
	v := m.provided_file_extension
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileExtension returns the old "provided_file_extension" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldProvidedFileExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileExtension: %w", err)
	}
	return oldValue.ProvidedFileExtension, nil
}

// ResetProvidedFileExtension resets all changes to the "provided_file_extension" field.
func (m *FileHistoryMutation) ResetProvidedFileExtension() {
	m.provided_file_extension = nil
}

// SetProvidedFileSize sets the "provided_file_size" field.
func (m *FileHistoryMutation) SetProvidedFileSize(i int64) {
	m.provided_file_size = &i
	m.addprovided_file_size = nil
}

// ProvidedFileSize returns the value of the "provided_file_size" field in the mutation.
func (m *FileHistoryMutation) ProvidedFileSize() (r int64, exists bool) {
	v := m.provided_file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldProvidedFileSize returns the old "provided_file_size" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldProvidedFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvidedFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvidedFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvidedFileSize: %w", err)
	}
	return oldValue.ProvidedFileSize, nil
}

// AddProvidedFileSize adds i to the "provided_file_size" field.
func (m *FileHistoryMutation) AddProvidedFileSize(i int64) {
	if m.addprovided_file_size != nil {
		*m.addprovided_file_size += i
	} else {
		m.addprovided_file_size = &i
	}
}

// AddedProvidedFileSize returns the value that was added to the "provided_file_size" field in this mutation.
func (m *FileHistoryMutation) AddedProvidedFileSize() (r int64, exists bool) {
	v := m.addprovided_file_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearProvidedFileSize clears the value of the "provided_file_size" field.
func (m *FileHistoryMutation) ClearProvidedFileSize() {
	m.provided_file_size = nil
	m.addprovided_file_size = nil
	m.clearedFields[filehistory.FieldProvidedFileSize] = struct{}{}
}

// ProvidedFileSizeCleared returns if the "provided_file_size" field was cleared in this mutation.
func (m *FileHistoryMutation) ProvidedFileSizeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldProvidedFileSize]
	return ok
}

// ResetProvidedFileSize resets all changes to the "provided_file_size" field.
func (m *FileHistoryMutation) ResetProvidedFileSize() {
	m.provided_file_size = nil
	m.addprovided_file_size = nil
	delete(m.clearedFields, filehistory.FieldProvidedFileSize)
}

// SetPersistedFileSize sets the "persisted_file_size" field.
func (m *FileHistoryMutation) SetPersistedFileSize(i int64) {
	m.persisted_file_size = &i
	m.addpersisted_file_size = nil
}

// PersistedFileSize returns the value of the "persisted_file_size" field in the mutation.
func (m *FileHistoryMutation) PersistedFileSize() (r int64, exists bool) {
	v := m.persisted_file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPersistedFileSize returns the old "persisted_file_size" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldPersistedFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersistedFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersistedFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersistedFileSize: %w", err)
	}
	return oldValue.PersistedFileSize, nil
}

// AddPersistedFileSize adds i to the "persisted_file_size" field.
func (m *FileHistoryMutation) AddPersistedFileSize(i int64) {
	if m.addpersisted_file_size != nil {
		*m.addpersisted_file_size += i
	} else {
		m.addpersisted_file_size = &i
	}
}

// AddedPersistedFileSize returns the value that was added to the "persisted_file_size" field in this mutation.
func (m *FileHistoryMutation) AddedPersistedFileSize() (r int64, exists bool) {
	v := m.addpersisted_file_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearPersistedFileSize clears the value of the "persisted_file_size" field.
func (m *FileHistoryMutation) ClearPersistedFileSize() {
	m.persisted_file_size = nil
	m.addpersisted_file_size = nil
	m.clearedFields[filehistory.FieldPersistedFileSize] = struct{}{}
}

// PersistedFileSizeCleared returns if the "persisted_file_size" field was cleared in this mutation.
func (m *FileHistoryMutation) PersistedFileSizeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldPersistedFileSize]
	return ok
}

// ResetPersistedFileSize resets all changes to the "persisted_file_size" field.
func (m *FileHistoryMutation) ResetPersistedFileSize() {
	m.persisted_file_size = nil
	m.addpersisted_file_size = nil
	delete(m.clearedFields, filehistory.FieldPersistedFileSize)
}

// SetDetectedMimeType sets the "detected_mime_type" field.
func (m *FileHistoryMutation) SetDetectedMimeType(s string) {
	m.detected_mime_type = &s
}

// DetectedMimeType returns the value of the "detected_mime_type" field in the mutation.
func (m *FileHistoryMutation) DetectedMimeType() (r string, exists bool) {
	v := m.detected_mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedMimeType returns the old "detected_mime_type" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldDetectedMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedMimeType: %w", err)
	}
	return oldValue.DetectedMimeType, nil
}

// ClearDetectedMimeType clears the value of the "detected_mime_type" field.
func (m *FileHistoryMutation) ClearDetectedMimeType() {
	m.detected_mime_type = nil
	m.clearedFields[filehistory.FieldDetectedMimeType] = struct{}{}
}

// DetectedMimeTypeCleared returns if the "detected_mime_type" field was cleared in this mutation.
func (m *FileHistoryMutation) DetectedMimeTypeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldDetectedMimeType]
	return ok
}

// ResetDetectedMimeType resets all changes to the "detected_mime_type" field.
func (m *FileHistoryMutation) ResetDetectedMimeType() {
	m.detected_mime_type = nil
	delete(m.clearedFields, filehistory.FieldDetectedMimeType)
}

// SetMd5Hash sets the "md5_hash" field.
func (m *FileHistoryMutation) SetMd5Hash(s string) {
	m.md5_hash = &s
}

// Md5Hash returns the value of the "md5_hash" field in the mutation.
func (m *FileHistoryMutation) Md5Hash() (r string, exists bool) {
	v := m.md5_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5Hash returns the old "md5_hash" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldMd5Hash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5Hash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5Hash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5Hash: %w", err)
	}
	return oldValue.Md5Hash, nil
}

// ClearMd5Hash clears the value of the "md5_hash" field.
func (m *FileHistoryMutation) ClearMd5Hash() {
	m.md5_hash = nil
	m.clearedFields[filehistory.FieldMd5Hash] = struct{}{}
}

// Md5HashCleared returns if the "md5_hash" field was cleared in this mutation.
func (m *FileHistoryMutation) Md5HashCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldMd5Hash]
	return ok
}

// ResetMd5Hash resets all changes to the "md5_hash" field.
func (m *FileHistoryMutation) ResetMd5Hash() {
	m.md5_hash = nil
	delete(m.clearedFields, filehistory.FieldMd5Hash)
}

// SetDetectedContentType sets the "detected_content_type" field.
func (m *FileHistoryMutation) SetDetectedContentType(s string) {
	m.detected_content_type = &s
}

// DetectedContentType returns the value of the "detected_content_type" field in the mutation.
func (m *FileHistoryMutation) DetectedContentType() (r string, exists bool) {
	v := m.detected_content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectedContentType returns the old "detected_content_type" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldDetectedContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectedContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectedContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectedContentType: %w", err)
	}
	return oldValue.DetectedContentType, nil
}

// ResetDetectedContentType resets all changes to the "detected_content_type" field.
func (m *FileHistoryMutation) ResetDetectedContentType() {
	m.detected_content_type = nil
}

// SetStoreKey sets the "store_key" field.
func (m *FileHistoryMutation) SetStoreKey(s string) {
	m.store_key = &s
}

// StoreKey returns the value of the "store_key" field in the mutation.
func (m *FileHistoryMutation) StoreKey() (r string, exists bool) {
	v := m.store_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreKey returns the old "store_key" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStoreKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreKey: %w", err)
	}
	return oldValue.StoreKey, nil
}

// ClearStoreKey clears the value of the "store_key" field.
func (m *FileHistoryMutation) ClearStoreKey() {
	m.store_key = nil
	m.clearedFields[filehistory.FieldStoreKey] = struct{}{}
}

// StoreKeyCleared returns if the "store_key" field was cleared in this mutation.
func (m *FileHistoryMutation) StoreKeyCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStoreKey]
	return ok
}

// ResetStoreKey resets all changes to the "store_key" field.
func (m *FileHistoryMutation) ResetStoreKey() {
	m.store_key = nil
	delete(m.clearedFields, filehistory.FieldStoreKey)
}

// SetCategoryType sets the "category_type" field.
func (m *FileHistoryMutation) SetCategoryType(s string) {
	m.category_type = &s
}

// CategoryType returns the value of the "category_type" field in the mutation.
func (m *FileHistoryMutation) CategoryType() (r string, exists bool) {
	v := m.category_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryType returns the old "category_type" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldCategoryType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryType: %w", err)
	}
	return oldValue.CategoryType, nil
}

// ClearCategoryType clears the value of the "category_type" field.
func (m *FileHistoryMutation) ClearCategoryType() {
	m.category_type = nil
	m.clearedFields[filehistory.FieldCategoryType] = struct{}{}
}

// CategoryTypeCleared returns if the "category_type" field was cleared in this mutation.
func (m *FileHistoryMutation) CategoryTypeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldCategoryType]
	return ok
}

// ResetCategoryType resets all changes to the "category_type" field.
func (m *FileHistoryMutation) ResetCategoryType() {
	m.category_type = nil
	delete(m.clearedFields, filehistory.FieldCategoryType)
}

// SetURI sets the "uri" field.
func (m *FileHistoryMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *FileHistoryMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ClearURI clears the value of the "uri" field.
func (m *FileHistoryMutation) ClearURI() {
	m.uri = nil
	m.clearedFields[filehistory.FieldURI] = struct{}{}
}

// URICleared returns if the "uri" field was cleared in this mutation.
func (m *FileHistoryMutation) URICleared() bool {
	_, ok := m.clearedFields[filehistory.FieldURI]
	return ok
}

// ResetURI resets all changes to the "uri" field.
func (m *FileHistoryMutation) ResetURI() {
	m.uri = nil
	delete(m.clearedFields, filehistory.FieldURI)
}

// SetStorageScheme sets the "storage_scheme" field.
func (m *FileHistoryMutation) SetStorageScheme(s string) {
	m.storage_scheme = &s
}

// StorageScheme returns the value of the "storage_scheme" field in the mutation.
func (m *FileHistoryMutation) StorageScheme() (r string, exists bool) {
	v := m.storage_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageScheme returns the old "storage_scheme" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStorageScheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageScheme: %w", err)
	}
	return oldValue.StorageScheme, nil
}

// ClearStorageScheme clears the value of the "storage_scheme" field.
func (m *FileHistoryMutation) ClearStorageScheme() {
	m.storage_scheme = nil
	m.clearedFields[filehistory.FieldStorageScheme] = struct{}{}
}

// StorageSchemeCleared returns if the "storage_scheme" field was cleared in this mutation.
func (m *FileHistoryMutation) StorageSchemeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStorageScheme]
	return ok
}

// ResetStorageScheme resets all changes to the "storage_scheme" field.
func (m *FileHistoryMutation) ResetStorageScheme() {
	m.storage_scheme = nil
	delete(m.clearedFields, filehistory.FieldStorageScheme)
}

// SetStorageVolume sets the "storage_volume" field.
func (m *FileHistoryMutation) SetStorageVolume(s string) {
	m.storage_volume = &s
}

// StorageVolume returns the value of the "storage_volume" field in the mutation.
func (m *FileHistoryMutation) StorageVolume() (r string, exists bool) {
	v := m.storage_volume
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageVolume returns the old "storage_volume" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStorageVolume(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageVolume: %w", err)
	}
	return oldValue.StorageVolume, nil
}

// ClearStorageVolume clears the value of the "storage_volume" field.
func (m *FileHistoryMutation) ClearStorageVolume() {
	m.storage_volume = nil
	m.clearedFields[filehistory.FieldStorageVolume] = struct{}{}
}

// StorageVolumeCleared returns if the "storage_volume" field was cleared in this mutation.
func (m *FileHistoryMutation) StorageVolumeCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStorageVolume]
	return ok
}

// ResetStorageVolume resets all changes to the "storage_volume" field.
func (m *FileHistoryMutation) ResetStorageVolume() {
	m.storage_volume = nil
	delete(m.clearedFields, filehistory.FieldStorageVolume)
}

// SetStoragePath sets the "storage_path" field.
func (m *FileHistoryMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *FileHistoryMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ClearStoragePath clears the value of the "storage_path" field.
func (m *FileHistoryMutation) ClearStoragePath() {
	m.storage_path = nil
	m.clearedFields[filehistory.FieldStoragePath] = struct{}{}
}

// StoragePathCleared returns if the "storage_path" field was cleared in this mutation.
func (m *FileHistoryMutation) StoragePathCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldStoragePath]
	return ok
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *FileHistoryMutation) ResetStoragePath() {
	m.storage_path = nil
	delete(m.clearedFields, filehistory.FieldStoragePath)
}

// SetFileContents sets the "file_contents" field.
func (m *FileHistoryMutation) SetFileContents(b []byte) {
	m.file_contents = &b
}

// FileContents returns the value of the "file_contents" field in the mutation.
func (m *FileHistoryMutation) FileContents() (r []byte, exists bool) {
	v := m.file_contents
	if v == nil {
		return
	}
	return *v, true
}

// OldFileContents returns the old "file_contents" field's value of the FileHistory entity.
// If the FileHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHistoryMutation) OldFileContents(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileContents: %w", err)
	}
	return oldValue.FileContents, nil
}

// ClearFileContents clears the value of the "file_contents" field.
func (m *FileHistoryMutation) ClearFileContents() {
	m.file_contents = nil
	m.clearedFields[filehistory.FieldFileContents] = struct{}{}
}

// FileContentsCleared returns if the "file_contents" field was cleared in this mutation.
func (m *FileHistoryMutation) FileContentsCleared() bool {
	_, ok := m.clearedFields[filehistory.FieldFileContents]
	return ok
}

// ResetFileContents resets all changes to the "file_contents" field.
func (m *FileHistoryMutation) ResetFileContents() {
	m.file_contents = nil
	delete(m.clearedFields, filehistory.FieldFileContents)
}

// Where appends a list predicates to the FileHistoryMutation builder.
func (m *FileHistoryMutation) Where(ps ...predicate.FileHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileHistory).
func (m *FileHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileHistoryMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.history_time != nil {
		fields = append(fields, filehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, filehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, filehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, filehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, filehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, filehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, filehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, filehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, filehistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, filehistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, filehistory.FieldTags)
	}
	if m.provided_file_name != nil {
		fields = append(fields, filehistory.FieldProvidedFileName)
	}
	if m.provided_file_extension != nil {
		fields = append(fields, filehistory.FieldProvidedFileExtension)
	}
	if m.provided_file_size != nil {
		fields = append(fields, filehistory.FieldProvidedFileSize)
	}
	if m.persisted_file_size != nil {
		fields = append(fields, filehistory.FieldPersistedFileSize)
	}
	if m.detected_mime_type != nil {
		fields = append(fields, filehistory.FieldDetectedMimeType)
	}
	if m.md5_hash != nil {
		fields = append(fields, filehistory.FieldMd5Hash)
	}
	if m.detected_content_type != nil {
		fields = append(fields, filehistory.FieldDetectedContentType)
	}
	if m.store_key != nil {
		fields = append(fields, filehistory.FieldStoreKey)
	}
	if m.category_type != nil {
		fields = append(fields, filehistory.FieldCategoryType)
	}
	if m.uri != nil {
		fields = append(fields, filehistory.FieldURI)
	}
	if m.storage_scheme != nil {
		fields = append(fields, filehistory.FieldStorageScheme)
	}
	if m.storage_volume != nil {
		fields = append(fields, filehistory.FieldStorageVolume)
	}
	if m.storage_path != nil {
		fields = append(fields, filehistory.FieldStoragePath)
	}
	if m.file_contents != nil {
		fields = append(fields, filehistory.FieldFileContents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filehistory.FieldHistoryTime:
		return m.HistoryTime()
	case filehistory.FieldRef:
		return m.Ref()
	case filehistory.FieldOperation:
		return m.Operation()
	case filehistory.FieldCreatedAt:
		return m.CreatedAt()
	case filehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case filehistory.FieldCreatedBy:
		return m.CreatedBy()
	case filehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case filehistory.FieldDeletedAt:
		return m.DeletedAt()
	case filehistory.FieldDeletedBy:
		return m.DeletedBy()
	case filehistory.FieldMappingID:
		return m.MappingID()
	case filehistory.FieldTags:
		return m.Tags()
	case filehistory.FieldProvidedFileName:
		return m.ProvidedFileName()
	case filehistory.FieldProvidedFileExtension:
		return m.ProvidedFileExtension()
	case filehistory.FieldProvidedFileSize:
		return m.ProvidedFileSize()
	case filehistory.FieldPersistedFileSize:
		return m.PersistedFileSize()
	case filehistory.FieldDetectedMimeType:
		return m.DetectedMimeType()
	case filehistory.FieldMd5Hash:
		return m.Md5Hash()
	case filehistory.FieldDetectedContentType:
		return m.DetectedContentType()
	case filehistory.FieldStoreKey:
		return m.StoreKey()
	case filehistory.FieldCategoryType:
		return m.CategoryType()
	case filehistory.FieldURI:
		return m.URI()
	case filehistory.FieldStorageScheme:
		return m.StorageScheme()
	case filehistory.FieldStorageVolume:
		return m.StorageVolume()
	case filehistory.FieldStoragePath:
		return m.StoragePath()
	case filehistory.FieldFileContents:
		return m.FileContents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case filehistory.FieldRef:
		return m.OldRef(ctx)
	case filehistory.FieldOperation:
		return m.OldOperation(ctx)
	case filehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case filehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case filehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case filehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case filehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case filehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case filehistory.FieldTags:
		return m.OldTags(ctx)
	case filehistory.FieldProvidedFileName:
		return m.OldProvidedFileName(ctx)
	case filehistory.FieldProvidedFileExtension:
		return m.OldProvidedFileExtension(ctx)
	case filehistory.FieldProvidedFileSize:
		return m.OldProvidedFileSize(ctx)
	case filehistory.FieldPersistedFileSize:
		return m.OldPersistedFileSize(ctx)
	case filehistory.FieldDetectedMimeType:
		return m.OldDetectedMimeType(ctx)
	case filehistory.FieldMd5Hash:
		return m.OldMd5Hash(ctx)
	case filehistory.FieldDetectedContentType:
		return m.OldDetectedContentType(ctx)
	case filehistory.FieldStoreKey:
		return m.OldStoreKey(ctx)
	case filehistory.FieldCategoryType:
		return m.OldCategoryType(ctx)
	case filehistory.FieldURI:
		return m.OldURI(ctx)
	case filehistory.FieldStorageScheme:
		return m.OldStorageScheme(ctx)
	case filehistory.FieldStorageVolume:
		return m.OldStorageVolume(ctx)
	case filehistory.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case filehistory.FieldFileContents:
		return m.OldFileContents(ctx)
	}
	return nil, fmt.Errorf("unknown FileHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case filehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case filehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case filehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case filehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case filehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case filehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case filehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case filehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case filehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case filehistory.FieldProvidedFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileName(v)
		return nil
	case filehistory.FieldProvidedFileExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileExtension(v)
		return nil
	case filehistory.FieldProvidedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvidedFileSize(v)
		return nil
	case filehistory.FieldPersistedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersistedFileSize(v)
		return nil
	case filehistory.FieldDetectedMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedMimeType(v)
		return nil
	case filehistory.FieldMd5Hash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5Hash(v)
		return nil
	case filehistory.FieldDetectedContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectedContentType(v)
		return nil
	case filehistory.FieldStoreKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreKey(v)
		return nil
	case filehistory.FieldCategoryType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryType(v)
		return nil
	case filehistory.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	case filehistory.FieldStorageScheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageScheme(v)
		return nil
	case filehistory.FieldStorageVolume:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageVolume(v)
		return nil
	case filehistory.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case filehistory.FieldFileContents:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileContents(v)
		return nil
	}
	return fmt.Errorf("unknown FileHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addprovided_file_size != nil {
		fields = append(fields, filehistory.FieldProvidedFileSize)
	}
	if m.addpersisted_file_size != nil {
		fields = append(fields, filehistory.FieldPersistedFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filehistory.FieldProvidedFileSize:
		return m.AddedProvidedFileSize()
	case filehistory.FieldPersistedFileSize:
		return m.AddedPersistedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filehistory.FieldProvidedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvidedFileSize(v)
		return nil
	case filehistory.FieldPersistedFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPersistedFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown FileHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filehistory.FieldRef) {
		fields = append(fields, filehistory.FieldRef)
	}
	if m.FieldCleared(filehistory.FieldCreatedAt) {
		fields = append(fields, filehistory.FieldCreatedAt)
	}
	if m.FieldCleared(filehistory.FieldUpdatedAt) {
		fields = append(fields, filehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(filehistory.FieldCreatedBy) {
		fields = append(fields, filehistory.FieldCreatedBy)
	}
	if m.FieldCleared(filehistory.FieldUpdatedBy) {
		fields = append(fields, filehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(filehistory.FieldDeletedAt) {
		fields = append(fields, filehistory.FieldDeletedAt)
	}
	if m.FieldCleared(filehistory.FieldDeletedBy) {
		fields = append(fields, filehistory.FieldDeletedBy)
	}
	if m.FieldCleared(filehistory.FieldTags) {
		fields = append(fields, filehistory.FieldTags)
	}
	if m.FieldCleared(filehistory.FieldProvidedFileSize) {
		fields = append(fields, filehistory.FieldProvidedFileSize)
	}
	if m.FieldCleared(filehistory.FieldPersistedFileSize) {
		fields = append(fields, filehistory.FieldPersistedFileSize)
	}
	if m.FieldCleared(filehistory.FieldDetectedMimeType) {
		fields = append(fields, filehistory.FieldDetectedMimeType)
	}
	if m.FieldCleared(filehistory.FieldMd5Hash) {
		fields = append(fields, filehistory.FieldMd5Hash)
	}
	if m.FieldCleared(filehistory.FieldStoreKey) {
		fields = append(fields, filehistory.FieldStoreKey)
	}
	if m.FieldCleared(filehistory.FieldCategoryType) {
		fields = append(fields, filehistory.FieldCategoryType)
	}
	if m.FieldCleared(filehistory.FieldURI) {
		fields = append(fields, filehistory.FieldURI)
	}
	if m.FieldCleared(filehistory.FieldStorageScheme) {
		fields = append(fields, filehistory.FieldStorageScheme)
	}
	if m.FieldCleared(filehistory.FieldStorageVolume) {
		fields = append(fields, filehistory.FieldStorageVolume)
	}
	if m.FieldCleared(filehistory.FieldStoragePath) {
		fields = append(fields, filehistory.FieldStoragePath)
	}
	if m.FieldCleared(filehistory.FieldFileContents) {
		fields = append(fields, filehistory.FieldFileContents)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileHistoryMutation) ClearField(name string) error {
	switch name {
	case filehistory.FieldRef:
		m.ClearRef()
		return nil
	case filehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case filehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case filehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case filehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case filehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case filehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case filehistory.FieldTags:
		m.ClearTags()
		return nil
	case filehistory.FieldProvidedFileSize:
		m.ClearProvidedFileSize()
		return nil
	case filehistory.FieldPersistedFileSize:
		m.ClearPersistedFileSize()
		return nil
	case filehistory.FieldDetectedMimeType:
		m.ClearDetectedMimeType()
		return nil
	case filehistory.FieldMd5Hash:
		m.ClearMd5Hash()
		return nil
	case filehistory.FieldStoreKey:
		m.ClearStoreKey()
		return nil
	case filehistory.FieldCategoryType:
		m.ClearCategoryType()
		return nil
	case filehistory.FieldURI:
		m.ClearURI()
		return nil
	case filehistory.FieldStorageScheme:
		m.ClearStorageScheme()
		return nil
	case filehistory.FieldStorageVolume:
		m.ClearStorageVolume()
		return nil
	case filehistory.FieldStoragePath:
		m.ClearStoragePath()
		return nil
	case filehistory.FieldFileContents:
		m.ClearFileContents()
		return nil
	}
	return fmt.Errorf("unknown FileHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileHistoryMutation) ResetField(name string) error {
	switch name {
	case filehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case filehistory.FieldRef:
		m.ResetRef()
		return nil
	case filehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case filehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case filehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case filehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case filehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case filehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case filehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case filehistory.FieldTags:
		m.ResetTags()
		return nil
	case filehistory.FieldProvidedFileName:
		m.ResetProvidedFileName()
		return nil
	case filehistory.FieldProvidedFileExtension:
		m.ResetProvidedFileExtension()
		return nil
	case filehistory.FieldProvidedFileSize:
		m.ResetProvidedFileSize()
		return nil
	case filehistory.FieldPersistedFileSize:
		m.ResetPersistedFileSize()
		return nil
	case filehistory.FieldDetectedMimeType:
		m.ResetDetectedMimeType()
		return nil
	case filehistory.FieldMd5Hash:
		m.ResetMd5Hash()
		return nil
	case filehistory.FieldDetectedContentType:
		m.ResetDetectedContentType()
		return nil
	case filehistory.FieldStoreKey:
		m.ResetStoreKey()
		return nil
	case filehistory.FieldCategoryType:
		m.ResetCategoryType()
		return nil
	case filehistory.FieldURI:
		m.ResetURI()
		return nil
	case filehistory.FieldStorageScheme:
		m.ResetStorageScheme()
		return nil
	case filehistory.FieldStorageVolume:
		m.ResetStorageVolume()
		return nil
	case filehistory.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case filehistory.FieldFileContents:
		m.ResetFileContents()
		return nil
	}
	return fmt.Errorf("unknown FileHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FileHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FileHistory edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	deleted_at          *time.Time
	deleted_by          *string
	mapping_id          *string
	tags                *[]string
	appendtags          []string
	name                *string
	description         *string
	gravatar_logo_url   *string
	logo_url            *string
	display_name        *string
	clearedFields       map[string]struct{}
	owner               *string
	clearedowner        bool
	setting             *string
	clearedsetting      bool
	users               map[string]struct{}
	removedusers        map[string]struct{}
	clearedusers        bool
	events              map[string]struct{}
	removedevents       map[string]struct{}
	clearedevents       bool
	integrations        map[string]struct{}
	removedintegrations map[string]struct{}
	clearedintegrations bool
	files               map[string]struct{}
	removedfiles        map[string]struct{}
	clearedfiles        bool
	tasks               map[string]struct{}
	removedtasks        map[string]struct{}
	clearedtasks        bool
	members             map[string]struct{}
	removedmembers      map[string]struct{}
	clearedmembers      bool
	done                bool
	oldValue            func(context.Context) (*Group, error)
	predicates          []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id string) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[group.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, group.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[group.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, group.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[group.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[group.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, group.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[group.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[group.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, group.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[group.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, group.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[group.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[group.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, group.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *GroupMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *GroupMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *GroupMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *GroupMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *GroupMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *GroupMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *GroupMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *GroupMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[group.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *GroupMutation) TagsCleared() bool {
	_, ok := m.clearedFields[group.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *GroupMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, group.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *GroupMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GroupMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *GroupMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[group.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *GroupMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[group.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GroupMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, group.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[group.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[group.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, group.FieldDescription)
}

// SetGravatarLogoURL sets the "gravatar_logo_url" field.
func (m *GroupMutation) SetGravatarLogoURL(s string) {
	m.gravatar_logo_url = &s
}

// GravatarLogoURL returns the value of the "gravatar_logo_url" field in the mutation.
func (m *GroupMutation) GravatarLogoURL() (r string, exists bool) {
	v := m.gravatar_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGravatarLogoURL returns the old "gravatar_logo_url" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldGravatarLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGravatarLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGravatarLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGravatarLogoURL: %w", err)
	}
	return oldValue.GravatarLogoURL, nil
}

// ClearGravatarLogoURL clears the value of the "gravatar_logo_url" field.
func (m *GroupMutation) ClearGravatarLogoURL() {
	m.gravatar_logo_url = nil
	m.clearedFields[group.FieldGravatarLogoURL] = struct{}{}
}

// GravatarLogoURLCleared returns if the "gravatar_logo_url" field was cleared in this mutation.
func (m *GroupMutation) GravatarLogoURLCleared() bool {
	_, ok := m.clearedFields[group.FieldGravatarLogoURL]
	return ok
}

// ResetGravatarLogoURL resets all changes to the "gravatar_logo_url" field.
func (m *GroupMutation) ResetGravatarLogoURL() {
	m.gravatar_logo_url = nil
	delete(m.clearedFields, group.FieldGravatarLogoURL)
}

// SetLogoURL sets the "logo_url" field.
func (m *GroupMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *GroupMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *GroupMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[group.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *GroupMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[group.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *GroupMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, group.FieldLogoURL)
}

// SetDisplayName sets the "display_name" field.
func (m *GroupMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *GroupMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *GroupMutation) ResetDisplayName() {
	m.display_name = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *GroupMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[group.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *GroupMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *GroupMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetSettingID sets the "setting" edge to the GroupSetting entity by id.
func (m *GroupMutation) SetSettingID(id string) {
	m.setting = &id
}

// ClearSetting clears the "setting" edge to the GroupSetting entity.
func (m *GroupMutation) ClearSetting() {
	m.clearedsetting = true
}

// SettingCleared reports if the "setting" edge to the GroupSetting entity was cleared.
func (m *GroupMutation) SettingCleared() bool {
	return m.clearedsetting
}

// SettingID returns the "setting" edge ID in the mutation.
func (m *GroupMutation) SettingID() (id string, exists bool) {
	if m.setting != nil {
		return *m.setting, true
	}
	return
}

// SettingIDs returns the "setting" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) SettingIDs() (ids []string) {
	if id := m.setting; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSetting resets all changes to the "setting" edge.
func (m *GroupMutation) ResetSetting() {
	m.setting = nil
	m.clearedsetting = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *GroupMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *GroupMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *GroupMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *GroupMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *GroupMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *GroupMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *GroupMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *GroupMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *GroupMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *GroupMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *GroupMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *GroupMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddIntegrationIDs adds the "integrations" edge to the Integration entity by ids.
func (m *GroupMutation) AddIntegrationIDs(ids ...string) {
	if m.integrations == nil {
		m.integrations = make(map[string]struct{})
	}
	for i := range ids {
		m.integrations[ids[i]] = struct{}{}
	}
}

// ClearIntegrations clears the "integrations" edge to the Integration entity.
func (m *GroupMutation) ClearIntegrations() {
	m.clearedintegrations = true
}

// IntegrationsCleared reports if the "integrations" edge to the Integration entity was cleared.
func (m *GroupMutation) IntegrationsCleared() bool {
	return m.clearedintegrations
}

// RemoveIntegrationIDs removes the "integrations" edge to the Integration entity by IDs.
func (m *GroupMutation) RemoveIntegrationIDs(ids ...string) {
	if m.removedintegrations == nil {
		m.removedintegrations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.integrations, ids[i])
		m.removedintegrations[ids[i]] = struct{}{}
	}
}

// RemovedIntegrations returns the removed IDs of the "integrations" edge to the Integration entity.
func (m *GroupMutation) RemovedIntegrationsIDs() (ids []string) {
	for id := range m.removedintegrations {
		ids = append(ids, id)
	}
	return
}

// IntegrationsIDs returns the "integrations" edge IDs in the mutation.
func (m *GroupMutation) IntegrationsIDs() (ids []string) {
	for id := range m.integrations {
		ids = append(ids, id)
	}
	return
}

// ResetIntegrations resets all changes to the "integrations" edge.
func (m *GroupMutation) ResetIntegrations() {
	m.integrations = nil
	m.clearedintegrations = false
	m.removedintegrations = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *GroupMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *GroupMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *GroupMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *GroupMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *GroupMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *GroupMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *GroupMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *GroupMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *GroupMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *GroupMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *GroupMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *GroupMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *GroupMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *GroupMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddMemberIDs adds the "members" edge to the GroupMembership entity by ids.
func (m *GroupMutation) AddMemberIDs(ids ...string) {
	if m.members == nil {
		m.members = make(map[string]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the GroupMembership entity.
func (m *GroupMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the GroupMembership entity was cleared.
func (m *GroupMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the GroupMembership entity by IDs.
func (m *GroupMutation) RemoveMemberIDs(ids ...string) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the GroupMembership entity.
func (m *GroupMutation) RemovedMembersIDs() (ids []string) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *GroupMutation) MembersIDs() (ids []string) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *GroupMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, group.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, group.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, group.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, group.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, group.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, group.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.description != nil {
		fields = append(fields, group.FieldDescription)
	}
	if m.gravatar_logo_url != nil {
		fields = append(fields, group.FieldGravatarLogoURL)
	}
	if m.logo_url != nil {
		fields = append(fields, group.FieldLogoURL)
	}
	if m.display_name != nil {
		fields = append(fields, group.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldCreatedBy:
		return m.CreatedBy()
	case group.FieldUpdatedBy:
		return m.UpdatedBy()
	case group.FieldDeletedAt:
		return m.DeletedAt()
	case group.FieldDeletedBy:
		return m.DeletedBy()
	case group.FieldMappingID:
		return m.MappingID()
	case group.FieldTags:
		return m.Tags()
	case group.FieldOwnerID:
		return m.OwnerID()
	case group.FieldName:
		return m.Name()
	case group.FieldDescription:
		return m.Description()
	case group.FieldGravatarLogoURL:
		return m.GravatarLogoURL()
	case group.FieldLogoURL:
		return m.LogoURL()
	case group.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case group.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case group.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case group.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case group.FieldMappingID:
		return m.OldMappingID(ctx)
	case group.FieldTags:
		return m.OldTags(ctx)
	case group.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	case group.FieldGravatarLogoURL:
		return m.OldGravatarLogoURL(ctx)
	case group.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case group.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case group.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case group.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case group.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case group.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case group.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case group.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case group.FieldGravatarLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGravatarLogoURL(v)
		return nil
	case group.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case group.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldCreatedAt) {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.FieldCleared(group.FieldUpdatedAt) {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.FieldCleared(group.FieldCreatedBy) {
		fields = append(fields, group.FieldCreatedBy)
	}
	if m.FieldCleared(group.FieldUpdatedBy) {
		fields = append(fields, group.FieldUpdatedBy)
	}
	if m.FieldCleared(group.FieldDeletedAt) {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.FieldCleared(group.FieldDeletedBy) {
		fields = append(fields, group.FieldDeletedBy)
	}
	if m.FieldCleared(group.FieldTags) {
		fields = append(fields, group.FieldTags)
	}
	if m.FieldCleared(group.FieldOwnerID) {
		fields = append(fields, group.FieldOwnerID)
	}
	if m.FieldCleared(group.FieldDescription) {
		fields = append(fields, group.FieldDescription)
	}
	if m.FieldCleared(group.FieldGravatarLogoURL) {
		fields = append(fields, group.FieldGravatarLogoURL)
	}
	if m.FieldCleared(group.FieldLogoURL) {
		fields = append(fields, group.FieldLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case group.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case group.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case group.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case group.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case group.FieldTags:
		m.ClearTags()
		return nil
	case group.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case group.FieldDescription:
		m.ClearDescription()
		return nil
	case group.FieldGravatarLogoURL:
		m.ClearGravatarLogoURL()
		return nil
	case group.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case group.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case group.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case group.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case group.FieldMappingID:
		m.ResetMappingID()
		return nil
	case group.FieldTags:
		m.ResetTags()
		return nil
	case group.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	case group.FieldGravatarLogoURL:
		m.ResetGravatarLogoURL()
		return nil
	case group.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case group.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.owner != nil {
		edges = append(edges, group.EdgeOwner)
	}
	if m.setting != nil {
		edges = append(edges, group.EdgeSetting)
	}
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.events != nil {
		edges = append(edges, group.EdgeEvents)
	}
	if m.integrations != nil {
		edges = append(edges, group.EdgeIntegrations)
	}
	if m.files != nil {
		edges = append(edges, group.EdgeFiles)
	}
	if m.tasks != nil {
		edges = append(edges, group.EdgeTasks)
	}
	if m.members != nil {
		edges = append(edges, group.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case group.EdgeSetting:
		if id := m.setting; id != nil {
			return []ent.Value{*id}
		}
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.integrations))
		for id := range m.integrations {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	if m.removedevents != nil {
		edges = append(edges, group.EdgeEvents)
	}
	if m.removedintegrations != nil {
		edges = append(edges, group.EdgeIntegrations)
	}
	if m.removedfiles != nil {
		edges = append(edges, group.EdgeFiles)
	}
	if m.removedtasks != nil {
		edges = append(edges, group.EdgeTasks)
	}
	if m.removedmembers != nil {
		edges = append(edges, group.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.removedintegrations))
		for id := range m.removedintegrations {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedowner {
		edges = append(edges, group.EdgeOwner)
	}
	if m.clearedsetting {
		edges = append(edges, group.EdgeSetting)
	}
	if m.clearedusers {
		edges = append(edges, group.EdgeUsers)
	}
	if m.clearedevents {
		edges = append(edges, group.EdgeEvents)
	}
	if m.clearedintegrations {
		edges = append(edges, group.EdgeIntegrations)
	}
	if m.clearedfiles {
		edges = append(edges, group.EdgeFiles)
	}
	if m.clearedtasks {
		edges = append(edges, group.EdgeTasks)
	}
	if m.clearedmembers {
		edges = append(edges, group.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeOwner:
		return m.clearedowner
	case group.EdgeSetting:
		return m.clearedsetting
	case group.EdgeUsers:
		return m.clearedusers
	case group.EdgeEvents:
		return m.clearedevents
	case group.EdgeIntegrations:
		return m.clearedintegrations
	case group.EdgeFiles:
		return m.clearedfiles
	case group.EdgeTasks:
		return m.clearedtasks
	case group.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	case group.EdgeOwner:
		m.ClearOwner()
		return nil
	case group.EdgeSetting:
		m.ClearSetting()
		return nil
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeOwner:
		m.ResetOwner()
		return nil
	case group.EdgeSetting:
		m.ResetSetting()
		return nil
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	case group.EdgeEvents:
		m.ResetEvents()
		return nil
	case group.EdgeIntegrations:
		m.ResetIntegrations()
		return nil
	case group.EdgeFiles:
		m.ResetFiles()
		return nil
	case group.EdgeTasks:
		m.ResetTasks()
		return nil
	case group.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// GroupHistoryMutation represents an operation that mutates the GroupHistory nodes in the graph.
type GroupHistoryMutation struct {
	config
	op                Op
	typ               string
	id                *string
	history_time      *time.Time
	ref               *string
	operation         *history.OpType
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	deleted_at        *time.Time
	deleted_by        *string
	mapping_id        *string
	tags              *[]string
	appendtags        []string
	owner_id          *string
	name              *string
	description       *string
	gravatar_logo_url *string
	logo_url          *string
	display_name      *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*GroupHistory, error)
	predicates        []predicate.GroupHistory
}

var _ ent.Mutation = (*GroupHistoryMutation)(nil)

// grouphistoryOption allows management of the mutation configuration using functional options.
type grouphistoryOption func(*GroupHistoryMutation)

// newGroupHistoryMutation creates new mutation for the GroupHistory entity.
func newGroupHistoryMutation(c config, op Op, opts ...grouphistoryOption) *GroupHistoryMutation {
	m := &GroupHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupHistoryID sets the ID field of the mutation.
func withGroupHistoryID(id string) grouphistoryOption {
	return func(m *GroupHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupHistory
		)
		m.oldValue = func(ctx context.Context) (*GroupHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupHistory sets the old GroupHistory of the mutation.
func withGroupHistory(node *GroupHistory) grouphistoryOption {
	return func(m *GroupHistoryMutation) {
		m.oldValue = func(context.Context) (*GroupHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupHistory entities.
func (m *GroupHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *GroupHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *GroupHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *GroupHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *GroupHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *GroupHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *GroupHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[grouphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *GroupHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *GroupHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, grouphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *GroupHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *GroupHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *GroupHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[grouphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, grouphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[grouphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, grouphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[grouphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, grouphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[grouphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, grouphistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[grouphistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, grouphistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[grouphistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, grouphistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *GroupHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *GroupHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *GroupHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *GroupHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *GroupHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *GroupHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *GroupHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *GroupHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[grouphistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *GroupHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *GroupHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, grouphistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *GroupHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GroupHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *GroupHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[grouphistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *GroupHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GroupHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, grouphistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *GroupHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[grouphistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, grouphistory.FieldDescription)
}

// SetGravatarLogoURL sets the "gravatar_logo_url" field.
func (m *GroupHistoryMutation) SetGravatarLogoURL(s string) {
	m.gravatar_logo_url = &s
}

// GravatarLogoURL returns the value of the "gravatar_logo_url" field in the mutation.
func (m *GroupHistoryMutation) GravatarLogoURL() (r string, exists bool) {
	v := m.gravatar_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGravatarLogoURL returns the old "gravatar_logo_url" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldGravatarLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGravatarLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGravatarLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGravatarLogoURL: %w", err)
	}
	return oldValue.GravatarLogoURL, nil
}

// ClearGravatarLogoURL clears the value of the "gravatar_logo_url" field.
func (m *GroupHistoryMutation) ClearGravatarLogoURL() {
	m.gravatar_logo_url = nil
	m.clearedFields[grouphistory.FieldGravatarLogoURL] = struct{}{}
}

// GravatarLogoURLCleared returns if the "gravatar_logo_url" field was cleared in this mutation.
func (m *GroupHistoryMutation) GravatarLogoURLCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldGravatarLogoURL]
	return ok
}

// ResetGravatarLogoURL resets all changes to the "gravatar_logo_url" field.
func (m *GroupHistoryMutation) ResetGravatarLogoURL() {
	m.gravatar_logo_url = nil
	delete(m.clearedFields, grouphistory.FieldGravatarLogoURL)
}

// SetLogoURL sets the "logo_url" field.
func (m *GroupHistoryMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *GroupHistoryMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *GroupHistoryMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[grouphistory.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *GroupHistoryMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[grouphistory.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *GroupHistoryMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, grouphistory.FieldLogoURL)
}

// SetDisplayName sets the "display_name" field.
func (m *GroupHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *GroupHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the GroupHistory entity.
// If the GroupHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *GroupHistoryMutation) ResetDisplayName() {
	m.display_name = nil
}

// Where appends a list predicates to the GroupHistoryMutation builder.
func (m *GroupHistoryMutation) Where(ps ...predicate.GroupHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupHistory).
func (m *GroupHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, grouphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, grouphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, grouphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, grouphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, grouphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, grouphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, grouphistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, grouphistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, grouphistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, grouphistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, grouphistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, grouphistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, grouphistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, grouphistory.FieldDescription)
	}
	if m.gravatar_logo_url != nil {
		fields = append(fields, grouphistory.FieldGravatarLogoURL)
	}
	if m.logo_url != nil {
		fields = append(fields, grouphistory.FieldLogoURL)
	}
	if m.display_name != nil {
		fields = append(fields, grouphistory.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grouphistory.FieldHistoryTime:
		return m.HistoryTime()
	case grouphistory.FieldRef:
		return m.Ref()
	case grouphistory.FieldOperation:
		return m.Operation()
	case grouphistory.FieldCreatedAt:
		return m.CreatedAt()
	case grouphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case grouphistory.FieldCreatedBy:
		return m.CreatedBy()
	case grouphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case grouphistory.FieldDeletedAt:
		return m.DeletedAt()
	case grouphistory.FieldDeletedBy:
		return m.DeletedBy()
	case grouphistory.FieldMappingID:
		return m.MappingID()
	case grouphistory.FieldTags:
		return m.Tags()
	case grouphistory.FieldOwnerID:
		return m.OwnerID()
	case grouphistory.FieldName:
		return m.Name()
	case grouphistory.FieldDescription:
		return m.Description()
	case grouphistory.FieldGravatarLogoURL:
		return m.GravatarLogoURL()
	case grouphistory.FieldLogoURL:
		return m.LogoURL()
	case grouphistory.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grouphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case grouphistory.FieldRef:
		return m.OldRef(ctx)
	case grouphistory.FieldOperation:
		return m.OldOperation(ctx)
	case grouphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grouphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case grouphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case grouphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case grouphistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case grouphistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case grouphistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case grouphistory.FieldTags:
		return m.OldTags(ctx)
	case grouphistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case grouphistory.FieldName:
		return m.OldName(ctx)
	case grouphistory.FieldDescription:
		return m.OldDescription(ctx)
	case grouphistory.FieldGravatarLogoURL:
		return m.OldGravatarLogoURL(ctx)
	case grouphistory.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case grouphistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown GroupHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grouphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case grouphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case grouphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case grouphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grouphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case grouphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case grouphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case grouphistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case grouphistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case grouphistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case grouphistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case grouphistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case grouphistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case grouphistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case grouphistory.FieldGravatarLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGravatarLogoURL(v)
		return nil
	case grouphistory.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case grouphistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown GroupHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grouphistory.FieldRef) {
		fields = append(fields, grouphistory.FieldRef)
	}
	if m.FieldCleared(grouphistory.FieldCreatedAt) {
		fields = append(fields, grouphistory.FieldCreatedAt)
	}
	if m.FieldCleared(grouphistory.FieldUpdatedAt) {
		fields = append(fields, grouphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(grouphistory.FieldCreatedBy) {
		fields = append(fields, grouphistory.FieldCreatedBy)
	}
	if m.FieldCleared(grouphistory.FieldUpdatedBy) {
		fields = append(fields, grouphistory.FieldUpdatedBy)
	}
	if m.FieldCleared(grouphistory.FieldDeletedAt) {
		fields = append(fields, grouphistory.FieldDeletedAt)
	}
	if m.FieldCleared(grouphistory.FieldDeletedBy) {
		fields = append(fields, grouphistory.FieldDeletedBy)
	}
	if m.FieldCleared(grouphistory.FieldTags) {
		fields = append(fields, grouphistory.FieldTags)
	}
	if m.FieldCleared(grouphistory.FieldOwnerID) {
		fields = append(fields, grouphistory.FieldOwnerID)
	}
	if m.FieldCleared(grouphistory.FieldDescription) {
		fields = append(fields, grouphistory.FieldDescription)
	}
	if m.FieldCleared(grouphistory.FieldGravatarLogoURL) {
		fields = append(fields, grouphistory.FieldGravatarLogoURL)
	}
	if m.FieldCleared(grouphistory.FieldLogoURL) {
		fields = append(fields, grouphistory.FieldLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupHistoryMutation) ClearField(name string) error {
	switch name {
	case grouphistory.FieldRef:
		m.ClearRef()
		return nil
	case grouphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case grouphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case grouphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case grouphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case grouphistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case grouphistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case grouphistory.FieldTags:
		m.ClearTags()
		return nil
	case grouphistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case grouphistory.FieldDescription:
		m.ClearDescription()
		return nil
	case grouphistory.FieldGravatarLogoURL:
		m.ClearGravatarLogoURL()
		return nil
	case grouphistory.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	}
	return fmt.Errorf("unknown GroupHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupHistoryMutation) ResetField(name string) error {
	switch name {
	case grouphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case grouphistory.FieldRef:
		m.ResetRef()
		return nil
	case grouphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case grouphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grouphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case grouphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case grouphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case grouphistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case grouphistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case grouphistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case grouphistory.FieldTags:
		m.ResetTags()
		return nil
	case grouphistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case grouphistory.FieldName:
		m.ResetName()
		return nil
	case grouphistory.FieldDescription:
		m.ResetDescription()
		return nil
	case grouphistory.FieldGravatarLogoURL:
		m.ResetGravatarLogoURL()
		return nil
	case grouphistory.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case grouphistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown GroupHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupHistory edge %s", name)
}

// GroupMembershipMutation represents an operation that mutates the GroupMembership nodes in the graph.
type GroupMembershipMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	role          *enums.Role
	clearedFields map[string]struct{}
	group         *string
	clearedgroup  bool
	user          *string
	cleareduser   bool
	events        map[string]struct{}
	removedevents map[string]struct{}
	clearedevents bool
	done          bool
	oldValue      func(context.Context) (*GroupMembership, error)
	predicates    []predicate.GroupMembership
}

var _ ent.Mutation = (*GroupMembershipMutation)(nil)

// groupmembershipOption allows management of the mutation configuration using functional options.
type groupmembershipOption func(*GroupMembershipMutation)

// newGroupMembershipMutation creates new mutation for the GroupMembership entity.
func newGroupMembershipMutation(c config, op Op, opts ...groupmembershipOption) *GroupMembershipMutation {
	m := &GroupMembershipMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupMembership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupMembershipID sets the ID field of the mutation.
func withGroupMembershipID(id string) groupmembershipOption {
	return func(m *GroupMembershipMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupMembership
		)
		m.oldValue = func(ctx context.Context) (*GroupMembership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupMembership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupMembership sets the old GroupMembership of the mutation.
func withGroupMembership(node *GroupMembership) groupmembershipOption {
	return func(m *GroupMembershipMutation) {
		m.oldValue = func(context.Context) (*GroupMembership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMembershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMembershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupMembership entities.
func (m *GroupMembershipMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMembershipMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMembershipMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupMembership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMembershipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMembershipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupMembershipMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[groupmembership.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupMembershipMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[groupmembership.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMembershipMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, groupmembership.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMembershipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMembershipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupMembershipMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[groupmembership.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupMembershipMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[groupmembership.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMembershipMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, groupmembership.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupMembershipMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupMembershipMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupMembershipMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[groupmembership.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupMembershipMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[groupmembership.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupMembershipMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, groupmembership.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupMembershipMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupMembershipMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupMembershipMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[groupmembership.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupMembershipMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[groupmembership.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupMembershipMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, groupmembership.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *GroupMembershipMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *GroupMembershipMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *GroupMembershipMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMembershipMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMembershipMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMembershipMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[groupmembership.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMembershipMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[groupmembership.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMembershipMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, groupmembership.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupMembershipMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupMembershipMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupMembershipMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[groupmembership.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupMembershipMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[groupmembership.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupMembershipMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, groupmembership.FieldDeletedBy)
}

// SetRole sets the "role" field.
func (m *GroupMembershipMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *GroupMembershipMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *GroupMembershipMutation) ResetRole() {
	m.role = nil
}

// SetGroupID sets the "group_id" field.
func (m *GroupMembershipMutation) SetGroupID(s string) {
	m.group = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupMembershipMutation) GroupID() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupMembershipMutation) ResetGroupID() {
	m.group = nil
}

// SetUserID sets the "user_id" field.
func (m *GroupMembershipMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GroupMembershipMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GroupMembership entity.
// If the GroupMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GroupMembershipMutation) ResetUserID() {
	m.user = nil
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *GroupMembershipMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[groupmembership.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *GroupMembershipMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *GroupMembershipMutation) GroupIDs() (ids []string) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *GroupMembershipMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *GroupMembershipMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[groupmembership.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *GroupMembershipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *GroupMembershipMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *GroupMembershipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *GroupMembershipMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *GroupMembershipMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *GroupMembershipMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *GroupMembershipMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *GroupMembershipMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *GroupMembershipMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *GroupMembershipMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the GroupMembershipMutation builder.
func (m *GroupMembershipMutation) Where(ps ...predicate.GroupMembership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMembershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMembershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupMembership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMembershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMembershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupMembership).
func (m *GroupMembershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMembershipMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, groupmembership.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, groupmembership.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, groupmembership.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, groupmembership.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, groupmembership.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, groupmembership.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, groupmembership.FieldDeletedBy)
	}
	if m.role != nil {
		fields = append(fields, groupmembership.FieldRole)
	}
	if m.group != nil {
		fields = append(fields, groupmembership.FieldGroupID)
	}
	if m.user != nil {
		fields = append(fields, groupmembership.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMembershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupmembership.FieldCreatedAt:
		return m.CreatedAt()
	case groupmembership.FieldUpdatedAt:
		return m.UpdatedAt()
	case groupmembership.FieldCreatedBy:
		return m.CreatedBy()
	case groupmembership.FieldUpdatedBy:
		return m.UpdatedBy()
	case groupmembership.FieldMappingID:
		return m.MappingID()
	case groupmembership.FieldDeletedAt:
		return m.DeletedAt()
	case groupmembership.FieldDeletedBy:
		return m.DeletedBy()
	case groupmembership.FieldRole:
		return m.Role()
	case groupmembership.FieldGroupID:
		return m.GroupID()
	case groupmembership.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMembershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupmembership.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupmembership.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case groupmembership.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case groupmembership.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case groupmembership.FieldMappingID:
		return m.OldMappingID(ctx)
	case groupmembership.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case groupmembership.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case groupmembership.FieldRole:
		return m.OldRole(ctx)
	case groupmembership.FieldGroupID:
		return m.OldGroupID(ctx)
	case groupmembership.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown GroupMembership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMembershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupmembership.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupmembership.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case groupmembership.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case groupmembership.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case groupmembership.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case groupmembership.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case groupmembership.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case groupmembership.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case groupmembership.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case groupmembership.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown GroupMembership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMembershipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMembershipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMembershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupMembership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMembershipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupmembership.FieldCreatedAt) {
		fields = append(fields, groupmembership.FieldCreatedAt)
	}
	if m.FieldCleared(groupmembership.FieldUpdatedAt) {
		fields = append(fields, groupmembership.FieldUpdatedAt)
	}
	if m.FieldCleared(groupmembership.FieldCreatedBy) {
		fields = append(fields, groupmembership.FieldCreatedBy)
	}
	if m.FieldCleared(groupmembership.FieldUpdatedBy) {
		fields = append(fields, groupmembership.FieldUpdatedBy)
	}
	if m.FieldCleared(groupmembership.FieldDeletedAt) {
		fields = append(fields, groupmembership.FieldDeletedAt)
	}
	if m.FieldCleared(groupmembership.FieldDeletedBy) {
		fields = append(fields, groupmembership.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMembershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMembershipMutation) ClearField(name string) error {
	switch name {
	case groupmembership.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case groupmembership.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case groupmembership.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case groupmembership.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case groupmembership.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case groupmembership.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown GroupMembership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMembershipMutation) ResetField(name string) error {
	switch name {
	case groupmembership.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupmembership.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case groupmembership.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case groupmembership.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case groupmembership.FieldMappingID:
		m.ResetMappingID()
		return nil
	case groupmembership.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case groupmembership.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case groupmembership.FieldRole:
		m.ResetRole()
		return nil
	case groupmembership.FieldGroupID:
		m.ResetGroupID()
		return nil
	case groupmembership.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown GroupMembership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMembershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.group != nil {
		edges = append(edges, groupmembership.EdgeGroup)
	}
	if m.user != nil {
		edges = append(edges, groupmembership.EdgeUser)
	}
	if m.events != nil {
		edges = append(edges, groupmembership.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMembershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groupmembership.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case groupmembership.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case groupmembership.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMembershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedevents != nil {
		edges = append(edges, groupmembership.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMembershipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case groupmembership.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMembershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgroup {
		edges = append(edges, groupmembership.EdgeGroup)
	}
	if m.cleareduser {
		edges = append(edges, groupmembership.EdgeUser)
	}
	if m.clearedevents {
		edges = append(edges, groupmembership.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMembershipMutation) EdgeCleared(name string) bool {
	switch name {
	case groupmembership.EdgeGroup:
		return m.clearedgroup
	case groupmembership.EdgeUser:
		return m.cleareduser
	case groupmembership.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMembershipMutation) ClearEdge(name string) error {
	switch name {
	case groupmembership.EdgeGroup:
		m.ClearGroup()
		return nil
	case groupmembership.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown GroupMembership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMembershipMutation) ResetEdge(name string) error {
	switch name {
	case groupmembership.EdgeGroup:
		m.ResetGroup()
		return nil
	case groupmembership.EdgeUser:
		m.ResetUser()
		return nil
	case groupmembership.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown GroupMembership edge %s", name)
}

// GroupMembershipHistoryMutation represents an operation that mutates the GroupMembershipHistory nodes in the graph.
type GroupMembershipHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	role          *enums.Role
	group_id      *string
	user_id       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GroupMembershipHistory, error)
	predicates    []predicate.GroupMembershipHistory
}

var _ ent.Mutation = (*GroupMembershipHistoryMutation)(nil)

// groupmembershiphistoryOption allows management of the mutation configuration using functional options.
type groupmembershiphistoryOption func(*GroupMembershipHistoryMutation)

// newGroupMembershipHistoryMutation creates new mutation for the GroupMembershipHistory entity.
func newGroupMembershipHistoryMutation(c config, op Op, opts ...groupmembershiphistoryOption) *GroupMembershipHistoryMutation {
	m := &GroupMembershipHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupMembershipHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupMembershipHistoryID sets the ID field of the mutation.
func withGroupMembershipHistoryID(id string) groupmembershiphistoryOption {
	return func(m *GroupMembershipHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupMembershipHistory
		)
		m.oldValue = func(ctx context.Context) (*GroupMembershipHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupMembershipHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupMembershipHistory sets the old GroupMembershipHistory of the mutation.
func withGroupMembershipHistory(node *GroupMembershipHistory) groupmembershiphistoryOption {
	return func(m *GroupMembershipHistoryMutation) {
		m.oldValue = func(context.Context) (*GroupMembershipHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMembershipHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMembershipHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupMembershipHistory entities.
func (m *GroupMembershipHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMembershipHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMembershipHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupMembershipHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *GroupMembershipHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *GroupMembershipHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *GroupMembershipHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *GroupMembershipHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *GroupMembershipHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *GroupMembershipHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[groupmembershiphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *GroupMembershipHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, groupmembershiphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *GroupMembershipHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *GroupMembershipHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *GroupMembershipHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMembershipHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMembershipHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupMembershipHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[groupmembershiphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMembershipHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, groupmembershiphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMembershipHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMembershipHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupMembershipHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[groupmembershiphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMembershipHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, groupmembershiphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupMembershipHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupMembershipHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupMembershipHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[groupmembershiphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupMembershipHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, groupmembershiphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupMembershipHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupMembershipHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupMembershipHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[groupmembershiphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupMembershipHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, groupmembershiphistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *GroupMembershipHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *GroupMembershipHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *GroupMembershipHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMembershipHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMembershipHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMembershipHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[groupmembershiphistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMembershipHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, groupmembershiphistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupMembershipHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupMembershipHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupMembershipHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[groupmembershiphistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[groupmembershiphistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupMembershipHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, groupmembershiphistory.FieldDeletedBy)
}

// SetRole sets the "role" field.
func (m *GroupMembershipHistoryMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *GroupMembershipHistoryMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *GroupMembershipHistoryMutation) ResetRole() {
	m.role = nil
}

// SetGroupID sets the "group_id" field.
func (m *GroupMembershipHistoryMutation) SetGroupID(s string) {
	m.group_id = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupMembershipHistoryMutation) GroupID() (r string, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupMembershipHistoryMutation) ResetGroupID() {
	m.group_id = nil
}

// SetUserID sets the "user_id" field.
func (m *GroupMembershipHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GroupMembershipHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GroupMembershipHistory entity.
// If the GroupMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMembershipHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GroupMembershipHistoryMutation) ResetUserID() {
	m.user_id = nil
}

// Where appends a list predicates to the GroupMembershipHistoryMutation builder.
func (m *GroupMembershipHistoryMutation) Where(ps ...predicate.GroupMembershipHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMembershipHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMembershipHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupMembershipHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMembershipHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMembershipHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupMembershipHistory).
func (m *GroupMembershipHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMembershipHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.history_time != nil {
		fields = append(fields, groupmembershiphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, groupmembershiphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, groupmembershiphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, groupmembershiphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, groupmembershiphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, groupmembershiphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, groupmembershiphistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, groupmembershiphistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, groupmembershiphistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, groupmembershiphistory.FieldDeletedBy)
	}
	if m.role != nil {
		fields = append(fields, groupmembershiphistory.FieldRole)
	}
	if m.group_id != nil {
		fields = append(fields, groupmembershiphistory.FieldGroupID)
	}
	if m.user_id != nil {
		fields = append(fields, groupmembershiphistory.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMembershipHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupmembershiphistory.FieldHistoryTime:
		return m.HistoryTime()
	case groupmembershiphistory.FieldRef:
		return m.Ref()
	case groupmembershiphistory.FieldOperation:
		return m.Operation()
	case groupmembershiphistory.FieldCreatedAt:
		return m.CreatedAt()
	case groupmembershiphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case groupmembershiphistory.FieldCreatedBy:
		return m.CreatedBy()
	case groupmembershiphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case groupmembershiphistory.FieldMappingID:
		return m.MappingID()
	case groupmembershiphistory.FieldDeletedAt:
		return m.DeletedAt()
	case groupmembershiphistory.FieldDeletedBy:
		return m.DeletedBy()
	case groupmembershiphistory.FieldRole:
		return m.Role()
	case groupmembershiphistory.FieldGroupID:
		return m.GroupID()
	case groupmembershiphistory.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMembershipHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupmembershiphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case groupmembershiphistory.FieldRef:
		return m.OldRef(ctx)
	case groupmembershiphistory.FieldOperation:
		return m.OldOperation(ctx)
	case groupmembershiphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupmembershiphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case groupmembershiphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case groupmembershiphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case groupmembershiphistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case groupmembershiphistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case groupmembershiphistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case groupmembershiphistory.FieldRole:
		return m.OldRole(ctx)
	case groupmembershiphistory.FieldGroupID:
		return m.OldGroupID(ctx)
	case groupmembershiphistory.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown GroupMembershipHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMembershipHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupmembershiphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case groupmembershiphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case groupmembershiphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case groupmembershiphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupmembershiphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case groupmembershiphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case groupmembershiphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case groupmembershiphistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case groupmembershiphistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case groupmembershiphistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case groupmembershiphistory.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case groupmembershiphistory.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case groupmembershiphistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown GroupMembershipHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMembershipHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMembershipHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMembershipHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupMembershipHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMembershipHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupmembershiphistory.FieldRef) {
		fields = append(fields, groupmembershiphistory.FieldRef)
	}
	if m.FieldCleared(groupmembershiphistory.FieldCreatedAt) {
		fields = append(fields, groupmembershiphistory.FieldCreatedAt)
	}
	if m.FieldCleared(groupmembershiphistory.FieldUpdatedAt) {
		fields = append(fields, groupmembershiphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(groupmembershiphistory.FieldCreatedBy) {
		fields = append(fields, groupmembershiphistory.FieldCreatedBy)
	}
	if m.FieldCleared(groupmembershiphistory.FieldUpdatedBy) {
		fields = append(fields, groupmembershiphistory.FieldUpdatedBy)
	}
	if m.FieldCleared(groupmembershiphistory.FieldDeletedAt) {
		fields = append(fields, groupmembershiphistory.FieldDeletedAt)
	}
	if m.FieldCleared(groupmembershiphistory.FieldDeletedBy) {
		fields = append(fields, groupmembershiphistory.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMembershipHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMembershipHistoryMutation) ClearField(name string) error {
	switch name {
	case groupmembershiphistory.FieldRef:
		m.ClearRef()
		return nil
	case groupmembershiphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case groupmembershiphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case groupmembershiphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case groupmembershiphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case groupmembershiphistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case groupmembershiphistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown GroupMembershipHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMembershipHistoryMutation) ResetField(name string) error {
	switch name {
	case groupmembershiphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case groupmembershiphistory.FieldRef:
		m.ResetRef()
		return nil
	case groupmembershiphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case groupmembershiphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupmembershiphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case groupmembershiphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case groupmembershiphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case groupmembershiphistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case groupmembershiphistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case groupmembershiphistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case groupmembershiphistory.FieldRole:
		m.ResetRole()
		return nil
	case groupmembershiphistory.FieldGroupID:
		m.ResetGroupID()
		return nil
	case groupmembershiphistory.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown GroupMembershipHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMembershipHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMembershipHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMembershipHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMembershipHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMembershipHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMembershipHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMembershipHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupMembershipHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMembershipHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupMembershipHistory edge %s", name)
}

// GroupSettingMutation represents an operation that mutates the GroupSetting nodes in the graph.
type GroupSettingMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	mapping_id     *string
	tags           *[]string
	appendtags     []string
	deleted_at     *time.Time
	deleted_by     *string
	visibility     *enums.Visibility
	join_policy    *enums.JoinPolicy
	sync_to_slack  *bool
	sync_to_github *bool
	clearedFields  map[string]struct{}
	group          *string
	clearedgroup   bool
	done           bool
	oldValue       func(context.Context) (*GroupSetting, error)
	predicates     []predicate.GroupSetting
}

var _ ent.Mutation = (*GroupSettingMutation)(nil)

// groupsettingOption allows management of the mutation configuration using functional options.
type groupsettingOption func(*GroupSettingMutation)

// newGroupSettingMutation creates new mutation for the GroupSetting entity.
func newGroupSettingMutation(c config, op Op, opts ...groupsettingOption) *GroupSettingMutation {
	m := &GroupSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupSettingID sets the ID field of the mutation.
func withGroupSettingID(id string) groupsettingOption {
	return func(m *GroupSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupSetting
		)
		m.oldValue = func(ctx context.Context) (*GroupSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupSetting sets the old GroupSetting of the mutation.
func withGroupSetting(node *GroupSetting) groupsettingOption {
	return func(m *GroupSettingMutation) {
		m.oldValue = func(context.Context) (*GroupSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupSetting entities.
func (m *GroupSettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupSettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupSettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupSettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[groupsetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupSettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupSettingMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, groupsetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupSettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[groupsetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupSettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, groupsetting.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupSettingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupSettingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupSettingMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[groupsetting.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupSettingMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupSettingMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, groupsetting.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupSettingMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupSettingMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupSettingMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[groupsetting.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupSettingMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupSettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, groupsetting.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *GroupSettingMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *GroupSettingMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *GroupSettingMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *GroupSettingMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *GroupSettingMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *GroupSettingMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *GroupSettingMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *GroupSettingMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[groupsetting.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *GroupSettingMutation) TagsCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *GroupSettingMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, groupsetting.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupSettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupSettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupSettingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[groupsetting.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupSettingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupSettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, groupsetting.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupSettingMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupSettingMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupSettingMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[groupsetting.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupSettingMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupSettingMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, groupsetting.FieldDeletedBy)
}

// SetVisibility sets the "visibility" field.
func (m *GroupSettingMutation) SetVisibility(e enums.Visibility) {
	m.visibility = &e
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *GroupSettingMutation) Visibility() (r enums.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldVisibility(ctx context.Context) (v enums.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *GroupSettingMutation) ResetVisibility() {
	m.visibility = nil
}

// SetJoinPolicy sets the "join_policy" field.
func (m *GroupSettingMutation) SetJoinPolicy(ep enums.JoinPolicy) {
	m.join_policy = &ep
}

// JoinPolicy returns the value of the "join_policy" field in the mutation.
func (m *GroupSettingMutation) JoinPolicy() (r enums.JoinPolicy, exists bool) {
	v := m.join_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinPolicy returns the old "join_policy" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldJoinPolicy(ctx context.Context) (v enums.JoinPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinPolicy: %w", err)
	}
	return oldValue.JoinPolicy, nil
}

// ResetJoinPolicy resets all changes to the "join_policy" field.
func (m *GroupSettingMutation) ResetJoinPolicy() {
	m.join_policy = nil
}

// SetSyncToSlack sets the "sync_to_slack" field.
func (m *GroupSettingMutation) SetSyncToSlack(b bool) {
	m.sync_to_slack = &b
}

// SyncToSlack returns the value of the "sync_to_slack" field in the mutation.
func (m *GroupSettingMutation) SyncToSlack() (r bool, exists bool) {
	v := m.sync_to_slack
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncToSlack returns the old "sync_to_slack" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldSyncToSlack(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncToSlack is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncToSlack requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncToSlack: %w", err)
	}
	return oldValue.SyncToSlack, nil
}

// ClearSyncToSlack clears the value of the "sync_to_slack" field.
func (m *GroupSettingMutation) ClearSyncToSlack() {
	m.sync_to_slack = nil
	m.clearedFields[groupsetting.FieldSyncToSlack] = struct{}{}
}

// SyncToSlackCleared returns if the "sync_to_slack" field was cleared in this mutation.
func (m *GroupSettingMutation) SyncToSlackCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldSyncToSlack]
	return ok
}

// ResetSyncToSlack resets all changes to the "sync_to_slack" field.
func (m *GroupSettingMutation) ResetSyncToSlack() {
	m.sync_to_slack = nil
	delete(m.clearedFields, groupsetting.FieldSyncToSlack)
}

// SetSyncToGithub sets the "sync_to_github" field.
func (m *GroupSettingMutation) SetSyncToGithub(b bool) {
	m.sync_to_github = &b
}

// SyncToGithub returns the value of the "sync_to_github" field in the mutation.
func (m *GroupSettingMutation) SyncToGithub() (r bool, exists bool) {
	v := m.sync_to_github
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncToGithub returns the old "sync_to_github" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldSyncToGithub(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncToGithub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncToGithub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncToGithub: %w", err)
	}
	return oldValue.SyncToGithub, nil
}

// ClearSyncToGithub clears the value of the "sync_to_github" field.
func (m *GroupSettingMutation) ClearSyncToGithub() {
	m.sync_to_github = nil
	m.clearedFields[groupsetting.FieldSyncToGithub] = struct{}{}
}

// SyncToGithubCleared returns if the "sync_to_github" field was cleared in this mutation.
func (m *GroupSettingMutation) SyncToGithubCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldSyncToGithub]
	return ok
}

// ResetSyncToGithub resets all changes to the "sync_to_github" field.
func (m *GroupSettingMutation) ResetSyncToGithub() {
	m.sync_to_github = nil
	delete(m.clearedFields, groupsetting.FieldSyncToGithub)
}

// SetGroupID sets the "group_id" field.
func (m *GroupSettingMutation) SetGroupID(s string) {
	m.group = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupSettingMutation) GroupID() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupSetting entity.
// If the GroupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *GroupSettingMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[groupsetting.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *GroupSettingMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[groupsetting.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupSettingMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, groupsetting.FieldGroupID)
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *GroupSettingMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[groupsetting.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *GroupSettingMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *GroupSettingMutation) GroupIDs() (ids []string) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *GroupSettingMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the GroupSettingMutation builder.
func (m *GroupSettingMutation) Where(ps ...predicate.GroupSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupSetting).
func (m *GroupSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupSettingMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, groupsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, groupsetting.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, groupsetting.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, groupsetting.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, groupsetting.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, groupsetting.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, groupsetting.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, groupsetting.FieldDeletedBy)
	}
	if m.visibility != nil {
		fields = append(fields, groupsetting.FieldVisibility)
	}
	if m.join_policy != nil {
		fields = append(fields, groupsetting.FieldJoinPolicy)
	}
	if m.sync_to_slack != nil {
		fields = append(fields, groupsetting.FieldSyncToSlack)
	}
	if m.sync_to_github != nil {
		fields = append(fields, groupsetting.FieldSyncToGithub)
	}
	if m.group != nil {
		fields = append(fields, groupsetting.FieldGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupsetting.FieldCreatedAt:
		return m.CreatedAt()
	case groupsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case groupsetting.FieldCreatedBy:
		return m.CreatedBy()
	case groupsetting.FieldUpdatedBy:
		return m.UpdatedBy()
	case groupsetting.FieldMappingID:
		return m.MappingID()
	case groupsetting.FieldTags:
		return m.Tags()
	case groupsetting.FieldDeletedAt:
		return m.DeletedAt()
	case groupsetting.FieldDeletedBy:
		return m.DeletedBy()
	case groupsetting.FieldVisibility:
		return m.Visibility()
	case groupsetting.FieldJoinPolicy:
		return m.JoinPolicy()
	case groupsetting.FieldSyncToSlack:
		return m.SyncToSlack()
	case groupsetting.FieldSyncToGithub:
		return m.SyncToGithub()
	case groupsetting.FieldGroupID:
		return m.GroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case groupsetting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case groupsetting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case groupsetting.FieldMappingID:
		return m.OldMappingID(ctx)
	case groupsetting.FieldTags:
		return m.OldTags(ctx)
	case groupsetting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case groupsetting.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case groupsetting.FieldVisibility:
		return m.OldVisibility(ctx)
	case groupsetting.FieldJoinPolicy:
		return m.OldJoinPolicy(ctx)
	case groupsetting.FieldSyncToSlack:
		return m.OldSyncToSlack(ctx)
	case groupsetting.FieldSyncToGithub:
		return m.OldSyncToGithub(ctx)
	case groupsetting.FieldGroupID:
		return m.OldGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown GroupSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case groupsetting.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case groupsetting.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case groupsetting.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case groupsetting.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case groupsetting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case groupsetting.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case groupsetting.FieldVisibility:
		v, ok := value.(enums.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case groupsetting.FieldJoinPolicy:
		v, ok := value.(enums.JoinPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinPolicy(v)
		return nil
	case groupsetting.FieldSyncToSlack:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncToSlack(v)
		return nil
	case groupsetting.FieldSyncToGithub:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncToGithub(v)
		return nil
	case groupsetting.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown GroupSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupSettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupSettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupsetting.FieldCreatedAt) {
		fields = append(fields, groupsetting.FieldCreatedAt)
	}
	if m.FieldCleared(groupsetting.FieldUpdatedAt) {
		fields = append(fields, groupsetting.FieldUpdatedAt)
	}
	if m.FieldCleared(groupsetting.FieldCreatedBy) {
		fields = append(fields, groupsetting.FieldCreatedBy)
	}
	if m.FieldCleared(groupsetting.FieldUpdatedBy) {
		fields = append(fields, groupsetting.FieldUpdatedBy)
	}
	if m.FieldCleared(groupsetting.FieldTags) {
		fields = append(fields, groupsetting.FieldTags)
	}
	if m.FieldCleared(groupsetting.FieldDeletedAt) {
		fields = append(fields, groupsetting.FieldDeletedAt)
	}
	if m.FieldCleared(groupsetting.FieldDeletedBy) {
		fields = append(fields, groupsetting.FieldDeletedBy)
	}
	if m.FieldCleared(groupsetting.FieldSyncToSlack) {
		fields = append(fields, groupsetting.FieldSyncToSlack)
	}
	if m.FieldCleared(groupsetting.FieldSyncToGithub) {
		fields = append(fields, groupsetting.FieldSyncToGithub)
	}
	if m.FieldCleared(groupsetting.FieldGroupID) {
		fields = append(fields, groupsetting.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupSettingMutation) ClearField(name string) error {
	switch name {
	case groupsetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case groupsetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case groupsetting.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case groupsetting.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case groupsetting.FieldTags:
		m.ClearTags()
		return nil
	case groupsetting.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case groupsetting.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case groupsetting.FieldSyncToSlack:
		m.ClearSyncToSlack()
		return nil
	case groupsetting.FieldSyncToGithub:
		m.ClearSyncToGithub()
		return nil
	case groupsetting.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown GroupSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupSettingMutation) ResetField(name string) error {
	switch name {
	case groupsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case groupsetting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case groupsetting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case groupsetting.FieldMappingID:
		m.ResetMappingID()
		return nil
	case groupsetting.FieldTags:
		m.ResetTags()
		return nil
	case groupsetting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case groupsetting.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case groupsetting.FieldVisibility:
		m.ResetVisibility()
		return nil
	case groupsetting.FieldJoinPolicy:
		m.ResetJoinPolicy()
		return nil
	case groupsetting.FieldSyncToSlack:
		m.ResetSyncToSlack()
		return nil
	case groupsetting.FieldSyncToGithub:
		m.ResetSyncToGithub()
		return nil
	case groupsetting.FieldGroupID:
		m.ResetGroupID()
		return nil
	}
	return fmt.Errorf("unknown GroupSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.group != nil {
		edges = append(edges, groupsetting.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groupsetting.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroup {
		edges = append(edges, groupsetting.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case groupsetting.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupSettingMutation) ClearEdge(name string) error {
	switch name {
	case groupsetting.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown GroupSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupSettingMutation) ResetEdge(name string) error {
	switch name {
	case groupsetting.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown GroupSetting edge %s", name)
}

// GroupSettingHistoryMutation represents an operation that mutates the GroupSettingHistory nodes in the graph.
type GroupSettingHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *string
	history_time   *time.Time
	ref            *string
	operation      *history.OpType
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	mapping_id     *string
	tags           *[]string
	appendtags     []string
	deleted_at     *time.Time
	deleted_by     *string
	visibility     *enums.Visibility
	join_policy    *enums.JoinPolicy
	sync_to_slack  *bool
	sync_to_github *bool
	group_id       *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*GroupSettingHistory, error)
	predicates     []predicate.GroupSettingHistory
}

var _ ent.Mutation = (*GroupSettingHistoryMutation)(nil)

// groupsettinghistoryOption allows management of the mutation configuration using functional options.
type groupsettinghistoryOption func(*GroupSettingHistoryMutation)

// newGroupSettingHistoryMutation creates new mutation for the GroupSettingHistory entity.
func newGroupSettingHistoryMutation(c config, op Op, opts ...groupsettinghistoryOption) *GroupSettingHistoryMutation {
	m := &GroupSettingHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupSettingHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupSettingHistoryID sets the ID field of the mutation.
func withGroupSettingHistoryID(id string) groupsettinghistoryOption {
	return func(m *GroupSettingHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupSettingHistory
		)
		m.oldValue = func(ctx context.Context) (*GroupSettingHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupSettingHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupSettingHistory sets the old GroupSettingHistory of the mutation.
func withGroupSettingHistory(node *GroupSettingHistory) groupsettinghistoryOption {
	return func(m *GroupSettingHistoryMutation) {
		m.oldValue = func(context.Context) (*GroupSettingHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupSettingHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupSettingHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupSettingHistory entities.
func (m *GroupSettingHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupSettingHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupSettingHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupSettingHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *GroupSettingHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *GroupSettingHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *GroupSettingHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *GroupSettingHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *GroupSettingHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *GroupSettingHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[groupsettinghistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *GroupSettingHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, groupsettinghistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *GroupSettingHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *GroupSettingHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *GroupSettingHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupSettingHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupSettingHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *GroupSettingHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[groupsettinghistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupSettingHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, groupsettinghistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupSettingHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupSettingHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupSettingHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[groupsettinghistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupSettingHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, groupsettinghistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupSettingHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupSettingHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupSettingHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[groupsettinghistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupSettingHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, groupsettinghistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupSettingHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupSettingHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupSettingHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[groupsettinghistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupSettingHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, groupsettinghistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *GroupSettingHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *GroupSettingHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *GroupSettingHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *GroupSettingHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *GroupSettingHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *GroupSettingHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *GroupSettingHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *GroupSettingHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[groupsettinghistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *GroupSettingHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, groupsettinghistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupSettingHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupSettingHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupSettingHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[groupsettinghistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupSettingHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, groupsettinghistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupSettingHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupSettingHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupSettingHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[groupsettinghistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupSettingHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, groupsettinghistory.FieldDeletedBy)
}

// SetVisibility sets the "visibility" field.
func (m *GroupSettingHistoryMutation) SetVisibility(e enums.Visibility) {
	m.visibility = &e
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *GroupSettingHistoryMutation) Visibility() (r enums.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldVisibility(ctx context.Context) (v enums.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *GroupSettingHistoryMutation) ResetVisibility() {
	m.visibility = nil
}

// SetJoinPolicy sets the "join_policy" field.
func (m *GroupSettingHistoryMutation) SetJoinPolicy(ep enums.JoinPolicy) {
	m.join_policy = &ep
}

// JoinPolicy returns the value of the "join_policy" field in the mutation.
func (m *GroupSettingHistoryMutation) JoinPolicy() (r enums.JoinPolicy, exists bool) {
	v := m.join_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinPolicy returns the old "join_policy" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldJoinPolicy(ctx context.Context) (v enums.JoinPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinPolicy: %w", err)
	}
	return oldValue.JoinPolicy, nil
}

// ResetJoinPolicy resets all changes to the "join_policy" field.
func (m *GroupSettingHistoryMutation) ResetJoinPolicy() {
	m.join_policy = nil
}

// SetSyncToSlack sets the "sync_to_slack" field.
func (m *GroupSettingHistoryMutation) SetSyncToSlack(b bool) {
	m.sync_to_slack = &b
}

// SyncToSlack returns the value of the "sync_to_slack" field in the mutation.
func (m *GroupSettingHistoryMutation) SyncToSlack() (r bool, exists bool) {
	v := m.sync_to_slack
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncToSlack returns the old "sync_to_slack" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldSyncToSlack(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncToSlack is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncToSlack requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncToSlack: %w", err)
	}
	return oldValue.SyncToSlack, nil
}

// ClearSyncToSlack clears the value of the "sync_to_slack" field.
func (m *GroupSettingHistoryMutation) ClearSyncToSlack() {
	m.sync_to_slack = nil
	m.clearedFields[groupsettinghistory.FieldSyncToSlack] = struct{}{}
}

// SyncToSlackCleared returns if the "sync_to_slack" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) SyncToSlackCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldSyncToSlack]
	return ok
}

// ResetSyncToSlack resets all changes to the "sync_to_slack" field.
func (m *GroupSettingHistoryMutation) ResetSyncToSlack() {
	m.sync_to_slack = nil
	delete(m.clearedFields, groupsettinghistory.FieldSyncToSlack)
}

// SetSyncToGithub sets the "sync_to_github" field.
func (m *GroupSettingHistoryMutation) SetSyncToGithub(b bool) {
	m.sync_to_github = &b
}

// SyncToGithub returns the value of the "sync_to_github" field in the mutation.
func (m *GroupSettingHistoryMutation) SyncToGithub() (r bool, exists bool) {
	v := m.sync_to_github
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncToGithub returns the old "sync_to_github" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldSyncToGithub(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncToGithub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncToGithub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncToGithub: %w", err)
	}
	return oldValue.SyncToGithub, nil
}

// ClearSyncToGithub clears the value of the "sync_to_github" field.
func (m *GroupSettingHistoryMutation) ClearSyncToGithub() {
	m.sync_to_github = nil
	m.clearedFields[groupsettinghistory.FieldSyncToGithub] = struct{}{}
}

// SyncToGithubCleared returns if the "sync_to_github" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) SyncToGithubCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldSyncToGithub]
	return ok
}

// ResetSyncToGithub resets all changes to the "sync_to_github" field.
func (m *GroupSettingHistoryMutation) ResetSyncToGithub() {
	m.sync_to_github = nil
	delete(m.clearedFields, groupsettinghistory.FieldSyncToGithub)
}

// SetGroupID sets the "group_id" field.
func (m *GroupSettingHistoryMutation) SetGroupID(s string) {
	m.group_id = &s
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupSettingHistoryMutation) GroupID() (r string, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupSettingHistory entity.
// If the GroupSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupSettingHistoryMutation) OldGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *GroupSettingHistoryMutation) ClearGroupID() {
	m.group_id = nil
	m.clearedFields[groupsettinghistory.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *GroupSettingHistoryMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[groupsettinghistory.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupSettingHistoryMutation) ResetGroupID() {
	m.group_id = nil
	delete(m.clearedFields, groupsettinghistory.FieldGroupID)
}

// Where appends a list predicates to the GroupSettingHistoryMutation builder.
func (m *GroupSettingHistoryMutation) Where(ps ...predicate.GroupSettingHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupSettingHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupSettingHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupSettingHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupSettingHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupSettingHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupSettingHistory).
func (m *GroupSettingHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupSettingHistoryMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.history_time != nil {
		fields = append(fields, groupsettinghistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, groupsettinghistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, groupsettinghistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, groupsettinghistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, groupsettinghistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, groupsettinghistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, groupsettinghistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, groupsettinghistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, groupsettinghistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, groupsettinghistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, groupsettinghistory.FieldDeletedBy)
	}
	if m.visibility != nil {
		fields = append(fields, groupsettinghistory.FieldVisibility)
	}
	if m.join_policy != nil {
		fields = append(fields, groupsettinghistory.FieldJoinPolicy)
	}
	if m.sync_to_slack != nil {
		fields = append(fields, groupsettinghistory.FieldSyncToSlack)
	}
	if m.sync_to_github != nil {
		fields = append(fields, groupsettinghistory.FieldSyncToGithub)
	}
	if m.group_id != nil {
		fields = append(fields, groupsettinghistory.FieldGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupSettingHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupsettinghistory.FieldHistoryTime:
		return m.HistoryTime()
	case groupsettinghistory.FieldRef:
		return m.Ref()
	case groupsettinghistory.FieldOperation:
		return m.Operation()
	case groupsettinghistory.FieldCreatedAt:
		return m.CreatedAt()
	case groupsettinghistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case groupsettinghistory.FieldCreatedBy:
		return m.CreatedBy()
	case groupsettinghistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case groupsettinghistory.FieldMappingID:
		return m.MappingID()
	case groupsettinghistory.FieldTags:
		return m.Tags()
	case groupsettinghistory.FieldDeletedAt:
		return m.DeletedAt()
	case groupsettinghistory.FieldDeletedBy:
		return m.DeletedBy()
	case groupsettinghistory.FieldVisibility:
		return m.Visibility()
	case groupsettinghistory.FieldJoinPolicy:
		return m.JoinPolicy()
	case groupsettinghistory.FieldSyncToSlack:
		return m.SyncToSlack()
	case groupsettinghistory.FieldSyncToGithub:
		return m.SyncToGithub()
	case groupsettinghistory.FieldGroupID:
		return m.GroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupSettingHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupsettinghistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case groupsettinghistory.FieldRef:
		return m.OldRef(ctx)
	case groupsettinghistory.FieldOperation:
		return m.OldOperation(ctx)
	case groupsettinghistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupsettinghistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case groupsettinghistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case groupsettinghistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case groupsettinghistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case groupsettinghistory.FieldTags:
		return m.OldTags(ctx)
	case groupsettinghistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case groupsettinghistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case groupsettinghistory.FieldVisibility:
		return m.OldVisibility(ctx)
	case groupsettinghistory.FieldJoinPolicy:
		return m.OldJoinPolicy(ctx)
	case groupsettinghistory.FieldSyncToSlack:
		return m.OldSyncToSlack(ctx)
	case groupsettinghistory.FieldSyncToGithub:
		return m.OldSyncToGithub(ctx)
	case groupsettinghistory.FieldGroupID:
		return m.OldGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown GroupSettingHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupSettingHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupsettinghistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case groupsettinghistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case groupsettinghistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case groupsettinghistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupsettinghistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case groupsettinghistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case groupsettinghistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case groupsettinghistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case groupsettinghistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case groupsettinghistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case groupsettinghistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case groupsettinghistory.FieldVisibility:
		v, ok := value.(enums.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case groupsettinghistory.FieldJoinPolicy:
		v, ok := value.(enums.JoinPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinPolicy(v)
		return nil
	case groupsettinghistory.FieldSyncToSlack:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncToSlack(v)
		return nil
	case groupsettinghistory.FieldSyncToGithub:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncToGithub(v)
		return nil
	case groupsettinghistory.FieldGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown GroupSettingHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupSettingHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupSettingHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupSettingHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupSettingHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupSettingHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupsettinghistory.FieldRef) {
		fields = append(fields, groupsettinghistory.FieldRef)
	}
	if m.FieldCleared(groupsettinghistory.FieldCreatedAt) {
		fields = append(fields, groupsettinghistory.FieldCreatedAt)
	}
	if m.FieldCleared(groupsettinghistory.FieldUpdatedAt) {
		fields = append(fields, groupsettinghistory.FieldUpdatedAt)
	}
	if m.FieldCleared(groupsettinghistory.FieldCreatedBy) {
		fields = append(fields, groupsettinghistory.FieldCreatedBy)
	}
	if m.FieldCleared(groupsettinghistory.FieldUpdatedBy) {
		fields = append(fields, groupsettinghistory.FieldUpdatedBy)
	}
	if m.FieldCleared(groupsettinghistory.FieldTags) {
		fields = append(fields, groupsettinghistory.FieldTags)
	}
	if m.FieldCleared(groupsettinghistory.FieldDeletedAt) {
		fields = append(fields, groupsettinghistory.FieldDeletedAt)
	}
	if m.FieldCleared(groupsettinghistory.FieldDeletedBy) {
		fields = append(fields, groupsettinghistory.FieldDeletedBy)
	}
	if m.FieldCleared(groupsettinghistory.FieldSyncToSlack) {
		fields = append(fields, groupsettinghistory.FieldSyncToSlack)
	}
	if m.FieldCleared(groupsettinghistory.FieldSyncToGithub) {
		fields = append(fields, groupsettinghistory.FieldSyncToGithub)
	}
	if m.FieldCleared(groupsettinghistory.FieldGroupID) {
		fields = append(fields, groupsettinghistory.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupSettingHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupSettingHistoryMutation) ClearField(name string) error {
	switch name {
	case groupsettinghistory.FieldRef:
		m.ClearRef()
		return nil
	case groupsettinghistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case groupsettinghistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case groupsettinghistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case groupsettinghistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case groupsettinghistory.FieldTags:
		m.ClearTags()
		return nil
	case groupsettinghistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case groupsettinghistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case groupsettinghistory.FieldSyncToSlack:
		m.ClearSyncToSlack()
		return nil
	case groupsettinghistory.FieldSyncToGithub:
		m.ClearSyncToGithub()
		return nil
	case groupsettinghistory.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown GroupSettingHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupSettingHistoryMutation) ResetField(name string) error {
	switch name {
	case groupsettinghistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case groupsettinghistory.FieldRef:
		m.ResetRef()
		return nil
	case groupsettinghistory.FieldOperation:
		m.ResetOperation()
		return nil
	case groupsettinghistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupsettinghistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case groupsettinghistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case groupsettinghistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case groupsettinghistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case groupsettinghistory.FieldTags:
		m.ResetTags()
		return nil
	case groupsettinghistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case groupsettinghistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case groupsettinghistory.FieldVisibility:
		m.ResetVisibility()
		return nil
	case groupsettinghistory.FieldJoinPolicy:
		m.ResetJoinPolicy()
		return nil
	case groupsettinghistory.FieldSyncToSlack:
		m.ResetSyncToSlack()
		return nil
	case groupsettinghistory.FieldSyncToGithub:
		m.ResetSyncToGithub()
		return nil
	case groupsettinghistory.FieldGroupID:
		m.ResetGroupID()
		return nil
	}
	return fmt.Errorf("unknown GroupSettingHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupSettingHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupSettingHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupSettingHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupSettingHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupSettingHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupSettingHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupSettingHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupSettingHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupSettingHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupSettingHistory edge %s", name)
}

// HushMutation represents an operation that mutates the Hush nodes in the graph.
type HushMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	mapping_id          *string
	deleted_at          *time.Time
	deleted_by          *string
	name                *string
	description         *string
	kind                *string
	secret_name         *string
	secret_value        *string
	clearedFields       map[string]struct{}
	integrations        map[string]struct{}
	removedintegrations map[string]struct{}
	clearedintegrations bool
	organization        map[string]struct{}
	removedorganization map[string]struct{}
	clearedorganization bool
	events              map[string]struct{}
	removedevents       map[string]struct{}
	clearedevents       bool
	done                bool
	oldValue            func(context.Context) (*Hush, error)
	predicates          []predicate.Hush
}

var _ ent.Mutation = (*HushMutation)(nil)

// hushOption allows management of the mutation configuration using functional options.
type hushOption func(*HushMutation)

// newHushMutation creates new mutation for the Hush entity.
func newHushMutation(c config, op Op, opts ...hushOption) *HushMutation {
	m := &HushMutation{
		config:        c,
		op:            op,
		typ:           TypeHush,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHushID sets the ID field of the mutation.
func withHushID(id string) hushOption {
	return func(m *HushMutation) {
		var (
			err   error
			once  sync.Once
			value *Hush
		)
		m.oldValue = func(ctx context.Context) (*Hush, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hush.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHush sets the old Hush of the mutation.
func withHush(node *Hush) hushOption {
	return func(m *HushMutation) {
		m.oldValue = func(context.Context) (*Hush, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HushMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HushMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hush entities.
func (m *HushMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HushMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HushMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hush.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HushMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HushMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HushMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hush.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HushMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hush.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HushMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hush.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HushMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HushMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HushMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hush.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HushMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hush.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HushMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hush.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *HushMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HushMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HushMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[hush.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HushMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[hush.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HushMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, hush.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HushMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HushMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *HushMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[hush.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *HushMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[hush.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HushMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, hush.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *HushMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *HushMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *HushMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HushMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HushMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HushMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hush.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HushMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hush.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HushMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hush.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *HushMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *HushMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *HushMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[hush.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *HushMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[hush.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *HushMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, hush.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *HushMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HushMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HushMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HushMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HushMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HushMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[hush.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HushMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[hush.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HushMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, hush.FieldDescription)
}

// SetKind sets the "kind" field.
func (m *HushMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *HushMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *HushMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[hush.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *HushMutation) KindCleared() bool {
	_, ok := m.clearedFields[hush.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *HushMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, hush.FieldKind)
}

// SetSecretName sets the "secret_name" field.
func (m *HushMutation) SetSecretName(s string) {
	m.secret_name = &s
}

// SecretName returns the value of the "secret_name" field in the mutation.
func (m *HushMutation) SecretName() (r string, exists bool) {
	v := m.secret_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretName returns the old "secret_name" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldSecretName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretName: %w", err)
	}
	return oldValue.SecretName, nil
}

// ClearSecretName clears the value of the "secret_name" field.
func (m *HushMutation) ClearSecretName() {
	m.secret_name = nil
	m.clearedFields[hush.FieldSecretName] = struct{}{}
}

// SecretNameCleared returns if the "secret_name" field was cleared in this mutation.
func (m *HushMutation) SecretNameCleared() bool {
	_, ok := m.clearedFields[hush.FieldSecretName]
	return ok
}

// ResetSecretName resets all changes to the "secret_name" field.
func (m *HushMutation) ResetSecretName() {
	m.secret_name = nil
	delete(m.clearedFields, hush.FieldSecretName)
}

// SetSecretValue sets the "secret_value" field.
func (m *HushMutation) SetSecretValue(s string) {
	m.secret_value = &s
}

// SecretValue returns the value of the "secret_value" field in the mutation.
func (m *HushMutation) SecretValue() (r string, exists bool) {
	v := m.secret_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretValue returns the old "secret_value" field's value of the Hush entity.
// If the Hush object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushMutation) OldSecretValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretValue: %w", err)
	}
	return oldValue.SecretValue, nil
}

// ClearSecretValue clears the value of the "secret_value" field.
func (m *HushMutation) ClearSecretValue() {
	m.secret_value = nil
	m.clearedFields[hush.FieldSecretValue] = struct{}{}
}

// SecretValueCleared returns if the "secret_value" field was cleared in this mutation.
func (m *HushMutation) SecretValueCleared() bool {
	_, ok := m.clearedFields[hush.FieldSecretValue]
	return ok
}

// ResetSecretValue resets all changes to the "secret_value" field.
func (m *HushMutation) ResetSecretValue() {
	m.secret_value = nil
	delete(m.clearedFields, hush.FieldSecretValue)
}

// AddIntegrationIDs adds the "integrations" edge to the Integration entity by ids.
func (m *HushMutation) AddIntegrationIDs(ids ...string) {
	if m.integrations == nil {
		m.integrations = make(map[string]struct{})
	}
	for i := range ids {
		m.integrations[ids[i]] = struct{}{}
	}
}

// ClearIntegrations clears the "integrations" edge to the Integration entity.
func (m *HushMutation) ClearIntegrations() {
	m.clearedintegrations = true
}

// IntegrationsCleared reports if the "integrations" edge to the Integration entity was cleared.
func (m *HushMutation) IntegrationsCleared() bool {
	return m.clearedintegrations
}

// RemoveIntegrationIDs removes the "integrations" edge to the Integration entity by IDs.
func (m *HushMutation) RemoveIntegrationIDs(ids ...string) {
	if m.removedintegrations == nil {
		m.removedintegrations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.integrations, ids[i])
		m.removedintegrations[ids[i]] = struct{}{}
	}
}

// RemovedIntegrations returns the removed IDs of the "integrations" edge to the Integration entity.
func (m *HushMutation) RemovedIntegrationsIDs() (ids []string) {
	for id := range m.removedintegrations {
		ids = append(ids, id)
	}
	return
}

// IntegrationsIDs returns the "integrations" edge IDs in the mutation.
func (m *HushMutation) IntegrationsIDs() (ids []string) {
	for id := range m.integrations {
		ids = append(ids, id)
	}
	return
}

// ResetIntegrations resets all changes to the "integrations" edge.
func (m *HushMutation) ResetIntegrations() {
	m.integrations = nil
	m.clearedintegrations = false
	m.removedintegrations = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *HushMutation) AddOrganizationIDs(ids ...string) {
	if m.organization == nil {
		m.organization = make(map[string]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *HushMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *HushMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *HushMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organization, ids[i])
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *HushMutation) RemovedOrganizationIDs() (ids []string) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *HushMutation) OrganizationIDs() (ids []string) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *HushMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *HushMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *HushMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *HushMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *HushMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *HushMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *HushMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *HushMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the HushMutation builder.
func (m *HushMutation) Where(ps ...predicate.Hush) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HushMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HushMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hush, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HushMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HushMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hush).
func (m *HushMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HushMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, hush.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hush.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, hush.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, hush.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, hush.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, hush.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, hush.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, hush.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hush.FieldDescription)
	}
	if m.kind != nil {
		fields = append(fields, hush.FieldKind)
	}
	if m.secret_name != nil {
		fields = append(fields, hush.FieldSecretName)
	}
	if m.secret_value != nil {
		fields = append(fields, hush.FieldSecretValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HushMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hush.FieldCreatedAt:
		return m.CreatedAt()
	case hush.FieldUpdatedAt:
		return m.UpdatedAt()
	case hush.FieldCreatedBy:
		return m.CreatedBy()
	case hush.FieldUpdatedBy:
		return m.UpdatedBy()
	case hush.FieldMappingID:
		return m.MappingID()
	case hush.FieldDeletedAt:
		return m.DeletedAt()
	case hush.FieldDeletedBy:
		return m.DeletedBy()
	case hush.FieldName:
		return m.Name()
	case hush.FieldDescription:
		return m.Description()
	case hush.FieldKind:
		return m.Kind()
	case hush.FieldSecretName:
		return m.SecretName()
	case hush.FieldSecretValue:
		return m.SecretValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HushMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hush.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hush.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hush.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hush.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case hush.FieldMappingID:
		return m.OldMappingID(ctx)
	case hush.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hush.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case hush.FieldName:
		return m.OldName(ctx)
	case hush.FieldDescription:
		return m.OldDescription(ctx)
	case hush.FieldKind:
		return m.OldKind(ctx)
	case hush.FieldSecretName:
		return m.OldSecretName(ctx)
	case hush.FieldSecretValue:
		return m.OldSecretValue(ctx)
	}
	return nil, fmt.Errorf("unknown Hush field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HushMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hush.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hush.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hush.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hush.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case hush.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case hush.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hush.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case hush.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hush.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hush.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case hush.FieldSecretName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretName(v)
		return nil
	case hush.FieldSecretValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretValue(v)
		return nil
	}
	return fmt.Errorf("unknown Hush field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HushMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HushMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HushMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hush numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HushMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hush.FieldCreatedAt) {
		fields = append(fields, hush.FieldCreatedAt)
	}
	if m.FieldCleared(hush.FieldUpdatedAt) {
		fields = append(fields, hush.FieldUpdatedAt)
	}
	if m.FieldCleared(hush.FieldCreatedBy) {
		fields = append(fields, hush.FieldCreatedBy)
	}
	if m.FieldCleared(hush.FieldUpdatedBy) {
		fields = append(fields, hush.FieldUpdatedBy)
	}
	if m.FieldCleared(hush.FieldDeletedAt) {
		fields = append(fields, hush.FieldDeletedAt)
	}
	if m.FieldCleared(hush.FieldDeletedBy) {
		fields = append(fields, hush.FieldDeletedBy)
	}
	if m.FieldCleared(hush.FieldDescription) {
		fields = append(fields, hush.FieldDescription)
	}
	if m.FieldCleared(hush.FieldKind) {
		fields = append(fields, hush.FieldKind)
	}
	if m.FieldCleared(hush.FieldSecretName) {
		fields = append(fields, hush.FieldSecretName)
	}
	if m.FieldCleared(hush.FieldSecretValue) {
		fields = append(fields, hush.FieldSecretValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HushMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HushMutation) ClearField(name string) error {
	switch name {
	case hush.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hush.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hush.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case hush.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case hush.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case hush.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case hush.FieldDescription:
		m.ClearDescription()
		return nil
	case hush.FieldKind:
		m.ClearKind()
		return nil
	case hush.FieldSecretName:
		m.ClearSecretName()
		return nil
	case hush.FieldSecretValue:
		m.ClearSecretValue()
		return nil
	}
	return fmt.Errorf("unknown Hush nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HushMutation) ResetField(name string) error {
	switch name {
	case hush.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hush.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hush.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hush.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hush.FieldMappingID:
		m.ResetMappingID()
		return nil
	case hush.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hush.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case hush.FieldName:
		m.ResetName()
		return nil
	case hush.FieldDescription:
		m.ResetDescription()
		return nil
	case hush.FieldKind:
		m.ResetKind()
		return nil
	case hush.FieldSecretName:
		m.ResetSecretName()
		return nil
	case hush.FieldSecretValue:
		m.ResetSecretValue()
		return nil
	}
	return fmt.Errorf("unknown Hush field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HushMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.integrations != nil {
		edges = append(edges, hush.EdgeIntegrations)
	}
	if m.organization != nil {
		edges = append(edges, hush.EdgeOrganization)
	}
	if m.events != nil {
		edges = append(edges, hush.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HushMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hush.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.integrations))
		for id := range m.integrations {
			ids = append(ids, id)
		}
		return ids
	case hush.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	case hush.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HushMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedintegrations != nil {
		edges = append(edges, hush.EdgeIntegrations)
	}
	if m.removedorganization != nil {
		edges = append(edges, hush.EdgeOrganization)
	}
	if m.removedevents != nil {
		edges = append(edges, hush.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HushMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hush.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.removedintegrations))
		for id := range m.removedintegrations {
			ids = append(ids, id)
		}
		return ids
	case hush.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	case hush.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HushMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedintegrations {
		edges = append(edges, hush.EdgeIntegrations)
	}
	if m.clearedorganization {
		edges = append(edges, hush.EdgeOrganization)
	}
	if m.clearedevents {
		edges = append(edges, hush.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HushMutation) EdgeCleared(name string) bool {
	switch name {
	case hush.EdgeIntegrations:
		return m.clearedintegrations
	case hush.EdgeOrganization:
		return m.clearedorganization
	case hush.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HushMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Hush unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HushMutation) ResetEdge(name string) error {
	switch name {
	case hush.EdgeIntegrations:
		m.ResetIntegrations()
		return nil
	case hush.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case hush.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Hush edge %s", name)
}

// HushHistoryMutation represents an operation that mutates the HushHistory nodes in the graph.
type HushHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	name          *string
	description   *string
	kind          *string
	secret_name   *string
	secret_value  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*HushHistory, error)
	predicates    []predicate.HushHistory
}

var _ ent.Mutation = (*HushHistoryMutation)(nil)

// hushhistoryOption allows management of the mutation configuration using functional options.
type hushhistoryOption func(*HushHistoryMutation)

// newHushHistoryMutation creates new mutation for the HushHistory entity.
func newHushHistoryMutation(c config, op Op, opts ...hushhistoryOption) *HushHistoryMutation {
	m := &HushHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHushHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHushHistoryID sets the ID field of the mutation.
func withHushHistoryID(id string) hushhistoryOption {
	return func(m *HushHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *HushHistory
		)
		m.oldValue = func(ctx context.Context) (*HushHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HushHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHushHistory sets the old HushHistory of the mutation.
func withHushHistory(node *HushHistory) hushhistoryOption {
	return func(m *HushHistoryMutation) {
		m.oldValue = func(context.Context) (*HushHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HushHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HushHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HushHistory entities.
func (m *HushHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HushHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HushHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HushHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *HushHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *HushHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *HushHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *HushHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *HushHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *HushHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[hushhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *HushHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *HushHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, hushhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *HushHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *HushHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *HushHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HushHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HushHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *HushHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[hushhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *HushHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HushHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, hushhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HushHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HushHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HushHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hushhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HushHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HushHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hushhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *HushHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HushHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HushHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[hushhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HushHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HushHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, hushhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HushHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HushHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *HushHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[hushhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *HushHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HushHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, hushhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *HushHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *HushHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *HushHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HushHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HushHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HushHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hushhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HushHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HushHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hushhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *HushHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *HushHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *HushHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[hushhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *HushHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *HushHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, hushhistory.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *HushHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HushHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HushHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HushHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HushHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HushHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[hushhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HushHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HushHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, hushhistory.FieldDescription)
}

// SetKind sets the "kind" field.
func (m *HushHistoryMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *HushHistoryMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *HushHistoryMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[hushhistory.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *HushHistoryMutation) KindCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *HushHistoryMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, hushhistory.FieldKind)
}

// SetSecretName sets the "secret_name" field.
func (m *HushHistoryMutation) SetSecretName(s string) {
	m.secret_name = &s
}

// SecretName returns the value of the "secret_name" field in the mutation.
func (m *HushHistoryMutation) SecretName() (r string, exists bool) {
	v := m.secret_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretName returns the old "secret_name" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldSecretName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretName: %w", err)
	}
	return oldValue.SecretName, nil
}

// ClearSecretName clears the value of the "secret_name" field.
func (m *HushHistoryMutation) ClearSecretName() {
	m.secret_name = nil
	m.clearedFields[hushhistory.FieldSecretName] = struct{}{}
}

// SecretNameCleared returns if the "secret_name" field was cleared in this mutation.
func (m *HushHistoryMutation) SecretNameCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldSecretName]
	return ok
}

// ResetSecretName resets all changes to the "secret_name" field.
func (m *HushHistoryMutation) ResetSecretName() {
	m.secret_name = nil
	delete(m.clearedFields, hushhistory.FieldSecretName)
}

// SetSecretValue sets the "secret_value" field.
func (m *HushHistoryMutation) SetSecretValue(s string) {
	m.secret_value = &s
}

// SecretValue returns the value of the "secret_value" field in the mutation.
func (m *HushHistoryMutation) SecretValue() (r string, exists bool) {
	v := m.secret_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretValue returns the old "secret_value" field's value of the HushHistory entity.
// If the HushHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HushHistoryMutation) OldSecretValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretValue: %w", err)
	}
	return oldValue.SecretValue, nil
}

// ClearSecretValue clears the value of the "secret_value" field.
func (m *HushHistoryMutation) ClearSecretValue() {
	m.secret_value = nil
	m.clearedFields[hushhistory.FieldSecretValue] = struct{}{}
}

// SecretValueCleared returns if the "secret_value" field was cleared in this mutation.
func (m *HushHistoryMutation) SecretValueCleared() bool {
	_, ok := m.clearedFields[hushhistory.FieldSecretValue]
	return ok
}

// ResetSecretValue resets all changes to the "secret_value" field.
func (m *HushHistoryMutation) ResetSecretValue() {
	m.secret_value = nil
	delete(m.clearedFields, hushhistory.FieldSecretValue)
}

// Where appends a list predicates to the HushHistoryMutation builder.
func (m *HushHistoryMutation) Where(ps ...predicate.HushHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HushHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HushHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HushHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HushHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HushHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HushHistory).
func (m *HushHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HushHistoryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.history_time != nil {
		fields = append(fields, hushhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, hushhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, hushhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, hushhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hushhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, hushhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, hushhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, hushhistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, hushhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, hushhistory.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, hushhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hushhistory.FieldDescription)
	}
	if m.kind != nil {
		fields = append(fields, hushhistory.FieldKind)
	}
	if m.secret_name != nil {
		fields = append(fields, hushhistory.FieldSecretName)
	}
	if m.secret_value != nil {
		fields = append(fields, hushhistory.FieldSecretValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HushHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hushhistory.FieldHistoryTime:
		return m.HistoryTime()
	case hushhistory.FieldRef:
		return m.Ref()
	case hushhistory.FieldOperation:
		return m.Operation()
	case hushhistory.FieldCreatedAt:
		return m.CreatedAt()
	case hushhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case hushhistory.FieldCreatedBy:
		return m.CreatedBy()
	case hushhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case hushhistory.FieldMappingID:
		return m.MappingID()
	case hushhistory.FieldDeletedAt:
		return m.DeletedAt()
	case hushhistory.FieldDeletedBy:
		return m.DeletedBy()
	case hushhistory.FieldName:
		return m.Name()
	case hushhistory.FieldDescription:
		return m.Description()
	case hushhistory.FieldKind:
		return m.Kind()
	case hushhistory.FieldSecretName:
		return m.SecretName()
	case hushhistory.FieldSecretValue:
		return m.SecretValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HushHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hushhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case hushhistory.FieldRef:
		return m.OldRef(ctx)
	case hushhistory.FieldOperation:
		return m.OldOperation(ctx)
	case hushhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hushhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hushhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hushhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case hushhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case hushhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hushhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case hushhistory.FieldName:
		return m.OldName(ctx)
	case hushhistory.FieldDescription:
		return m.OldDescription(ctx)
	case hushhistory.FieldKind:
		return m.OldKind(ctx)
	case hushhistory.FieldSecretName:
		return m.OldSecretName(ctx)
	case hushhistory.FieldSecretValue:
		return m.OldSecretValue(ctx)
	}
	return nil, fmt.Errorf("unknown HushHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HushHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hushhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case hushhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case hushhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case hushhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hushhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hushhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hushhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case hushhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case hushhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hushhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case hushhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hushhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hushhistory.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case hushhistory.FieldSecretName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretName(v)
		return nil
	case hushhistory.FieldSecretValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretValue(v)
		return nil
	}
	return fmt.Errorf("unknown HushHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HushHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HushHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HushHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HushHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HushHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hushhistory.FieldRef) {
		fields = append(fields, hushhistory.FieldRef)
	}
	if m.FieldCleared(hushhistory.FieldCreatedAt) {
		fields = append(fields, hushhistory.FieldCreatedAt)
	}
	if m.FieldCleared(hushhistory.FieldUpdatedAt) {
		fields = append(fields, hushhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(hushhistory.FieldCreatedBy) {
		fields = append(fields, hushhistory.FieldCreatedBy)
	}
	if m.FieldCleared(hushhistory.FieldUpdatedBy) {
		fields = append(fields, hushhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(hushhistory.FieldDeletedAt) {
		fields = append(fields, hushhistory.FieldDeletedAt)
	}
	if m.FieldCleared(hushhistory.FieldDeletedBy) {
		fields = append(fields, hushhistory.FieldDeletedBy)
	}
	if m.FieldCleared(hushhistory.FieldDescription) {
		fields = append(fields, hushhistory.FieldDescription)
	}
	if m.FieldCleared(hushhistory.FieldKind) {
		fields = append(fields, hushhistory.FieldKind)
	}
	if m.FieldCleared(hushhistory.FieldSecretName) {
		fields = append(fields, hushhistory.FieldSecretName)
	}
	if m.FieldCleared(hushhistory.FieldSecretValue) {
		fields = append(fields, hushhistory.FieldSecretValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HushHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HushHistoryMutation) ClearField(name string) error {
	switch name {
	case hushhistory.FieldRef:
		m.ClearRef()
		return nil
	case hushhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case hushhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hushhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case hushhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case hushhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case hushhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case hushhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case hushhistory.FieldKind:
		m.ClearKind()
		return nil
	case hushhistory.FieldSecretName:
		m.ClearSecretName()
		return nil
	case hushhistory.FieldSecretValue:
		m.ClearSecretValue()
		return nil
	}
	return fmt.Errorf("unknown HushHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HushHistoryMutation) ResetField(name string) error {
	switch name {
	case hushhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case hushhistory.FieldRef:
		m.ResetRef()
		return nil
	case hushhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case hushhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hushhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hushhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hushhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hushhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case hushhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hushhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case hushhistory.FieldName:
		m.ResetName()
		return nil
	case hushhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case hushhistory.FieldKind:
		m.ResetKind()
		return nil
	case hushhistory.FieldSecretName:
		m.ResetSecretName()
		return nil
	case hushhistory.FieldSecretValue:
		m.ResetSecretValue()
		return nil
	}
	return fmt.Errorf("unknown HushHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HushHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HushHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HushHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HushHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HushHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HushHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HushHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HushHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HushHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HushHistory edge %s", name)
}

// IntegrationMutation represents an operation that mutates the Integration nodes in the graph.
type IntegrationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	mapping_id          *string
	tags                *[]string
	appendtags          []string
	deleted_at          *time.Time
	deleted_by          *string
	name                *string
	description         *string
	kind                *string
	clearedFields       map[string]struct{}
	owner               *string
	clearedowner        bool
	secrets             map[string]struct{}
	removedsecrets      map[string]struct{}
	clearedsecrets      bool
	oauth2tokens        map[string]struct{}
	removedoauth2tokens map[string]struct{}
	clearedoauth2tokens bool
	events              map[string]struct{}
	removedevents       map[string]struct{}
	clearedevents       bool
	webhooks            map[string]struct{}
	removedwebhooks     map[string]struct{}
	clearedwebhooks     bool
	done                bool
	oldValue            func(context.Context) (*Integration, error)
	predicates          []predicate.Integration
}

var _ ent.Mutation = (*IntegrationMutation)(nil)

// integrationOption allows management of the mutation configuration using functional options.
type integrationOption func(*IntegrationMutation)

// newIntegrationMutation creates new mutation for the Integration entity.
func newIntegrationMutation(c config, op Op, opts ...integrationOption) *IntegrationMutation {
	m := &IntegrationMutation{
		config:        c,
		op:            op,
		typ:           TypeIntegration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIntegrationID sets the ID field of the mutation.
func withIntegrationID(id string) integrationOption {
	return func(m *IntegrationMutation) {
		var (
			err   error
			once  sync.Once
			value *Integration
		)
		m.oldValue = func(ctx context.Context) (*Integration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Integration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIntegration sets the old Integration of the mutation.
func withIntegration(node *Integration) integrationOption {
	return func(m *IntegrationMutation) {
		m.oldValue = func(context.Context) (*Integration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IntegrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IntegrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Integration entities.
func (m *IntegrationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IntegrationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IntegrationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Integration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IntegrationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IntegrationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *IntegrationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[integration.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *IntegrationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[integration.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IntegrationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, integration.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IntegrationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IntegrationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *IntegrationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[integration.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *IntegrationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[integration.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IntegrationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, integration.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *IntegrationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *IntegrationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *IntegrationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[integration.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *IntegrationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[integration.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *IntegrationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, integration.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *IntegrationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *IntegrationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *IntegrationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[integration.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *IntegrationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[integration.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *IntegrationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, integration.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *IntegrationMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *IntegrationMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *IntegrationMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *IntegrationMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IntegrationMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *IntegrationMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *IntegrationMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *IntegrationMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[integration.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *IntegrationMutation) TagsCleared() bool {
	_, ok := m.clearedFields[integration.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *IntegrationMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, integration.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IntegrationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IntegrationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IntegrationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[integration.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IntegrationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[integration.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IntegrationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, integration.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *IntegrationMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *IntegrationMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *IntegrationMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[integration.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *IntegrationMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[integration.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *IntegrationMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, integration.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *IntegrationMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *IntegrationMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *IntegrationMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[integration.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *IntegrationMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[integration.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *IntegrationMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, integration.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *IntegrationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IntegrationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IntegrationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *IntegrationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IntegrationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IntegrationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[integration.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IntegrationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[integration.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IntegrationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, integration.FieldDescription)
}

// SetKind sets the "kind" field.
func (m *IntegrationMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *IntegrationMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Integration entity.
// If the Integration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *IntegrationMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[integration.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *IntegrationMutation) KindCleared() bool {
	_, ok := m.clearedFields[integration.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *IntegrationMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, integration.FieldKind)
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *IntegrationMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[integration.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *IntegrationMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *IntegrationMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *IntegrationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddSecretIDs adds the "secrets" edge to the Hush entity by ids.
func (m *IntegrationMutation) AddSecretIDs(ids ...string) {
	if m.secrets == nil {
		m.secrets = make(map[string]struct{})
	}
	for i := range ids {
		m.secrets[ids[i]] = struct{}{}
	}
}

// ClearSecrets clears the "secrets" edge to the Hush entity.
func (m *IntegrationMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the Hush entity was cleared.
func (m *IntegrationMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// RemoveSecretIDs removes the "secrets" edge to the Hush entity by IDs.
func (m *IntegrationMutation) RemoveSecretIDs(ids ...string) {
	if m.removedsecrets == nil {
		m.removedsecrets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.secrets, ids[i])
		m.removedsecrets[ids[i]] = struct{}{}
	}
}

// RemovedSecrets returns the removed IDs of the "secrets" edge to the Hush entity.
func (m *IntegrationMutation) RemovedSecretsIDs() (ids []string) {
	for id := range m.removedsecrets {
		ids = append(ids, id)
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
func (m *IntegrationMutation) SecretsIDs() (ids []string) {
	for id := range m.secrets {
		ids = append(ids, id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *IntegrationMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
	m.removedsecrets = nil
}

// AddOauth2tokenIDs adds the "oauth2tokens" edge to the OhAuthTooToken entity by ids.
func (m *IntegrationMutation) AddOauth2tokenIDs(ids ...string) {
	if m.oauth2tokens == nil {
		m.oauth2tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.oauth2tokens[ids[i]] = struct{}{}
	}
}

// ClearOauth2tokens clears the "oauth2tokens" edge to the OhAuthTooToken entity.
func (m *IntegrationMutation) ClearOauth2tokens() {
	m.clearedoauth2tokens = true
}

// Oauth2tokensCleared reports if the "oauth2tokens" edge to the OhAuthTooToken entity was cleared.
func (m *IntegrationMutation) Oauth2tokensCleared() bool {
	return m.clearedoauth2tokens
}

// RemoveOauth2tokenIDs removes the "oauth2tokens" edge to the OhAuthTooToken entity by IDs.
func (m *IntegrationMutation) RemoveOauth2tokenIDs(ids ...string) {
	if m.removedoauth2tokens == nil {
		m.removedoauth2tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.oauth2tokens, ids[i])
		m.removedoauth2tokens[ids[i]] = struct{}{}
	}
}

// RemovedOauth2tokens returns the removed IDs of the "oauth2tokens" edge to the OhAuthTooToken entity.
func (m *IntegrationMutation) RemovedOauth2tokensIDs() (ids []string) {
	for id := range m.removedoauth2tokens {
		ids = append(ids, id)
	}
	return
}

// Oauth2tokensIDs returns the "oauth2tokens" edge IDs in the mutation.
func (m *IntegrationMutation) Oauth2tokensIDs() (ids []string) {
	for id := range m.oauth2tokens {
		ids = append(ids, id)
	}
	return
}

// ResetOauth2tokens resets all changes to the "oauth2tokens" edge.
func (m *IntegrationMutation) ResetOauth2tokens() {
	m.oauth2tokens = nil
	m.clearedoauth2tokens = false
	m.removedoauth2tokens = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *IntegrationMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *IntegrationMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *IntegrationMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *IntegrationMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *IntegrationMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *IntegrationMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *IntegrationMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddWebhookIDs adds the "webhooks" edge to the Webhook entity by ids.
func (m *IntegrationMutation) AddWebhookIDs(ids ...string) {
	if m.webhooks == nil {
		m.webhooks = make(map[string]struct{})
	}
	for i := range ids {
		m.webhooks[ids[i]] = struct{}{}
	}
}

// ClearWebhooks clears the "webhooks" edge to the Webhook entity.
func (m *IntegrationMutation) ClearWebhooks() {
	m.clearedwebhooks = true
}

// WebhooksCleared reports if the "webhooks" edge to the Webhook entity was cleared.
func (m *IntegrationMutation) WebhooksCleared() bool {
	return m.clearedwebhooks
}

// RemoveWebhookIDs removes the "webhooks" edge to the Webhook entity by IDs.
func (m *IntegrationMutation) RemoveWebhookIDs(ids ...string) {
	if m.removedwebhooks == nil {
		m.removedwebhooks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.webhooks, ids[i])
		m.removedwebhooks[ids[i]] = struct{}{}
	}
}

// RemovedWebhooks returns the removed IDs of the "webhooks" edge to the Webhook entity.
func (m *IntegrationMutation) RemovedWebhooksIDs() (ids []string) {
	for id := range m.removedwebhooks {
		ids = append(ids, id)
	}
	return
}

// WebhooksIDs returns the "webhooks" edge IDs in the mutation.
func (m *IntegrationMutation) WebhooksIDs() (ids []string) {
	for id := range m.webhooks {
		ids = append(ids, id)
	}
	return
}

// ResetWebhooks resets all changes to the "webhooks" edge.
func (m *IntegrationMutation) ResetWebhooks() {
	m.webhooks = nil
	m.clearedwebhooks = false
	m.removedwebhooks = nil
}

// Where appends a list predicates to the IntegrationMutation builder.
func (m *IntegrationMutation) Where(ps ...predicate.Integration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IntegrationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IntegrationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Integration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IntegrationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IntegrationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Integration).
func (m *IntegrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IntegrationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, integration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, integration.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, integration.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, integration.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, integration.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, integration.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, integration.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, integration.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, integration.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, integration.FieldName)
	}
	if m.description != nil {
		fields = append(fields, integration.FieldDescription)
	}
	if m.kind != nil {
		fields = append(fields, integration.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IntegrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case integration.FieldCreatedAt:
		return m.CreatedAt()
	case integration.FieldUpdatedAt:
		return m.UpdatedAt()
	case integration.FieldCreatedBy:
		return m.CreatedBy()
	case integration.FieldUpdatedBy:
		return m.UpdatedBy()
	case integration.FieldMappingID:
		return m.MappingID()
	case integration.FieldTags:
		return m.Tags()
	case integration.FieldDeletedAt:
		return m.DeletedAt()
	case integration.FieldDeletedBy:
		return m.DeletedBy()
	case integration.FieldOwnerID:
		return m.OwnerID()
	case integration.FieldName:
		return m.Name()
	case integration.FieldDescription:
		return m.Description()
	case integration.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IntegrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case integration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case integration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case integration.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case integration.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case integration.FieldMappingID:
		return m.OldMappingID(ctx)
	case integration.FieldTags:
		return m.OldTags(ctx)
	case integration.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case integration.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case integration.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case integration.FieldName:
		return m.OldName(ctx)
	case integration.FieldDescription:
		return m.OldDescription(ctx)
	case integration.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown Integration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case integration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case integration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case integration.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case integration.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case integration.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case integration.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case integration.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case integration.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case integration.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case integration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case integration.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case integration.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown Integration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IntegrationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IntegrationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Integration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IntegrationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(integration.FieldCreatedAt) {
		fields = append(fields, integration.FieldCreatedAt)
	}
	if m.FieldCleared(integration.FieldUpdatedAt) {
		fields = append(fields, integration.FieldUpdatedAt)
	}
	if m.FieldCleared(integration.FieldCreatedBy) {
		fields = append(fields, integration.FieldCreatedBy)
	}
	if m.FieldCleared(integration.FieldUpdatedBy) {
		fields = append(fields, integration.FieldUpdatedBy)
	}
	if m.FieldCleared(integration.FieldTags) {
		fields = append(fields, integration.FieldTags)
	}
	if m.FieldCleared(integration.FieldDeletedAt) {
		fields = append(fields, integration.FieldDeletedAt)
	}
	if m.FieldCleared(integration.FieldDeletedBy) {
		fields = append(fields, integration.FieldDeletedBy)
	}
	if m.FieldCleared(integration.FieldOwnerID) {
		fields = append(fields, integration.FieldOwnerID)
	}
	if m.FieldCleared(integration.FieldDescription) {
		fields = append(fields, integration.FieldDescription)
	}
	if m.FieldCleared(integration.FieldKind) {
		fields = append(fields, integration.FieldKind)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IntegrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IntegrationMutation) ClearField(name string) error {
	switch name {
	case integration.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case integration.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case integration.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case integration.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case integration.FieldTags:
		m.ClearTags()
		return nil
	case integration.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case integration.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case integration.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case integration.FieldDescription:
		m.ClearDescription()
		return nil
	case integration.FieldKind:
		m.ClearKind()
		return nil
	}
	return fmt.Errorf("unknown Integration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IntegrationMutation) ResetField(name string) error {
	switch name {
	case integration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case integration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case integration.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case integration.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case integration.FieldMappingID:
		m.ResetMappingID()
		return nil
	case integration.FieldTags:
		m.ResetTags()
		return nil
	case integration.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case integration.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case integration.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case integration.FieldName:
		m.ResetName()
		return nil
	case integration.FieldDescription:
		m.ResetDescription()
		return nil
	case integration.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown Integration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IntegrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, integration.EdgeOwner)
	}
	if m.secrets != nil {
		edges = append(edges, integration.EdgeSecrets)
	}
	if m.oauth2tokens != nil {
		edges = append(edges, integration.EdgeOauth2tokens)
	}
	if m.events != nil {
		edges = append(edges, integration.EdgeEvents)
	}
	if m.webhooks != nil {
		edges = append(edges, integration.EdgeWebhooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IntegrationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case integration.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case integration.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.secrets))
		for id := range m.secrets {
			ids = append(ids, id)
		}
		return ids
	case integration.EdgeOauth2tokens:
		ids := make([]ent.Value, 0, len(m.oauth2tokens))
		for id := range m.oauth2tokens {
			ids = append(ids, id)
		}
		return ids
	case integration.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case integration.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.webhooks))
		for id := range m.webhooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IntegrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedsecrets != nil {
		edges = append(edges, integration.EdgeSecrets)
	}
	if m.removedoauth2tokens != nil {
		edges = append(edges, integration.EdgeOauth2tokens)
	}
	if m.removedevents != nil {
		edges = append(edges, integration.EdgeEvents)
	}
	if m.removedwebhooks != nil {
		edges = append(edges, integration.EdgeWebhooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IntegrationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case integration.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.removedsecrets))
		for id := range m.removedsecrets {
			ids = append(ids, id)
		}
		return ids
	case integration.EdgeOauth2tokens:
		ids := make([]ent.Value, 0, len(m.removedoauth2tokens))
		for id := range m.removedoauth2tokens {
			ids = append(ids, id)
		}
		return ids
	case integration.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case integration.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.removedwebhooks))
		for id := range m.removedwebhooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IntegrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, integration.EdgeOwner)
	}
	if m.clearedsecrets {
		edges = append(edges, integration.EdgeSecrets)
	}
	if m.clearedoauth2tokens {
		edges = append(edges, integration.EdgeOauth2tokens)
	}
	if m.clearedevents {
		edges = append(edges, integration.EdgeEvents)
	}
	if m.clearedwebhooks {
		edges = append(edges, integration.EdgeWebhooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IntegrationMutation) EdgeCleared(name string) bool {
	switch name {
	case integration.EdgeOwner:
		return m.clearedowner
	case integration.EdgeSecrets:
		return m.clearedsecrets
	case integration.EdgeOauth2tokens:
		return m.clearedoauth2tokens
	case integration.EdgeEvents:
		return m.clearedevents
	case integration.EdgeWebhooks:
		return m.clearedwebhooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IntegrationMutation) ClearEdge(name string) error {
	switch name {
	case integration.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Integration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IntegrationMutation) ResetEdge(name string) error {
	switch name {
	case integration.EdgeOwner:
		m.ResetOwner()
		return nil
	case integration.EdgeSecrets:
		m.ResetSecrets()
		return nil
	case integration.EdgeOauth2tokens:
		m.ResetOauth2tokens()
		return nil
	case integration.EdgeEvents:
		m.ResetEvents()
		return nil
	case integration.EdgeWebhooks:
		m.ResetWebhooks()
		return nil
	}
	return fmt.Errorf("unknown Integration edge %s", name)
}

// IntegrationHistoryMutation represents an operation that mutates the IntegrationHistory nodes in the graph.
type IntegrationHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	deleted_at    *time.Time
	deleted_by    *string
	owner_id      *string
	name          *string
	description   *string
	kind          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IntegrationHistory, error)
	predicates    []predicate.IntegrationHistory
}

var _ ent.Mutation = (*IntegrationHistoryMutation)(nil)

// integrationhistoryOption allows management of the mutation configuration using functional options.
type integrationhistoryOption func(*IntegrationHistoryMutation)

// newIntegrationHistoryMutation creates new mutation for the IntegrationHistory entity.
func newIntegrationHistoryMutation(c config, op Op, opts ...integrationhistoryOption) *IntegrationHistoryMutation {
	m := &IntegrationHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeIntegrationHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIntegrationHistoryID sets the ID field of the mutation.
func withIntegrationHistoryID(id string) integrationhistoryOption {
	return func(m *IntegrationHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *IntegrationHistory
		)
		m.oldValue = func(ctx context.Context) (*IntegrationHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IntegrationHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIntegrationHistory sets the old IntegrationHistory of the mutation.
func withIntegrationHistory(node *IntegrationHistory) integrationhistoryOption {
	return func(m *IntegrationHistoryMutation) {
		m.oldValue = func(context.Context) (*IntegrationHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IntegrationHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IntegrationHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IntegrationHistory entities.
func (m *IntegrationHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IntegrationHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IntegrationHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IntegrationHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *IntegrationHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *IntegrationHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *IntegrationHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *IntegrationHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *IntegrationHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *IntegrationHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[integrationhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *IntegrationHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, integrationhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *IntegrationHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *IntegrationHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *IntegrationHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IntegrationHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IntegrationHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *IntegrationHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[integrationhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IntegrationHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, integrationhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IntegrationHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IntegrationHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *IntegrationHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[integrationhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IntegrationHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, integrationhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *IntegrationHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *IntegrationHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *IntegrationHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[integrationhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *IntegrationHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, integrationhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *IntegrationHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *IntegrationHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *IntegrationHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[integrationhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *IntegrationHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, integrationhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *IntegrationHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *IntegrationHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *IntegrationHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *IntegrationHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IntegrationHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *IntegrationHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *IntegrationHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *IntegrationHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[integrationhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *IntegrationHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, integrationhistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IntegrationHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IntegrationHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IntegrationHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[integrationhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IntegrationHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, integrationhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *IntegrationHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *IntegrationHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *IntegrationHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[integrationhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *IntegrationHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, integrationhistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *IntegrationHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *IntegrationHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *IntegrationHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[integrationhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *IntegrationHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, integrationhistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *IntegrationHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IntegrationHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IntegrationHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *IntegrationHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IntegrationHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IntegrationHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[integrationhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IntegrationHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, integrationhistory.FieldDescription)
}

// SetKind sets the "kind" field.
func (m *IntegrationHistoryMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *IntegrationHistoryMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the IntegrationHistory entity.
// If the IntegrationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntegrationHistoryMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *IntegrationHistoryMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[integrationhistory.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *IntegrationHistoryMutation) KindCleared() bool {
	_, ok := m.clearedFields[integrationhistory.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *IntegrationHistoryMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, integrationhistory.FieldKind)
}

// Where appends a list predicates to the IntegrationHistoryMutation builder.
func (m *IntegrationHistoryMutation) Where(ps ...predicate.IntegrationHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IntegrationHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IntegrationHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IntegrationHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IntegrationHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IntegrationHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IntegrationHistory).
func (m *IntegrationHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IntegrationHistoryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.history_time != nil {
		fields = append(fields, integrationhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, integrationhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, integrationhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, integrationhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, integrationhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, integrationhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, integrationhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, integrationhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, integrationhistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, integrationhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, integrationhistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, integrationhistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, integrationhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, integrationhistory.FieldDescription)
	}
	if m.kind != nil {
		fields = append(fields, integrationhistory.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IntegrationHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case integrationhistory.FieldHistoryTime:
		return m.HistoryTime()
	case integrationhistory.FieldRef:
		return m.Ref()
	case integrationhistory.FieldOperation:
		return m.Operation()
	case integrationhistory.FieldCreatedAt:
		return m.CreatedAt()
	case integrationhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case integrationhistory.FieldCreatedBy:
		return m.CreatedBy()
	case integrationhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case integrationhistory.FieldMappingID:
		return m.MappingID()
	case integrationhistory.FieldTags:
		return m.Tags()
	case integrationhistory.FieldDeletedAt:
		return m.DeletedAt()
	case integrationhistory.FieldDeletedBy:
		return m.DeletedBy()
	case integrationhistory.FieldOwnerID:
		return m.OwnerID()
	case integrationhistory.FieldName:
		return m.Name()
	case integrationhistory.FieldDescription:
		return m.Description()
	case integrationhistory.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IntegrationHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case integrationhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case integrationhistory.FieldRef:
		return m.OldRef(ctx)
	case integrationhistory.FieldOperation:
		return m.OldOperation(ctx)
	case integrationhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case integrationhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case integrationhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case integrationhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case integrationhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case integrationhistory.FieldTags:
		return m.OldTags(ctx)
	case integrationhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case integrationhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case integrationhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case integrationhistory.FieldName:
		return m.OldName(ctx)
	case integrationhistory.FieldDescription:
		return m.OldDescription(ctx)
	case integrationhistory.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown IntegrationHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case integrationhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case integrationhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case integrationhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case integrationhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case integrationhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case integrationhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case integrationhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case integrationhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case integrationhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case integrationhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case integrationhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case integrationhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case integrationhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case integrationhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case integrationhistory.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown IntegrationHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IntegrationHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IntegrationHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntegrationHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IntegrationHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IntegrationHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(integrationhistory.FieldRef) {
		fields = append(fields, integrationhistory.FieldRef)
	}
	if m.FieldCleared(integrationhistory.FieldCreatedAt) {
		fields = append(fields, integrationhistory.FieldCreatedAt)
	}
	if m.FieldCleared(integrationhistory.FieldUpdatedAt) {
		fields = append(fields, integrationhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(integrationhistory.FieldCreatedBy) {
		fields = append(fields, integrationhistory.FieldCreatedBy)
	}
	if m.FieldCleared(integrationhistory.FieldUpdatedBy) {
		fields = append(fields, integrationhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(integrationhistory.FieldTags) {
		fields = append(fields, integrationhistory.FieldTags)
	}
	if m.FieldCleared(integrationhistory.FieldDeletedAt) {
		fields = append(fields, integrationhistory.FieldDeletedAt)
	}
	if m.FieldCleared(integrationhistory.FieldDeletedBy) {
		fields = append(fields, integrationhistory.FieldDeletedBy)
	}
	if m.FieldCleared(integrationhistory.FieldOwnerID) {
		fields = append(fields, integrationhistory.FieldOwnerID)
	}
	if m.FieldCleared(integrationhistory.FieldDescription) {
		fields = append(fields, integrationhistory.FieldDescription)
	}
	if m.FieldCleared(integrationhistory.FieldKind) {
		fields = append(fields, integrationhistory.FieldKind)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IntegrationHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IntegrationHistoryMutation) ClearField(name string) error {
	switch name {
	case integrationhistory.FieldRef:
		m.ClearRef()
		return nil
	case integrationhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case integrationhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case integrationhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case integrationhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case integrationhistory.FieldTags:
		m.ClearTags()
		return nil
	case integrationhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case integrationhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case integrationhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case integrationhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case integrationhistory.FieldKind:
		m.ClearKind()
		return nil
	}
	return fmt.Errorf("unknown IntegrationHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IntegrationHistoryMutation) ResetField(name string) error {
	switch name {
	case integrationhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case integrationhistory.FieldRef:
		m.ResetRef()
		return nil
	case integrationhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case integrationhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case integrationhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case integrationhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case integrationhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case integrationhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case integrationhistory.FieldTags:
		m.ResetTags()
		return nil
	case integrationhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case integrationhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case integrationhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case integrationhistory.FieldName:
		m.ResetName()
		return nil
	case integrationhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case integrationhistory.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown IntegrationHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IntegrationHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IntegrationHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IntegrationHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IntegrationHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IntegrationHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IntegrationHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IntegrationHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IntegrationHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IntegrationHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IntegrationHistory edge %s", name)
}

// InternalPolicyMutation represents an operation that mutates the InternalPolicy nodes in the graph.
type InternalPolicyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	deleted_at               *time.Time
	deleted_by               *string
	mapping_id               *string
	tags                     *[]string
	appendtags               []string
	name                     *string
	description              *string
	status                   *string
	policy_type              *string
	version                  *string
	purpose_and_scope        *string
	background               *string
	details                  *map[string]interface{}
	clearedFields            map[string]struct{}
	controlobjectives        map[string]struct{}
	removedcontrolobjectives map[string]struct{}
	clearedcontrolobjectives bool
	controls                 map[string]struct{}
	removedcontrols          map[string]struct{}
	clearedcontrols          bool
	procedures               map[string]struct{}
	removedprocedures        map[string]struct{}
	clearedprocedures        bool
	narratives               map[string]struct{}
	removednarratives        map[string]struct{}
	clearednarratives        bool
	tasks                    map[string]struct{}
	removedtasks             map[string]struct{}
	clearedtasks             bool
	programs                 map[string]struct{}
	removedprograms          map[string]struct{}
	clearedprograms          bool
	done                     bool
	oldValue                 func(context.Context) (*InternalPolicy, error)
	predicates               []predicate.InternalPolicy
}

var _ ent.Mutation = (*InternalPolicyMutation)(nil)

// internalpolicyOption allows management of the mutation configuration using functional options.
type internalpolicyOption func(*InternalPolicyMutation)

// newInternalPolicyMutation creates new mutation for the InternalPolicy entity.
func newInternalPolicyMutation(c config, op Op, opts ...internalpolicyOption) *InternalPolicyMutation {
	m := &InternalPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeInternalPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternalPolicyID sets the ID field of the mutation.
func withInternalPolicyID(id string) internalpolicyOption {
	return func(m *InternalPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *InternalPolicy
		)
		m.oldValue = func(ctx context.Context) (*InternalPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternalPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternalPolicy sets the old InternalPolicy of the mutation.
func withInternalPolicy(node *InternalPolicy) internalpolicyOption {
	return func(m *InternalPolicyMutation) {
		m.oldValue = func(context.Context) (*InternalPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternalPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternalPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternalPolicy entities.
func (m *InternalPolicyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternalPolicyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternalPolicyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternalPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InternalPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternalPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InternalPolicyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[internalpolicy.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InternalPolicyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternalPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, internalpolicy.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InternalPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InternalPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InternalPolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[internalpolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InternalPolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InternalPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, internalpolicy.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *InternalPolicyMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InternalPolicyMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *InternalPolicyMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[internalpolicy.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *InternalPolicyMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InternalPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, internalpolicy.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InternalPolicyMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InternalPolicyMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *InternalPolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[internalpolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *InternalPolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InternalPolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, internalpolicy.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InternalPolicyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InternalPolicyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InternalPolicyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[internalpolicy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InternalPolicyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InternalPolicyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, internalpolicy.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *InternalPolicyMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *InternalPolicyMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *InternalPolicyMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[internalpolicy.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *InternalPolicyMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *InternalPolicyMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, internalpolicy.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *InternalPolicyMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *InternalPolicyMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *InternalPolicyMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *InternalPolicyMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *InternalPolicyMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *InternalPolicyMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *InternalPolicyMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *InternalPolicyMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[internalpolicy.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *InternalPolicyMutation) TagsCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *InternalPolicyMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, internalpolicy.FieldTags)
}

// SetName sets the "name" field.
func (m *InternalPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InternalPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InternalPolicyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *InternalPolicyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InternalPolicyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *InternalPolicyMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *InternalPolicyMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InternalPolicyMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *InternalPolicyMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[internalpolicy.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *InternalPolicyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *InternalPolicyMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, internalpolicy.FieldStatus)
}

// SetPolicyType sets the "policy_type" field.
func (m *InternalPolicyMutation) SetPolicyType(s string) {
	m.policy_type = &s
}

// PolicyType returns the value of the "policy_type" field in the mutation.
func (m *InternalPolicyMutation) PolicyType() (r string, exists bool) {
	v := m.policy_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyType returns the old "policy_type" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldPolicyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyType: %w", err)
	}
	return oldValue.PolicyType, nil
}

// ClearPolicyType clears the value of the "policy_type" field.
func (m *InternalPolicyMutation) ClearPolicyType() {
	m.policy_type = nil
	m.clearedFields[internalpolicy.FieldPolicyType] = struct{}{}
}

// PolicyTypeCleared returns if the "policy_type" field was cleared in this mutation.
func (m *InternalPolicyMutation) PolicyTypeCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldPolicyType]
	return ok
}

// ResetPolicyType resets all changes to the "policy_type" field.
func (m *InternalPolicyMutation) ResetPolicyType() {
	m.policy_type = nil
	delete(m.clearedFields, internalpolicy.FieldPolicyType)
}

// SetVersion sets the "version" field.
func (m *InternalPolicyMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *InternalPolicyMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *InternalPolicyMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[internalpolicy.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *InternalPolicyMutation) VersionCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *InternalPolicyMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, internalpolicy.FieldVersion)
}

// SetPurposeAndScope sets the "purpose_and_scope" field.
func (m *InternalPolicyMutation) SetPurposeAndScope(s string) {
	m.purpose_and_scope = &s
}

// PurposeAndScope returns the value of the "purpose_and_scope" field in the mutation.
func (m *InternalPolicyMutation) PurposeAndScope() (r string, exists bool) {
	v := m.purpose_and_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldPurposeAndScope returns the old "purpose_and_scope" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldPurposeAndScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurposeAndScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurposeAndScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurposeAndScope: %w", err)
	}
	return oldValue.PurposeAndScope, nil
}

// ClearPurposeAndScope clears the value of the "purpose_and_scope" field.
func (m *InternalPolicyMutation) ClearPurposeAndScope() {
	m.purpose_and_scope = nil
	m.clearedFields[internalpolicy.FieldPurposeAndScope] = struct{}{}
}

// PurposeAndScopeCleared returns if the "purpose_and_scope" field was cleared in this mutation.
func (m *InternalPolicyMutation) PurposeAndScopeCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldPurposeAndScope]
	return ok
}

// ResetPurposeAndScope resets all changes to the "purpose_and_scope" field.
func (m *InternalPolicyMutation) ResetPurposeAndScope() {
	m.purpose_and_scope = nil
	delete(m.clearedFields, internalpolicy.FieldPurposeAndScope)
}

// SetBackground sets the "background" field.
func (m *InternalPolicyMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *InternalPolicyMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *InternalPolicyMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[internalpolicy.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *InternalPolicyMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *InternalPolicyMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, internalpolicy.FieldBackground)
}

// SetDetails sets the "details" field.
func (m *InternalPolicyMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *InternalPolicyMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the InternalPolicy entity.
// If the InternalPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *InternalPolicyMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[internalpolicy.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *InternalPolicyMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[internalpolicy.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *InternalPolicyMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, internalpolicy.FieldDetails)
}

// AddControlobjectiveIDs adds the "controlobjectives" edge to the ControlObjective entity by ids.
func (m *InternalPolicyMutation) AddControlobjectiveIDs(ids ...string) {
	if m.controlobjectives == nil {
		m.controlobjectives = make(map[string]struct{})
	}
	for i := range ids {
		m.controlobjectives[ids[i]] = struct{}{}
	}
}

// ClearControlobjectives clears the "controlobjectives" edge to the ControlObjective entity.
func (m *InternalPolicyMutation) ClearControlobjectives() {
	m.clearedcontrolobjectives = true
}

// ControlobjectivesCleared reports if the "controlobjectives" edge to the ControlObjective entity was cleared.
func (m *InternalPolicyMutation) ControlobjectivesCleared() bool {
	return m.clearedcontrolobjectives
}

// RemoveControlobjectiveIDs removes the "controlobjectives" edge to the ControlObjective entity by IDs.
func (m *InternalPolicyMutation) RemoveControlobjectiveIDs(ids ...string) {
	if m.removedcontrolobjectives == nil {
		m.removedcontrolobjectives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controlobjectives, ids[i])
		m.removedcontrolobjectives[ids[i]] = struct{}{}
	}
}

// RemovedControlobjectives returns the removed IDs of the "controlobjectives" edge to the ControlObjective entity.
func (m *InternalPolicyMutation) RemovedControlobjectivesIDs() (ids []string) {
	for id := range m.removedcontrolobjectives {
		ids = append(ids, id)
	}
	return
}

// ControlobjectivesIDs returns the "controlobjectives" edge IDs in the mutation.
func (m *InternalPolicyMutation) ControlobjectivesIDs() (ids []string) {
	for id := range m.controlobjectives {
		ids = append(ids, id)
	}
	return
}

// ResetControlobjectives resets all changes to the "controlobjectives" edge.
func (m *InternalPolicyMutation) ResetControlobjectives() {
	m.controlobjectives = nil
	m.clearedcontrolobjectives = false
	m.removedcontrolobjectives = nil
}

// AddControlIDs adds the "controls" edge to the Control entity by ids.
func (m *InternalPolicyMutation) AddControlIDs(ids ...string) {
	if m.controls == nil {
		m.controls = make(map[string]struct{})
	}
	for i := range ids {
		m.controls[ids[i]] = struct{}{}
	}
}

// ClearControls clears the "controls" edge to the Control entity.
func (m *InternalPolicyMutation) ClearControls() {
	m.clearedcontrols = true
}

// ControlsCleared reports if the "controls" edge to the Control entity was cleared.
func (m *InternalPolicyMutation) ControlsCleared() bool {
	return m.clearedcontrols
}

// RemoveControlIDs removes the "controls" edge to the Control entity by IDs.
func (m *InternalPolicyMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrols == nil {
		m.removedcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controls, ids[i])
		m.removedcontrols[ids[i]] = struct{}{}
	}
}

// RemovedControls returns the removed IDs of the "controls" edge to the Control entity.
func (m *InternalPolicyMutation) RemovedControlsIDs() (ids []string) {
	for id := range m.removedcontrols {
		ids = append(ids, id)
	}
	return
}

// ControlsIDs returns the "controls" edge IDs in the mutation.
func (m *InternalPolicyMutation) ControlsIDs() (ids []string) {
	for id := range m.controls {
		ids = append(ids, id)
	}
	return
}

// ResetControls resets all changes to the "controls" edge.
func (m *InternalPolicyMutation) ResetControls() {
	m.controls = nil
	m.clearedcontrols = false
	m.removedcontrols = nil
}

// AddProcedureIDs adds the "procedures" edge to the Procedure entity by ids.
func (m *InternalPolicyMutation) AddProcedureIDs(ids ...string) {
	if m.procedures == nil {
		m.procedures = make(map[string]struct{})
	}
	for i := range ids {
		m.procedures[ids[i]] = struct{}{}
	}
}

// ClearProcedures clears the "procedures" edge to the Procedure entity.
func (m *InternalPolicyMutation) ClearProcedures() {
	m.clearedprocedures = true
}

// ProceduresCleared reports if the "procedures" edge to the Procedure entity was cleared.
func (m *InternalPolicyMutation) ProceduresCleared() bool {
	return m.clearedprocedures
}

// RemoveProcedureIDs removes the "procedures" edge to the Procedure entity by IDs.
func (m *InternalPolicyMutation) RemoveProcedureIDs(ids ...string) {
	if m.removedprocedures == nil {
		m.removedprocedures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.procedures, ids[i])
		m.removedprocedures[ids[i]] = struct{}{}
	}
}

// RemovedProcedures returns the removed IDs of the "procedures" edge to the Procedure entity.
func (m *InternalPolicyMutation) RemovedProceduresIDs() (ids []string) {
	for id := range m.removedprocedures {
		ids = append(ids, id)
	}
	return
}

// ProceduresIDs returns the "procedures" edge IDs in the mutation.
func (m *InternalPolicyMutation) ProceduresIDs() (ids []string) {
	for id := range m.procedures {
		ids = append(ids, id)
	}
	return
}

// ResetProcedures resets all changes to the "procedures" edge.
func (m *InternalPolicyMutation) ResetProcedures() {
	m.procedures = nil
	m.clearedprocedures = false
	m.removedprocedures = nil
}

// AddNarrativeIDs adds the "narratives" edge to the Narrative entity by ids.
func (m *InternalPolicyMutation) AddNarrativeIDs(ids ...string) {
	if m.narratives == nil {
		m.narratives = make(map[string]struct{})
	}
	for i := range ids {
		m.narratives[ids[i]] = struct{}{}
	}
}

// ClearNarratives clears the "narratives" edge to the Narrative entity.
func (m *InternalPolicyMutation) ClearNarratives() {
	m.clearednarratives = true
}

// NarrativesCleared reports if the "narratives" edge to the Narrative entity was cleared.
func (m *InternalPolicyMutation) NarrativesCleared() bool {
	return m.clearednarratives
}

// RemoveNarrativeIDs removes the "narratives" edge to the Narrative entity by IDs.
func (m *InternalPolicyMutation) RemoveNarrativeIDs(ids ...string) {
	if m.removednarratives == nil {
		m.removednarratives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.narratives, ids[i])
		m.removednarratives[ids[i]] = struct{}{}
	}
}

// RemovedNarratives returns the removed IDs of the "narratives" edge to the Narrative entity.
func (m *InternalPolicyMutation) RemovedNarrativesIDs() (ids []string) {
	for id := range m.removednarratives {
		ids = append(ids, id)
	}
	return
}

// NarrativesIDs returns the "narratives" edge IDs in the mutation.
func (m *InternalPolicyMutation) NarrativesIDs() (ids []string) {
	for id := range m.narratives {
		ids = append(ids, id)
	}
	return
}

// ResetNarratives resets all changes to the "narratives" edge.
func (m *InternalPolicyMutation) ResetNarratives() {
	m.narratives = nil
	m.clearednarratives = false
	m.removednarratives = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *InternalPolicyMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *InternalPolicyMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *InternalPolicyMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *InternalPolicyMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *InternalPolicyMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *InternalPolicyMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *InternalPolicyMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *InternalPolicyMutation) AddProgramIDs(ids ...string) {
	if m.programs == nil {
		m.programs = make(map[string]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *InternalPolicyMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *InternalPolicyMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *InternalPolicyMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *InternalPolicyMutation) RemovedProgramsIDs() (ids []string) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *InternalPolicyMutation) ProgramsIDs() (ids []string) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *InternalPolicyMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// Where appends a list predicates to the InternalPolicyMutation builder.
func (m *InternalPolicyMutation) Where(ps ...predicate.InternalPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternalPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternalPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternalPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternalPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternalPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternalPolicy).
func (m *InternalPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternalPolicyMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, internalpolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, internalpolicy.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, internalpolicy.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, internalpolicy.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, internalpolicy.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, internalpolicy.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, internalpolicy.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, internalpolicy.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, internalpolicy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, internalpolicy.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, internalpolicy.FieldStatus)
	}
	if m.policy_type != nil {
		fields = append(fields, internalpolicy.FieldPolicyType)
	}
	if m.version != nil {
		fields = append(fields, internalpolicy.FieldVersion)
	}
	if m.purpose_and_scope != nil {
		fields = append(fields, internalpolicy.FieldPurposeAndScope)
	}
	if m.background != nil {
		fields = append(fields, internalpolicy.FieldBackground)
	}
	if m.details != nil {
		fields = append(fields, internalpolicy.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternalPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internalpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case internalpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case internalpolicy.FieldCreatedBy:
		return m.CreatedBy()
	case internalpolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case internalpolicy.FieldDeletedAt:
		return m.DeletedAt()
	case internalpolicy.FieldDeletedBy:
		return m.DeletedBy()
	case internalpolicy.FieldMappingID:
		return m.MappingID()
	case internalpolicy.FieldTags:
		return m.Tags()
	case internalpolicy.FieldName:
		return m.Name()
	case internalpolicy.FieldDescription:
		return m.Description()
	case internalpolicy.FieldStatus:
		return m.Status()
	case internalpolicy.FieldPolicyType:
		return m.PolicyType()
	case internalpolicy.FieldVersion:
		return m.Version()
	case internalpolicy.FieldPurposeAndScope:
		return m.PurposeAndScope()
	case internalpolicy.FieldBackground:
		return m.Background()
	case internalpolicy.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternalPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internalpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case internalpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case internalpolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case internalpolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case internalpolicy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case internalpolicy.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case internalpolicy.FieldMappingID:
		return m.OldMappingID(ctx)
	case internalpolicy.FieldTags:
		return m.OldTags(ctx)
	case internalpolicy.FieldName:
		return m.OldName(ctx)
	case internalpolicy.FieldDescription:
		return m.OldDescription(ctx)
	case internalpolicy.FieldStatus:
		return m.OldStatus(ctx)
	case internalpolicy.FieldPolicyType:
		return m.OldPolicyType(ctx)
	case internalpolicy.FieldVersion:
		return m.OldVersion(ctx)
	case internalpolicy.FieldPurposeAndScope:
		return m.OldPurposeAndScope(ctx)
	case internalpolicy.FieldBackground:
		return m.OldBackground(ctx)
	case internalpolicy.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown InternalPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internalpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case internalpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case internalpolicy.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case internalpolicy.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case internalpolicy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case internalpolicy.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case internalpolicy.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case internalpolicy.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case internalpolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case internalpolicy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case internalpolicy.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case internalpolicy.FieldPolicyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyType(v)
		return nil
	case internalpolicy.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case internalpolicy.FieldPurposeAndScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurposeAndScope(v)
		return nil
	case internalpolicy.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case internalpolicy.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown InternalPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternalPolicyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternalPolicyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InternalPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternalPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(internalpolicy.FieldCreatedAt) {
		fields = append(fields, internalpolicy.FieldCreatedAt)
	}
	if m.FieldCleared(internalpolicy.FieldUpdatedAt) {
		fields = append(fields, internalpolicy.FieldUpdatedAt)
	}
	if m.FieldCleared(internalpolicy.FieldCreatedBy) {
		fields = append(fields, internalpolicy.FieldCreatedBy)
	}
	if m.FieldCleared(internalpolicy.FieldUpdatedBy) {
		fields = append(fields, internalpolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(internalpolicy.FieldDeletedAt) {
		fields = append(fields, internalpolicy.FieldDeletedAt)
	}
	if m.FieldCleared(internalpolicy.FieldDeletedBy) {
		fields = append(fields, internalpolicy.FieldDeletedBy)
	}
	if m.FieldCleared(internalpolicy.FieldTags) {
		fields = append(fields, internalpolicy.FieldTags)
	}
	if m.FieldCleared(internalpolicy.FieldStatus) {
		fields = append(fields, internalpolicy.FieldStatus)
	}
	if m.FieldCleared(internalpolicy.FieldPolicyType) {
		fields = append(fields, internalpolicy.FieldPolicyType)
	}
	if m.FieldCleared(internalpolicy.FieldVersion) {
		fields = append(fields, internalpolicy.FieldVersion)
	}
	if m.FieldCleared(internalpolicy.FieldPurposeAndScope) {
		fields = append(fields, internalpolicy.FieldPurposeAndScope)
	}
	if m.FieldCleared(internalpolicy.FieldBackground) {
		fields = append(fields, internalpolicy.FieldBackground)
	}
	if m.FieldCleared(internalpolicy.FieldDetails) {
		fields = append(fields, internalpolicy.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternalPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternalPolicyMutation) ClearField(name string) error {
	switch name {
	case internalpolicy.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case internalpolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case internalpolicy.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case internalpolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case internalpolicy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case internalpolicy.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case internalpolicy.FieldTags:
		m.ClearTags()
		return nil
	case internalpolicy.FieldStatus:
		m.ClearStatus()
		return nil
	case internalpolicy.FieldPolicyType:
		m.ClearPolicyType()
		return nil
	case internalpolicy.FieldVersion:
		m.ClearVersion()
		return nil
	case internalpolicy.FieldPurposeAndScope:
		m.ClearPurposeAndScope()
		return nil
	case internalpolicy.FieldBackground:
		m.ClearBackground()
		return nil
	case internalpolicy.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown InternalPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternalPolicyMutation) ResetField(name string) error {
	switch name {
	case internalpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case internalpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case internalpolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case internalpolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case internalpolicy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case internalpolicy.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case internalpolicy.FieldMappingID:
		m.ResetMappingID()
		return nil
	case internalpolicy.FieldTags:
		m.ResetTags()
		return nil
	case internalpolicy.FieldName:
		m.ResetName()
		return nil
	case internalpolicy.FieldDescription:
		m.ResetDescription()
		return nil
	case internalpolicy.FieldStatus:
		m.ResetStatus()
		return nil
	case internalpolicy.FieldPolicyType:
		m.ResetPolicyType()
		return nil
	case internalpolicy.FieldVersion:
		m.ResetVersion()
		return nil
	case internalpolicy.FieldPurposeAndScope:
		m.ResetPurposeAndScope()
		return nil
	case internalpolicy.FieldBackground:
		m.ResetBackground()
		return nil
	case internalpolicy.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown InternalPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternalPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.controlobjectives != nil {
		edges = append(edges, internalpolicy.EdgeControlobjectives)
	}
	if m.controls != nil {
		edges = append(edges, internalpolicy.EdgeControls)
	}
	if m.procedures != nil {
		edges = append(edges, internalpolicy.EdgeProcedures)
	}
	if m.narratives != nil {
		edges = append(edges, internalpolicy.EdgeNarratives)
	}
	if m.tasks != nil {
		edges = append(edges, internalpolicy.EdgeTasks)
	}
	if m.programs != nil {
		edges = append(edges, internalpolicy.EdgePrograms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternalPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case internalpolicy.EdgeControlobjectives:
		ids := make([]ent.Value, 0, len(m.controlobjectives))
		for id := range m.controlobjectives {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgeControls:
		ids := make([]ent.Value, 0, len(m.controls))
		for id := range m.controls {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.procedures))
		for id := range m.procedures {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.narratives))
		for id := range m.narratives {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternalPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcontrolobjectives != nil {
		edges = append(edges, internalpolicy.EdgeControlobjectives)
	}
	if m.removedcontrols != nil {
		edges = append(edges, internalpolicy.EdgeControls)
	}
	if m.removedprocedures != nil {
		edges = append(edges, internalpolicy.EdgeProcedures)
	}
	if m.removednarratives != nil {
		edges = append(edges, internalpolicy.EdgeNarratives)
	}
	if m.removedtasks != nil {
		edges = append(edges, internalpolicy.EdgeTasks)
	}
	if m.removedprograms != nil {
		edges = append(edges, internalpolicy.EdgePrograms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternalPolicyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case internalpolicy.EdgeControlobjectives:
		ids := make([]ent.Value, 0, len(m.removedcontrolobjectives))
		for id := range m.removedcontrolobjectives {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgeControls:
		ids := make([]ent.Value, 0, len(m.removedcontrols))
		for id := range m.removedcontrols {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.removedprocedures))
		for id := range m.removedprocedures {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.removednarratives))
		for id := range m.removednarratives {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case internalpolicy.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternalPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcontrolobjectives {
		edges = append(edges, internalpolicy.EdgeControlobjectives)
	}
	if m.clearedcontrols {
		edges = append(edges, internalpolicy.EdgeControls)
	}
	if m.clearedprocedures {
		edges = append(edges, internalpolicy.EdgeProcedures)
	}
	if m.clearednarratives {
		edges = append(edges, internalpolicy.EdgeNarratives)
	}
	if m.clearedtasks {
		edges = append(edges, internalpolicy.EdgeTasks)
	}
	if m.clearedprograms {
		edges = append(edges, internalpolicy.EdgePrograms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternalPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case internalpolicy.EdgeControlobjectives:
		return m.clearedcontrolobjectives
	case internalpolicy.EdgeControls:
		return m.clearedcontrols
	case internalpolicy.EdgeProcedures:
		return m.clearedprocedures
	case internalpolicy.EdgeNarratives:
		return m.clearednarratives
	case internalpolicy.EdgeTasks:
		return m.clearedtasks
	case internalpolicy.EdgePrograms:
		return m.clearedprograms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternalPolicyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown InternalPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternalPolicyMutation) ResetEdge(name string) error {
	switch name {
	case internalpolicy.EdgeControlobjectives:
		m.ResetControlobjectives()
		return nil
	case internalpolicy.EdgeControls:
		m.ResetControls()
		return nil
	case internalpolicy.EdgeProcedures:
		m.ResetProcedures()
		return nil
	case internalpolicy.EdgeNarratives:
		m.ResetNarratives()
		return nil
	case internalpolicy.EdgeTasks:
		m.ResetTasks()
		return nil
	case internalpolicy.EdgePrograms:
		m.ResetPrograms()
		return nil
	}
	return fmt.Errorf("unknown InternalPolicy edge %s", name)
}

// InternalPolicyHistoryMutation represents an operation that mutates the InternalPolicyHistory nodes in the graph.
type InternalPolicyHistoryMutation struct {
	config
	op                Op
	typ               string
	id                *string
	history_time      *time.Time
	ref               *string
	operation         *history.OpType
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	deleted_at        *time.Time
	deleted_by        *string
	mapping_id        *string
	tags              *[]string
	appendtags        []string
	name              *string
	description       *string
	status            *string
	policy_type       *string
	version           *string
	purpose_and_scope *string
	background        *string
	details           *map[string]interface{}
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*InternalPolicyHistory, error)
	predicates        []predicate.InternalPolicyHistory
}

var _ ent.Mutation = (*InternalPolicyHistoryMutation)(nil)

// internalpolicyhistoryOption allows management of the mutation configuration using functional options.
type internalpolicyhistoryOption func(*InternalPolicyHistoryMutation)

// newInternalPolicyHistoryMutation creates new mutation for the InternalPolicyHistory entity.
func newInternalPolicyHistoryMutation(c config, op Op, opts ...internalpolicyhistoryOption) *InternalPolicyHistoryMutation {
	m := &InternalPolicyHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeInternalPolicyHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInternalPolicyHistoryID sets the ID field of the mutation.
func withInternalPolicyHistoryID(id string) internalpolicyhistoryOption {
	return func(m *InternalPolicyHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *InternalPolicyHistory
		)
		m.oldValue = func(ctx context.Context) (*InternalPolicyHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InternalPolicyHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInternalPolicyHistory sets the old InternalPolicyHistory of the mutation.
func withInternalPolicyHistory(node *InternalPolicyHistory) internalpolicyhistoryOption {
	return func(m *InternalPolicyHistoryMutation) {
		m.oldValue = func(context.Context) (*InternalPolicyHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InternalPolicyHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InternalPolicyHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InternalPolicyHistory entities.
func (m *InternalPolicyHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InternalPolicyHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InternalPolicyHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InternalPolicyHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *InternalPolicyHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *InternalPolicyHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *InternalPolicyHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *InternalPolicyHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *InternalPolicyHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *InternalPolicyHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[internalpolicyhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *InternalPolicyHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, internalpolicyhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *InternalPolicyHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *InternalPolicyHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *InternalPolicyHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InternalPolicyHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InternalPolicyHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InternalPolicyHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[internalpolicyhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InternalPolicyHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, internalpolicyhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InternalPolicyHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InternalPolicyHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InternalPolicyHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[internalpolicyhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InternalPolicyHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, internalpolicyhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *InternalPolicyHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InternalPolicyHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *InternalPolicyHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[internalpolicyhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InternalPolicyHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, internalpolicyhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InternalPolicyHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InternalPolicyHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *InternalPolicyHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[internalpolicyhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InternalPolicyHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, internalpolicyhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InternalPolicyHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InternalPolicyHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InternalPolicyHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[internalpolicyhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InternalPolicyHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *InternalPolicyHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *InternalPolicyHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *InternalPolicyHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[internalpolicyhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *InternalPolicyHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *InternalPolicyHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *InternalPolicyHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *InternalPolicyHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *InternalPolicyHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *InternalPolicyHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *InternalPolicyHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *InternalPolicyHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *InternalPolicyHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[internalpolicyhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *InternalPolicyHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, internalpolicyhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *InternalPolicyHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InternalPolicyHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InternalPolicyHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *InternalPolicyHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InternalPolicyHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *InternalPolicyHistoryMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *InternalPolicyHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InternalPolicyHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *InternalPolicyHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[internalpolicyhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *InternalPolicyHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, internalpolicyhistory.FieldStatus)
}

// SetPolicyType sets the "policy_type" field.
func (m *InternalPolicyHistoryMutation) SetPolicyType(s string) {
	m.policy_type = &s
}

// PolicyType returns the value of the "policy_type" field in the mutation.
func (m *InternalPolicyHistoryMutation) PolicyType() (r string, exists bool) {
	v := m.policy_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicyType returns the old "policy_type" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldPolicyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicyType: %w", err)
	}
	return oldValue.PolicyType, nil
}

// ClearPolicyType clears the value of the "policy_type" field.
func (m *InternalPolicyHistoryMutation) ClearPolicyType() {
	m.policy_type = nil
	m.clearedFields[internalpolicyhistory.FieldPolicyType] = struct{}{}
}

// PolicyTypeCleared returns if the "policy_type" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) PolicyTypeCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldPolicyType]
	return ok
}

// ResetPolicyType resets all changes to the "policy_type" field.
func (m *InternalPolicyHistoryMutation) ResetPolicyType() {
	m.policy_type = nil
	delete(m.clearedFields, internalpolicyhistory.FieldPolicyType)
}

// SetVersion sets the "version" field.
func (m *InternalPolicyHistoryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *InternalPolicyHistoryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *InternalPolicyHistoryMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[internalpolicyhistory.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) VersionCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *InternalPolicyHistoryMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, internalpolicyhistory.FieldVersion)
}

// SetPurposeAndScope sets the "purpose_and_scope" field.
func (m *InternalPolicyHistoryMutation) SetPurposeAndScope(s string) {
	m.purpose_and_scope = &s
}

// PurposeAndScope returns the value of the "purpose_and_scope" field in the mutation.
func (m *InternalPolicyHistoryMutation) PurposeAndScope() (r string, exists bool) {
	v := m.purpose_and_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldPurposeAndScope returns the old "purpose_and_scope" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldPurposeAndScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurposeAndScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurposeAndScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurposeAndScope: %w", err)
	}
	return oldValue.PurposeAndScope, nil
}

// ClearPurposeAndScope clears the value of the "purpose_and_scope" field.
func (m *InternalPolicyHistoryMutation) ClearPurposeAndScope() {
	m.purpose_and_scope = nil
	m.clearedFields[internalpolicyhistory.FieldPurposeAndScope] = struct{}{}
}

// PurposeAndScopeCleared returns if the "purpose_and_scope" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) PurposeAndScopeCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldPurposeAndScope]
	return ok
}

// ResetPurposeAndScope resets all changes to the "purpose_and_scope" field.
func (m *InternalPolicyHistoryMutation) ResetPurposeAndScope() {
	m.purpose_and_scope = nil
	delete(m.clearedFields, internalpolicyhistory.FieldPurposeAndScope)
}

// SetBackground sets the "background" field.
func (m *InternalPolicyHistoryMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *InternalPolicyHistoryMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *InternalPolicyHistoryMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[internalpolicyhistory.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *InternalPolicyHistoryMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, internalpolicyhistory.FieldBackground)
}

// SetDetails sets the "details" field.
func (m *InternalPolicyHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *InternalPolicyHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the InternalPolicyHistory entity.
// If the InternalPolicyHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InternalPolicyHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *InternalPolicyHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[internalpolicyhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[internalpolicyhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *InternalPolicyHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, internalpolicyhistory.FieldDetails)
}

// Where appends a list predicates to the InternalPolicyHistoryMutation builder.
func (m *InternalPolicyHistoryMutation) Where(ps ...predicate.InternalPolicyHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InternalPolicyHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InternalPolicyHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InternalPolicyHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InternalPolicyHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InternalPolicyHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InternalPolicyHistory).
func (m *InternalPolicyHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InternalPolicyHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, internalpolicyhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, internalpolicyhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, internalpolicyhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, internalpolicyhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, internalpolicyhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, internalpolicyhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, internalpolicyhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, internalpolicyhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, internalpolicyhistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, internalpolicyhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, internalpolicyhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, internalpolicyhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, internalpolicyhistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, internalpolicyhistory.FieldStatus)
	}
	if m.policy_type != nil {
		fields = append(fields, internalpolicyhistory.FieldPolicyType)
	}
	if m.version != nil {
		fields = append(fields, internalpolicyhistory.FieldVersion)
	}
	if m.purpose_and_scope != nil {
		fields = append(fields, internalpolicyhistory.FieldPurposeAndScope)
	}
	if m.background != nil {
		fields = append(fields, internalpolicyhistory.FieldBackground)
	}
	if m.details != nil {
		fields = append(fields, internalpolicyhistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InternalPolicyHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case internalpolicyhistory.FieldHistoryTime:
		return m.HistoryTime()
	case internalpolicyhistory.FieldRef:
		return m.Ref()
	case internalpolicyhistory.FieldOperation:
		return m.Operation()
	case internalpolicyhistory.FieldCreatedAt:
		return m.CreatedAt()
	case internalpolicyhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case internalpolicyhistory.FieldCreatedBy:
		return m.CreatedBy()
	case internalpolicyhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case internalpolicyhistory.FieldDeletedAt:
		return m.DeletedAt()
	case internalpolicyhistory.FieldDeletedBy:
		return m.DeletedBy()
	case internalpolicyhistory.FieldMappingID:
		return m.MappingID()
	case internalpolicyhistory.FieldTags:
		return m.Tags()
	case internalpolicyhistory.FieldName:
		return m.Name()
	case internalpolicyhistory.FieldDescription:
		return m.Description()
	case internalpolicyhistory.FieldStatus:
		return m.Status()
	case internalpolicyhistory.FieldPolicyType:
		return m.PolicyType()
	case internalpolicyhistory.FieldVersion:
		return m.Version()
	case internalpolicyhistory.FieldPurposeAndScope:
		return m.PurposeAndScope()
	case internalpolicyhistory.FieldBackground:
		return m.Background()
	case internalpolicyhistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InternalPolicyHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case internalpolicyhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case internalpolicyhistory.FieldRef:
		return m.OldRef(ctx)
	case internalpolicyhistory.FieldOperation:
		return m.OldOperation(ctx)
	case internalpolicyhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case internalpolicyhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case internalpolicyhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case internalpolicyhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case internalpolicyhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case internalpolicyhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case internalpolicyhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case internalpolicyhistory.FieldTags:
		return m.OldTags(ctx)
	case internalpolicyhistory.FieldName:
		return m.OldName(ctx)
	case internalpolicyhistory.FieldDescription:
		return m.OldDescription(ctx)
	case internalpolicyhistory.FieldStatus:
		return m.OldStatus(ctx)
	case internalpolicyhistory.FieldPolicyType:
		return m.OldPolicyType(ctx)
	case internalpolicyhistory.FieldVersion:
		return m.OldVersion(ctx)
	case internalpolicyhistory.FieldPurposeAndScope:
		return m.OldPurposeAndScope(ctx)
	case internalpolicyhistory.FieldBackground:
		return m.OldBackground(ctx)
	case internalpolicyhistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown InternalPolicyHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalPolicyHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case internalpolicyhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case internalpolicyhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case internalpolicyhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case internalpolicyhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case internalpolicyhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case internalpolicyhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case internalpolicyhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case internalpolicyhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case internalpolicyhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case internalpolicyhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case internalpolicyhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case internalpolicyhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case internalpolicyhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case internalpolicyhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case internalpolicyhistory.FieldPolicyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyType(v)
		return nil
	case internalpolicyhistory.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case internalpolicyhistory.FieldPurposeAndScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurposeAndScope(v)
		return nil
	case internalpolicyhistory.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case internalpolicyhistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown InternalPolicyHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InternalPolicyHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InternalPolicyHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InternalPolicyHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InternalPolicyHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InternalPolicyHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(internalpolicyhistory.FieldRef) {
		fields = append(fields, internalpolicyhistory.FieldRef)
	}
	if m.FieldCleared(internalpolicyhistory.FieldCreatedAt) {
		fields = append(fields, internalpolicyhistory.FieldCreatedAt)
	}
	if m.FieldCleared(internalpolicyhistory.FieldUpdatedAt) {
		fields = append(fields, internalpolicyhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(internalpolicyhistory.FieldCreatedBy) {
		fields = append(fields, internalpolicyhistory.FieldCreatedBy)
	}
	if m.FieldCleared(internalpolicyhistory.FieldUpdatedBy) {
		fields = append(fields, internalpolicyhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDeletedAt) {
		fields = append(fields, internalpolicyhistory.FieldDeletedAt)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDeletedBy) {
		fields = append(fields, internalpolicyhistory.FieldDeletedBy)
	}
	if m.FieldCleared(internalpolicyhistory.FieldTags) {
		fields = append(fields, internalpolicyhistory.FieldTags)
	}
	if m.FieldCleared(internalpolicyhistory.FieldStatus) {
		fields = append(fields, internalpolicyhistory.FieldStatus)
	}
	if m.FieldCleared(internalpolicyhistory.FieldPolicyType) {
		fields = append(fields, internalpolicyhistory.FieldPolicyType)
	}
	if m.FieldCleared(internalpolicyhistory.FieldVersion) {
		fields = append(fields, internalpolicyhistory.FieldVersion)
	}
	if m.FieldCleared(internalpolicyhistory.FieldPurposeAndScope) {
		fields = append(fields, internalpolicyhistory.FieldPurposeAndScope)
	}
	if m.FieldCleared(internalpolicyhistory.FieldBackground) {
		fields = append(fields, internalpolicyhistory.FieldBackground)
	}
	if m.FieldCleared(internalpolicyhistory.FieldDetails) {
		fields = append(fields, internalpolicyhistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InternalPolicyHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InternalPolicyHistoryMutation) ClearField(name string) error {
	switch name {
	case internalpolicyhistory.FieldRef:
		m.ClearRef()
		return nil
	case internalpolicyhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case internalpolicyhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case internalpolicyhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case internalpolicyhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case internalpolicyhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case internalpolicyhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case internalpolicyhistory.FieldTags:
		m.ClearTags()
		return nil
	case internalpolicyhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case internalpolicyhistory.FieldPolicyType:
		m.ClearPolicyType()
		return nil
	case internalpolicyhistory.FieldVersion:
		m.ClearVersion()
		return nil
	case internalpolicyhistory.FieldPurposeAndScope:
		m.ClearPurposeAndScope()
		return nil
	case internalpolicyhistory.FieldBackground:
		m.ClearBackground()
		return nil
	case internalpolicyhistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown InternalPolicyHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InternalPolicyHistoryMutation) ResetField(name string) error {
	switch name {
	case internalpolicyhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case internalpolicyhistory.FieldRef:
		m.ResetRef()
		return nil
	case internalpolicyhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case internalpolicyhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case internalpolicyhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case internalpolicyhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case internalpolicyhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case internalpolicyhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case internalpolicyhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case internalpolicyhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case internalpolicyhistory.FieldTags:
		m.ResetTags()
		return nil
	case internalpolicyhistory.FieldName:
		m.ResetName()
		return nil
	case internalpolicyhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case internalpolicyhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case internalpolicyhistory.FieldPolicyType:
		m.ResetPolicyType()
		return nil
	case internalpolicyhistory.FieldVersion:
		m.ResetVersion()
		return nil
	case internalpolicyhistory.FieldPurposeAndScope:
		m.ResetPurposeAndScope()
		return nil
	case internalpolicyhistory.FieldBackground:
		m.ResetBackground()
		return nil
	case internalpolicyhistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown InternalPolicyHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InternalPolicyHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InternalPolicyHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InternalPolicyHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InternalPolicyHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InternalPolicyHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InternalPolicyHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InternalPolicyHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InternalPolicyHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InternalPolicyHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InternalPolicyHistory edge %s", name)
}

// InviteMutation represents an operation that mutates the Invite nodes in the graph.
type InviteMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	created_by       *string
	updated_by       *string
	mapping_id       *string
	deleted_at       *time.Time
	deleted_by       *string
	token            *string
	expires          *time.Time
	recipient        *string
	status           *enums.InviteStatus
	role             *enums.Role
	send_attempts    *int
	addsend_attempts *int
	requestor_id     *string
	secret           *[]byte
	clearedFields    map[string]struct{}
	owner            *string
	clearedowner     bool
	events           map[string]struct{}
	removedevents    map[string]struct{}
	clearedevents    bool
	done             bool
	oldValue         func(context.Context) (*Invite, error)
	predicates       []predicate.Invite
}

var _ ent.Mutation = (*InviteMutation)(nil)

// inviteOption allows management of the mutation configuration using functional options.
type inviteOption func(*InviteMutation)

// newInviteMutation creates new mutation for the Invite entity.
func newInviteMutation(c config, op Op, opts ...inviteOption) *InviteMutation {
	m := &InviteMutation{
		config:        c,
		op:            op,
		typ:           TypeInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteID sets the ID field of the mutation.
func withInviteID(id string) inviteOption {
	return func(m *InviteMutation) {
		var (
			err   error
			once  sync.Once
			value *Invite
		)
		m.oldValue = func(ctx context.Context) (*Invite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvite sets the old Invite of the mutation.
func withInvite(node *Invite) inviteOption {
	return func(m *InviteMutation) {
		m.oldValue = func(context.Context) (*Invite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invite entities.
func (m *InviteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InviteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InviteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InviteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InviteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *InviteMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[invite.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *InviteMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[invite.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InviteMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, invite.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InviteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InviteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *InviteMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[invite.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *InviteMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[invite.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InviteMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, invite.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *InviteMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *InviteMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *InviteMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[invite.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *InviteMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[invite.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *InviteMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, invite.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *InviteMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *InviteMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *InviteMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[invite.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *InviteMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[invite.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *InviteMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, invite.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *InviteMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *InviteMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *InviteMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InviteMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InviteMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InviteMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[invite.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InviteMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[invite.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InviteMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, invite.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *InviteMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *InviteMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *InviteMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[invite.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *InviteMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[invite.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *InviteMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, invite.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *InviteMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *InviteMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *InviteMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[invite.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *InviteMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[invite.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *InviteMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, invite.FieldOwnerID)
}

// SetToken sets the "token" field.
func (m *InviteMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *InviteMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *InviteMutation) ResetToken() {
	m.token = nil
}

// SetExpires sets the "expires" field.
func (m *InviteMutation) SetExpires(t time.Time) {
	m.expires = &t
}

// Expires returns the value of the "expires" field in the mutation.
func (m *InviteMutation) Expires() (r time.Time, exists bool) {
	v := m.expires
	if v == nil {
		return
	}
	return *v, true
}

// OldExpires returns the old "expires" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldExpires(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpires: %w", err)
	}
	return oldValue.Expires, nil
}

// ClearExpires clears the value of the "expires" field.
func (m *InviteMutation) ClearExpires() {
	m.expires = nil
	m.clearedFields[invite.FieldExpires] = struct{}{}
}

// ExpiresCleared returns if the "expires" field was cleared in this mutation.
func (m *InviteMutation) ExpiresCleared() bool {
	_, ok := m.clearedFields[invite.FieldExpires]
	return ok
}

// ResetExpires resets all changes to the "expires" field.
func (m *InviteMutation) ResetExpires() {
	m.expires = nil
	delete(m.clearedFields, invite.FieldExpires)
}

// SetRecipient sets the "recipient" field.
func (m *InviteMutation) SetRecipient(s string) {
	m.recipient = &s
}

// Recipient returns the value of the "recipient" field in the mutation.
func (m *InviteMutation) Recipient() (r string, exists bool) {
	v := m.recipient
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipient returns the old "recipient" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldRecipient(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipient is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipient requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipient: %w", err)
	}
	return oldValue.Recipient, nil
}

// ResetRecipient resets all changes to the "recipient" field.
func (m *InviteMutation) ResetRecipient() {
	m.recipient = nil
}

// SetStatus sets the "status" field.
func (m *InviteMutation) SetStatus(es enums.InviteStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *InviteMutation) Status() (r enums.InviteStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldStatus(ctx context.Context) (v enums.InviteStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InviteMutation) ResetStatus() {
	m.status = nil
}

// SetRole sets the "role" field.
func (m *InviteMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *InviteMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *InviteMutation) ResetRole() {
	m.role = nil
}

// SetSendAttempts sets the "send_attempts" field.
func (m *InviteMutation) SetSendAttempts(i int) {
	m.send_attempts = &i
	m.addsend_attempts = nil
}

// SendAttempts returns the value of the "send_attempts" field in the mutation.
func (m *InviteMutation) SendAttempts() (r int, exists bool) {
	v := m.send_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldSendAttempts returns the old "send_attempts" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldSendAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendAttempts: %w", err)
	}
	return oldValue.SendAttempts, nil
}

// AddSendAttempts adds i to the "send_attempts" field.
func (m *InviteMutation) AddSendAttempts(i int) {
	if m.addsend_attempts != nil {
		*m.addsend_attempts += i
	} else {
		m.addsend_attempts = &i
	}
}

// AddedSendAttempts returns the value that was added to the "send_attempts" field in this mutation.
func (m *InviteMutation) AddedSendAttempts() (r int, exists bool) {
	v := m.addsend_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetSendAttempts resets all changes to the "send_attempts" field.
func (m *InviteMutation) ResetSendAttempts() {
	m.send_attempts = nil
	m.addsend_attempts = nil
}

// SetRequestorID sets the "requestor_id" field.
func (m *InviteMutation) SetRequestorID(s string) {
	m.requestor_id = &s
}

// RequestorID returns the value of the "requestor_id" field in the mutation.
func (m *InviteMutation) RequestorID() (r string, exists bool) {
	v := m.requestor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestorID returns the old "requestor_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldRequestorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestorID: %w", err)
	}
	return oldValue.RequestorID, nil
}

// ClearRequestorID clears the value of the "requestor_id" field.
func (m *InviteMutation) ClearRequestorID() {
	m.requestor_id = nil
	m.clearedFields[invite.FieldRequestorID] = struct{}{}
}

// RequestorIDCleared returns if the "requestor_id" field was cleared in this mutation.
func (m *InviteMutation) RequestorIDCleared() bool {
	_, ok := m.clearedFields[invite.FieldRequestorID]
	return ok
}

// ResetRequestorID resets all changes to the "requestor_id" field.
func (m *InviteMutation) ResetRequestorID() {
	m.requestor_id = nil
	delete(m.clearedFields, invite.FieldRequestorID)
}

// SetSecret sets the "secret" field.
func (m *InviteMutation) SetSecret(b []byte) {
	m.secret = &b
}

// Secret returns the value of the "secret" field in the mutation.
func (m *InviteMutation) Secret() (r []byte, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldSecret(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *InviteMutation) ResetSecret() {
	m.secret = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *InviteMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[invite.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *InviteMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *InviteMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *InviteMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *InviteMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *InviteMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *InviteMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *InviteMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *InviteMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *InviteMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the InviteMutation builder.
func (m *InviteMutation) Where(ps ...predicate.Invite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InviteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InviteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InviteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InviteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invite).
func (m *InviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, invite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invite.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, invite.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, invite.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, invite.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, invite.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, invite.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, invite.FieldOwnerID)
	}
	if m.token != nil {
		fields = append(fields, invite.FieldToken)
	}
	if m.expires != nil {
		fields = append(fields, invite.FieldExpires)
	}
	if m.recipient != nil {
		fields = append(fields, invite.FieldRecipient)
	}
	if m.status != nil {
		fields = append(fields, invite.FieldStatus)
	}
	if m.role != nil {
		fields = append(fields, invite.FieldRole)
	}
	if m.send_attempts != nil {
		fields = append(fields, invite.FieldSendAttempts)
	}
	if m.requestor_id != nil {
		fields = append(fields, invite.FieldRequestorID)
	}
	if m.secret != nil {
		fields = append(fields, invite.FieldSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldCreatedAt:
		return m.CreatedAt()
	case invite.FieldUpdatedAt:
		return m.UpdatedAt()
	case invite.FieldCreatedBy:
		return m.CreatedBy()
	case invite.FieldUpdatedBy:
		return m.UpdatedBy()
	case invite.FieldMappingID:
		return m.MappingID()
	case invite.FieldDeletedAt:
		return m.DeletedAt()
	case invite.FieldDeletedBy:
		return m.DeletedBy()
	case invite.FieldOwnerID:
		return m.OwnerID()
	case invite.FieldToken:
		return m.Token()
	case invite.FieldExpires:
		return m.Expires()
	case invite.FieldRecipient:
		return m.Recipient()
	case invite.FieldStatus:
		return m.Status()
	case invite.FieldRole:
		return m.Role()
	case invite.FieldSendAttempts:
		return m.SendAttempts()
	case invite.FieldRequestorID:
		return m.RequestorID()
	case invite.FieldSecret:
		return m.Secret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invite.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case invite.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case invite.FieldMappingID:
		return m.OldMappingID(ctx)
	case invite.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case invite.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case invite.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case invite.FieldToken:
		return m.OldToken(ctx)
	case invite.FieldExpires:
		return m.OldExpires(ctx)
	case invite.FieldRecipient:
		return m.OldRecipient(ctx)
	case invite.FieldStatus:
		return m.OldStatus(ctx)
	case invite.FieldRole:
		return m.OldRole(ctx)
	case invite.FieldSendAttempts:
		return m.OldSendAttempts(ctx)
	case invite.FieldRequestorID:
		return m.OldRequestorID(ctx)
	case invite.FieldSecret:
		return m.OldSecret(ctx)
	}
	return nil, fmt.Errorf("unknown Invite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invite.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case invite.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case invite.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case invite.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case invite.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case invite.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case invite.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case invite.FieldExpires:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpires(v)
		return nil
	case invite.FieldRecipient:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipient(v)
		return nil
	case invite.FieldStatus:
		v, ok := value.(enums.InviteStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case invite.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case invite.FieldSendAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendAttempts(v)
		return nil
	case invite.FieldRequestorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestorID(v)
		return nil
	case invite.FieldSecret:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteMutation) AddedFields() []string {
	var fields []string
	if m.addsend_attempts != nil {
		fields = append(fields, invite.FieldSendAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldSendAttempts:
		return m.AddedSendAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invite.FieldSendAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSendAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown Invite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invite.FieldCreatedAt) {
		fields = append(fields, invite.FieldCreatedAt)
	}
	if m.FieldCleared(invite.FieldUpdatedAt) {
		fields = append(fields, invite.FieldUpdatedAt)
	}
	if m.FieldCleared(invite.FieldCreatedBy) {
		fields = append(fields, invite.FieldCreatedBy)
	}
	if m.FieldCleared(invite.FieldUpdatedBy) {
		fields = append(fields, invite.FieldUpdatedBy)
	}
	if m.FieldCleared(invite.FieldDeletedAt) {
		fields = append(fields, invite.FieldDeletedAt)
	}
	if m.FieldCleared(invite.FieldDeletedBy) {
		fields = append(fields, invite.FieldDeletedBy)
	}
	if m.FieldCleared(invite.FieldOwnerID) {
		fields = append(fields, invite.FieldOwnerID)
	}
	if m.FieldCleared(invite.FieldExpires) {
		fields = append(fields, invite.FieldExpires)
	}
	if m.FieldCleared(invite.FieldRequestorID) {
		fields = append(fields, invite.FieldRequestorID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteMutation) ClearField(name string) error {
	switch name {
	case invite.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case invite.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case invite.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case invite.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case invite.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case invite.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case invite.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case invite.FieldExpires:
		m.ClearExpires()
		return nil
	case invite.FieldRequestorID:
		m.ClearRequestorID()
		return nil
	}
	return fmt.Errorf("unknown Invite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteMutation) ResetField(name string) error {
	switch name {
	case invite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invite.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case invite.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case invite.FieldMappingID:
		m.ResetMappingID()
		return nil
	case invite.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case invite.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case invite.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case invite.FieldToken:
		m.ResetToken()
		return nil
	case invite.FieldExpires:
		m.ResetExpires()
		return nil
	case invite.FieldRecipient:
		m.ResetRecipient()
		return nil
	case invite.FieldStatus:
		m.ResetStatus()
		return nil
	case invite.FieldRole:
		m.ResetRole()
		return nil
	case invite.FieldSendAttempts:
		m.ResetSendAttempts()
		return nil
	case invite.FieldRequestorID:
		m.ResetRequestorID()
		return nil
	case invite.FieldSecret:
		m.ResetSecret()
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, invite.EdgeOwner)
	}
	if m.events != nil {
		edges = append(edges, invite.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, invite.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, invite.EdgeOwner)
	}
	if m.clearedevents {
		edges = append(edges, invite.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteMutation) EdgeCleared(name string) bool {
	switch name {
	case invite.EdgeOwner:
		return m.clearedowner
	case invite.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteMutation) ClearEdge(name string) error {
	switch name {
	case invite.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Invite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteMutation) ResetEdge(name string) error {
	switch name {
	case invite.EdgeOwner:
		m.ResetOwner()
		return nil
	case invite.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Invite edge %s", name)
}

// NarrativeMutation represents an operation that mutates the Narrative nodes in the graph.
type NarrativeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	created_at              *time.Time
	updated_at              *time.Time
	created_by              *string
	updated_by              *string
	deleted_at              *time.Time
	deleted_by              *string
	mapping_id              *string
	tags                    *[]string
	appendtags              []string
	name                    *string
	description             *string
	satisfies               *string
	details                 *map[string]interface{}
	clearedFields           map[string]struct{}
	policy                  map[string]struct{}
	removedpolicy           map[string]struct{}
	clearedpolicy           bool
	control                 map[string]struct{}
	removedcontrol          map[string]struct{}
	clearedcontrol          bool
	procedure               map[string]struct{}
	removedprocedure        map[string]struct{}
	clearedprocedure        bool
	controlobjective        map[string]struct{}
	removedcontrolobjective map[string]struct{}
	clearedcontrolobjective bool
	program                 map[string]struct{}
	removedprogram          map[string]struct{}
	clearedprogram          bool
	done                    bool
	oldValue                func(context.Context) (*Narrative, error)
	predicates              []predicate.Narrative
}

var _ ent.Mutation = (*NarrativeMutation)(nil)

// narrativeOption allows management of the mutation configuration using functional options.
type narrativeOption func(*NarrativeMutation)

// newNarrativeMutation creates new mutation for the Narrative entity.
func newNarrativeMutation(c config, op Op, opts ...narrativeOption) *NarrativeMutation {
	m := &NarrativeMutation{
		config:        c,
		op:            op,
		typ:           TypeNarrative,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNarrativeID sets the ID field of the mutation.
func withNarrativeID(id string) narrativeOption {
	return func(m *NarrativeMutation) {
		var (
			err   error
			once  sync.Once
			value *Narrative
		)
		m.oldValue = func(ctx context.Context) (*Narrative, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Narrative.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNarrative sets the old Narrative of the mutation.
func withNarrative(node *Narrative) narrativeOption {
	return func(m *NarrativeMutation) {
		m.oldValue = func(context.Context) (*Narrative, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NarrativeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NarrativeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Narrative entities.
func (m *NarrativeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NarrativeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NarrativeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Narrative.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NarrativeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NarrativeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NarrativeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[narrative.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NarrativeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[narrative.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NarrativeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, narrative.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NarrativeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NarrativeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NarrativeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[narrative.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NarrativeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[narrative.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NarrativeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, narrative.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *NarrativeMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NarrativeMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NarrativeMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[narrative.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NarrativeMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[narrative.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NarrativeMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, narrative.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NarrativeMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NarrativeMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NarrativeMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[narrative.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NarrativeMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[narrative.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NarrativeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, narrative.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NarrativeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NarrativeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NarrativeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[narrative.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NarrativeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[narrative.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NarrativeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, narrative.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *NarrativeMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *NarrativeMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *NarrativeMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[narrative.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *NarrativeMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[narrative.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *NarrativeMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, narrative.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *NarrativeMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *NarrativeMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *NarrativeMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *NarrativeMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NarrativeMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *NarrativeMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *NarrativeMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *NarrativeMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[narrative.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *NarrativeMutation) TagsCleared() bool {
	_, ok := m.clearedFields[narrative.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *NarrativeMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, narrative.FieldTags)
}

// SetName sets the "name" field.
func (m *NarrativeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NarrativeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NarrativeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NarrativeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NarrativeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NarrativeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[narrative.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NarrativeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[narrative.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NarrativeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, narrative.FieldDescription)
}

// SetSatisfies sets the "satisfies" field.
func (m *NarrativeMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *NarrativeMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *NarrativeMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[narrative.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *NarrativeMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[narrative.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *NarrativeMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, narrative.FieldSatisfies)
}

// SetDetails sets the "details" field.
func (m *NarrativeMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *NarrativeMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Narrative entity.
// If the Narrative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *NarrativeMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[narrative.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *NarrativeMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[narrative.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *NarrativeMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, narrative.FieldDetails)
}

// AddPolicyIDs adds the "policy" edge to the InternalPolicy entity by ids.
func (m *NarrativeMutation) AddPolicyIDs(ids ...string) {
	if m.policy == nil {
		m.policy = make(map[string]struct{})
	}
	for i := range ids {
		m.policy[ids[i]] = struct{}{}
	}
}

// ClearPolicy clears the "policy" edge to the InternalPolicy entity.
func (m *NarrativeMutation) ClearPolicy() {
	m.clearedpolicy = true
}

// PolicyCleared reports if the "policy" edge to the InternalPolicy entity was cleared.
func (m *NarrativeMutation) PolicyCleared() bool {
	return m.clearedpolicy
}

// RemovePolicyIDs removes the "policy" edge to the InternalPolicy entity by IDs.
func (m *NarrativeMutation) RemovePolicyIDs(ids ...string) {
	if m.removedpolicy == nil {
		m.removedpolicy = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.policy, ids[i])
		m.removedpolicy[ids[i]] = struct{}{}
	}
}

// RemovedPolicy returns the removed IDs of the "policy" edge to the InternalPolicy entity.
func (m *NarrativeMutation) RemovedPolicyIDs() (ids []string) {
	for id := range m.removedpolicy {
		ids = append(ids, id)
	}
	return
}

// PolicyIDs returns the "policy" edge IDs in the mutation.
func (m *NarrativeMutation) PolicyIDs() (ids []string) {
	for id := range m.policy {
		ids = append(ids, id)
	}
	return
}

// ResetPolicy resets all changes to the "policy" edge.
func (m *NarrativeMutation) ResetPolicy() {
	m.policy = nil
	m.clearedpolicy = false
	m.removedpolicy = nil
}

// AddControlIDs adds the "control" edge to the Control entity by ids.
func (m *NarrativeMutation) AddControlIDs(ids ...string) {
	if m.control == nil {
		m.control = make(map[string]struct{})
	}
	for i := range ids {
		m.control[ids[i]] = struct{}{}
	}
}

// ClearControl clears the "control" edge to the Control entity.
func (m *NarrativeMutation) ClearControl() {
	m.clearedcontrol = true
}

// ControlCleared reports if the "control" edge to the Control entity was cleared.
func (m *NarrativeMutation) ControlCleared() bool {
	return m.clearedcontrol
}

// RemoveControlIDs removes the "control" edge to the Control entity by IDs.
func (m *NarrativeMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrol == nil {
		m.removedcontrol = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.control, ids[i])
		m.removedcontrol[ids[i]] = struct{}{}
	}
}

// RemovedControl returns the removed IDs of the "control" edge to the Control entity.
func (m *NarrativeMutation) RemovedControlIDs() (ids []string) {
	for id := range m.removedcontrol {
		ids = append(ids, id)
	}
	return
}

// ControlIDs returns the "control" edge IDs in the mutation.
func (m *NarrativeMutation) ControlIDs() (ids []string) {
	for id := range m.control {
		ids = append(ids, id)
	}
	return
}

// ResetControl resets all changes to the "control" edge.
func (m *NarrativeMutation) ResetControl() {
	m.control = nil
	m.clearedcontrol = false
	m.removedcontrol = nil
}

// AddProcedureIDs adds the "procedure" edge to the Procedure entity by ids.
func (m *NarrativeMutation) AddProcedureIDs(ids ...string) {
	if m.procedure == nil {
		m.procedure = make(map[string]struct{})
	}
	for i := range ids {
		m.procedure[ids[i]] = struct{}{}
	}
}

// ClearProcedure clears the "procedure" edge to the Procedure entity.
func (m *NarrativeMutation) ClearProcedure() {
	m.clearedprocedure = true
}

// ProcedureCleared reports if the "procedure" edge to the Procedure entity was cleared.
func (m *NarrativeMutation) ProcedureCleared() bool {
	return m.clearedprocedure
}

// RemoveProcedureIDs removes the "procedure" edge to the Procedure entity by IDs.
func (m *NarrativeMutation) RemoveProcedureIDs(ids ...string) {
	if m.removedprocedure == nil {
		m.removedprocedure = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.procedure, ids[i])
		m.removedprocedure[ids[i]] = struct{}{}
	}
}

// RemovedProcedure returns the removed IDs of the "procedure" edge to the Procedure entity.
func (m *NarrativeMutation) RemovedProcedureIDs() (ids []string) {
	for id := range m.removedprocedure {
		ids = append(ids, id)
	}
	return
}

// ProcedureIDs returns the "procedure" edge IDs in the mutation.
func (m *NarrativeMutation) ProcedureIDs() (ids []string) {
	for id := range m.procedure {
		ids = append(ids, id)
	}
	return
}

// ResetProcedure resets all changes to the "procedure" edge.
func (m *NarrativeMutation) ResetProcedure() {
	m.procedure = nil
	m.clearedprocedure = false
	m.removedprocedure = nil
}

// AddControlobjectiveIDs adds the "controlobjective" edge to the ControlObjective entity by ids.
func (m *NarrativeMutation) AddControlobjectiveIDs(ids ...string) {
	if m.controlobjective == nil {
		m.controlobjective = make(map[string]struct{})
	}
	for i := range ids {
		m.controlobjective[ids[i]] = struct{}{}
	}
}

// ClearControlobjective clears the "controlobjective" edge to the ControlObjective entity.
func (m *NarrativeMutation) ClearControlobjective() {
	m.clearedcontrolobjective = true
}

// ControlobjectiveCleared reports if the "controlobjective" edge to the ControlObjective entity was cleared.
func (m *NarrativeMutation) ControlobjectiveCleared() bool {
	return m.clearedcontrolobjective
}

// RemoveControlobjectiveIDs removes the "controlobjective" edge to the ControlObjective entity by IDs.
func (m *NarrativeMutation) RemoveControlobjectiveIDs(ids ...string) {
	if m.removedcontrolobjective == nil {
		m.removedcontrolobjective = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controlobjective, ids[i])
		m.removedcontrolobjective[ids[i]] = struct{}{}
	}
}

// RemovedControlobjective returns the removed IDs of the "controlobjective" edge to the ControlObjective entity.
func (m *NarrativeMutation) RemovedControlobjectiveIDs() (ids []string) {
	for id := range m.removedcontrolobjective {
		ids = append(ids, id)
	}
	return
}

// ControlobjectiveIDs returns the "controlobjective" edge IDs in the mutation.
func (m *NarrativeMutation) ControlobjectiveIDs() (ids []string) {
	for id := range m.controlobjective {
		ids = append(ids, id)
	}
	return
}

// ResetControlobjective resets all changes to the "controlobjective" edge.
func (m *NarrativeMutation) ResetControlobjective() {
	m.controlobjective = nil
	m.clearedcontrolobjective = false
	m.removedcontrolobjective = nil
}

// AddProgramIDs adds the "program" edge to the Program entity by ids.
func (m *NarrativeMutation) AddProgramIDs(ids ...string) {
	if m.program == nil {
		m.program = make(map[string]struct{})
	}
	for i := range ids {
		m.program[ids[i]] = struct{}{}
	}
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *NarrativeMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *NarrativeMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// RemoveProgramIDs removes the "program" edge to the Program entity by IDs.
func (m *NarrativeMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprogram == nil {
		m.removedprogram = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.program, ids[i])
		m.removedprogram[ids[i]] = struct{}{}
	}
}

// RemovedProgram returns the removed IDs of the "program" edge to the Program entity.
func (m *NarrativeMutation) RemovedProgramIDs() (ids []string) {
	for id := range m.removedprogram {
		ids = append(ids, id)
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
func (m *NarrativeMutation) ProgramIDs() (ids []string) {
	for id := range m.program {
		ids = append(ids, id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *NarrativeMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
	m.removedprogram = nil
}

// Where appends a list predicates to the NarrativeMutation builder.
func (m *NarrativeMutation) Where(ps ...predicate.Narrative) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NarrativeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NarrativeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Narrative, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NarrativeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NarrativeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Narrative).
func (m *NarrativeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NarrativeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, narrative.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, narrative.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, narrative.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, narrative.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, narrative.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, narrative.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, narrative.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, narrative.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, narrative.FieldName)
	}
	if m.description != nil {
		fields = append(fields, narrative.FieldDescription)
	}
	if m.satisfies != nil {
		fields = append(fields, narrative.FieldSatisfies)
	}
	if m.details != nil {
		fields = append(fields, narrative.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NarrativeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case narrative.FieldCreatedAt:
		return m.CreatedAt()
	case narrative.FieldUpdatedAt:
		return m.UpdatedAt()
	case narrative.FieldCreatedBy:
		return m.CreatedBy()
	case narrative.FieldUpdatedBy:
		return m.UpdatedBy()
	case narrative.FieldDeletedAt:
		return m.DeletedAt()
	case narrative.FieldDeletedBy:
		return m.DeletedBy()
	case narrative.FieldMappingID:
		return m.MappingID()
	case narrative.FieldTags:
		return m.Tags()
	case narrative.FieldName:
		return m.Name()
	case narrative.FieldDescription:
		return m.Description()
	case narrative.FieldSatisfies:
		return m.Satisfies()
	case narrative.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NarrativeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case narrative.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case narrative.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case narrative.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case narrative.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case narrative.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case narrative.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case narrative.FieldMappingID:
		return m.OldMappingID(ctx)
	case narrative.FieldTags:
		return m.OldTags(ctx)
	case narrative.FieldName:
		return m.OldName(ctx)
	case narrative.FieldDescription:
		return m.OldDescription(ctx)
	case narrative.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case narrative.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Narrative field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NarrativeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case narrative.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case narrative.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case narrative.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case narrative.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case narrative.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case narrative.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case narrative.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case narrative.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case narrative.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case narrative.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case narrative.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case narrative.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Narrative field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NarrativeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NarrativeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NarrativeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Narrative numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NarrativeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(narrative.FieldCreatedAt) {
		fields = append(fields, narrative.FieldCreatedAt)
	}
	if m.FieldCleared(narrative.FieldUpdatedAt) {
		fields = append(fields, narrative.FieldUpdatedAt)
	}
	if m.FieldCleared(narrative.FieldCreatedBy) {
		fields = append(fields, narrative.FieldCreatedBy)
	}
	if m.FieldCleared(narrative.FieldUpdatedBy) {
		fields = append(fields, narrative.FieldUpdatedBy)
	}
	if m.FieldCleared(narrative.FieldDeletedAt) {
		fields = append(fields, narrative.FieldDeletedAt)
	}
	if m.FieldCleared(narrative.FieldDeletedBy) {
		fields = append(fields, narrative.FieldDeletedBy)
	}
	if m.FieldCleared(narrative.FieldTags) {
		fields = append(fields, narrative.FieldTags)
	}
	if m.FieldCleared(narrative.FieldDescription) {
		fields = append(fields, narrative.FieldDescription)
	}
	if m.FieldCleared(narrative.FieldSatisfies) {
		fields = append(fields, narrative.FieldSatisfies)
	}
	if m.FieldCleared(narrative.FieldDetails) {
		fields = append(fields, narrative.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NarrativeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NarrativeMutation) ClearField(name string) error {
	switch name {
	case narrative.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case narrative.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case narrative.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case narrative.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case narrative.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case narrative.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case narrative.FieldTags:
		m.ClearTags()
		return nil
	case narrative.FieldDescription:
		m.ClearDescription()
		return nil
	case narrative.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case narrative.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Narrative nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NarrativeMutation) ResetField(name string) error {
	switch name {
	case narrative.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case narrative.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case narrative.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case narrative.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case narrative.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case narrative.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case narrative.FieldMappingID:
		m.ResetMappingID()
		return nil
	case narrative.FieldTags:
		m.ResetTags()
		return nil
	case narrative.FieldName:
		m.ResetName()
		return nil
	case narrative.FieldDescription:
		m.ResetDescription()
		return nil
	case narrative.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case narrative.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Narrative field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NarrativeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.policy != nil {
		edges = append(edges, narrative.EdgePolicy)
	}
	if m.control != nil {
		edges = append(edges, narrative.EdgeControl)
	}
	if m.procedure != nil {
		edges = append(edges, narrative.EdgeProcedure)
	}
	if m.controlobjective != nil {
		edges = append(edges, narrative.EdgeControlobjective)
	}
	if m.program != nil {
		edges = append(edges, narrative.EdgeProgram)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NarrativeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case narrative.EdgePolicy:
		ids := make([]ent.Value, 0, len(m.policy))
		for id := range m.policy {
			ids = append(ids, id)
		}
		return ids
	case narrative.EdgeControl:
		ids := make([]ent.Value, 0, len(m.control))
		for id := range m.control {
			ids = append(ids, id)
		}
		return ids
	case narrative.EdgeProcedure:
		ids := make([]ent.Value, 0, len(m.procedure))
		for id := range m.procedure {
			ids = append(ids, id)
		}
		return ids
	case narrative.EdgeControlobjective:
		ids := make([]ent.Value, 0, len(m.controlobjective))
		for id := range m.controlobjective {
			ids = append(ids, id)
		}
		return ids
	case narrative.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.program))
		for id := range m.program {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NarrativeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpolicy != nil {
		edges = append(edges, narrative.EdgePolicy)
	}
	if m.removedcontrol != nil {
		edges = append(edges, narrative.EdgeControl)
	}
	if m.removedprocedure != nil {
		edges = append(edges, narrative.EdgeProcedure)
	}
	if m.removedcontrolobjective != nil {
		edges = append(edges, narrative.EdgeControlobjective)
	}
	if m.removedprogram != nil {
		edges = append(edges, narrative.EdgeProgram)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NarrativeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case narrative.EdgePolicy:
		ids := make([]ent.Value, 0, len(m.removedpolicy))
		for id := range m.removedpolicy {
			ids = append(ids, id)
		}
		return ids
	case narrative.EdgeControl:
		ids := make([]ent.Value, 0, len(m.removedcontrol))
		for id := range m.removedcontrol {
			ids = append(ids, id)
		}
		return ids
	case narrative.EdgeProcedure:
		ids := make([]ent.Value, 0, len(m.removedprocedure))
		for id := range m.removedprocedure {
			ids = append(ids, id)
		}
		return ids
	case narrative.EdgeControlobjective:
		ids := make([]ent.Value, 0, len(m.removedcontrolobjective))
		for id := range m.removedcontrolobjective {
			ids = append(ids, id)
		}
		return ids
	case narrative.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.removedprogram))
		for id := range m.removedprogram {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NarrativeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedpolicy {
		edges = append(edges, narrative.EdgePolicy)
	}
	if m.clearedcontrol {
		edges = append(edges, narrative.EdgeControl)
	}
	if m.clearedprocedure {
		edges = append(edges, narrative.EdgeProcedure)
	}
	if m.clearedcontrolobjective {
		edges = append(edges, narrative.EdgeControlobjective)
	}
	if m.clearedprogram {
		edges = append(edges, narrative.EdgeProgram)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NarrativeMutation) EdgeCleared(name string) bool {
	switch name {
	case narrative.EdgePolicy:
		return m.clearedpolicy
	case narrative.EdgeControl:
		return m.clearedcontrol
	case narrative.EdgeProcedure:
		return m.clearedprocedure
	case narrative.EdgeControlobjective:
		return m.clearedcontrolobjective
	case narrative.EdgeProgram:
		return m.clearedprogram
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NarrativeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Narrative unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NarrativeMutation) ResetEdge(name string) error {
	switch name {
	case narrative.EdgePolicy:
		m.ResetPolicy()
		return nil
	case narrative.EdgeControl:
		m.ResetControl()
		return nil
	case narrative.EdgeProcedure:
		m.ResetProcedure()
		return nil
	case narrative.EdgeControlobjective:
		m.ResetControlobjective()
		return nil
	case narrative.EdgeProgram:
		m.ResetProgram()
		return nil
	}
	return fmt.Errorf("unknown Narrative edge %s", name)
}

// NarrativeHistoryMutation represents an operation that mutates the NarrativeHistory nodes in the graph.
type NarrativeHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	name          *string
	description   *string
	satisfies     *string
	details       *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NarrativeHistory, error)
	predicates    []predicate.NarrativeHistory
}

var _ ent.Mutation = (*NarrativeHistoryMutation)(nil)

// narrativehistoryOption allows management of the mutation configuration using functional options.
type narrativehistoryOption func(*NarrativeHistoryMutation)

// newNarrativeHistoryMutation creates new mutation for the NarrativeHistory entity.
func newNarrativeHistoryMutation(c config, op Op, opts ...narrativehistoryOption) *NarrativeHistoryMutation {
	m := &NarrativeHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeNarrativeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNarrativeHistoryID sets the ID field of the mutation.
func withNarrativeHistoryID(id string) narrativehistoryOption {
	return func(m *NarrativeHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *NarrativeHistory
		)
		m.oldValue = func(ctx context.Context) (*NarrativeHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NarrativeHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNarrativeHistory sets the old NarrativeHistory of the mutation.
func withNarrativeHistory(node *NarrativeHistory) narrativehistoryOption {
	return func(m *NarrativeHistoryMutation) {
		m.oldValue = func(context.Context) (*NarrativeHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NarrativeHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NarrativeHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NarrativeHistory entities.
func (m *NarrativeHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NarrativeHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NarrativeHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NarrativeHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *NarrativeHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *NarrativeHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *NarrativeHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *NarrativeHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *NarrativeHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *NarrativeHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[narrativehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *NarrativeHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, narrativehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *NarrativeHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *NarrativeHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *NarrativeHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NarrativeHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NarrativeHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NarrativeHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[narrativehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NarrativeHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, narrativehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NarrativeHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NarrativeHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NarrativeHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[narrativehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NarrativeHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, narrativehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *NarrativeHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NarrativeHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NarrativeHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[narrativehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NarrativeHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, narrativehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NarrativeHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NarrativeHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NarrativeHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[narrativehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NarrativeHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, narrativehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NarrativeHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NarrativeHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NarrativeHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[narrativehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NarrativeHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, narrativehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *NarrativeHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *NarrativeHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *NarrativeHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[narrativehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *NarrativeHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, narrativehistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *NarrativeHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *NarrativeHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *NarrativeHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *NarrativeHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NarrativeHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *NarrativeHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *NarrativeHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *NarrativeHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[narrativehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *NarrativeHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, narrativehistory.FieldTags)
}

// SetName sets the "name" field.
func (m *NarrativeHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NarrativeHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NarrativeHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NarrativeHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NarrativeHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NarrativeHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[narrativehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NarrativeHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, narrativehistory.FieldDescription)
}

// SetSatisfies sets the "satisfies" field.
func (m *NarrativeHistoryMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *NarrativeHistoryMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *NarrativeHistoryMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[narrativehistory.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *NarrativeHistoryMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, narrativehistory.FieldSatisfies)
}

// SetDetails sets the "details" field.
func (m *NarrativeHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *NarrativeHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the NarrativeHistory entity.
// If the NarrativeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NarrativeHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *NarrativeHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[narrativehistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *NarrativeHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[narrativehistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *NarrativeHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, narrativehistory.FieldDetails)
}

// Where appends a list predicates to the NarrativeHistoryMutation builder.
func (m *NarrativeHistoryMutation) Where(ps ...predicate.NarrativeHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NarrativeHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NarrativeHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NarrativeHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NarrativeHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NarrativeHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NarrativeHistory).
func (m *NarrativeHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NarrativeHistoryMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.history_time != nil {
		fields = append(fields, narrativehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, narrativehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, narrativehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, narrativehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, narrativehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, narrativehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, narrativehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, narrativehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, narrativehistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, narrativehistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, narrativehistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, narrativehistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, narrativehistory.FieldDescription)
	}
	if m.satisfies != nil {
		fields = append(fields, narrativehistory.FieldSatisfies)
	}
	if m.details != nil {
		fields = append(fields, narrativehistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NarrativeHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case narrativehistory.FieldHistoryTime:
		return m.HistoryTime()
	case narrativehistory.FieldRef:
		return m.Ref()
	case narrativehistory.FieldOperation:
		return m.Operation()
	case narrativehistory.FieldCreatedAt:
		return m.CreatedAt()
	case narrativehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case narrativehistory.FieldCreatedBy:
		return m.CreatedBy()
	case narrativehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case narrativehistory.FieldDeletedAt:
		return m.DeletedAt()
	case narrativehistory.FieldDeletedBy:
		return m.DeletedBy()
	case narrativehistory.FieldMappingID:
		return m.MappingID()
	case narrativehistory.FieldTags:
		return m.Tags()
	case narrativehistory.FieldName:
		return m.Name()
	case narrativehistory.FieldDescription:
		return m.Description()
	case narrativehistory.FieldSatisfies:
		return m.Satisfies()
	case narrativehistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NarrativeHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case narrativehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case narrativehistory.FieldRef:
		return m.OldRef(ctx)
	case narrativehistory.FieldOperation:
		return m.OldOperation(ctx)
	case narrativehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case narrativehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case narrativehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case narrativehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case narrativehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case narrativehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case narrativehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case narrativehistory.FieldTags:
		return m.OldTags(ctx)
	case narrativehistory.FieldName:
		return m.OldName(ctx)
	case narrativehistory.FieldDescription:
		return m.OldDescription(ctx)
	case narrativehistory.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case narrativehistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown NarrativeHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NarrativeHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case narrativehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case narrativehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case narrativehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case narrativehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case narrativehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case narrativehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case narrativehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case narrativehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case narrativehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case narrativehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case narrativehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case narrativehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case narrativehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case narrativehistory.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case narrativehistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown NarrativeHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NarrativeHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NarrativeHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NarrativeHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NarrativeHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NarrativeHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(narrativehistory.FieldRef) {
		fields = append(fields, narrativehistory.FieldRef)
	}
	if m.FieldCleared(narrativehistory.FieldCreatedAt) {
		fields = append(fields, narrativehistory.FieldCreatedAt)
	}
	if m.FieldCleared(narrativehistory.FieldUpdatedAt) {
		fields = append(fields, narrativehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(narrativehistory.FieldCreatedBy) {
		fields = append(fields, narrativehistory.FieldCreatedBy)
	}
	if m.FieldCleared(narrativehistory.FieldUpdatedBy) {
		fields = append(fields, narrativehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(narrativehistory.FieldDeletedAt) {
		fields = append(fields, narrativehistory.FieldDeletedAt)
	}
	if m.FieldCleared(narrativehistory.FieldDeletedBy) {
		fields = append(fields, narrativehistory.FieldDeletedBy)
	}
	if m.FieldCleared(narrativehistory.FieldTags) {
		fields = append(fields, narrativehistory.FieldTags)
	}
	if m.FieldCleared(narrativehistory.FieldDescription) {
		fields = append(fields, narrativehistory.FieldDescription)
	}
	if m.FieldCleared(narrativehistory.FieldSatisfies) {
		fields = append(fields, narrativehistory.FieldSatisfies)
	}
	if m.FieldCleared(narrativehistory.FieldDetails) {
		fields = append(fields, narrativehistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NarrativeHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NarrativeHistoryMutation) ClearField(name string) error {
	switch name {
	case narrativehistory.FieldRef:
		m.ClearRef()
		return nil
	case narrativehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case narrativehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case narrativehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case narrativehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case narrativehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case narrativehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case narrativehistory.FieldTags:
		m.ClearTags()
		return nil
	case narrativehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case narrativehistory.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case narrativehistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown NarrativeHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NarrativeHistoryMutation) ResetField(name string) error {
	switch name {
	case narrativehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case narrativehistory.FieldRef:
		m.ResetRef()
		return nil
	case narrativehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case narrativehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case narrativehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case narrativehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case narrativehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case narrativehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case narrativehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case narrativehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case narrativehistory.FieldTags:
		m.ResetTags()
		return nil
	case narrativehistory.FieldName:
		m.ResetName()
		return nil
	case narrativehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case narrativehistory.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case narrativehistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown NarrativeHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NarrativeHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NarrativeHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NarrativeHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NarrativeHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NarrativeHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NarrativeHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NarrativeHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NarrativeHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NarrativeHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NarrativeHistory edge %s", name)
}

// NoteMutation represents an operation that mutates the Note nodes in the graph.
type NoteMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	mapping_id         *string
	deleted_at         *time.Time
	deleted_by         *string
	tags               *[]string
	appendtags         []string
	text               *string
	clearedFields      map[string]struct{}
	owner              *string
	clearedowner       bool
	entity             *string
	clearedentity      bool
	subcontrols        map[string]struct{}
	removedsubcontrols map[string]struct{}
	clearedsubcontrols bool
	program            map[string]struct{}
	removedprogram     map[string]struct{}
	clearedprogram     bool
	done               bool
	oldValue           func(context.Context) (*Note, error)
	predicates         []predicate.Note
}

var _ ent.Mutation = (*NoteMutation)(nil)

// noteOption allows management of the mutation configuration using functional options.
type noteOption func(*NoteMutation)

// newNoteMutation creates new mutation for the Note entity.
func newNoteMutation(c config, op Op, opts ...noteOption) *NoteMutation {
	m := &NoteMutation{
		config:        c,
		op:            op,
		typ:           TypeNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNoteID sets the ID field of the mutation.
func withNoteID(id string) noteOption {
	return func(m *NoteMutation) {
		var (
			err   error
			once  sync.Once
			value *Note
		)
		m.oldValue = func(ctx context.Context) (*Note, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Note.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNote sets the old Note of the mutation.
func withNote(node *Note) noteOption {
	return func(m *NoteMutation) {
		m.oldValue = func(context.Context) (*Note, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Note entities.
func (m *NoteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NoteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NoteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Note.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NoteMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[note.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NoteMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[note.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NoteMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, note.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NoteMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[note.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NoteMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[note.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, note.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *NoteMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NoteMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NoteMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[note.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NoteMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[note.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NoteMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, note.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NoteMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NoteMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NoteMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[note.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NoteMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[note.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NoteMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, note.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *NoteMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *NoteMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *NoteMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NoteMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NoteMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NoteMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[note.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NoteMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[note.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NoteMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, note.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *NoteMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *NoteMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *NoteMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[note.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *NoteMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[note.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *NoteMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, note.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *NoteMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NoteMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *NoteMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *NoteMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *NoteMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[note.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *NoteMutation) TagsCleared() bool {
	_, ok := m.clearedFields[note.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *NoteMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, note.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *NoteMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *NoteMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *NoteMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[note.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *NoteMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[note.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *NoteMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, note.FieldOwnerID)
}

// SetText sets the "text" field.
func (m *NoteMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *NoteMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Note entity.
// If the Note object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *NoteMutation) ResetText() {
	m.text = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *NoteMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[note.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *NoteMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NoteMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NoteMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetEntityID sets the "entity" edge to the Entity entity by id.
func (m *NoteMutation) SetEntityID(id string) {
	m.entity = &id
}

// ClearEntity clears the "entity" edge to the Entity entity.
func (m *NoteMutation) ClearEntity() {
	m.clearedentity = true
}

// EntityCleared reports if the "entity" edge to the Entity entity was cleared.
func (m *NoteMutation) EntityCleared() bool {
	return m.clearedentity
}

// EntityID returns the "entity" edge ID in the mutation.
func (m *NoteMutation) EntityID() (id string, exists bool) {
	if m.entity != nil {
		return *m.entity, true
	}
	return
}

// EntityIDs returns the "entity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EntityID instead. It exists only for internal usage by the builders.
func (m *NoteMutation) EntityIDs() (ids []string) {
	if id := m.entity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEntity resets all changes to the "entity" edge.
func (m *NoteMutation) ResetEntity() {
	m.entity = nil
	m.clearedentity = false
}

// AddSubcontrolIDs adds the "subcontrols" edge to the Subcontrol entity by ids.
func (m *NoteMutation) AddSubcontrolIDs(ids ...string) {
	if m.subcontrols == nil {
		m.subcontrols = make(map[string]struct{})
	}
	for i := range ids {
		m.subcontrols[ids[i]] = struct{}{}
	}
}

// ClearSubcontrols clears the "subcontrols" edge to the Subcontrol entity.
func (m *NoteMutation) ClearSubcontrols() {
	m.clearedsubcontrols = true
}

// SubcontrolsCleared reports if the "subcontrols" edge to the Subcontrol entity was cleared.
func (m *NoteMutation) SubcontrolsCleared() bool {
	return m.clearedsubcontrols
}

// RemoveSubcontrolIDs removes the "subcontrols" edge to the Subcontrol entity by IDs.
func (m *NoteMutation) RemoveSubcontrolIDs(ids ...string) {
	if m.removedsubcontrols == nil {
		m.removedsubcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subcontrols, ids[i])
		m.removedsubcontrols[ids[i]] = struct{}{}
	}
}

// RemovedSubcontrols returns the removed IDs of the "subcontrols" edge to the Subcontrol entity.
func (m *NoteMutation) RemovedSubcontrolsIDs() (ids []string) {
	for id := range m.removedsubcontrols {
		ids = append(ids, id)
	}
	return
}

// SubcontrolsIDs returns the "subcontrols" edge IDs in the mutation.
func (m *NoteMutation) SubcontrolsIDs() (ids []string) {
	for id := range m.subcontrols {
		ids = append(ids, id)
	}
	return
}

// ResetSubcontrols resets all changes to the "subcontrols" edge.
func (m *NoteMutation) ResetSubcontrols() {
	m.subcontrols = nil
	m.clearedsubcontrols = false
	m.removedsubcontrols = nil
}

// AddProgramIDs adds the "program" edge to the Program entity by ids.
func (m *NoteMutation) AddProgramIDs(ids ...string) {
	if m.program == nil {
		m.program = make(map[string]struct{})
	}
	for i := range ids {
		m.program[ids[i]] = struct{}{}
	}
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *NoteMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *NoteMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// RemoveProgramIDs removes the "program" edge to the Program entity by IDs.
func (m *NoteMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprogram == nil {
		m.removedprogram = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.program, ids[i])
		m.removedprogram[ids[i]] = struct{}{}
	}
}

// RemovedProgram returns the removed IDs of the "program" edge to the Program entity.
func (m *NoteMutation) RemovedProgramIDs() (ids []string) {
	for id := range m.removedprogram {
		ids = append(ids, id)
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
func (m *NoteMutation) ProgramIDs() (ids []string) {
	for id := range m.program {
		ids = append(ids, id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *NoteMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
	m.removedprogram = nil
}

// Where appends a list predicates to the NoteMutation builder.
func (m *NoteMutation) Where(ps ...predicate.Note) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Note, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Note).
func (m *NoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NoteMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, note.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, note.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, note.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, note.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, note.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, note.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, note.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, note.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, note.FieldOwnerID)
	}
	if m.text != nil {
		fields = append(fields, note.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case note.FieldCreatedAt:
		return m.CreatedAt()
	case note.FieldUpdatedAt:
		return m.UpdatedAt()
	case note.FieldCreatedBy:
		return m.CreatedBy()
	case note.FieldUpdatedBy:
		return m.UpdatedBy()
	case note.FieldMappingID:
		return m.MappingID()
	case note.FieldDeletedAt:
		return m.DeletedAt()
	case note.FieldDeletedBy:
		return m.DeletedBy()
	case note.FieldTags:
		return m.Tags()
	case note.FieldOwnerID:
		return m.OwnerID()
	case note.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case note.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case note.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case note.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case note.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case note.FieldMappingID:
		return m.OldMappingID(ctx)
	case note.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case note.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case note.FieldTags:
		return m.OldTags(ctx)
	case note.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case note.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown Note field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case note.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case note.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case note.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case note.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case note.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case note.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case note.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case note.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case note.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case note.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown Note field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Note numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(note.FieldCreatedAt) {
		fields = append(fields, note.FieldCreatedAt)
	}
	if m.FieldCleared(note.FieldUpdatedAt) {
		fields = append(fields, note.FieldUpdatedAt)
	}
	if m.FieldCleared(note.FieldCreatedBy) {
		fields = append(fields, note.FieldCreatedBy)
	}
	if m.FieldCleared(note.FieldUpdatedBy) {
		fields = append(fields, note.FieldUpdatedBy)
	}
	if m.FieldCleared(note.FieldDeletedAt) {
		fields = append(fields, note.FieldDeletedAt)
	}
	if m.FieldCleared(note.FieldDeletedBy) {
		fields = append(fields, note.FieldDeletedBy)
	}
	if m.FieldCleared(note.FieldTags) {
		fields = append(fields, note.FieldTags)
	}
	if m.FieldCleared(note.FieldOwnerID) {
		fields = append(fields, note.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NoteMutation) ClearField(name string) error {
	switch name {
	case note.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case note.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case note.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case note.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case note.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case note.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case note.FieldTags:
		m.ClearTags()
		return nil
	case note.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown Note nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NoteMutation) ResetField(name string) error {
	switch name {
	case note.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case note.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case note.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case note.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case note.FieldMappingID:
		m.ResetMappingID()
		return nil
	case note.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case note.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case note.FieldTags:
		m.ResetTags()
		return nil
	case note.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case note.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown Note field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, note.EdgeOwner)
	}
	if m.entity != nil {
		edges = append(edges, note.EdgeEntity)
	}
	if m.subcontrols != nil {
		edges = append(edges, note.EdgeSubcontrols)
	}
	if m.program != nil {
		edges = append(edges, note.EdgeProgram)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case note.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case note.EdgeEntity:
		if id := m.entity; id != nil {
			return []ent.Value{*id}
		}
	case note.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.subcontrols))
		for id := range m.subcontrols {
			ids = append(ids, id)
		}
		return ids
	case note.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.program))
		for id := range m.program {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsubcontrols != nil {
		edges = append(edges, note.EdgeSubcontrols)
	}
	if m.removedprogram != nil {
		edges = append(edges, note.EdgeProgram)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NoteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case note.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.removedsubcontrols))
		for id := range m.removedsubcontrols {
			ids = append(ids, id)
		}
		return ids
	case note.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.removedprogram))
		for id := range m.removedprogram {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, note.EdgeOwner)
	}
	if m.clearedentity {
		edges = append(edges, note.EdgeEntity)
	}
	if m.clearedsubcontrols {
		edges = append(edges, note.EdgeSubcontrols)
	}
	if m.clearedprogram {
		edges = append(edges, note.EdgeProgram)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NoteMutation) EdgeCleared(name string) bool {
	switch name {
	case note.EdgeOwner:
		return m.clearedowner
	case note.EdgeEntity:
		return m.clearedentity
	case note.EdgeSubcontrols:
		return m.clearedsubcontrols
	case note.EdgeProgram:
		return m.clearedprogram
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NoteMutation) ClearEdge(name string) error {
	switch name {
	case note.EdgeOwner:
		m.ClearOwner()
		return nil
	case note.EdgeEntity:
		m.ClearEntity()
		return nil
	}
	return fmt.Errorf("unknown Note unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NoteMutation) ResetEdge(name string) error {
	switch name {
	case note.EdgeOwner:
		m.ResetOwner()
		return nil
	case note.EdgeEntity:
		m.ResetEntity()
		return nil
	case note.EdgeSubcontrols:
		m.ResetSubcontrols()
		return nil
	case note.EdgeProgram:
		m.ResetProgram()
		return nil
	}
	return fmt.Errorf("unknown Note edge %s", name)
}

// NoteHistoryMutation represents an operation that mutates the NoteHistory nodes in the graph.
type NoteHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	text          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NoteHistory, error)
	predicates    []predicate.NoteHistory
}

var _ ent.Mutation = (*NoteHistoryMutation)(nil)

// notehistoryOption allows management of the mutation configuration using functional options.
type notehistoryOption func(*NoteHistoryMutation)

// newNoteHistoryMutation creates new mutation for the NoteHistory entity.
func newNoteHistoryMutation(c config, op Op, opts ...notehistoryOption) *NoteHistoryMutation {
	m := &NoteHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeNoteHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNoteHistoryID sets the ID field of the mutation.
func withNoteHistoryID(id string) notehistoryOption {
	return func(m *NoteHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *NoteHistory
		)
		m.oldValue = func(ctx context.Context) (*NoteHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NoteHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNoteHistory sets the old NoteHistory of the mutation.
func withNoteHistory(node *NoteHistory) notehistoryOption {
	return func(m *NoteHistoryMutation) {
		m.oldValue = func(context.Context) (*NoteHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NoteHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NoteHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NoteHistory entities.
func (m *NoteHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NoteHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NoteHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NoteHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *NoteHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *NoteHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *NoteHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *NoteHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *NoteHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *NoteHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[notehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *NoteHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *NoteHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, notehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *NoteHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *NoteHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *NoteHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NoteHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NoteHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *NoteHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[notehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *NoteHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NoteHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, notehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NoteHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NoteHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *NoteHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[notehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *NoteHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NoteHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, notehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *NoteHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *NoteHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *NoteHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[notehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *NoteHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *NoteHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, notehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *NoteHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *NoteHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *NoteHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[notehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *NoteHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *NoteHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, notehistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *NoteHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *NoteHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *NoteHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NoteHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NoteHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NoteHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NoteHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NoteHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *NoteHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *NoteHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *NoteHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[notehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *NoteHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *NoteHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, notehistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *NoteHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NoteHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *NoteHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *NoteHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *NoteHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[notehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *NoteHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *NoteHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, notehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *NoteHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *NoteHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *NoteHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[notehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *NoteHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[notehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *NoteHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, notehistory.FieldOwnerID)
}

// SetText sets the "text" field.
func (m *NoteHistoryMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *NoteHistoryMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the NoteHistory entity.
// If the NoteHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NoteHistoryMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *NoteHistoryMutation) ResetText() {
	m.text = nil
}

// Where appends a list predicates to the NoteHistoryMutation builder.
func (m *NoteHistoryMutation) Where(ps ...predicate.NoteHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NoteHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NoteHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NoteHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NoteHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NoteHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NoteHistory).
func (m *NoteHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NoteHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.history_time != nil {
		fields = append(fields, notehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, notehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, notehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, notehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, notehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, notehistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, notehistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, notehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, notehistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, notehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, notehistory.FieldOwnerID)
	}
	if m.text != nil {
		fields = append(fields, notehistory.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NoteHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notehistory.FieldHistoryTime:
		return m.HistoryTime()
	case notehistory.FieldRef:
		return m.Ref()
	case notehistory.FieldOperation:
		return m.Operation()
	case notehistory.FieldCreatedAt:
		return m.CreatedAt()
	case notehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case notehistory.FieldCreatedBy:
		return m.CreatedBy()
	case notehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case notehistory.FieldMappingID:
		return m.MappingID()
	case notehistory.FieldDeletedAt:
		return m.DeletedAt()
	case notehistory.FieldDeletedBy:
		return m.DeletedBy()
	case notehistory.FieldTags:
		return m.Tags()
	case notehistory.FieldOwnerID:
		return m.OwnerID()
	case notehistory.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NoteHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case notehistory.FieldRef:
		return m.OldRef(ctx)
	case notehistory.FieldOperation:
		return m.OldOperation(ctx)
	case notehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case notehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case notehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case notehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case notehistory.FieldTags:
		return m.OldTags(ctx)
	case notehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case notehistory.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown NoteHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoteHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case notehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case notehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case notehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case notehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case notehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case notehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case notehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case notehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case notehistory.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown NoteHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NoteHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NoteHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NoteHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NoteHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NoteHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notehistory.FieldRef) {
		fields = append(fields, notehistory.FieldRef)
	}
	if m.FieldCleared(notehistory.FieldCreatedAt) {
		fields = append(fields, notehistory.FieldCreatedAt)
	}
	if m.FieldCleared(notehistory.FieldUpdatedAt) {
		fields = append(fields, notehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(notehistory.FieldCreatedBy) {
		fields = append(fields, notehistory.FieldCreatedBy)
	}
	if m.FieldCleared(notehistory.FieldUpdatedBy) {
		fields = append(fields, notehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(notehistory.FieldDeletedAt) {
		fields = append(fields, notehistory.FieldDeletedAt)
	}
	if m.FieldCleared(notehistory.FieldDeletedBy) {
		fields = append(fields, notehistory.FieldDeletedBy)
	}
	if m.FieldCleared(notehistory.FieldTags) {
		fields = append(fields, notehistory.FieldTags)
	}
	if m.FieldCleared(notehistory.FieldOwnerID) {
		fields = append(fields, notehistory.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NoteHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NoteHistoryMutation) ClearField(name string) error {
	switch name {
	case notehistory.FieldRef:
		m.ClearRef()
		return nil
	case notehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case notehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case notehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case notehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case notehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case notehistory.FieldTags:
		m.ClearTags()
		return nil
	case notehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown NoteHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NoteHistoryMutation) ResetField(name string) error {
	switch name {
	case notehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case notehistory.FieldRef:
		m.ResetRef()
		return nil
	case notehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case notehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case notehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case notehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case notehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case notehistory.FieldTags:
		m.ResetTags()
		return nil
	case notehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case notehistory.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown NoteHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NoteHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NoteHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NoteHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NoteHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NoteHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NoteHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NoteHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NoteHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NoteHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NoteHistory edge %s", name)
}

// OauthProviderMutation represents an operation that mutates the OauthProvider nodes in the graph.
type OauthProviderMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	deleted_at    *time.Time
	deleted_by    *string
	name          *string
	client_id     *string
	client_secret *string
	redirect_url  *string
	scopes        *string
	auth_url      *string
	token_url     *string
	auth_style    *customtypes.Uint8
	addauth_style *customtypes.Uint8
	info_url      *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*OauthProvider, error)
	predicates    []predicate.OauthProvider
}

var _ ent.Mutation = (*OauthProviderMutation)(nil)

// oauthproviderOption allows management of the mutation configuration using functional options.
type oauthproviderOption func(*OauthProviderMutation)

// newOauthProviderMutation creates new mutation for the OauthProvider entity.
func newOauthProviderMutation(c config, op Op, opts ...oauthproviderOption) *OauthProviderMutation {
	m := &OauthProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeOauthProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthProviderID sets the ID field of the mutation.
func withOauthProviderID(id string) oauthproviderOption {
	return func(m *OauthProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *OauthProvider
		)
		m.oldValue = func(ctx context.Context) (*OauthProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OauthProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauthProvider sets the old OauthProvider of the mutation.
func withOauthProvider(node *OauthProvider) oauthproviderOption {
	return func(m *OauthProviderMutation) {
		m.oldValue = func(context.Context) (*OauthProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OauthProvider entities.
func (m *OauthProviderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OauthProviderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OauthProviderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OauthProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OauthProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OauthProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OauthProviderMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[oauthprovider.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OauthProviderMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OauthProviderMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, oauthprovider.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OauthProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OauthProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OauthProviderMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[oauthprovider.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OauthProviderMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OauthProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, oauthprovider.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OauthProviderMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OauthProviderMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OauthProviderMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[oauthprovider.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OauthProviderMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OauthProviderMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, oauthprovider.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OauthProviderMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OauthProviderMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OauthProviderMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[oauthprovider.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OauthProviderMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OauthProviderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, oauthprovider.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *OauthProviderMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OauthProviderMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OauthProviderMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *OauthProviderMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OauthProviderMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OauthProviderMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OauthProviderMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OauthProviderMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[oauthprovider.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OauthProviderMutation) TagsCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OauthProviderMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, oauthprovider.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OauthProviderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OauthProviderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OauthProviderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[oauthprovider.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OauthProviderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OauthProviderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, oauthprovider.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OauthProviderMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OauthProviderMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OauthProviderMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[oauthprovider.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OauthProviderMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OauthProviderMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, oauthprovider.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *OauthProviderMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OauthProviderMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *OauthProviderMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[oauthprovider.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *OauthProviderMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OauthProviderMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, oauthprovider.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *OauthProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OauthProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OauthProviderMutation) ResetName() {
	m.name = nil
}

// SetClientID sets the "client_id" field.
func (m *OauthProviderMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OauthProviderMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OauthProviderMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *OauthProviderMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OauthProviderMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OauthProviderMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetRedirectURL sets the "redirect_url" field.
func (m *OauthProviderMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *OauthProviderMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *OauthProviderMutation) ResetRedirectURL() {
	m.redirect_url = nil
}

// SetScopes sets the "scopes" field.
func (m *OauthProviderMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *OauthProviderMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ResetScopes resets all changes to the "scopes" field.
func (m *OauthProviderMutation) ResetScopes() {
	m.scopes = nil
}

// SetAuthURL sets the "auth_url" field.
func (m *OauthProviderMutation) SetAuthURL(s string) {
	m.auth_url = &s
}

// AuthURL returns the value of the "auth_url" field in the mutation.
func (m *OauthProviderMutation) AuthURL() (r string, exists bool) {
	v := m.auth_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthURL returns the old "auth_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldAuthURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthURL: %w", err)
	}
	return oldValue.AuthURL, nil
}

// ResetAuthURL resets all changes to the "auth_url" field.
func (m *OauthProviderMutation) ResetAuthURL() {
	m.auth_url = nil
}

// SetTokenURL sets the "token_url" field.
func (m *OauthProviderMutation) SetTokenURL(s string) {
	m.token_url = &s
}

// TokenURL returns the value of the "token_url" field in the mutation.
func (m *OauthProviderMutation) TokenURL() (r string, exists bool) {
	v := m.token_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenURL returns the old "token_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldTokenURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenURL: %w", err)
	}
	return oldValue.TokenURL, nil
}

// ResetTokenURL resets all changes to the "token_url" field.
func (m *OauthProviderMutation) ResetTokenURL() {
	m.token_url = nil
}

// SetAuthStyle sets the "auth_style" field.
func (m *OauthProviderMutation) SetAuthStyle(c customtypes.Uint8) {
	m.auth_style = &c
	m.addauth_style = nil
}

// AuthStyle returns the value of the "auth_style" field in the mutation.
func (m *OauthProviderMutation) AuthStyle() (r customtypes.Uint8, exists bool) {
	v := m.auth_style
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthStyle returns the old "auth_style" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldAuthStyle(ctx context.Context) (v customtypes.Uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthStyle: %w", err)
	}
	return oldValue.AuthStyle, nil
}

// AddAuthStyle adds c to the "auth_style" field.
func (m *OauthProviderMutation) AddAuthStyle(c customtypes.Uint8) {
	if m.addauth_style != nil {
		*m.addauth_style += c
	} else {
		m.addauth_style = &c
	}
}

// AddedAuthStyle returns the value that was added to the "auth_style" field in this mutation.
func (m *OauthProviderMutation) AddedAuthStyle() (r customtypes.Uint8, exists bool) {
	v := m.addauth_style
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthStyle resets all changes to the "auth_style" field.
func (m *OauthProviderMutation) ResetAuthStyle() {
	m.auth_style = nil
	m.addauth_style = nil
}

// SetInfoURL sets the "info_url" field.
func (m *OauthProviderMutation) SetInfoURL(s string) {
	m.info_url = &s
}

// InfoURL returns the value of the "info_url" field in the mutation.
func (m *OauthProviderMutation) InfoURL() (r string, exists bool) {
	v := m.info_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInfoURL returns the old "info_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldInfoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfoURL: %w", err)
	}
	return oldValue.InfoURL, nil
}

// ResetInfoURL resets all changes to the "info_url" field.
func (m *OauthProviderMutation) ResetInfoURL() {
	m.info_url = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *OauthProviderMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[oauthprovider.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *OauthProviderMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OauthProviderMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OauthProviderMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the OauthProviderMutation builder.
func (m *OauthProviderMutation) Where(ps ...predicate.OauthProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OauthProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OauthProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OauthProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OauthProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OauthProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OauthProvider).
func (m *OauthProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OauthProviderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, oauthprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthprovider.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, oauthprovider.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, oauthprovider.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, oauthprovider.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, oauthprovider.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, oauthprovider.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, oauthprovider.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, oauthprovider.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, oauthprovider.FieldName)
	}
	if m.client_id != nil {
		fields = append(fields, oauthprovider.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthprovider.FieldClientSecret)
	}
	if m.redirect_url != nil {
		fields = append(fields, oauthprovider.FieldRedirectURL)
	}
	if m.scopes != nil {
		fields = append(fields, oauthprovider.FieldScopes)
	}
	if m.auth_url != nil {
		fields = append(fields, oauthprovider.FieldAuthURL)
	}
	if m.token_url != nil {
		fields = append(fields, oauthprovider.FieldTokenURL)
	}
	if m.auth_style != nil {
		fields = append(fields, oauthprovider.FieldAuthStyle)
	}
	if m.info_url != nil {
		fields = append(fields, oauthprovider.FieldInfoURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OauthProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthprovider.FieldCreatedAt:
		return m.CreatedAt()
	case oauthprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthprovider.FieldCreatedBy:
		return m.CreatedBy()
	case oauthprovider.FieldUpdatedBy:
		return m.UpdatedBy()
	case oauthprovider.FieldMappingID:
		return m.MappingID()
	case oauthprovider.FieldTags:
		return m.Tags()
	case oauthprovider.FieldDeletedAt:
		return m.DeletedAt()
	case oauthprovider.FieldDeletedBy:
		return m.DeletedBy()
	case oauthprovider.FieldOwnerID:
		return m.OwnerID()
	case oauthprovider.FieldName:
		return m.Name()
	case oauthprovider.FieldClientID:
		return m.ClientID()
	case oauthprovider.FieldClientSecret:
		return m.ClientSecret()
	case oauthprovider.FieldRedirectURL:
		return m.RedirectURL()
	case oauthprovider.FieldScopes:
		return m.Scopes()
	case oauthprovider.FieldAuthURL:
		return m.AuthURL()
	case oauthprovider.FieldTokenURL:
		return m.TokenURL()
	case oauthprovider.FieldAuthStyle:
		return m.AuthStyle()
	case oauthprovider.FieldInfoURL:
		return m.InfoURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OauthProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthprovider.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case oauthprovider.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case oauthprovider.FieldMappingID:
		return m.OldMappingID(ctx)
	case oauthprovider.FieldTags:
		return m.OldTags(ctx)
	case oauthprovider.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case oauthprovider.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case oauthprovider.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case oauthprovider.FieldName:
		return m.OldName(ctx)
	case oauthprovider.FieldClientID:
		return m.OldClientID(ctx)
	case oauthprovider.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthprovider.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	case oauthprovider.FieldScopes:
		return m.OldScopes(ctx)
	case oauthprovider.FieldAuthURL:
		return m.OldAuthURL(ctx)
	case oauthprovider.FieldTokenURL:
		return m.OldTokenURL(ctx)
	case oauthprovider.FieldAuthStyle:
		return m.OldAuthStyle(ctx)
	case oauthprovider.FieldInfoURL:
		return m.OldInfoURL(ctx)
	}
	return nil, fmt.Errorf("unknown OauthProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthprovider.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case oauthprovider.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case oauthprovider.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case oauthprovider.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case oauthprovider.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case oauthprovider.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case oauthprovider.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case oauthprovider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauthprovider.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthprovider.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthprovider.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	case oauthprovider.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case oauthprovider.FieldAuthURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthURL(v)
		return nil
	case oauthprovider.FieldTokenURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenURL(v)
		return nil
	case oauthprovider.FieldAuthStyle:
		v, ok := value.(customtypes.Uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthStyle(v)
		return nil
	case oauthprovider.FieldInfoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfoURL(v)
		return nil
	}
	return fmt.Errorf("unknown OauthProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OauthProviderMutation) AddedFields() []string {
	var fields []string
	if m.addauth_style != nil {
		fields = append(fields, oauthprovider.FieldAuthStyle)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OauthProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthprovider.FieldAuthStyle:
		return m.AddedAuthStyle()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthprovider.FieldAuthStyle:
		v, ok := value.(customtypes.Uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthStyle(v)
		return nil
	}
	return fmt.Errorf("unknown OauthProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OauthProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthprovider.FieldCreatedAt) {
		fields = append(fields, oauthprovider.FieldCreatedAt)
	}
	if m.FieldCleared(oauthprovider.FieldUpdatedAt) {
		fields = append(fields, oauthprovider.FieldUpdatedAt)
	}
	if m.FieldCleared(oauthprovider.FieldCreatedBy) {
		fields = append(fields, oauthprovider.FieldCreatedBy)
	}
	if m.FieldCleared(oauthprovider.FieldUpdatedBy) {
		fields = append(fields, oauthprovider.FieldUpdatedBy)
	}
	if m.FieldCleared(oauthprovider.FieldTags) {
		fields = append(fields, oauthprovider.FieldTags)
	}
	if m.FieldCleared(oauthprovider.FieldDeletedAt) {
		fields = append(fields, oauthprovider.FieldDeletedAt)
	}
	if m.FieldCleared(oauthprovider.FieldDeletedBy) {
		fields = append(fields, oauthprovider.FieldDeletedBy)
	}
	if m.FieldCleared(oauthprovider.FieldOwnerID) {
		fields = append(fields, oauthprovider.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OauthProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthProviderMutation) ClearField(name string) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case oauthprovider.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case oauthprovider.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case oauthprovider.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case oauthprovider.FieldTags:
		m.ClearTags()
		return nil
	case oauthprovider.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case oauthprovider.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case oauthprovider.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OauthProviderMutation) ResetField(name string) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthprovider.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case oauthprovider.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case oauthprovider.FieldMappingID:
		m.ResetMappingID()
		return nil
	case oauthprovider.FieldTags:
		m.ResetTags()
		return nil
	case oauthprovider.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case oauthprovider.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case oauthprovider.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case oauthprovider.FieldName:
		m.ResetName()
		return nil
	case oauthprovider.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthprovider.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthprovider.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	case oauthprovider.FieldScopes:
		m.ResetScopes()
		return nil
	case oauthprovider.FieldAuthURL:
		m.ResetAuthURL()
		return nil
	case oauthprovider.FieldTokenURL:
		m.ResetTokenURL()
		return nil
	case oauthprovider.FieldAuthStyle:
		m.ResetAuthStyle()
		return nil
	case oauthprovider.FieldInfoURL:
		m.ResetInfoURL()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OauthProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, oauthprovider.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OauthProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthprovider.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OauthProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OauthProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OauthProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, oauthprovider.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OauthProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthprovider.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OauthProviderMutation) ClearEdge(name string) error {
	switch name {
	case oauthprovider.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OauthProviderMutation) ResetEdge(name string) error {
	switch name {
	case oauthprovider.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider edge %s", name)
}

// OauthProviderHistoryMutation represents an operation that mutates the OauthProviderHistory nodes in the graph.
type OauthProviderHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	deleted_at    *time.Time
	deleted_by    *string
	owner_id      *string
	name          *string
	client_id     *string
	client_secret *string
	redirect_url  *string
	scopes        *string
	auth_url      *string
	token_url     *string
	auth_style    *customtypes.Uint8
	addauth_style *customtypes.Uint8
	info_url      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OauthProviderHistory, error)
	predicates    []predicate.OauthProviderHistory
}

var _ ent.Mutation = (*OauthProviderHistoryMutation)(nil)

// oauthproviderhistoryOption allows management of the mutation configuration using functional options.
type oauthproviderhistoryOption func(*OauthProviderHistoryMutation)

// newOauthProviderHistoryMutation creates new mutation for the OauthProviderHistory entity.
func newOauthProviderHistoryMutation(c config, op Op, opts ...oauthproviderhistoryOption) *OauthProviderHistoryMutation {
	m := &OauthProviderHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOauthProviderHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthProviderHistoryID sets the ID field of the mutation.
func withOauthProviderHistoryID(id string) oauthproviderhistoryOption {
	return func(m *OauthProviderHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OauthProviderHistory
		)
		m.oldValue = func(ctx context.Context) (*OauthProviderHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OauthProviderHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauthProviderHistory sets the old OauthProviderHistory of the mutation.
func withOauthProviderHistory(node *OauthProviderHistory) oauthproviderhistoryOption {
	return func(m *OauthProviderHistoryMutation) {
		m.oldValue = func(context.Context) (*OauthProviderHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthProviderHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthProviderHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OauthProviderHistory entities.
func (m *OauthProviderHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OauthProviderHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OauthProviderHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OauthProviderHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *OauthProviderHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *OauthProviderHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *OauthProviderHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *OauthProviderHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *OauthProviderHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *OauthProviderHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[oauthproviderhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *OauthProviderHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, oauthproviderhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *OauthProviderHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *OauthProviderHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *OauthProviderHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OauthProviderHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OauthProviderHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OauthProviderHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[oauthproviderhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OauthProviderHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, oauthproviderhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OauthProviderHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OauthProviderHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OauthProviderHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[oauthproviderhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OauthProviderHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, oauthproviderhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OauthProviderHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OauthProviderHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OauthProviderHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[oauthproviderhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OauthProviderHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, oauthproviderhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OauthProviderHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OauthProviderHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OauthProviderHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[oauthproviderhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OauthProviderHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, oauthproviderhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *OauthProviderHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OauthProviderHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OauthProviderHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *OauthProviderHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OauthProviderHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OauthProviderHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OauthProviderHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OauthProviderHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[oauthproviderhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OauthProviderHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, oauthproviderhistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OauthProviderHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OauthProviderHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OauthProviderHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[oauthproviderhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OauthProviderHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, oauthproviderhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OauthProviderHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OauthProviderHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OauthProviderHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[oauthproviderhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OauthProviderHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, oauthproviderhistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *OauthProviderHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OauthProviderHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *OauthProviderHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[oauthproviderhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *OauthProviderHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[oauthproviderhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OauthProviderHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, oauthproviderhistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *OauthProviderHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OauthProviderHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OauthProviderHistoryMutation) ResetName() {
	m.name = nil
}

// SetClientID sets the "client_id" field.
func (m *OauthProviderHistoryMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OauthProviderHistoryMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OauthProviderHistoryMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *OauthProviderHistoryMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OauthProviderHistoryMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OauthProviderHistoryMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetRedirectURL sets the "redirect_url" field.
func (m *OauthProviderHistoryMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *OauthProviderHistoryMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *OauthProviderHistoryMutation) ResetRedirectURL() {
	m.redirect_url = nil
}

// SetScopes sets the "scopes" field.
func (m *OauthProviderHistoryMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *OauthProviderHistoryMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ResetScopes resets all changes to the "scopes" field.
func (m *OauthProviderHistoryMutation) ResetScopes() {
	m.scopes = nil
}

// SetAuthURL sets the "auth_url" field.
func (m *OauthProviderHistoryMutation) SetAuthURL(s string) {
	m.auth_url = &s
}

// AuthURL returns the value of the "auth_url" field in the mutation.
func (m *OauthProviderHistoryMutation) AuthURL() (r string, exists bool) {
	v := m.auth_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthURL returns the old "auth_url" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldAuthURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthURL: %w", err)
	}
	return oldValue.AuthURL, nil
}

// ResetAuthURL resets all changes to the "auth_url" field.
func (m *OauthProviderHistoryMutation) ResetAuthURL() {
	m.auth_url = nil
}

// SetTokenURL sets the "token_url" field.
func (m *OauthProviderHistoryMutation) SetTokenURL(s string) {
	m.token_url = &s
}

// TokenURL returns the value of the "token_url" field in the mutation.
func (m *OauthProviderHistoryMutation) TokenURL() (r string, exists bool) {
	v := m.token_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenURL returns the old "token_url" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldTokenURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenURL: %w", err)
	}
	return oldValue.TokenURL, nil
}

// ResetTokenURL resets all changes to the "token_url" field.
func (m *OauthProviderHistoryMutation) ResetTokenURL() {
	m.token_url = nil
}

// SetAuthStyle sets the "auth_style" field.
func (m *OauthProviderHistoryMutation) SetAuthStyle(c customtypes.Uint8) {
	m.auth_style = &c
	m.addauth_style = nil
}

// AuthStyle returns the value of the "auth_style" field in the mutation.
func (m *OauthProviderHistoryMutation) AuthStyle() (r customtypes.Uint8, exists bool) {
	v := m.auth_style
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthStyle returns the old "auth_style" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldAuthStyle(ctx context.Context) (v customtypes.Uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthStyle: %w", err)
	}
	return oldValue.AuthStyle, nil
}

// AddAuthStyle adds c to the "auth_style" field.
func (m *OauthProviderHistoryMutation) AddAuthStyle(c customtypes.Uint8) {
	if m.addauth_style != nil {
		*m.addauth_style += c
	} else {
		m.addauth_style = &c
	}
}

// AddedAuthStyle returns the value that was added to the "auth_style" field in this mutation.
func (m *OauthProviderHistoryMutation) AddedAuthStyle() (r customtypes.Uint8, exists bool) {
	v := m.addauth_style
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthStyle resets all changes to the "auth_style" field.
func (m *OauthProviderHistoryMutation) ResetAuthStyle() {
	m.auth_style = nil
	m.addauth_style = nil
}

// SetInfoURL sets the "info_url" field.
func (m *OauthProviderHistoryMutation) SetInfoURL(s string) {
	m.info_url = &s
}

// InfoURL returns the value of the "info_url" field in the mutation.
func (m *OauthProviderHistoryMutation) InfoURL() (r string, exists bool) {
	v := m.info_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInfoURL returns the old "info_url" field's value of the OauthProviderHistory entity.
// If the OauthProviderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderHistoryMutation) OldInfoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfoURL: %w", err)
	}
	return oldValue.InfoURL, nil
}

// ResetInfoURL resets all changes to the "info_url" field.
func (m *OauthProviderHistoryMutation) ResetInfoURL() {
	m.info_url = nil
}

// Where appends a list predicates to the OauthProviderHistoryMutation builder.
func (m *OauthProviderHistoryMutation) Where(ps ...predicate.OauthProviderHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OauthProviderHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OauthProviderHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OauthProviderHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OauthProviderHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OauthProviderHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OauthProviderHistory).
func (m *OauthProviderHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OauthProviderHistoryMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.history_time != nil {
		fields = append(fields, oauthproviderhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, oauthproviderhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, oauthproviderhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, oauthproviderhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthproviderhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, oauthproviderhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, oauthproviderhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, oauthproviderhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, oauthproviderhistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, oauthproviderhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, oauthproviderhistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, oauthproviderhistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, oauthproviderhistory.FieldName)
	}
	if m.client_id != nil {
		fields = append(fields, oauthproviderhistory.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthproviderhistory.FieldClientSecret)
	}
	if m.redirect_url != nil {
		fields = append(fields, oauthproviderhistory.FieldRedirectURL)
	}
	if m.scopes != nil {
		fields = append(fields, oauthproviderhistory.FieldScopes)
	}
	if m.auth_url != nil {
		fields = append(fields, oauthproviderhistory.FieldAuthURL)
	}
	if m.token_url != nil {
		fields = append(fields, oauthproviderhistory.FieldTokenURL)
	}
	if m.auth_style != nil {
		fields = append(fields, oauthproviderhistory.FieldAuthStyle)
	}
	if m.info_url != nil {
		fields = append(fields, oauthproviderhistory.FieldInfoURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OauthProviderHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthproviderhistory.FieldHistoryTime:
		return m.HistoryTime()
	case oauthproviderhistory.FieldRef:
		return m.Ref()
	case oauthproviderhistory.FieldOperation:
		return m.Operation()
	case oauthproviderhistory.FieldCreatedAt:
		return m.CreatedAt()
	case oauthproviderhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthproviderhistory.FieldCreatedBy:
		return m.CreatedBy()
	case oauthproviderhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case oauthproviderhistory.FieldMappingID:
		return m.MappingID()
	case oauthproviderhistory.FieldTags:
		return m.Tags()
	case oauthproviderhistory.FieldDeletedAt:
		return m.DeletedAt()
	case oauthproviderhistory.FieldDeletedBy:
		return m.DeletedBy()
	case oauthproviderhistory.FieldOwnerID:
		return m.OwnerID()
	case oauthproviderhistory.FieldName:
		return m.Name()
	case oauthproviderhistory.FieldClientID:
		return m.ClientID()
	case oauthproviderhistory.FieldClientSecret:
		return m.ClientSecret()
	case oauthproviderhistory.FieldRedirectURL:
		return m.RedirectURL()
	case oauthproviderhistory.FieldScopes:
		return m.Scopes()
	case oauthproviderhistory.FieldAuthURL:
		return m.AuthURL()
	case oauthproviderhistory.FieldTokenURL:
		return m.TokenURL()
	case oauthproviderhistory.FieldAuthStyle:
		return m.AuthStyle()
	case oauthproviderhistory.FieldInfoURL:
		return m.InfoURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OauthProviderHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthproviderhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case oauthproviderhistory.FieldRef:
		return m.OldRef(ctx)
	case oauthproviderhistory.FieldOperation:
		return m.OldOperation(ctx)
	case oauthproviderhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthproviderhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthproviderhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case oauthproviderhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case oauthproviderhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case oauthproviderhistory.FieldTags:
		return m.OldTags(ctx)
	case oauthproviderhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case oauthproviderhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case oauthproviderhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case oauthproviderhistory.FieldName:
		return m.OldName(ctx)
	case oauthproviderhistory.FieldClientID:
		return m.OldClientID(ctx)
	case oauthproviderhistory.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthproviderhistory.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	case oauthproviderhistory.FieldScopes:
		return m.OldScopes(ctx)
	case oauthproviderhistory.FieldAuthURL:
		return m.OldAuthURL(ctx)
	case oauthproviderhistory.FieldTokenURL:
		return m.OldTokenURL(ctx)
	case oauthproviderhistory.FieldAuthStyle:
		return m.OldAuthStyle(ctx)
	case oauthproviderhistory.FieldInfoURL:
		return m.OldInfoURL(ctx)
	}
	return nil, fmt.Errorf("unknown OauthProviderHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthProviderHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthproviderhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case oauthproviderhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case oauthproviderhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case oauthproviderhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthproviderhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthproviderhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case oauthproviderhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case oauthproviderhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case oauthproviderhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case oauthproviderhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case oauthproviderhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case oauthproviderhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case oauthproviderhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauthproviderhistory.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthproviderhistory.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthproviderhistory.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	case oauthproviderhistory.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case oauthproviderhistory.FieldAuthURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthURL(v)
		return nil
	case oauthproviderhistory.FieldTokenURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenURL(v)
		return nil
	case oauthproviderhistory.FieldAuthStyle:
		v, ok := value.(customtypes.Uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthStyle(v)
		return nil
	case oauthproviderhistory.FieldInfoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfoURL(v)
		return nil
	}
	return fmt.Errorf("unknown OauthProviderHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OauthProviderHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addauth_style != nil {
		fields = append(fields, oauthproviderhistory.FieldAuthStyle)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OauthProviderHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthproviderhistory.FieldAuthStyle:
		return m.AddedAuthStyle()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthProviderHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthproviderhistory.FieldAuthStyle:
		v, ok := value.(customtypes.Uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthStyle(v)
		return nil
	}
	return fmt.Errorf("unknown OauthProviderHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OauthProviderHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthproviderhistory.FieldRef) {
		fields = append(fields, oauthproviderhistory.FieldRef)
	}
	if m.FieldCleared(oauthproviderhistory.FieldCreatedAt) {
		fields = append(fields, oauthproviderhistory.FieldCreatedAt)
	}
	if m.FieldCleared(oauthproviderhistory.FieldUpdatedAt) {
		fields = append(fields, oauthproviderhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(oauthproviderhistory.FieldCreatedBy) {
		fields = append(fields, oauthproviderhistory.FieldCreatedBy)
	}
	if m.FieldCleared(oauthproviderhistory.FieldUpdatedBy) {
		fields = append(fields, oauthproviderhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(oauthproviderhistory.FieldTags) {
		fields = append(fields, oauthproviderhistory.FieldTags)
	}
	if m.FieldCleared(oauthproviderhistory.FieldDeletedAt) {
		fields = append(fields, oauthproviderhistory.FieldDeletedAt)
	}
	if m.FieldCleared(oauthproviderhistory.FieldDeletedBy) {
		fields = append(fields, oauthproviderhistory.FieldDeletedBy)
	}
	if m.FieldCleared(oauthproviderhistory.FieldOwnerID) {
		fields = append(fields, oauthproviderhistory.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OauthProviderHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthProviderHistoryMutation) ClearField(name string) error {
	switch name {
	case oauthproviderhistory.FieldRef:
		m.ClearRef()
		return nil
	case oauthproviderhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case oauthproviderhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case oauthproviderhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case oauthproviderhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case oauthproviderhistory.FieldTags:
		m.ClearTags()
		return nil
	case oauthproviderhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case oauthproviderhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case oauthproviderhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown OauthProviderHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OauthProviderHistoryMutation) ResetField(name string) error {
	switch name {
	case oauthproviderhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case oauthproviderhistory.FieldRef:
		m.ResetRef()
		return nil
	case oauthproviderhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case oauthproviderhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthproviderhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthproviderhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case oauthproviderhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case oauthproviderhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case oauthproviderhistory.FieldTags:
		m.ResetTags()
		return nil
	case oauthproviderhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case oauthproviderhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case oauthproviderhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case oauthproviderhistory.FieldName:
		m.ResetName()
		return nil
	case oauthproviderhistory.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthproviderhistory.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthproviderhistory.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	case oauthproviderhistory.FieldScopes:
		m.ResetScopes()
		return nil
	case oauthproviderhistory.FieldAuthURL:
		m.ResetAuthURL()
		return nil
	case oauthproviderhistory.FieldTokenURL:
		m.ResetTokenURL()
		return nil
	case oauthproviderhistory.FieldAuthStyle:
		m.ResetAuthStyle()
		return nil
	case oauthproviderhistory.FieldInfoURL:
		m.ResetInfoURL()
		return nil
	}
	return fmt.Errorf("unknown OauthProviderHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OauthProviderHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OauthProviderHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OauthProviderHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OauthProviderHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OauthProviderHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OauthProviderHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OauthProviderHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OauthProviderHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OauthProviderHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OauthProviderHistory edge %s", name)
}

// OhAuthTooTokenMutation represents an operation that mutates the OhAuthTooToken nodes in the graph.
type OhAuthTooTokenMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	mapping_id                *string
	tags                      *[]string
	appendtags                []string
	client_id                 *string
	scopes                    *[]string
	appendscopes              []string
	nonce                     *string
	claims_user_id            *string
	claims_username           *string
	claims_email              *string
	claims_email_verified     *bool
	claims_groups             *[]string
	appendclaims_groups       []string
	claims_preferred_username *string
	connector_id              *string
	connector_data            *[]string
	appendconnector_data      []string
	last_used                 *time.Time
	clearedFields             map[string]struct{}
	integration               map[string]struct{}
	removedintegration        map[string]struct{}
	clearedintegration        bool
	events                    map[string]struct{}
	removedevents             map[string]struct{}
	clearedevents             bool
	done                      bool
	oldValue                  func(context.Context) (*OhAuthTooToken, error)
	predicates                []predicate.OhAuthTooToken
}

var _ ent.Mutation = (*OhAuthTooTokenMutation)(nil)

// ohauthtootokenOption allows management of the mutation configuration using functional options.
type ohauthtootokenOption func(*OhAuthTooTokenMutation)

// newOhAuthTooTokenMutation creates new mutation for the OhAuthTooToken entity.
func newOhAuthTooTokenMutation(c config, op Op, opts ...ohauthtootokenOption) *OhAuthTooTokenMutation {
	m := &OhAuthTooTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeOhAuthTooToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOhAuthTooTokenID sets the ID field of the mutation.
func withOhAuthTooTokenID(id string) ohauthtootokenOption {
	return func(m *OhAuthTooTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *OhAuthTooToken
		)
		m.oldValue = func(ctx context.Context) (*OhAuthTooToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OhAuthTooToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOhAuthTooToken sets the old OhAuthTooToken of the mutation.
func withOhAuthTooToken(node *OhAuthTooToken) ohauthtootokenOption {
	return func(m *OhAuthTooTokenMutation) {
		m.oldValue = func(context.Context) (*OhAuthTooToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OhAuthTooTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OhAuthTooTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OhAuthTooToken entities.
func (m *OhAuthTooTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OhAuthTooTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OhAuthTooTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OhAuthTooToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMappingID sets the "mapping_id" field.
func (m *OhAuthTooTokenMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OhAuthTooTokenMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OhAuthTooTokenMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *OhAuthTooTokenMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OhAuthTooTokenMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OhAuthTooTokenMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OhAuthTooTokenMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OhAuthTooTokenMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[ohauthtootoken.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OhAuthTooTokenMutation) TagsCleared() bool {
	_, ok := m.clearedFields[ohauthtootoken.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OhAuthTooTokenMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, ohauthtootoken.FieldTags)
}

// SetClientID sets the "client_id" field.
func (m *OhAuthTooTokenMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OhAuthTooTokenMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OhAuthTooTokenMutation) ResetClientID() {
	m.client_id = nil
}

// SetScopes sets the "scopes" field.
func (m *OhAuthTooTokenMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *OhAuthTooTokenMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *OhAuthTooTokenMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *OhAuthTooTokenMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *OhAuthTooTokenMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[ohauthtootoken.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *OhAuthTooTokenMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[ohauthtootoken.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *OhAuthTooTokenMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, ohauthtootoken.FieldScopes)
}

// SetNonce sets the "nonce" field.
func (m *OhAuthTooTokenMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *OhAuthTooTokenMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *OhAuthTooTokenMutation) ResetNonce() {
	m.nonce = nil
}

// SetClaimsUserID sets the "claims_user_id" field.
func (m *OhAuthTooTokenMutation) SetClaimsUserID(s string) {
	m.claims_user_id = &s
}

// ClaimsUserID returns the value of the "claims_user_id" field in the mutation.
func (m *OhAuthTooTokenMutation) ClaimsUserID() (r string, exists bool) {
	v := m.claims_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsUserID returns the old "claims_user_id" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldClaimsUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsUserID: %w", err)
	}
	return oldValue.ClaimsUserID, nil
}

// ResetClaimsUserID resets all changes to the "claims_user_id" field.
func (m *OhAuthTooTokenMutation) ResetClaimsUserID() {
	m.claims_user_id = nil
}

// SetClaimsUsername sets the "claims_username" field.
func (m *OhAuthTooTokenMutation) SetClaimsUsername(s string) {
	m.claims_username = &s
}

// ClaimsUsername returns the value of the "claims_username" field in the mutation.
func (m *OhAuthTooTokenMutation) ClaimsUsername() (r string, exists bool) {
	v := m.claims_username
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsUsername returns the old "claims_username" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldClaimsUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsUsername: %w", err)
	}
	return oldValue.ClaimsUsername, nil
}

// ResetClaimsUsername resets all changes to the "claims_username" field.
func (m *OhAuthTooTokenMutation) ResetClaimsUsername() {
	m.claims_username = nil
}

// SetClaimsEmail sets the "claims_email" field.
func (m *OhAuthTooTokenMutation) SetClaimsEmail(s string) {
	m.claims_email = &s
}

// ClaimsEmail returns the value of the "claims_email" field in the mutation.
func (m *OhAuthTooTokenMutation) ClaimsEmail() (r string, exists bool) {
	v := m.claims_email
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsEmail returns the old "claims_email" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldClaimsEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsEmail: %w", err)
	}
	return oldValue.ClaimsEmail, nil
}

// ResetClaimsEmail resets all changes to the "claims_email" field.
func (m *OhAuthTooTokenMutation) ResetClaimsEmail() {
	m.claims_email = nil
}

// SetClaimsEmailVerified sets the "claims_email_verified" field.
func (m *OhAuthTooTokenMutation) SetClaimsEmailVerified(b bool) {
	m.claims_email_verified = &b
}

// ClaimsEmailVerified returns the value of the "claims_email_verified" field in the mutation.
func (m *OhAuthTooTokenMutation) ClaimsEmailVerified() (r bool, exists bool) {
	v := m.claims_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsEmailVerified returns the old "claims_email_verified" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldClaimsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsEmailVerified: %w", err)
	}
	return oldValue.ClaimsEmailVerified, nil
}

// ResetClaimsEmailVerified resets all changes to the "claims_email_verified" field.
func (m *OhAuthTooTokenMutation) ResetClaimsEmailVerified() {
	m.claims_email_verified = nil
}

// SetClaimsGroups sets the "claims_groups" field.
func (m *OhAuthTooTokenMutation) SetClaimsGroups(s []string) {
	m.claims_groups = &s
	m.appendclaims_groups = nil
}

// ClaimsGroups returns the value of the "claims_groups" field in the mutation.
func (m *OhAuthTooTokenMutation) ClaimsGroups() (r []string, exists bool) {
	v := m.claims_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsGroups returns the old "claims_groups" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldClaimsGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsGroups: %w", err)
	}
	return oldValue.ClaimsGroups, nil
}

// AppendClaimsGroups adds s to the "claims_groups" field.
func (m *OhAuthTooTokenMutation) AppendClaimsGroups(s []string) {
	m.appendclaims_groups = append(m.appendclaims_groups, s...)
}

// AppendedClaimsGroups returns the list of values that were appended to the "claims_groups" field in this mutation.
func (m *OhAuthTooTokenMutation) AppendedClaimsGroups() ([]string, bool) {
	if len(m.appendclaims_groups) == 0 {
		return nil, false
	}
	return m.appendclaims_groups, true
}

// ClearClaimsGroups clears the value of the "claims_groups" field.
func (m *OhAuthTooTokenMutation) ClearClaimsGroups() {
	m.claims_groups = nil
	m.appendclaims_groups = nil
	m.clearedFields[ohauthtootoken.FieldClaimsGroups] = struct{}{}
}

// ClaimsGroupsCleared returns if the "claims_groups" field was cleared in this mutation.
func (m *OhAuthTooTokenMutation) ClaimsGroupsCleared() bool {
	_, ok := m.clearedFields[ohauthtootoken.FieldClaimsGroups]
	return ok
}

// ResetClaimsGroups resets all changes to the "claims_groups" field.
func (m *OhAuthTooTokenMutation) ResetClaimsGroups() {
	m.claims_groups = nil
	m.appendclaims_groups = nil
	delete(m.clearedFields, ohauthtootoken.FieldClaimsGroups)
}

// SetClaimsPreferredUsername sets the "claims_preferred_username" field.
func (m *OhAuthTooTokenMutation) SetClaimsPreferredUsername(s string) {
	m.claims_preferred_username = &s
}

// ClaimsPreferredUsername returns the value of the "claims_preferred_username" field in the mutation.
func (m *OhAuthTooTokenMutation) ClaimsPreferredUsername() (r string, exists bool) {
	v := m.claims_preferred_username
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimsPreferredUsername returns the old "claims_preferred_username" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldClaimsPreferredUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimsPreferredUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimsPreferredUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimsPreferredUsername: %w", err)
	}
	return oldValue.ClaimsPreferredUsername, nil
}

// ResetClaimsPreferredUsername resets all changes to the "claims_preferred_username" field.
func (m *OhAuthTooTokenMutation) ResetClaimsPreferredUsername() {
	m.claims_preferred_username = nil
}

// SetConnectorID sets the "connector_id" field.
func (m *OhAuthTooTokenMutation) SetConnectorID(s string) {
	m.connector_id = &s
}

// ConnectorID returns the value of the "connector_id" field in the mutation.
func (m *OhAuthTooTokenMutation) ConnectorID() (r string, exists bool) {
	v := m.connector_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorID returns the old "connector_id" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldConnectorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorID: %w", err)
	}
	return oldValue.ConnectorID, nil
}

// ResetConnectorID resets all changes to the "connector_id" field.
func (m *OhAuthTooTokenMutation) ResetConnectorID() {
	m.connector_id = nil
}

// SetConnectorData sets the "connector_data" field.
func (m *OhAuthTooTokenMutation) SetConnectorData(s []string) {
	m.connector_data = &s
	m.appendconnector_data = nil
}

// ConnectorData returns the value of the "connector_data" field in the mutation.
func (m *OhAuthTooTokenMutation) ConnectorData() (r []string, exists bool) {
	v := m.connector_data
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorData returns the old "connector_data" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldConnectorData(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorData: %w", err)
	}
	return oldValue.ConnectorData, nil
}

// AppendConnectorData adds s to the "connector_data" field.
func (m *OhAuthTooTokenMutation) AppendConnectorData(s []string) {
	m.appendconnector_data = append(m.appendconnector_data, s...)
}

// AppendedConnectorData returns the list of values that were appended to the "connector_data" field in this mutation.
func (m *OhAuthTooTokenMutation) AppendedConnectorData() ([]string, bool) {
	if len(m.appendconnector_data) == 0 {
		return nil, false
	}
	return m.appendconnector_data, true
}

// ClearConnectorData clears the value of the "connector_data" field.
func (m *OhAuthTooTokenMutation) ClearConnectorData() {
	m.connector_data = nil
	m.appendconnector_data = nil
	m.clearedFields[ohauthtootoken.FieldConnectorData] = struct{}{}
}

// ConnectorDataCleared returns if the "connector_data" field was cleared in this mutation.
func (m *OhAuthTooTokenMutation) ConnectorDataCleared() bool {
	_, ok := m.clearedFields[ohauthtootoken.FieldConnectorData]
	return ok
}

// ResetConnectorData resets all changes to the "connector_data" field.
func (m *OhAuthTooTokenMutation) ResetConnectorData() {
	m.connector_data = nil
	m.appendconnector_data = nil
	delete(m.clearedFields, ohauthtootoken.FieldConnectorData)
}

// SetLastUsed sets the "last_used" field.
func (m *OhAuthTooTokenMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *OhAuthTooTokenMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the OhAuthTooToken entity.
// If the OhAuthTooToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OhAuthTooTokenMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *OhAuthTooTokenMutation) ResetLastUsed() {
	m.last_used = nil
}

// AddIntegrationIDs adds the "integration" edge to the Integration entity by ids.
func (m *OhAuthTooTokenMutation) AddIntegrationIDs(ids ...string) {
	if m.integration == nil {
		m.integration = make(map[string]struct{})
	}
	for i := range ids {
		m.integration[ids[i]] = struct{}{}
	}
}

// ClearIntegration clears the "integration" edge to the Integration entity.
func (m *OhAuthTooTokenMutation) ClearIntegration() {
	m.clearedintegration = true
}

// IntegrationCleared reports if the "integration" edge to the Integration entity was cleared.
func (m *OhAuthTooTokenMutation) IntegrationCleared() bool {
	return m.clearedintegration
}

// RemoveIntegrationIDs removes the "integration" edge to the Integration entity by IDs.
func (m *OhAuthTooTokenMutation) RemoveIntegrationIDs(ids ...string) {
	if m.removedintegration == nil {
		m.removedintegration = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.integration, ids[i])
		m.removedintegration[ids[i]] = struct{}{}
	}
}

// RemovedIntegration returns the removed IDs of the "integration" edge to the Integration entity.
func (m *OhAuthTooTokenMutation) RemovedIntegrationIDs() (ids []string) {
	for id := range m.removedintegration {
		ids = append(ids, id)
	}
	return
}

// IntegrationIDs returns the "integration" edge IDs in the mutation.
func (m *OhAuthTooTokenMutation) IntegrationIDs() (ids []string) {
	for id := range m.integration {
		ids = append(ids, id)
	}
	return
}

// ResetIntegration resets all changes to the "integration" edge.
func (m *OhAuthTooTokenMutation) ResetIntegration() {
	m.integration = nil
	m.clearedintegration = false
	m.removedintegration = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *OhAuthTooTokenMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *OhAuthTooTokenMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *OhAuthTooTokenMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *OhAuthTooTokenMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *OhAuthTooTokenMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *OhAuthTooTokenMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *OhAuthTooTokenMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the OhAuthTooTokenMutation builder.
func (m *OhAuthTooTokenMutation) Where(ps ...predicate.OhAuthTooToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OhAuthTooTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OhAuthTooTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OhAuthTooToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OhAuthTooTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OhAuthTooTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OhAuthTooToken).
func (m *OhAuthTooTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OhAuthTooTokenMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.mapping_id != nil {
		fields = append(fields, ohauthtootoken.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, ohauthtootoken.FieldTags)
	}
	if m.client_id != nil {
		fields = append(fields, ohauthtootoken.FieldClientID)
	}
	if m.scopes != nil {
		fields = append(fields, ohauthtootoken.FieldScopes)
	}
	if m.nonce != nil {
		fields = append(fields, ohauthtootoken.FieldNonce)
	}
	if m.claims_user_id != nil {
		fields = append(fields, ohauthtootoken.FieldClaimsUserID)
	}
	if m.claims_username != nil {
		fields = append(fields, ohauthtootoken.FieldClaimsUsername)
	}
	if m.claims_email != nil {
		fields = append(fields, ohauthtootoken.FieldClaimsEmail)
	}
	if m.claims_email_verified != nil {
		fields = append(fields, ohauthtootoken.FieldClaimsEmailVerified)
	}
	if m.claims_groups != nil {
		fields = append(fields, ohauthtootoken.FieldClaimsGroups)
	}
	if m.claims_preferred_username != nil {
		fields = append(fields, ohauthtootoken.FieldClaimsPreferredUsername)
	}
	if m.connector_id != nil {
		fields = append(fields, ohauthtootoken.FieldConnectorID)
	}
	if m.connector_data != nil {
		fields = append(fields, ohauthtootoken.FieldConnectorData)
	}
	if m.last_used != nil {
		fields = append(fields, ohauthtootoken.FieldLastUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OhAuthTooTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ohauthtootoken.FieldMappingID:
		return m.MappingID()
	case ohauthtootoken.FieldTags:
		return m.Tags()
	case ohauthtootoken.FieldClientID:
		return m.ClientID()
	case ohauthtootoken.FieldScopes:
		return m.Scopes()
	case ohauthtootoken.FieldNonce:
		return m.Nonce()
	case ohauthtootoken.FieldClaimsUserID:
		return m.ClaimsUserID()
	case ohauthtootoken.FieldClaimsUsername:
		return m.ClaimsUsername()
	case ohauthtootoken.FieldClaimsEmail:
		return m.ClaimsEmail()
	case ohauthtootoken.FieldClaimsEmailVerified:
		return m.ClaimsEmailVerified()
	case ohauthtootoken.FieldClaimsGroups:
		return m.ClaimsGroups()
	case ohauthtootoken.FieldClaimsPreferredUsername:
		return m.ClaimsPreferredUsername()
	case ohauthtootoken.FieldConnectorID:
		return m.ConnectorID()
	case ohauthtootoken.FieldConnectorData:
		return m.ConnectorData()
	case ohauthtootoken.FieldLastUsed:
		return m.LastUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OhAuthTooTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ohauthtootoken.FieldMappingID:
		return m.OldMappingID(ctx)
	case ohauthtootoken.FieldTags:
		return m.OldTags(ctx)
	case ohauthtootoken.FieldClientID:
		return m.OldClientID(ctx)
	case ohauthtootoken.FieldScopes:
		return m.OldScopes(ctx)
	case ohauthtootoken.FieldNonce:
		return m.OldNonce(ctx)
	case ohauthtootoken.FieldClaimsUserID:
		return m.OldClaimsUserID(ctx)
	case ohauthtootoken.FieldClaimsUsername:
		return m.OldClaimsUsername(ctx)
	case ohauthtootoken.FieldClaimsEmail:
		return m.OldClaimsEmail(ctx)
	case ohauthtootoken.FieldClaimsEmailVerified:
		return m.OldClaimsEmailVerified(ctx)
	case ohauthtootoken.FieldClaimsGroups:
		return m.OldClaimsGroups(ctx)
	case ohauthtootoken.FieldClaimsPreferredUsername:
		return m.OldClaimsPreferredUsername(ctx)
	case ohauthtootoken.FieldConnectorID:
		return m.OldConnectorID(ctx)
	case ohauthtootoken.FieldConnectorData:
		return m.OldConnectorData(ctx)
	case ohauthtootoken.FieldLastUsed:
		return m.OldLastUsed(ctx)
	}
	return nil, fmt.Errorf("unknown OhAuthTooToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OhAuthTooTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ohauthtootoken.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case ohauthtootoken.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case ohauthtootoken.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case ohauthtootoken.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case ohauthtootoken.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case ohauthtootoken.FieldClaimsUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsUserID(v)
		return nil
	case ohauthtootoken.FieldClaimsUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsUsername(v)
		return nil
	case ohauthtootoken.FieldClaimsEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsEmail(v)
		return nil
	case ohauthtootoken.FieldClaimsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsEmailVerified(v)
		return nil
	case ohauthtootoken.FieldClaimsGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsGroups(v)
		return nil
	case ohauthtootoken.FieldClaimsPreferredUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimsPreferredUsername(v)
		return nil
	case ohauthtootoken.FieldConnectorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorID(v)
		return nil
	case ohauthtootoken.FieldConnectorData:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorData(v)
		return nil
	case ohauthtootoken.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	}
	return fmt.Errorf("unknown OhAuthTooToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OhAuthTooTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OhAuthTooTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OhAuthTooTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OhAuthTooToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OhAuthTooTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ohauthtootoken.FieldTags) {
		fields = append(fields, ohauthtootoken.FieldTags)
	}
	if m.FieldCleared(ohauthtootoken.FieldScopes) {
		fields = append(fields, ohauthtootoken.FieldScopes)
	}
	if m.FieldCleared(ohauthtootoken.FieldClaimsGroups) {
		fields = append(fields, ohauthtootoken.FieldClaimsGroups)
	}
	if m.FieldCleared(ohauthtootoken.FieldConnectorData) {
		fields = append(fields, ohauthtootoken.FieldConnectorData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OhAuthTooTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OhAuthTooTokenMutation) ClearField(name string) error {
	switch name {
	case ohauthtootoken.FieldTags:
		m.ClearTags()
		return nil
	case ohauthtootoken.FieldScopes:
		m.ClearScopes()
		return nil
	case ohauthtootoken.FieldClaimsGroups:
		m.ClearClaimsGroups()
		return nil
	case ohauthtootoken.FieldConnectorData:
		m.ClearConnectorData()
		return nil
	}
	return fmt.Errorf("unknown OhAuthTooToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OhAuthTooTokenMutation) ResetField(name string) error {
	switch name {
	case ohauthtootoken.FieldMappingID:
		m.ResetMappingID()
		return nil
	case ohauthtootoken.FieldTags:
		m.ResetTags()
		return nil
	case ohauthtootoken.FieldClientID:
		m.ResetClientID()
		return nil
	case ohauthtootoken.FieldScopes:
		m.ResetScopes()
		return nil
	case ohauthtootoken.FieldNonce:
		m.ResetNonce()
		return nil
	case ohauthtootoken.FieldClaimsUserID:
		m.ResetClaimsUserID()
		return nil
	case ohauthtootoken.FieldClaimsUsername:
		m.ResetClaimsUsername()
		return nil
	case ohauthtootoken.FieldClaimsEmail:
		m.ResetClaimsEmail()
		return nil
	case ohauthtootoken.FieldClaimsEmailVerified:
		m.ResetClaimsEmailVerified()
		return nil
	case ohauthtootoken.FieldClaimsGroups:
		m.ResetClaimsGroups()
		return nil
	case ohauthtootoken.FieldClaimsPreferredUsername:
		m.ResetClaimsPreferredUsername()
		return nil
	case ohauthtootoken.FieldConnectorID:
		m.ResetConnectorID()
		return nil
	case ohauthtootoken.FieldConnectorData:
		m.ResetConnectorData()
		return nil
	case ohauthtootoken.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	}
	return fmt.Errorf("unknown OhAuthTooToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OhAuthTooTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.integration != nil {
		edges = append(edges, ohauthtootoken.EdgeIntegration)
	}
	if m.events != nil {
		edges = append(edges, ohauthtootoken.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OhAuthTooTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ohauthtootoken.EdgeIntegration:
		ids := make([]ent.Value, 0, len(m.integration))
		for id := range m.integration {
			ids = append(ids, id)
		}
		return ids
	case ohauthtootoken.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OhAuthTooTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedintegration != nil {
		edges = append(edges, ohauthtootoken.EdgeIntegration)
	}
	if m.removedevents != nil {
		edges = append(edges, ohauthtootoken.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OhAuthTooTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ohauthtootoken.EdgeIntegration:
		ids := make([]ent.Value, 0, len(m.removedintegration))
		for id := range m.removedintegration {
			ids = append(ids, id)
		}
		return ids
	case ohauthtootoken.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OhAuthTooTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedintegration {
		edges = append(edges, ohauthtootoken.EdgeIntegration)
	}
	if m.clearedevents {
		edges = append(edges, ohauthtootoken.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OhAuthTooTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case ohauthtootoken.EdgeIntegration:
		return m.clearedintegration
	case ohauthtootoken.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OhAuthTooTokenMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OhAuthTooToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OhAuthTooTokenMutation) ResetEdge(name string) error {
	switch name {
	case ohauthtootoken.EdgeIntegration:
		m.ResetIntegration()
		return nil
	case ohauthtootoken.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown OhAuthTooToken edge %s", name)
}

// OrgMembershipMutation represents an operation that mutates the OrgMembership nodes in the graph.
type OrgMembershipMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	mapping_id          *string
	deleted_at          *time.Time
	deleted_by          *string
	role                *enums.Role
	clearedFields       map[string]struct{}
	organization        *string
	clearedorganization bool
	user                *string
	cleareduser         bool
	events              map[string]struct{}
	removedevents       map[string]struct{}
	clearedevents       bool
	done                bool
	oldValue            func(context.Context) (*OrgMembership, error)
	predicates          []predicate.OrgMembership
}

var _ ent.Mutation = (*OrgMembershipMutation)(nil)

// orgmembershipOption allows management of the mutation configuration using functional options.
type orgmembershipOption func(*OrgMembershipMutation)

// newOrgMembershipMutation creates new mutation for the OrgMembership entity.
func newOrgMembershipMutation(c config, op Op, opts ...orgmembershipOption) *OrgMembershipMutation {
	m := &OrgMembershipMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgMembership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgMembershipID sets the ID field of the mutation.
func withOrgMembershipID(id string) orgmembershipOption {
	return func(m *OrgMembershipMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgMembership
		)
		m.oldValue = func(ctx context.Context) (*OrgMembership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgMembership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgMembership sets the old OrgMembership of the mutation.
func withOrgMembership(node *OrgMembership) orgmembershipOption {
	return func(m *OrgMembershipMutation) {
		m.oldValue = func(context.Context) (*OrgMembership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgMembershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgMembershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgMembership entities.
func (m *OrgMembershipMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgMembershipMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgMembershipMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgMembership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgMembershipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgMembershipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrgMembershipMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orgmembership.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrgMembershipMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orgmembership.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgMembershipMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orgmembership.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgMembershipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgMembershipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgMembershipMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgmembership.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgMembershipMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgmembership.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgMembershipMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgmembership.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgMembershipMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgMembershipMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrgMembershipMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[orgmembership.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrgMembershipMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[orgmembership.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgMembershipMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, orgmembership.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgMembershipMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgMembershipMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgMembershipMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[orgmembership.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgMembershipMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgmembership.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgMembershipMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, orgmembership.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *OrgMembershipMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OrgMembershipMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OrgMembershipMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrgMembershipMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrgMembershipMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrgMembershipMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orgmembership.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrgMembershipMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orgmembership.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrgMembershipMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orgmembership.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrgMembershipMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrgMembershipMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrgMembershipMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[orgmembership.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrgMembershipMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[orgmembership.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrgMembershipMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, orgmembership.FieldDeletedBy)
}

// SetRole sets the "role" field.
func (m *OrgMembershipMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *OrgMembershipMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *OrgMembershipMutation) ResetRole() {
	m.role = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrgMembershipMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrgMembershipMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrgMembershipMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetUserID sets the "user_id" field.
func (m *OrgMembershipMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgMembershipMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgMembership entity.
// If the OrgMembership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgMembershipMutation) ResetUserID() {
	m.user = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrgMembershipMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[orgmembership.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrgMembershipMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrgMembershipMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrgMembershipMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrgMembershipMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[orgmembership.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrgMembershipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrgMembershipMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrgMembershipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *OrgMembershipMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *OrgMembershipMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *OrgMembershipMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *OrgMembershipMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *OrgMembershipMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *OrgMembershipMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *OrgMembershipMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the OrgMembershipMutation builder.
func (m *OrgMembershipMutation) Where(ps ...predicate.OrgMembership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgMembershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgMembershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgMembership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgMembershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgMembershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgMembership).
func (m *OrgMembershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgMembershipMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, orgmembership.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orgmembership.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, orgmembership.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, orgmembership.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, orgmembership.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, orgmembership.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, orgmembership.FieldDeletedBy)
	}
	if m.role != nil {
		fields = append(fields, orgmembership.FieldRole)
	}
	if m.organization != nil {
		fields = append(fields, orgmembership.FieldOrganizationID)
	}
	if m.user != nil {
		fields = append(fields, orgmembership.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgMembershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgmembership.FieldCreatedAt:
		return m.CreatedAt()
	case orgmembership.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgmembership.FieldCreatedBy:
		return m.CreatedBy()
	case orgmembership.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgmembership.FieldMappingID:
		return m.MappingID()
	case orgmembership.FieldDeletedAt:
		return m.DeletedAt()
	case orgmembership.FieldDeletedBy:
		return m.DeletedBy()
	case orgmembership.FieldRole:
		return m.Role()
	case orgmembership.FieldOrganizationID:
		return m.OrganizationID()
	case orgmembership.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgMembershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgmembership.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgmembership.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgmembership.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgmembership.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgmembership.FieldMappingID:
		return m.OldMappingID(ctx)
	case orgmembership.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orgmembership.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case orgmembership.FieldRole:
		return m.OldRole(ctx)
	case orgmembership.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case orgmembership.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgMembership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMembershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgmembership.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgmembership.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgmembership.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgmembership.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgmembership.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case orgmembership.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orgmembership.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case orgmembership.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case orgmembership.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case orgmembership.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgMembership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgMembershipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgMembershipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMembershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgMembership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgMembershipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgmembership.FieldCreatedAt) {
		fields = append(fields, orgmembership.FieldCreatedAt)
	}
	if m.FieldCleared(orgmembership.FieldUpdatedAt) {
		fields = append(fields, orgmembership.FieldUpdatedAt)
	}
	if m.FieldCleared(orgmembership.FieldCreatedBy) {
		fields = append(fields, orgmembership.FieldCreatedBy)
	}
	if m.FieldCleared(orgmembership.FieldUpdatedBy) {
		fields = append(fields, orgmembership.FieldUpdatedBy)
	}
	if m.FieldCleared(orgmembership.FieldDeletedAt) {
		fields = append(fields, orgmembership.FieldDeletedAt)
	}
	if m.FieldCleared(orgmembership.FieldDeletedBy) {
		fields = append(fields, orgmembership.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgMembershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgMembershipMutation) ClearField(name string) error {
	switch name {
	case orgmembership.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orgmembership.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orgmembership.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case orgmembership.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orgmembership.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orgmembership.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown OrgMembership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgMembershipMutation) ResetField(name string) error {
	switch name {
	case orgmembership.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgmembership.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgmembership.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgmembership.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgmembership.FieldMappingID:
		m.ResetMappingID()
		return nil
	case orgmembership.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orgmembership.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case orgmembership.FieldRole:
		m.ResetRole()
		return nil
	case orgmembership.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case orgmembership.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown OrgMembership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgMembershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.organization != nil {
		edges = append(edges, orgmembership.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, orgmembership.EdgeUser)
	}
	if m.events != nil {
		edges = append(edges, orgmembership.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgMembershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgmembership.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case orgmembership.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case orgmembership.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgMembershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedevents != nil {
		edges = append(edges, orgmembership.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgMembershipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgmembership.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgMembershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorganization {
		edges = append(edges, orgmembership.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, orgmembership.EdgeUser)
	}
	if m.clearedevents {
		edges = append(edges, orgmembership.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgMembershipMutation) EdgeCleared(name string) bool {
	switch name {
	case orgmembership.EdgeOrganization:
		return m.clearedorganization
	case orgmembership.EdgeUser:
		return m.cleareduser
	case orgmembership.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgMembershipMutation) ClearEdge(name string) error {
	switch name {
	case orgmembership.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case orgmembership.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OrgMembership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgMembershipMutation) ResetEdge(name string) error {
	switch name {
	case orgmembership.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case orgmembership.EdgeUser:
		m.ResetUser()
		return nil
	case orgmembership.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown OrgMembership edge %s", name)
}

// OrgMembershipHistoryMutation represents an operation that mutates the OrgMembershipHistory nodes in the graph.
type OrgMembershipHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	history_time    *time.Time
	ref             *string
	operation       *history.OpType
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	mapping_id      *string
	deleted_at      *time.Time
	deleted_by      *string
	role            *enums.Role
	organization_id *string
	user_id         *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*OrgMembershipHistory, error)
	predicates      []predicate.OrgMembershipHistory
}

var _ ent.Mutation = (*OrgMembershipHistoryMutation)(nil)

// orgmembershiphistoryOption allows management of the mutation configuration using functional options.
type orgmembershiphistoryOption func(*OrgMembershipHistoryMutation)

// newOrgMembershipHistoryMutation creates new mutation for the OrgMembershipHistory entity.
func newOrgMembershipHistoryMutation(c config, op Op, opts ...orgmembershiphistoryOption) *OrgMembershipHistoryMutation {
	m := &OrgMembershipHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgMembershipHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgMembershipHistoryID sets the ID field of the mutation.
func withOrgMembershipHistoryID(id string) orgmembershiphistoryOption {
	return func(m *OrgMembershipHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgMembershipHistory
		)
		m.oldValue = func(ctx context.Context) (*OrgMembershipHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgMembershipHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgMembershipHistory sets the old OrgMembershipHistory of the mutation.
func withOrgMembershipHistory(node *OrgMembershipHistory) orgmembershiphistoryOption {
	return func(m *OrgMembershipHistoryMutation) {
		m.oldValue = func(context.Context) (*OrgMembershipHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgMembershipHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgMembershipHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgMembershipHistory entities.
func (m *OrgMembershipHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgMembershipHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgMembershipHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgMembershipHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *OrgMembershipHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *OrgMembershipHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *OrgMembershipHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *OrgMembershipHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *OrgMembershipHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *OrgMembershipHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[orgmembershiphistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *OrgMembershipHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, orgmembershiphistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *OrgMembershipHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *OrgMembershipHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *OrgMembershipHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgMembershipHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgMembershipHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrgMembershipHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orgmembershiphistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgMembershipHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orgmembershiphistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgMembershipHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgMembershipHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgMembershipHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgmembershiphistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgMembershipHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgmembershiphistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgMembershipHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgMembershipHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrgMembershipHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[orgmembershiphistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgMembershipHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, orgmembershiphistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgMembershipHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgMembershipHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgMembershipHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[orgmembershiphistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgMembershipHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, orgmembershiphistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *OrgMembershipHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OrgMembershipHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OrgMembershipHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrgMembershipHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrgMembershipHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrgMembershipHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orgmembershiphistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrgMembershipHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orgmembershiphistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrgMembershipHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrgMembershipHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrgMembershipHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[orgmembershiphistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[orgmembershiphistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrgMembershipHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, orgmembershiphistory.FieldDeletedBy)
}

// SetRole sets the "role" field.
func (m *OrgMembershipHistoryMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *OrgMembershipHistoryMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *OrgMembershipHistoryMutation) ResetRole() {
	m.role = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrgMembershipHistoryMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrgMembershipHistoryMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrgMembershipHistoryMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetUserID sets the "user_id" field.
func (m *OrgMembershipHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgMembershipHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgMembershipHistory entity.
// If the OrgMembershipHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMembershipHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgMembershipHistoryMutation) ResetUserID() {
	m.user_id = nil
}

// Where appends a list predicates to the OrgMembershipHistoryMutation builder.
func (m *OrgMembershipHistoryMutation) Where(ps ...predicate.OrgMembershipHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgMembershipHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgMembershipHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgMembershipHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgMembershipHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgMembershipHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgMembershipHistory).
func (m *OrgMembershipHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgMembershipHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.history_time != nil {
		fields = append(fields, orgmembershiphistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, orgmembershiphistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, orgmembershiphistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, orgmembershiphistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orgmembershiphistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, orgmembershiphistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, orgmembershiphistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, orgmembershiphistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, orgmembershiphistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, orgmembershiphistory.FieldDeletedBy)
	}
	if m.role != nil {
		fields = append(fields, orgmembershiphistory.FieldRole)
	}
	if m.organization_id != nil {
		fields = append(fields, orgmembershiphistory.FieldOrganizationID)
	}
	if m.user_id != nil {
		fields = append(fields, orgmembershiphistory.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgMembershipHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgmembershiphistory.FieldHistoryTime:
		return m.HistoryTime()
	case orgmembershiphistory.FieldRef:
		return m.Ref()
	case orgmembershiphistory.FieldOperation:
		return m.Operation()
	case orgmembershiphistory.FieldCreatedAt:
		return m.CreatedAt()
	case orgmembershiphistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgmembershiphistory.FieldCreatedBy:
		return m.CreatedBy()
	case orgmembershiphistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgmembershiphistory.FieldMappingID:
		return m.MappingID()
	case orgmembershiphistory.FieldDeletedAt:
		return m.DeletedAt()
	case orgmembershiphistory.FieldDeletedBy:
		return m.DeletedBy()
	case orgmembershiphistory.FieldRole:
		return m.Role()
	case orgmembershiphistory.FieldOrganizationID:
		return m.OrganizationID()
	case orgmembershiphistory.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgMembershipHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgmembershiphistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case orgmembershiphistory.FieldRef:
		return m.OldRef(ctx)
	case orgmembershiphistory.FieldOperation:
		return m.OldOperation(ctx)
	case orgmembershiphistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgmembershiphistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgmembershiphistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgmembershiphistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgmembershiphistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case orgmembershiphistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orgmembershiphistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case orgmembershiphistory.FieldRole:
		return m.OldRole(ctx)
	case orgmembershiphistory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case orgmembershiphistory.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgMembershipHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMembershipHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgmembershiphistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case orgmembershiphistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case orgmembershiphistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case orgmembershiphistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgmembershiphistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgmembershiphistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgmembershiphistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgmembershiphistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case orgmembershiphistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orgmembershiphistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case orgmembershiphistory.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case orgmembershiphistory.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case orgmembershiphistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgMembershipHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgMembershipHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgMembershipHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMembershipHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgMembershipHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgMembershipHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgmembershiphistory.FieldRef) {
		fields = append(fields, orgmembershiphistory.FieldRef)
	}
	if m.FieldCleared(orgmembershiphistory.FieldCreatedAt) {
		fields = append(fields, orgmembershiphistory.FieldCreatedAt)
	}
	if m.FieldCleared(orgmembershiphistory.FieldUpdatedAt) {
		fields = append(fields, orgmembershiphistory.FieldUpdatedAt)
	}
	if m.FieldCleared(orgmembershiphistory.FieldCreatedBy) {
		fields = append(fields, orgmembershiphistory.FieldCreatedBy)
	}
	if m.FieldCleared(orgmembershiphistory.FieldUpdatedBy) {
		fields = append(fields, orgmembershiphistory.FieldUpdatedBy)
	}
	if m.FieldCleared(orgmembershiphistory.FieldDeletedAt) {
		fields = append(fields, orgmembershiphistory.FieldDeletedAt)
	}
	if m.FieldCleared(orgmembershiphistory.FieldDeletedBy) {
		fields = append(fields, orgmembershiphistory.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgMembershipHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgMembershipHistoryMutation) ClearField(name string) error {
	switch name {
	case orgmembershiphistory.FieldRef:
		m.ClearRef()
		return nil
	case orgmembershiphistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case orgmembershiphistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orgmembershiphistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case orgmembershiphistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orgmembershiphistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orgmembershiphistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown OrgMembershipHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgMembershipHistoryMutation) ResetField(name string) error {
	switch name {
	case orgmembershiphistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case orgmembershiphistory.FieldRef:
		m.ResetRef()
		return nil
	case orgmembershiphistory.FieldOperation:
		m.ResetOperation()
		return nil
	case orgmembershiphistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgmembershiphistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgmembershiphistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgmembershiphistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgmembershiphistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case orgmembershiphistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orgmembershiphistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case orgmembershiphistory.FieldRole:
		m.ResetRole()
		return nil
	case orgmembershiphistory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case orgmembershiphistory.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown OrgMembershipHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgMembershipHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgMembershipHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgMembershipHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgMembershipHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgMembershipHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgMembershipHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgMembershipHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrgMembershipHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgMembershipHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrgMembershipHistory edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                              Op
	typ                             string
	id                              *string
	created_at                      *time.Time
	updated_at                      *time.Time
	created_by                      *string
	updated_by                      *string
	mapping_id                      *string
	tags                            *[]string
	appendtags                      []string
	deleted_at                      *time.Time
	deleted_by                      *string
	name                            *string
	display_name                    *string
	description                     *string
	personal_org                    *bool
	avatar_remote_url               *string
	dedicated_db                    *bool
	clearedFields                   map[string]struct{}
	parent                          *string
	clearedparent                   bool
	children                        map[string]struct{}
	removedchildren                 map[string]struct{}
	clearedchildren                 bool
	groups                          map[string]struct{}
	removedgroups                   map[string]struct{}
	clearedgroups                   bool
	templates                       map[string]struct{}
	removedtemplates                map[string]struct{}
	clearedtemplates                bool
	integrations                    map[string]struct{}
	removedintegrations             map[string]struct{}
	clearedintegrations             bool
	setting                         *string
	clearedsetting                  bool
	documentdata                    map[string]struct{}
	removeddocumentdata             map[string]struct{}
	cleareddocumentdata             bool
	entitlements                    map[string]struct{}
	removedentitlements             map[string]struct{}
	clearedentitlements             bool
	organization_entitlement        map[string]struct{}
	removedorganization_entitlement map[string]struct{}
	clearedorganization_entitlement bool
	personal_access_tokens          map[string]struct{}
	removedpersonal_access_tokens   map[string]struct{}
	clearedpersonal_access_tokens   bool
	api_tokens                      map[string]struct{}
	removedapi_tokens               map[string]struct{}
	clearedapi_tokens               bool
	oauthprovider                   map[string]struct{}
	removedoauthprovider            map[string]struct{}
	clearedoauthprovider            bool
	users                           map[string]struct{}
	removedusers                    map[string]struct{}
	clearedusers                    bool
	invites                         map[string]struct{}
	removedinvites                  map[string]struct{}
	clearedinvites                  bool
	subscribers                     map[string]struct{}
	removedsubscribers              map[string]struct{}
	clearedsubscribers              bool
	webhooks                        map[string]struct{}
	removedwebhooks                 map[string]struct{}
	clearedwebhooks                 bool
	events                          map[string]struct{}
	removedevents                   map[string]struct{}
	clearedevents                   bool
	secrets                         map[string]struct{}
	removedsecrets                  map[string]struct{}
	clearedsecrets                  bool
	features                        map[string]struct{}
	removedfeatures                 map[string]struct{}
	clearedfeatures                 bool
	files                           map[string]struct{}
	removedfiles                    map[string]struct{}
	clearedfiles                    bool
	entitlementplans                map[string]struct{}
	removedentitlementplans         map[string]struct{}
	clearedentitlementplans         bool
	entitlementplanfeatures         map[string]struct{}
	removedentitlementplanfeatures  map[string]struct{}
	clearedentitlementplanfeatures  bool
	entities                        map[string]struct{}
	removedentities                 map[string]struct{}
	clearedentities                 bool
	entitytypes                     map[string]struct{}
	removedentitytypes              map[string]struct{}
	clearedentitytypes              bool
	contacts                        map[string]struct{}
	removedcontacts                 map[string]struct{}
	clearedcontacts                 bool
	notes                           map[string]struct{}
	removednotes                    map[string]struct{}
	clearednotes                    bool
	tasks                           map[string]struct{}
	removedtasks                    map[string]struct{}
	clearedtasks                    bool
	programs                        map[string]struct{}
	removedprograms                 map[string]struct{}
	clearedprograms                 bool
	members                         map[string]struct{}
	removedmembers                  map[string]struct{}
	clearedmembers                  bool
	done                            bool
	oldValue                        func(context.Context) (*Organization, error)
	predicates                      []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id string) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrganizationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[organization.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrganizationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, organization.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organization.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organization.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organization.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organization.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organization.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organization.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *OrganizationMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OrganizationMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OrganizationMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *OrganizationMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OrganizationMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OrganizationMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OrganizationMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OrganizationMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[organization.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OrganizationMutation) TagsCleared() bool {
	_, ok := m.clearedFields[organization.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OrganizationMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, organization.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organization.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organization.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrganizationMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrganizationMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrganizationMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[organization.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrganizationMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrganizationMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, organization.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OrganizationMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrganizationMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrganizationMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetDescription sets the "description" field.
func (m *OrganizationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organization.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organization.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organization.FieldDescription)
}

// SetParentOrganizationID sets the "parent_organization_id" field.
func (m *OrganizationMutation) SetParentOrganizationID(s string) {
	m.parent = &s
}

// ParentOrganizationID returns the value of the "parent_organization_id" field in the mutation.
func (m *OrganizationMutation) ParentOrganizationID() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentOrganizationID returns the old "parent_organization_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldParentOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentOrganizationID: %w", err)
	}
	return oldValue.ParentOrganizationID, nil
}

// ClearParentOrganizationID clears the value of the "parent_organization_id" field.
func (m *OrganizationMutation) ClearParentOrganizationID() {
	m.parent = nil
	m.clearedFields[organization.FieldParentOrganizationID] = struct{}{}
}

// ParentOrganizationIDCleared returns if the "parent_organization_id" field was cleared in this mutation.
func (m *OrganizationMutation) ParentOrganizationIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldParentOrganizationID]
	return ok
}

// ResetParentOrganizationID resets all changes to the "parent_organization_id" field.
func (m *OrganizationMutation) ResetParentOrganizationID() {
	m.parent = nil
	delete(m.clearedFields, organization.FieldParentOrganizationID)
}

// SetPersonalOrg sets the "personal_org" field.
func (m *OrganizationMutation) SetPersonalOrg(b bool) {
	m.personal_org = &b
}

// PersonalOrg returns the value of the "personal_org" field in the mutation.
func (m *OrganizationMutation) PersonalOrg() (r bool, exists bool) {
	v := m.personal_org
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalOrg returns the old "personal_org" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPersonalOrg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalOrg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalOrg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalOrg: %w", err)
	}
	return oldValue.PersonalOrg, nil
}

// ClearPersonalOrg clears the value of the "personal_org" field.
func (m *OrganizationMutation) ClearPersonalOrg() {
	m.personal_org = nil
	m.clearedFields[organization.FieldPersonalOrg] = struct{}{}
}

// PersonalOrgCleared returns if the "personal_org" field was cleared in this mutation.
func (m *OrganizationMutation) PersonalOrgCleared() bool {
	_, ok := m.clearedFields[organization.FieldPersonalOrg]
	return ok
}

// ResetPersonalOrg resets all changes to the "personal_org" field.
func (m *OrganizationMutation) ResetPersonalOrg() {
	m.personal_org = nil
	delete(m.clearedFields, organization.FieldPersonalOrg)
}

// SetAvatarRemoteURL sets the "avatar_remote_url" field.
func (m *OrganizationMutation) SetAvatarRemoteURL(s string) {
	m.avatar_remote_url = &s
}

// AvatarRemoteURL returns the value of the "avatar_remote_url" field in the mutation.
func (m *OrganizationMutation) AvatarRemoteURL() (r string, exists bool) {
	v := m.avatar_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarRemoteURL returns the old "avatar_remote_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAvatarRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarRemoteURL: %w", err)
	}
	return oldValue.AvatarRemoteURL, nil
}

// ClearAvatarRemoteURL clears the value of the "avatar_remote_url" field.
func (m *OrganizationMutation) ClearAvatarRemoteURL() {
	m.avatar_remote_url = nil
	m.clearedFields[organization.FieldAvatarRemoteURL] = struct{}{}
}

// AvatarRemoteURLCleared returns if the "avatar_remote_url" field was cleared in this mutation.
func (m *OrganizationMutation) AvatarRemoteURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldAvatarRemoteURL]
	return ok
}

// ResetAvatarRemoteURL resets all changes to the "avatar_remote_url" field.
func (m *OrganizationMutation) ResetAvatarRemoteURL() {
	m.avatar_remote_url = nil
	delete(m.clearedFields, organization.FieldAvatarRemoteURL)
}

// SetDedicatedDb sets the "dedicated_db" field.
func (m *OrganizationMutation) SetDedicatedDb(b bool) {
	m.dedicated_db = &b
}

// DedicatedDb returns the value of the "dedicated_db" field in the mutation.
func (m *OrganizationMutation) DedicatedDb() (r bool, exists bool) {
	v := m.dedicated_db
	if v == nil {
		return
	}
	return *v, true
}

// OldDedicatedDb returns the old "dedicated_db" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDedicatedDb(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDedicatedDb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDedicatedDb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDedicatedDb: %w", err)
	}
	return oldValue.DedicatedDb, nil
}

// ResetDedicatedDb resets all changes to the "dedicated_db" field.
func (m *OrganizationMutation) ResetDedicatedDb() {
	m.dedicated_db = nil
}

// SetParentID sets the "parent" edge to the Organization entity by id.
func (m *OrganizationMutation) SetParentID(id string) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Organization entity.
func (m *OrganizationMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[organization.FieldParentOrganizationID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ParentCleared() bool {
	return m.ParentOrganizationIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OrganizationMutation) ParentID() (id string, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrganizationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Organization entity by ids.
func (m *OrganizationMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Organization entity.
func (m *OrganizationMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Organization entity by IDs.
func (m *OrganizationMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Organization entity.
func (m *OrganizationMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrganizationMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrganizationMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *OrganizationMutation) AddGroupIDs(ids ...string) {
	if m.groups == nil {
		m.groups = make(map[string]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *OrganizationMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *OrganizationMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *OrganizationMutation) RemoveGroupIDs(ids ...string) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *OrganizationMutation) RemovedGroupsIDs() (ids []string) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *OrganizationMutation) GroupsIDs() (ids []string) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *OrganizationMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddTemplateIDs adds the "templates" edge to the Template entity by ids.
func (m *OrganizationMutation) AddTemplateIDs(ids ...string) {
	if m.templates == nil {
		m.templates = make(map[string]struct{})
	}
	for i := range ids {
		m.templates[ids[i]] = struct{}{}
	}
}

// ClearTemplates clears the "templates" edge to the Template entity.
func (m *OrganizationMutation) ClearTemplates() {
	m.clearedtemplates = true
}

// TemplatesCleared reports if the "templates" edge to the Template entity was cleared.
func (m *OrganizationMutation) TemplatesCleared() bool {
	return m.clearedtemplates
}

// RemoveTemplateIDs removes the "templates" edge to the Template entity by IDs.
func (m *OrganizationMutation) RemoveTemplateIDs(ids ...string) {
	if m.removedtemplates == nil {
		m.removedtemplates = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.templates, ids[i])
		m.removedtemplates[ids[i]] = struct{}{}
	}
}

// RemovedTemplates returns the removed IDs of the "templates" edge to the Template entity.
func (m *OrganizationMutation) RemovedTemplatesIDs() (ids []string) {
	for id := range m.removedtemplates {
		ids = append(ids, id)
	}
	return
}

// TemplatesIDs returns the "templates" edge IDs in the mutation.
func (m *OrganizationMutation) TemplatesIDs() (ids []string) {
	for id := range m.templates {
		ids = append(ids, id)
	}
	return
}

// ResetTemplates resets all changes to the "templates" edge.
func (m *OrganizationMutation) ResetTemplates() {
	m.templates = nil
	m.clearedtemplates = false
	m.removedtemplates = nil
}

// AddIntegrationIDs adds the "integrations" edge to the Integration entity by ids.
func (m *OrganizationMutation) AddIntegrationIDs(ids ...string) {
	if m.integrations == nil {
		m.integrations = make(map[string]struct{})
	}
	for i := range ids {
		m.integrations[ids[i]] = struct{}{}
	}
}

// ClearIntegrations clears the "integrations" edge to the Integration entity.
func (m *OrganizationMutation) ClearIntegrations() {
	m.clearedintegrations = true
}

// IntegrationsCleared reports if the "integrations" edge to the Integration entity was cleared.
func (m *OrganizationMutation) IntegrationsCleared() bool {
	return m.clearedintegrations
}

// RemoveIntegrationIDs removes the "integrations" edge to the Integration entity by IDs.
func (m *OrganizationMutation) RemoveIntegrationIDs(ids ...string) {
	if m.removedintegrations == nil {
		m.removedintegrations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.integrations, ids[i])
		m.removedintegrations[ids[i]] = struct{}{}
	}
}

// RemovedIntegrations returns the removed IDs of the "integrations" edge to the Integration entity.
func (m *OrganizationMutation) RemovedIntegrationsIDs() (ids []string) {
	for id := range m.removedintegrations {
		ids = append(ids, id)
	}
	return
}

// IntegrationsIDs returns the "integrations" edge IDs in the mutation.
func (m *OrganizationMutation) IntegrationsIDs() (ids []string) {
	for id := range m.integrations {
		ids = append(ids, id)
	}
	return
}

// ResetIntegrations resets all changes to the "integrations" edge.
func (m *OrganizationMutation) ResetIntegrations() {
	m.integrations = nil
	m.clearedintegrations = false
	m.removedintegrations = nil
}

// SetSettingID sets the "setting" edge to the OrganizationSetting entity by id.
func (m *OrganizationMutation) SetSettingID(id string) {
	m.setting = &id
}

// ClearSetting clears the "setting" edge to the OrganizationSetting entity.
func (m *OrganizationMutation) ClearSetting() {
	m.clearedsetting = true
}

// SettingCleared reports if the "setting" edge to the OrganizationSetting entity was cleared.
func (m *OrganizationMutation) SettingCleared() bool {
	return m.clearedsetting
}

// SettingID returns the "setting" edge ID in the mutation.
func (m *OrganizationMutation) SettingID() (id string, exists bool) {
	if m.setting != nil {
		return *m.setting, true
	}
	return
}

// SettingIDs returns the "setting" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) SettingIDs() (ids []string) {
	if id := m.setting; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSetting resets all changes to the "setting" edge.
func (m *OrganizationMutation) ResetSetting() {
	m.setting = nil
	m.clearedsetting = false
}

// AddDocumentdatumIDs adds the "documentdata" edge to the DocumentData entity by ids.
func (m *OrganizationMutation) AddDocumentdatumIDs(ids ...string) {
	if m.documentdata == nil {
		m.documentdata = make(map[string]struct{})
	}
	for i := range ids {
		m.documentdata[ids[i]] = struct{}{}
	}
}

// ClearDocumentdata clears the "documentdata" edge to the DocumentData entity.
func (m *OrganizationMutation) ClearDocumentdata() {
	m.cleareddocumentdata = true
}

// DocumentdataCleared reports if the "documentdata" edge to the DocumentData entity was cleared.
func (m *OrganizationMutation) DocumentdataCleared() bool {
	return m.cleareddocumentdata
}

// RemoveDocumentdatumIDs removes the "documentdata" edge to the DocumentData entity by IDs.
func (m *OrganizationMutation) RemoveDocumentdatumIDs(ids ...string) {
	if m.removeddocumentdata == nil {
		m.removeddocumentdata = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.documentdata, ids[i])
		m.removeddocumentdata[ids[i]] = struct{}{}
	}
}

// RemovedDocumentdata returns the removed IDs of the "documentdata" edge to the DocumentData entity.
func (m *OrganizationMutation) RemovedDocumentdataIDs() (ids []string) {
	for id := range m.removeddocumentdata {
		ids = append(ids, id)
	}
	return
}

// DocumentdataIDs returns the "documentdata" edge IDs in the mutation.
func (m *OrganizationMutation) DocumentdataIDs() (ids []string) {
	for id := range m.documentdata {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentdata resets all changes to the "documentdata" edge.
func (m *OrganizationMutation) ResetDocumentdata() {
	m.documentdata = nil
	m.cleareddocumentdata = false
	m.removeddocumentdata = nil
}

// AddEntitlementIDs adds the "entitlements" edge to the Entitlement entity by ids.
func (m *OrganizationMutation) AddEntitlementIDs(ids ...string) {
	if m.entitlements == nil {
		m.entitlements = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlements[ids[i]] = struct{}{}
	}
}

// ClearEntitlements clears the "entitlements" edge to the Entitlement entity.
func (m *OrganizationMutation) ClearEntitlements() {
	m.clearedentitlements = true
}

// EntitlementsCleared reports if the "entitlements" edge to the Entitlement entity was cleared.
func (m *OrganizationMutation) EntitlementsCleared() bool {
	return m.clearedentitlements
}

// RemoveEntitlementIDs removes the "entitlements" edge to the Entitlement entity by IDs.
func (m *OrganizationMutation) RemoveEntitlementIDs(ids ...string) {
	if m.removedentitlements == nil {
		m.removedentitlements = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlements, ids[i])
		m.removedentitlements[ids[i]] = struct{}{}
	}
}

// RemovedEntitlements returns the removed IDs of the "entitlements" edge to the Entitlement entity.
func (m *OrganizationMutation) RemovedEntitlementsIDs() (ids []string) {
	for id := range m.removedentitlements {
		ids = append(ids, id)
	}
	return
}

// EntitlementsIDs returns the "entitlements" edge IDs in the mutation.
func (m *OrganizationMutation) EntitlementsIDs() (ids []string) {
	for id := range m.entitlements {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlements resets all changes to the "entitlements" edge.
func (m *OrganizationMutation) ResetEntitlements() {
	m.entitlements = nil
	m.clearedentitlements = false
	m.removedentitlements = nil
}

// AddOrganizationEntitlementIDs adds the "organization_entitlement" edge to the Entitlement entity by ids.
func (m *OrganizationMutation) AddOrganizationEntitlementIDs(ids ...string) {
	if m.organization_entitlement == nil {
		m.organization_entitlement = make(map[string]struct{})
	}
	for i := range ids {
		m.organization_entitlement[ids[i]] = struct{}{}
	}
}

// ClearOrganizationEntitlement clears the "organization_entitlement" edge to the Entitlement entity.
func (m *OrganizationMutation) ClearOrganizationEntitlement() {
	m.clearedorganization_entitlement = true
}

// OrganizationEntitlementCleared reports if the "organization_entitlement" edge to the Entitlement entity was cleared.
func (m *OrganizationMutation) OrganizationEntitlementCleared() bool {
	return m.clearedorganization_entitlement
}

// RemoveOrganizationEntitlementIDs removes the "organization_entitlement" edge to the Entitlement entity by IDs.
func (m *OrganizationMutation) RemoveOrganizationEntitlementIDs(ids ...string) {
	if m.removedorganization_entitlement == nil {
		m.removedorganization_entitlement = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organization_entitlement, ids[i])
		m.removedorganization_entitlement[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationEntitlement returns the removed IDs of the "organization_entitlement" edge to the Entitlement entity.
func (m *OrganizationMutation) RemovedOrganizationEntitlementIDs() (ids []string) {
	for id := range m.removedorganization_entitlement {
		ids = append(ids, id)
	}
	return
}

// OrganizationEntitlementIDs returns the "organization_entitlement" edge IDs in the mutation.
func (m *OrganizationMutation) OrganizationEntitlementIDs() (ids []string) {
	for id := range m.organization_entitlement {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationEntitlement resets all changes to the "organization_entitlement" edge.
func (m *OrganizationMutation) ResetOrganizationEntitlement() {
	m.organization_entitlement = nil
	m.clearedorganization_entitlement = false
	m.removedorganization_entitlement = nil
}

// AddPersonalAccessTokenIDs adds the "personal_access_tokens" edge to the PersonalAccessToken entity by ids.
func (m *OrganizationMutation) AddPersonalAccessTokenIDs(ids ...string) {
	if m.personal_access_tokens == nil {
		m.personal_access_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.personal_access_tokens[ids[i]] = struct{}{}
	}
}

// ClearPersonalAccessTokens clears the "personal_access_tokens" edge to the PersonalAccessToken entity.
func (m *OrganizationMutation) ClearPersonalAccessTokens() {
	m.clearedpersonal_access_tokens = true
}

// PersonalAccessTokensCleared reports if the "personal_access_tokens" edge to the PersonalAccessToken entity was cleared.
func (m *OrganizationMutation) PersonalAccessTokensCleared() bool {
	return m.clearedpersonal_access_tokens
}

// RemovePersonalAccessTokenIDs removes the "personal_access_tokens" edge to the PersonalAccessToken entity by IDs.
func (m *OrganizationMutation) RemovePersonalAccessTokenIDs(ids ...string) {
	if m.removedpersonal_access_tokens == nil {
		m.removedpersonal_access_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.personal_access_tokens, ids[i])
		m.removedpersonal_access_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPersonalAccessTokens returns the removed IDs of the "personal_access_tokens" edge to the PersonalAccessToken entity.
func (m *OrganizationMutation) RemovedPersonalAccessTokensIDs() (ids []string) {
	for id := range m.removedpersonal_access_tokens {
		ids = append(ids, id)
	}
	return
}

// PersonalAccessTokensIDs returns the "personal_access_tokens" edge IDs in the mutation.
func (m *OrganizationMutation) PersonalAccessTokensIDs() (ids []string) {
	for id := range m.personal_access_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPersonalAccessTokens resets all changes to the "personal_access_tokens" edge.
func (m *OrganizationMutation) ResetPersonalAccessTokens() {
	m.personal_access_tokens = nil
	m.clearedpersonal_access_tokens = false
	m.removedpersonal_access_tokens = nil
}

// AddAPITokenIDs adds the "api_tokens" edge to the APIToken entity by ids.
func (m *OrganizationMutation) AddAPITokenIDs(ids ...string) {
	if m.api_tokens == nil {
		m.api_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.api_tokens[ids[i]] = struct{}{}
	}
}

// ClearAPITokens clears the "api_tokens" edge to the APIToken entity.
func (m *OrganizationMutation) ClearAPITokens() {
	m.clearedapi_tokens = true
}

// APITokensCleared reports if the "api_tokens" edge to the APIToken entity was cleared.
func (m *OrganizationMutation) APITokensCleared() bool {
	return m.clearedapi_tokens
}

// RemoveAPITokenIDs removes the "api_tokens" edge to the APIToken entity by IDs.
func (m *OrganizationMutation) RemoveAPITokenIDs(ids ...string) {
	if m.removedapi_tokens == nil {
		m.removedapi_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.api_tokens, ids[i])
		m.removedapi_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAPITokens returns the removed IDs of the "api_tokens" edge to the APIToken entity.
func (m *OrganizationMutation) RemovedAPITokensIDs() (ids []string) {
	for id := range m.removedapi_tokens {
		ids = append(ids, id)
	}
	return
}

// APITokensIDs returns the "api_tokens" edge IDs in the mutation.
func (m *OrganizationMutation) APITokensIDs() (ids []string) {
	for id := range m.api_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAPITokens resets all changes to the "api_tokens" edge.
func (m *OrganizationMutation) ResetAPITokens() {
	m.api_tokens = nil
	m.clearedapi_tokens = false
	m.removedapi_tokens = nil
}

// AddOauthproviderIDs adds the "oauthprovider" edge to the OauthProvider entity by ids.
func (m *OrganizationMutation) AddOauthproviderIDs(ids ...string) {
	if m.oauthprovider == nil {
		m.oauthprovider = make(map[string]struct{})
	}
	for i := range ids {
		m.oauthprovider[ids[i]] = struct{}{}
	}
}

// ClearOauthprovider clears the "oauthprovider" edge to the OauthProvider entity.
func (m *OrganizationMutation) ClearOauthprovider() {
	m.clearedoauthprovider = true
}

// OauthproviderCleared reports if the "oauthprovider" edge to the OauthProvider entity was cleared.
func (m *OrganizationMutation) OauthproviderCleared() bool {
	return m.clearedoauthprovider
}

// RemoveOauthproviderIDs removes the "oauthprovider" edge to the OauthProvider entity by IDs.
func (m *OrganizationMutation) RemoveOauthproviderIDs(ids ...string) {
	if m.removedoauthprovider == nil {
		m.removedoauthprovider = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.oauthprovider, ids[i])
		m.removedoauthprovider[ids[i]] = struct{}{}
	}
}

// RemovedOauthprovider returns the removed IDs of the "oauthprovider" edge to the OauthProvider entity.
func (m *OrganizationMutation) RemovedOauthproviderIDs() (ids []string) {
	for id := range m.removedoauthprovider {
		ids = append(ids, id)
	}
	return
}

// OauthproviderIDs returns the "oauthprovider" edge IDs in the mutation.
func (m *OrganizationMutation) OauthproviderIDs() (ids []string) {
	for id := range m.oauthprovider {
		ids = append(ids, id)
	}
	return
}

// ResetOauthprovider resets all changes to the "oauthprovider" edge.
func (m *OrganizationMutation) ResetOauthprovider() {
	m.oauthprovider = nil
	m.clearedoauthprovider = false
	m.removedoauthprovider = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrganizationMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrganizationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrganizationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrganizationMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrganizationMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrganizationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddInviteIDs adds the "invites" edge to the Invite entity by ids.
func (m *OrganizationMutation) AddInviteIDs(ids ...string) {
	if m.invites == nil {
		m.invites = make(map[string]struct{})
	}
	for i := range ids {
		m.invites[ids[i]] = struct{}{}
	}
}

// ClearInvites clears the "invites" edge to the Invite entity.
func (m *OrganizationMutation) ClearInvites() {
	m.clearedinvites = true
}

// InvitesCleared reports if the "invites" edge to the Invite entity was cleared.
func (m *OrganizationMutation) InvitesCleared() bool {
	return m.clearedinvites
}

// RemoveInviteIDs removes the "invites" edge to the Invite entity by IDs.
func (m *OrganizationMutation) RemoveInviteIDs(ids ...string) {
	if m.removedinvites == nil {
		m.removedinvites = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.invites, ids[i])
		m.removedinvites[ids[i]] = struct{}{}
	}
}

// RemovedInvites returns the removed IDs of the "invites" edge to the Invite entity.
func (m *OrganizationMutation) RemovedInvitesIDs() (ids []string) {
	for id := range m.removedinvites {
		ids = append(ids, id)
	}
	return
}

// InvitesIDs returns the "invites" edge IDs in the mutation.
func (m *OrganizationMutation) InvitesIDs() (ids []string) {
	for id := range m.invites {
		ids = append(ids, id)
	}
	return
}

// ResetInvites resets all changes to the "invites" edge.
func (m *OrganizationMutation) ResetInvites() {
	m.invites = nil
	m.clearedinvites = false
	m.removedinvites = nil
}

// AddSubscriberIDs adds the "subscribers" edge to the Subscriber entity by ids.
func (m *OrganizationMutation) AddSubscriberIDs(ids ...string) {
	if m.subscribers == nil {
		m.subscribers = make(map[string]struct{})
	}
	for i := range ids {
		m.subscribers[ids[i]] = struct{}{}
	}
}

// ClearSubscribers clears the "subscribers" edge to the Subscriber entity.
func (m *OrganizationMutation) ClearSubscribers() {
	m.clearedsubscribers = true
}

// SubscribersCleared reports if the "subscribers" edge to the Subscriber entity was cleared.
func (m *OrganizationMutation) SubscribersCleared() bool {
	return m.clearedsubscribers
}

// RemoveSubscriberIDs removes the "subscribers" edge to the Subscriber entity by IDs.
func (m *OrganizationMutation) RemoveSubscriberIDs(ids ...string) {
	if m.removedsubscribers == nil {
		m.removedsubscribers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscribers, ids[i])
		m.removedsubscribers[ids[i]] = struct{}{}
	}
}

// RemovedSubscribers returns the removed IDs of the "subscribers" edge to the Subscriber entity.
func (m *OrganizationMutation) RemovedSubscribersIDs() (ids []string) {
	for id := range m.removedsubscribers {
		ids = append(ids, id)
	}
	return
}

// SubscribersIDs returns the "subscribers" edge IDs in the mutation.
func (m *OrganizationMutation) SubscribersIDs() (ids []string) {
	for id := range m.subscribers {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribers resets all changes to the "subscribers" edge.
func (m *OrganizationMutation) ResetSubscribers() {
	m.subscribers = nil
	m.clearedsubscribers = false
	m.removedsubscribers = nil
}

// AddWebhookIDs adds the "webhooks" edge to the Webhook entity by ids.
func (m *OrganizationMutation) AddWebhookIDs(ids ...string) {
	if m.webhooks == nil {
		m.webhooks = make(map[string]struct{})
	}
	for i := range ids {
		m.webhooks[ids[i]] = struct{}{}
	}
}

// ClearWebhooks clears the "webhooks" edge to the Webhook entity.
func (m *OrganizationMutation) ClearWebhooks() {
	m.clearedwebhooks = true
}

// WebhooksCleared reports if the "webhooks" edge to the Webhook entity was cleared.
func (m *OrganizationMutation) WebhooksCleared() bool {
	return m.clearedwebhooks
}

// RemoveWebhookIDs removes the "webhooks" edge to the Webhook entity by IDs.
func (m *OrganizationMutation) RemoveWebhookIDs(ids ...string) {
	if m.removedwebhooks == nil {
		m.removedwebhooks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.webhooks, ids[i])
		m.removedwebhooks[ids[i]] = struct{}{}
	}
}

// RemovedWebhooks returns the removed IDs of the "webhooks" edge to the Webhook entity.
func (m *OrganizationMutation) RemovedWebhooksIDs() (ids []string) {
	for id := range m.removedwebhooks {
		ids = append(ids, id)
	}
	return
}

// WebhooksIDs returns the "webhooks" edge IDs in the mutation.
func (m *OrganizationMutation) WebhooksIDs() (ids []string) {
	for id := range m.webhooks {
		ids = append(ids, id)
	}
	return
}

// ResetWebhooks resets all changes to the "webhooks" edge.
func (m *OrganizationMutation) ResetWebhooks() {
	m.webhooks = nil
	m.clearedwebhooks = false
	m.removedwebhooks = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *OrganizationMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *OrganizationMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *OrganizationMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *OrganizationMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *OrganizationMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *OrganizationMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *OrganizationMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddSecretIDs adds the "secrets" edge to the Hush entity by ids.
func (m *OrganizationMutation) AddSecretIDs(ids ...string) {
	if m.secrets == nil {
		m.secrets = make(map[string]struct{})
	}
	for i := range ids {
		m.secrets[ids[i]] = struct{}{}
	}
}

// ClearSecrets clears the "secrets" edge to the Hush entity.
func (m *OrganizationMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the Hush entity was cleared.
func (m *OrganizationMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// RemoveSecretIDs removes the "secrets" edge to the Hush entity by IDs.
func (m *OrganizationMutation) RemoveSecretIDs(ids ...string) {
	if m.removedsecrets == nil {
		m.removedsecrets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.secrets, ids[i])
		m.removedsecrets[ids[i]] = struct{}{}
	}
}

// RemovedSecrets returns the removed IDs of the "secrets" edge to the Hush entity.
func (m *OrganizationMutation) RemovedSecretsIDs() (ids []string) {
	for id := range m.removedsecrets {
		ids = append(ids, id)
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
func (m *OrganizationMutation) SecretsIDs() (ids []string) {
	for id := range m.secrets {
		ids = append(ids, id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *OrganizationMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
	m.removedsecrets = nil
}

// AddFeatureIDs adds the "features" edge to the Feature entity by ids.
func (m *OrganizationMutation) AddFeatureIDs(ids ...string) {
	if m.features == nil {
		m.features = make(map[string]struct{})
	}
	for i := range ids {
		m.features[ids[i]] = struct{}{}
	}
}

// ClearFeatures clears the "features" edge to the Feature entity.
func (m *OrganizationMutation) ClearFeatures() {
	m.clearedfeatures = true
}

// FeaturesCleared reports if the "features" edge to the Feature entity was cleared.
func (m *OrganizationMutation) FeaturesCleared() bool {
	return m.clearedfeatures
}

// RemoveFeatureIDs removes the "features" edge to the Feature entity by IDs.
func (m *OrganizationMutation) RemoveFeatureIDs(ids ...string) {
	if m.removedfeatures == nil {
		m.removedfeatures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.features, ids[i])
		m.removedfeatures[ids[i]] = struct{}{}
	}
}

// RemovedFeatures returns the removed IDs of the "features" edge to the Feature entity.
func (m *OrganizationMutation) RemovedFeaturesIDs() (ids []string) {
	for id := range m.removedfeatures {
		ids = append(ids, id)
	}
	return
}

// FeaturesIDs returns the "features" edge IDs in the mutation.
func (m *OrganizationMutation) FeaturesIDs() (ids []string) {
	for id := range m.features {
		ids = append(ids, id)
	}
	return
}

// ResetFeatures resets all changes to the "features" edge.
func (m *OrganizationMutation) ResetFeatures() {
	m.features = nil
	m.clearedfeatures = false
	m.removedfeatures = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *OrganizationMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *OrganizationMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *OrganizationMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *OrganizationMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *OrganizationMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *OrganizationMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *OrganizationMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddEntitlementplanIDs adds the "entitlementplans" edge to the EntitlementPlan entity by ids.
func (m *OrganizationMutation) AddEntitlementplanIDs(ids ...string) {
	if m.entitlementplans == nil {
		m.entitlementplans = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlementplans[ids[i]] = struct{}{}
	}
}

// ClearEntitlementplans clears the "entitlementplans" edge to the EntitlementPlan entity.
func (m *OrganizationMutation) ClearEntitlementplans() {
	m.clearedentitlementplans = true
}

// EntitlementplansCleared reports if the "entitlementplans" edge to the EntitlementPlan entity was cleared.
func (m *OrganizationMutation) EntitlementplansCleared() bool {
	return m.clearedentitlementplans
}

// RemoveEntitlementplanIDs removes the "entitlementplans" edge to the EntitlementPlan entity by IDs.
func (m *OrganizationMutation) RemoveEntitlementplanIDs(ids ...string) {
	if m.removedentitlementplans == nil {
		m.removedentitlementplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlementplans, ids[i])
		m.removedentitlementplans[ids[i]] = struct{}{}
	}
}

// RemovedEntitlementplans returns the removed IDs of the "entitlementplans" edge to the EntitlementPlan entity.
func (m *OrganizationMutation) RemovedEntitlementplansIDs() (ids []string) {
	for id := range m.removedentitlementplans {
		ids = append(ids, id)
	}
	return
}

// EntitlementplansIDs returns the "entitlementplans" edge IDs in the mutation.
func (m *OrganizationMutation) EntitlementplansIDs() (ids []string) {
	for id := range m.entitlementplans {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlementplans resets all changes to the "entitlementplans" edge.
func (m *OrganizationMutation) ResetEntitlementplans() {
	m.entitlementplans = nil
	m.clearedentitlementplans = false
	m.removedentitlementplans = nil
}

// AddEntitlementplanfeatureIDs adds the "entitlementplanfeatures" edge to the EntitlementPlanFeature entity by ids.
func (m *OrganizationMutation) AddEntitlementplanfeatureIDs(ids ...string) {
	if m.entitlementplanfeatures == nil {
		m.entitlementplanfeatures = make(map[string]struct{})
	}
	for i := range ids {
		m.entitlementplanfeatures[ids[i]] = struct{}{}
	}
}

// ClearEntitlementplanfeatures clears the "entitlementplanfeatures" edge to the EntitlementPlanFeature entity.
func (m *OrganizationMutation) ClearEntitlementplanfeatures() {
	m.clearedentitlementplanfeatures = true
}

// EntitlementplanfeaturesCleared reports if the "entitlementplanfeatures" edge to the EntitlementPlanFeature entity was cleared.
func (m *OrganizationMutation) EntitlementplanfeaturesCleared() bool {
	return m.clearedentitlementplanfeatures
}

// RemoveEntitlementplanfeatureIDs removes the "entitlementplanfeatures" edge to the EntitlementPlanFeature entity by IDs.
func (m *OrganizationMutation) RemoveEntitlementplanfeatureIDs(ids ...string) {
	if m.removedentitlementplanfeatures == nil {
		m.removedentitlementplanfeatures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitlementplanfeatures, ids[i])
		m.removedentitlementplanfeatures[ids[i]] = struct{}{}
	}
}

// RemovedEntitlementplanfeatures returns the removed IDs of the "entitlementplanfeatures" edge to the EntitlementPlanFeature entity.
func (m *OrganizationMutation) RemovedEntitlementplanfeaturesIDs() (ids []string) {
	for id := range m.removedentitlementplanfeatures {
		ids = append(ids, id)
	}
	return
}

// EntitlementplanfeaturesIDs returns the "entitlementplanfeatures" edge IDs in the mutation.
func (m *OrganizationMutation) EntitlementplanfeaturesIDs() (ids []string) {
	for id := range m.entitlementplanfeatures {
		ids = append(ids, id)
	}
	return
}

// ResetEntitlementplanfeatures resets all changes to the "entitlementplanfeatures" edge.
func (m *OrganizationMutation) ResetEntitlementplanfeatures() {
	m.entitlementplanfeatures = nil
	m.clearedentitlementplanfeatures = false
	m.removedentitlementplanfeatures = nil
}

// AddEntityIDs adds the "entities" edge to the Entity entity by ids.
func (m *OrganizationMutation) AddEntityIDs(ids ...string) {
	if m.entities == nil {
		m.entities = make(map[string]struct{})
	}
	for i := range ids {
		m.entities[ids[i]] = struct{}{}
	}
}

// ClearEntities clears the "entities" edge to the Entity entity.
func (m *OrganizationMutation) ClearEntities() {
	m.clearedentities = true
}

// EntitiesCleared reports if the "entities" edge to the Entity entity was cleared.
func (m *OrganizationMutation) EntitiesCleared() bool {
	return m.clearedentities
}

// RemoveEntityIDs removes the "entities" edge to the Entity entity by IDs.
func (m *OrganizationMutation) RemoveEntityIDs(ids ...string) {
	if m.removedentities == nil {
		m.removedentities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entities, ids[i])
		m.removedentities[ids[i]] = struct{}{}
	}
}

// RemovedEntities returns the removed IDs of the "entities" edge to the Entity entity.
func (m *OrganizationMutation) RemovedEntitiesIDs() (ids []string) {
	for id := range m.removedentities {
		ids = append(ids, id)
	}
	return
}

// EntitiesIDs returns the "entities" edge IDs in the mutation.
func (m *OrganizationMutation) EntitiesIDs() (ids []string) {
	for id := range m.entities {
		ids = append(ids, id)
	}
	return
}

// ResetEntities resets all changes to the "entities" edge.
func (m *OrganizationMutation) ResetEntities() {
	m.entities = nil
	m.clearedentities = false
	m.removedentities = nil
}

// AddEntitytypeIDs adds the "entitytypes" edge to the EntityType entity by ids.
func (m *OrganizationMutation) AddEntitytypeIDs(ids ...string) {
	if m.entitytypes == nil {
		m.entitytypes = make(map[string]struct{})
	}
	for i := range ids {
		m.entitytypes[ids[i]] = struct{}{}
	}
}

// ClearEntitytypes clears the "entitytypes" edge to the EntityType entity.
func (m *OrganizationMutation) ClearEntitytypes() {
	m.clearedentitytypes = true
}

// EntitytypesCleared reports if the "entitytypes" edge to the EntityType entity was cleared.
func (m *OrganizationMutation) EntitytypesCleared() bool {
	return m.clearedentitytypes
}

// RemoveEntitytypeIDs removes the "entitytypes" edge to the EntityType entity by IDs.
func (m *OrganizationMutation) RemoveEntitytypeIDs(ids ...string) {
	if m.removedentitytypes == nil {
		m.removedentitytypes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.entitytypes, ids[i])
		m.removedentitytypes[ids[i]] = struct{}{}
	}
}

// RemovedEntitytypes returns the removed IDs of the "entitytypes" edge to the EntityType entity.
func (m *OrganizationMutation) RemovedEntitytypesIDs() (ids []string) {
	for id := range m.removedentitytypes {
		ids = append(ids, id)
	}
	return
}

// EntitytypesIDs returns the "entitytypes" edge IDs in the mutation.
func (m *OrganizationMutation) EntitytypesIDs() (ids []string) {
	for id := range m.entitytypes {
		ids = append(ids, id)
	}
	return
}

// ResetEntitytypes resets all changes to the "entitytypes" edge.
func (m *OrganizationMutation) ResetEntitytypes() {
	m.entitytypes = nil
	m.clearedentitytypes = false
	m.removedentitytypes = nil
}

// AddContactIDs adds the "contacts" edge to the Contact entity by ids.
func (m *OrganizationMutation) AddContactIDs(ids ...string) {
	if m.contacts == nil {
		m.contacts = make(map[string]struct{})
	}
	for i := range ids {
		m.contacts[ids[i]] = struct{}{}
	}
}

// ClearContacts clears the "contacts" edge to the Contact entity.
func (m *OrganizationMutation) ClearContacts() {
	m.clearedcontacts = true
}

// ContactsCleared reports if the "contacts" edge to the Contact entity was cleared.
func (m *OrganizationMutation) ContactsCleared() bool {
	return m.clearedcontacts
}

// RemoveContactIDs removes the "contacts" edge to the Contact entity by IDs.
func (m *OrganizationMutation) RemoveContactIDs(ids ...string) {
	if m.removedcontacts == nil {
		m.removedcontacts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.contacts, ids[i])
		m.removedcontacts[ids[i]] = struct{}{}
	}
}

// RemovedContacts returns the removed IDs of the "contacts" edge to the Contact entity.
func (m *OrganizationMutation) RemovedContactsIDs() (ids []string) {
	for id := range m.removedcontacts {
		ids = append(ids, id)
	}
	return
}

// ContactsIDs returns the "contacts" edge IDs in the mutation.
func (m *OrganizationMutation) ContactsIDs() (ids []string) {
	for id := range m.contacts {
		ids = append(ids, id)
	}
	return
}

// ResetContacts resets all changes to the "contacts" edge.
func (m *OrganizationMutation) ResetContacts() {
	m.contacts = nil
	m.clearedcontacts = false
	m.removedcontacts = nil
}

// AddNoteIDs adds the "notes" edge to the Note entity by ids.
func (m *OrganizationMutation) AddNoteIDs(ids ...string) {
	if m.notes == nil {
		m.notes = make(map[string]struct{})
	}
	for i := range ids {
		m.notes[ids[i]] = struct{}{}
	}
}

// ClearNotes clears the "notes" edge to the Note entity.
func (m *OrganizationMutation) ClearNotes() {
	m.clearednotes = true
}

// NotesCleared reports if the "notes" edge to the Note entity was cleared.
func (m *OrganizationMutation) NotesCleared() bool {
	return m.clearednotes
}

// RemoveNoteIDs removes the "notes" edge to the Note entity by IDs.
func (m *OrganizationMutation) RemoveNoteIDs(ids ...string) {
	if m.removednotes == nil {
		m.removednotes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notes, ids[i])
		m.removednotes[ids[i]] = struct{}{}
	}
}

// RemovedNotes returns the removed IDs of the "notes" edge to the Note entity.
func (m *OrganizationMutation) RemovedNotesIDs() (ids []string) {
	for id := range m.removednotes {
		ids = append(ids, id)
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
func (m *OrganizationMutation) NotesIDs() (ids []string) {
	for id := range m.notes {
		ids = append(ids, id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *OrganizationMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
	m.removednotes = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *OrganizationMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *OrganizationMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *OrganizationMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *OrganizationMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *OrganizationMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *OrganizationMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *OrganizationMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *OrganizationMutation) AddProgramIDs(ids ...string) {
	if m.programs == nil {
		m.programs = make(map[string]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *OrganizationMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *OrganizationMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *OrganizationMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *OrganizationMutation) RemovedProgramsIDs() (ids []string) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *OrganizationMutation) ProgramsIDs() (ids []string) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *OrganizationMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// AddMemberIDs adds the "members" edge to the OrgMembership entity by ids.
func (m *OrganizationMutation) AddMemberIDs(ids ...string) {
	if m.members == nil {
		m.members = make(map[string]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the OrgMembership entity.
func (m *OrganizationMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the OrgMembership entity was cleared.
func (m *OrganizationMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the OrgMembership entity by IDs.
func (m *OrganizationMutation) RemoveMemberIDs(ids ...string) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the OrgMembership entity.
func (m *OrganizationMutation) RemovedMembersIDs() (ids []string) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *OrganizationMutation) MembersIDs() (ids []string) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *OrganizationMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, organization.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, organization.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, organization.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, organization.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, organization.FieldDescription)
	}
	if m.parent != nil {
		fields = append(fields, organization.FieldParentOrganizationID)
	}
	if m.personal_org != nil {
		fields = append(fields, organization.FieldPersonalOrg)
	}
	if m.avatar_remote_url != nil {
		fields = append(fields, organization.FieldAvatarRemoteURL)
	}
	if m.dedicated_db != nil {
		fields = append(fields, organization.FieldDedicatedDb)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldCreatedBy:
		return m.CreatedBy()
	case organization.FieldUpdatedBy:
		return m.UpdatedBy()
	case organization.FieldMappingID:
		return m.MappingID()
	case organization.FieldTags:
		return m.Tags()
	case organization.FieldDeletedAt:
		return m.DeletedAt()
	case organization.FieldDeletedBy:
		return m.DeletedBy()
	case organization.FieldName:
		return m.Name()
	case organization.FieldDisplayName:
		return m.DisplayName()
	case organization.FieldDescription:
		return m.Description()
	case organization.FieldParentOrganizationID:
		return m.ParentOrganizationID()
	case organization.FieldPersonalOrg:
		return m.PersonalOrg()
	case organization.FieldAvatarRemoteURL:
		return m.AvatarRemoteURL()
	case organization.FieldDedicatedDb:
		return m.DedicatedDb()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organization.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organization.FieldMappingID:
		return m.OldMappingID(ctx)
	case organization.FieldTags:
		return m.OldTags(ctx)
	case organization.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organization.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case organization.FieldDescription:
		return m.OldDescription(ctx)
	case organization.FieldParentOrganizationID:
		return m.OldParentOrganizationID(ctx)
	case organization.FieldPersonalOrg:
		return m.OldPersonalOrg(ctx)
	case organization.FieldAvatarRemoteURL:
		return m.OldAvatarRemoteURL(ctx)
	case organization.FieldDedicatedDb:
		return m.OldDedicatedDb(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organization.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case organization.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case organization.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organization.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case organization.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organization.FieldParentOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentOrganizationID(v)
		return nil
	case organization.FieldPersonalOrg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalOrg(v)
		return nil
	case organization.FieldAvatarRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarRemoteURL(v)
		return nil
	case organization.FieldDedicatedDb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDedicatedDb(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldCreatedAt) {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.FieldCleared(organization.FieldUpdatedAt) {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.FieldCleared(organization.FieldCreatedBy) {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.FieldCleared(organization.FieldUpdatedBy) {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.FieldCleared(organization.FieldTags) {
		fields = append(fields, organization.FieldTags)
	}
	if m.FieldCleared(organization.FieldDeletedAt) {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.FieldCleared(organization.FieldDeletedBy) {
		fields = append(fields, organization.FieldDeletedBy)
	}
	if m.FieldCleared(organization.FieldDescription) {
		fields = append(fields, organization.FieldDescription)
	}
	if m.FieldCleared(organization.FieldParentOrganizationID) {
		fields = append(fields, organization.FieldParentOrganizationID)
	}
	if m.FieldCleared(organization.FieldPersonalOrg) {
		fields = append(fields, organization.FieldPersonalOrg)
	}
	if m.FieldCleared(organization.FieldAvatarRemoteURL) {
		fields = append(fields, organization.FieldAvatarRemoteURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organization.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organization.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organization.FieldTags:
		m.ClearTags()
		return nil
	case organization.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organization.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case organization.FieldDescription:
		m.ClearDescription()
		return nil
	case organization.FieldParentOrganizationID:
		m.ClearParentOrganizationID()
		return nil
	case organization.FieldPersonalOrg:
		m.ClearPersonalOrg()
		return nil
	case organization.FieldAvatarRemoteURL:
		m.ClearAvatarRemoteURL()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organization.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organization.FieldMappingID:
		m.ResetMappingID()
		return nil
	case organization.FieldTags:
		m.ResetTags()
		return nil
	case organization.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organization.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case organization.FieldDescription:
		m.ResetDescription()
		return nil
	case organization.FieldParentOrganizationID:
		m.ResetParentOrganizationID()
		return nil
	case organization.FieldPersonalOrg:
		m.ResetPersonalOrg()
		return nil
	case organization.FieldAvatarRemoteURL:
		m.ResetAvatarRemoteURL()
		return nil
	case organization.FieldDedicatedDb:
		m.ResetDedicatedDb()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 29)
	if m.parent != nil {
		edges = append(edges, organization.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.groups != nil {
		edges = append(edges, organization.EdgeGroups)
	}
	if m.templates != nil {
		edges = append(edges, organization.EdgeTemplates)
	}
	if m.integrations != nil {
		edges = append(edges, organization.EdgeIntegrations)
	}
	if m.setting != nil {
		edges = append(edges, organization.EdgeSetting)
	}
	if m.documentdata != nil {
		edges = append(edges, organization.EdgeDocumentdata)
	}
	if m.entitlements != nil {
		edges = append(edges, organization.EdgeEntitlements)
	}
	if m.organization_entitlement != nil {
		edges = append(edges, organization.EdgeOrganizationEntitlement)
	}
	if m.personal_access_tokens != nil {
		edges = append(edges, organization.EdgePersonalAccessTokens)
	}
	if m.api_tokens != nil {
		edges = append(edges, organization.EdgeAPITokens)
	}
	if m.oauthprovider != nil {
		edges = append(edges, organization.EdgeOauthprovider)
	}
	if m.users != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.invites != nil {
		edges = append(edges, organization.EdgeInvites)
	}
	if m.subscribers != nil {
		edges = append(edges, organization.EdgeSubscribers)
	}
	if m.webhooks != nil {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.events != nil {
		edges = append(edges, organization.EdgeEvents)
	}
	if m.secrets != nil {
		edges = append(edges, organization.EdgeSecrets)
	}
	if m.features != nil {
		edges = append(edges, organization.EdgeFeatures)
	}
	if m.files != nil {
		edges = append(edges, organization.EdgeFiles)
	}
	if m.entitlementplans != nil {
		edges = append(edges, organization.EdgeEntitlementplans)
	}
	if m.entitlementplanfeatures != nil {
		edges = append(edges, organization.EdgeEntitlementplanfeatures)
	}
	if m.entities != nil {
		edges = append(edges, organization.EdgeEntities)
	}
	if m.entitytypes != nil {
		edges = append(edges, organization.EdgeEntitytypes)
	}
	if m.contacts != nil {
		edges = append(edges, organization.EdgeContacts)
	}
	if m.notes != nil {
		edges = append(edges, organization.EdgeNotes)
	}
	if m.tasks != nil {
		edges = append(edges, organization.EdgeTasks)
	}
	if m.programs != nil {
		edges = append(edges, organization.EdgePrograms)
	}
	if m.members != nil {
		edges = append(edges, organization.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.templates))
		for id := range m.templates {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.integrations))
		for id := range m.integrations {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSetting:
		if id := m.setting; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeDocumentdata:
		ids := make([]ent.Value, 0, len(m.documentdata))
		for id := range m.documentdata {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.entitlements))
		for id := range m.entitlements {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOrganizationEntitlement:
		ids := make([]ent.Value, 0, len(m.organization_entitlement))
		for id := range m.organization_entitlement {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePersonalAccessTokens:
		ids := make([]ent.Value, 0, len(m.personal_access_tokens))
		for id := range m.personal_access_tokens {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.api_tokens))
		for id := range m.api_tokens {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOauthprovider:
		ids := make([]ent.Value, 0, len(m.oauthprovider))
		for id := range m.oauthprovider {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.invites))
		for id := range m.invites {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSubscribers:
		ids := make([]ent.Value, 0, len(m.subscribers))
		for id := range m.subscribers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.webhooks))
		for id := range m.webhooks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.secrets))
		for id := range m.secrets {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.features))
		for id := range m.features {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntitlementplans:
		ids := make([]ent.Value, 0, len(m.entitlementplans))
		for id := range m.entitlementplans {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntitlementplanfeatures:
		ids := make([]ent.Value, 0, len(m.entitlementplanfeatures))
		for id := range m.entitlementplanfeatures {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.entities))
		for id := range m.entities {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntitytypes:
		ids := make([]ent.Value, 0, len(m.entitytypes))
		for id := range m.entitytypes {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.contacts))
		for id := range m.contacts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.notes))
		for id := range m.notes {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 29)
	if m.removedchildren != nil {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.removedgroups != nil {
		edges = append(edges, organization.EdgeGroups)
	}
	if m.removedtemplates != nil {
		edges = append(edges, organization.EdgeTemplates)
	}
	if m.removedintegrations != nil {
		edges = append(edges, organization.EdgeIntegrations)
	}
	if m.removeddocumentdata != nil {
		edges = append(edges, organization.EdgeDocumentdata)
	}
	if m.removedentitlements != nil {
		edges = append(edges, organization.EdgeEntitlements)
	}
	if m.removedorganization_entitlement != nil {
		edges = append(edges, organization.EdgeOrganizationEntitlement)
	}
	if m.removedpersonal_access_tokens != nil {
		edges = append(edges, organization.EdgePersonalAccessTokens)
	}
	if m.removedapi_tokens != nil {
		edges = append(edges, organization.EdgeAPITokens)
	}
	if m.removedoauthprovider != nil {
		edges = append(edges, organization.EdgeOauthprovider)
	}
	if m.removedusers != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.removedinvites != nil {
		edges = append(edges, organization.EdgeInvites)
	}
	if m.removedsubscribers != nil {
		edges = append(edges, organization.EdgeSubscribers)
	}
	if m.removedwebhooks != nil {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.removedevents != nil {
		edges = append(edges, organization.EdgeEvents)
	}
	if m.removedsecrets != nil {
		edges = append(edges, organization.EdgeSecrets)
	}
	if m.removedfeatures != nil {
		edges = append(edges, organization.EdgeFeatures)
	}
	if m.removedfiles != nil {
		edges = append(edges, organization.EdgeFiles)
	}
	if m.removedentitlementplans != nil {
		edges = append(edges, organization.EdgeEntitlementplans)
	}
	if m.removedentitlementplanfeatures != nil {
		edges = append(edges, organization.EdgeEntitlementplanfeatures)
	}
	if m.removedentities != nil {
		edges = append(edges, organization.EdgeEntities)
	}
	if m.removedentitytypes != nil {
		edges = append(edges, organization.EdgeEntitytypes)
	}
	if m.removedcontacts != nil {
		edges = append(edges, organization.EdgeContacts)
	}
	if m.removednotes != nil {
		edges = append(edges, organization.EdgeNotes)
	}
	if m.removedtasks != nil {
		edges = append(edges, organization.EdgeTasks)
	}
	if m.removedprograms != nil {
		edges = append(edges, organization.EdgePrograms)
	}
	if m.removedmembers != nil {
		edges = append(edges, organization.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeTemplates:
		ids := make([]ent.Value, 0, len(m.removedtemplates))
		for id := range m.removedtemplates {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.removedintegrations))
		for id := range m.removedintegrations {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeDocumentdata:
		ids := make([]ent.Value, 0, len(m.removeddocumentdata))
		for id := range m.removeddocumentdata {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntitlements:
		ids := make([]ent.Value, 0, len(m.removedentitlements))
		for id := range m.removedentitlements {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOrganizationEntitlement:
		ids := make([]ent.Value, 0, len(m.removedorganization_entitlement))
		for id := range m.removedorganization_entitlement {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePersonalAccessTokens:
		ids := make([]ent.Value, 0, len(m.removedpersonal_access_tokens))
		for id := range m.removedpersonal_access_tokens {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAPITokens:
		ids := make([]ent.Value, 0, len(m.removedapi_tokens))
		for id := range m.removedapi_tokens {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOauthprovider:
		ids := make([]ent.Value, 0, len(m.removedoauthprovider))
		for id := range m.removedoauthprovider {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.removedinvites))
		for id := range m.removedinvites {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSubscribers:
		ids := make([]ent.Value, 0, len(m.removedsubscribers))
		for id := range m.removedsubscribers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.removedwebhooks))
		for id := range m.removedwebhooks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.removedsecrets))
		for id := range m.removedsecrets {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeFeatures:
		ids := make([]ent.Value, 0, len(m.removedfeatures))
		for id := range m.removedfeatures {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntitlementplans:
		ids := make([]ent.Value, 0, len(m.removedentitlementplans))
		for id := range m.removedentitlementplans {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntitlementplanfeatures:
		ids := make([]ent.Value, 0, len(m.removedentitlementplanfeatures))
		for id := range m.removedentitlementplanfeatures {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntities:
		ids := make([]ent.Value, 0, len(m.removedentities))
		for id := range m.removedentities {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEntitytypes:
		ids := make([]ent.Value, 0, len(m.removedentitytypes))
		for id := range m.removedentitytypes {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.removedcontacts))
		for id := range m.removedcontacts {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.removednotes))
		for id := range m.removednotes {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 29)
	if m.clearedparent {
		edges = append(edges, organization.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.clearedgroups {
		edges = append(edges, organization.EdgeGroups)
	}
	if m.clearedtemplates {
		edges = append(edges, organization.EdgeTemplates)
	}
	if m.clearedintegrations {
		edges = append(edges, organization.EdgeIntegrations)
	}
	if m.clearedsetting {
		edges = append(edges, organization.EdgeSetting)
	}
	if m.cleareddocumentdata {
		edges = append(edges, organization.EdgeDocumentdata)
	}
	if m.clearedentitlements {
		edges = append(edges, organization.EdgeEntitlements)
	}
	if m.clearedorganization_entitlement {
		edges = append(edges, organization.EdgeOrganizationEntitlement)
	}
	if m.clearedpersonal_access_tokens {
		edges = append(edges, organization.EdgePersonalAccessTokens)
	}
	if m.clearedapi_tokens {
		edges = append(edges, organization.EdgeAPITokens)
	}
	if m.clearedoauthprovider {
		edges = append(edges, organization.EdgeOauthprovider)
	}
	if m.clearedusers {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.clearedinvites {
		edges = append(edges, organization.EdgeInvites)
	}
	if m.clearedsubscribers {
		edges = append(edges, organization.EdgeSubscribers)
	}
	if m.clearedwebhooks {
		edges = append(edges, organization.EdgeWebhooks)
	}
	if m.clearedevents {
		edges = append(edges, organization.EdgeEvents)
	}
	if m.clearedsecrets {
		edges = append(edges, organization.EdgeSecrets)
	}
	if m.clearedfeatures {
		edges = append(edges, organization.EdgeFeatures)
	}
	if m.clearedfiles {
		edges = append(edges, organization.EdgeFiles)
	}
	if m.clearedentitlementplans {
		edges = append(edges, organization.EdgeEntitlementplans)
	}
	if m.clearedentitlementplanfeatures {
		edges = append(edges, organization.EdgeEntitlementplanfeatures)
	}
	if m.clearedentities {
		edges = append(edges, organization.EdgeEntities)
	}
	if m.clearedentitytypes {
		edges = append(edges, organization.EdgeEntitytypes)
	}
	if m.clearedcontacts {
		edges = append(edges, organization.EdgeContacts)
	}
	if m.clearednotes {
		edges = append(edges, organization.EdgeNotes)
	}
	if m.clearedtasks {
		edges = append(edges, organization.EdgeTasks)
	}
	if m.clearedprograms {
		edges = append(edges, organization.EdgePrograms)
	}
	if m.clearedmembers {
		edges = append(edges, organization.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeParent:
		return m.clearedparent
	case organization.EdgeChildren:
		return m.clearedchildren
	case organization.EdgeGroups:
		return m.clearedgroups
	case organization.EdgeTemplates:
		return m.clearedtemplates
	case organization.EdgeIntegrations:
		return m.clearedintegrations
	case organization.EdgeSetting:
		return m.clearedsetting
	case organization.EdgeDocumentdata:
		return m.cleareddocumentdata
	case organization.EdgeEntitlements:
		return m.clearedentitlements
	case organization.EdgeOrganizationEntitlement:
		return m.clearedorganization_entitlement
	case organization.EdgePersonalAccessTokens:
		return m.clearedpersonal_access_tokens
	case organization.EdgeAPITokens:
		return m.clearedapi_tokens
	case organization.EdgeOauthprovider:
		return m.clearedoauthprovider
	case organization.EdgeUsers:
		return m.clearedusers
	case organization.EdgeInvites:
		return m.clearedinvites
	case organization.EdgeSubscribers:
		return m.clearedsubscribers
	case organization.EdgeWebhooks:
		return m.clearedwebhooks
	case organization.EdgeEvents:
		return m.clearedevents
	case organization.EdgeSecrets:
		return m.clearedsecrets
	case organization.EdgeFeatures:
		return m.clearedfeatures
	case organization.EdgeFiles:
		return m.clearedfiles
	case organization.EdgeEntitlementplans:
		return m.clearedentitlementplans
	case organization.EdgeEntitlementplanfeatures:
		return m.clearedentitlementplanfeatures
	case organization.EdgeEntities:
		return m.clearedentities
	case organization.EdgeEntitytypes:
		return m.clearedentitytypes
	case organization.EdgeContacts:
		return m.clearedcontacts
	case organization.EdgeNotes:
		return m.clearednotes
	case organization.EdgeTasks:
		return m.clearedtasks
	case organization.EdgePrograms:
		return m.clearedprograms
	case organization.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeParent:
		m.ClearParent()
		return nil
	case organization.EdgeSetting:
		m.ClearSetting()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeParent:
		m.ResetParent()
		return nil
	case organization.EdgeChildren:
		m.ResetChildren()
		return nil
	case organization.EdgeGroups:
		m.ResetGroups()
		return nil
	case organization.EdgeTemplates:
		m.ResetTemplates()
		return nil
	case organization.EdgeIntegrations:
		m.ResetIntegrations()
		return nil
	case organization.EdgeSetting:
		m.ResetSetting()
		return nil
	case organization.EdgeDocumentdata:
		m.ResetDocumentdata()
		return nil
	case organization.EdgeEntitlements:
		m.ResetEntitlements()
		return nil
	case organization.EdgeOrganizationEntitlement:
		m.ResetOrganizationEntitlement()
		return nil
	case organization.EdgePersonalAccessTokens:
		m.ResetPersonalAccessTokens()
		return nil
	case organization.EdgeAPITokens:
		m.ResetAPITokens()
		return nil
	case organization.EdgeOauthprovider:
		m.ResetOauthprovider()
		return nil
	case organization.EdgeUsers:
		m.ResetUsers()
		return nil
	case organization.EdgeInvites:
		m.ResetInvites()
		return nil
	case organization.EdgeSubscribers:
		m.ResetSubscribers()
		return nil
	case organization.EdgeWebhooks:
		m.ResetWebhooks()
		return nil
	case organization.EdgeEvents:
		m.ResetEvents()
		return nil
	case organization.EdgeSecrets:
		m.ResetSecrets()
		return nil
	case organization.EdgeFeatures:
		m.ResetFeatures()
		return nil
	case organization.EdgeFiles:
		m.ResetFiles()
		return nil
	case organization.EdgeEntitlementplans:
		m.ResetEntitlementplans()
		return nil
	case organization.EdgeEntitlementplanfeatures:
		m.ResetEntitlementplanfeatures()
		return nil
	case organization.EdgeEntities:
		m.ResetEntities()
		return nil
	case organization.EdgeEntitytypes:
		m.ResetEntitytypes()
		return nil
	case organization.EdgeContacts:
		m.ResetContacts()
		return nil
	case organization.EdgeNotes:
		m.ResetNotes()
		return nil
	case organization.EdgeTasks:
		m.ResetTasks()
		return nil
	case organization.EdgePrograms:
		m.ResetPrograms()
		return nil
	case organization.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationHistoryMutation represents an operation that mutates the OrganizationHistory nodes in the graph.
type OrganizationHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	history_time           *time.Time
	ref                    *string
	operation              *history.OpType
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	mapping_id             *string
	tags                   *[]string
	appendtags             []string
	deleted_at             *time.Time
	deleted_by             *string
	name                   *string
	display_name           *string
	description            *string
	parent_organization_id *string
	personal_org           *bool
	avatar_remote_url      *string
	dedicated_db           *bool
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*OrganizationHistory, error)
	predicates             []predicate.OrganizationHistory
}

var _ ent.Mutation = (*OrganizationHistoryMutation)(nil)

// organizationhistoryOption allows management of the mutation configuration using functional options.
type organizationhistoryOption func(*OrganizationHistoryMutation)

// newOrganizationHistoryMutation creates new mutation for the OrganizationHistory entity.
func newOrganizationHistoryMutation(c config, op Op, opts ...organizationhistoryOption) *OrganizationHistoryMutation {
	m := &OrganizationHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationHistoryID sets the ID field of the mutation.
func withOrganizationHistoryID(id string) organizationhistoryOption {
	return func(m *OrganizationHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationHistory
		)
		m.oldValue = func(ctx context.Context) (*OrganizationHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationHistory sets the old OrganizationHistory of the mutation.
func withOrganizationHistory(node *OrganizationHistory) organizationhistoryOption {
	return func(m *OrganizationHistoryMutation) {
		m.oldValue = func(context.Context) (*OrganizationHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationHistory entities.
func (m *OrganizationHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *OrganizationHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *OrganizationHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *OrganizationHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *OrganizationHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *OrganizationHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *OrganizationHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[organizationhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *OrganizationHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, organizationhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *OrganizationHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *OrganizationHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *OrganizationHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrganizationHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[organizationhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, organizationhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organizationhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organizationhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organizationhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organizationhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *OrganizationHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OrganizationHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OrganizationHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *OrganizationHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OrganizationHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OrganizationHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OrganizationHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OrganizationHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[organizationhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OrganizationHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, organizationhistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrganizationHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrganizationHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrganizationHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[organizationhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrganizationHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, organizationhistory.FieldDeletedBy)
}

// SetName sets the "name" field.
func (m *OrganizationHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationHistoryMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OrganizationHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrganizationHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrganizationHistoryMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetDescription sets the "description" field.
func (m *OrganizationHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organizationhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organizationhistory.FieldDescription)
}

// SetParentOrganizationID sets the "parent_organization_id" field.
func (m *OrganizationHistoryMutation) SetParentOrganizationID(s string) {
	m.parent_organization_id = &s
}

// ParentOrganizationID returns the value of the "parent_organization_id" field in the mutation.
func (m *OrganizationHistoryMutation) ParentOrganizationID() (r string, exists bool) {
	v := m.parent_organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentOrganizationID returns the old "parent_organization_id" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldParentOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentOrganizationID: %w", err)
	}
	return oldValue.ParentOrganizationID, nil
}

// ClearParentOrganizationID clears the value of the "parent_organization_id" field.
func (m *OrganizationHistoryMutation) ClearParentOrganizationID() {
	m.parent_organization_id = nil
	m.clearedFields[organizationhistory.FieldParentOrganizationID] = struct{}{}
}

// ParentOrganizationIDCleared returns if the "parent_organization_id" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) ParentOrganizationIDCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldParentOrganizationID]
	return ok
}

// ResetParentOrganizationID resets all changes to the "parent_organization_id" field.
func (m *OrganizationHistoryMutation) ResetParentOrganizationID() {
	m.parent_organization_id = nil
	delete(m.clearedFields, organizationhistory.FieldParentOrganizationID)
}

// SetPersonalOrg sets the "personal_org" field.
func (m *OrganizationHistoryMutation) SetPersonalOrg(b bool) {
	m.personal_org = &b
}

// PersonalOrg returns the value of the "personal_org" field in the mutation.
func (m *OrganizationHistoryMutation) PersonalOrg() (r bool, exists bool) {
	v := m.personal_org
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalOrg returns the old "personal_org" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldPersonalOrg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalOrg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalOrg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalOrg: %w", err)
	}
	return oldValue.PersonalOrg, nil
}

// ClearPersonalOrg clears the value of the "personal_org" field.
func (m *OrganizationHistoryMutation) ClearPersonalOrg() {
	m.personal_org = nil
	m.clearedFields[organizationhistory.FieldPersonalOrg] = struct{}{}
}

// PersonalOrgCleared returns if the "personal_org" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) PersonalOrgCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldPersonalOrg]
	return ok
}

// ResetPersonalOrg resets all changes to the "personal_org" field.
func (m *OrganizationHistoryMutation) ResetPersonalOrg() {
	m.personal_org = nil
	delete(m.clearedFields, organizationhistory.FieldPersonalOrg)
}

// SetAvatarRemoteURL sets the "avatar_remote_url" field.
func (m *OrganizationHistoryMutation) SetAvatarRemoteURL(s string) {
	m.avatar_remote_url = &s
}

// AvatarRemoteURL returns the value of the "avatar_remote_url" field in the mutation.
func (m *OrganizationHistoryMutation) AvatarRemoteURL() (r string, exists bool) {
	v := m.avatar_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarRemoteURL returns the old "avatar_remote_url" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldAvatarRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarRemoteURL: %w", err)
	}
	return oldValue.AvatarRemoteURL, nil
}

// ClearAvatarRemoteURL clears the value of the "avatar_remote_url" field.
func (m *OrganizationHistoryMutation) ClearAvatarRemoteURL() {
	m.avatar_remote_url = nil
	m.clearedFields[organizationhistory.FieldAvatarRemoteURL] = struct{}{}
}

// AvatarRemoteURLCleared returns if the "avatar_remote_url" field was cleared in this mutation.
func (m *OrganizationHistoryMutation) AvatarRemoteURLCleared() bool {
	_, ok := m.clearedFields[organizationhistory.FieldAvatarRemoteURL]
	return ok
}

// ResetAvatarRemoteURL resets all changes to the "avatar_remote_url" field.
func (m *OrganizationHistoryMutation) ResetAvatarRemoteURL() {
	m.avatar_remote_url = nil
	delete(m.clearedFields, organizationhistory.FieldAvatarRemoteURL)
}

// SetDedicatedDb sets the "dedicated_db" field.
func (m *OrganizationHistoryMutation) SetDedicatedDb(b bool) {
	m.dedicated_db = &b
}

// DedicatedDb returns the value of the "dedicated_db" field in the mutation.
func (m *OrganizationHistoryMutation) DedicatedDb() (r bool, exists bool) {
	v := m.dedicated_db
	if v == nil {
		return
	}
	return *v, true
}

// OldDedicatedDb returns the old "dedicated_db" field's value of the OrganizationHistory entity.
// If the OrganizationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationHistoryMutation) OldDedicatedDb(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDedicatedDb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDedicatedDb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDedicatedDb: %w", err)
	}
	return oldValue.DedicatedDb, nil
}

// ResetDedicatedDb resets all changes to the "dedicated_db" field.
func (m *OrganizationHistoryMutation) ResetDedicatedDb() {
	m.dedicated_db = nil
}

// Where appends a list predicates to the OrganizationHistoryMutation builder.
func (m *OrganizationHistoryMutation) Where(ps ...predicate.OrganizationHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationHistory).
func (m *OrganizationHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationHistoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.history_time != nil {
		fields = append(fields, organizationhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, organizationhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, organizationhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, organizationhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organizationhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, organizationhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, organizationhistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, organizationhistory.FieldDeletedBy)
	}
	if m.name != nil {
		fields = append(fields, organizationhistory.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, organizationhistory.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, organizationhistory.FieldDescription)
	}
	if m.parent_organization_id != nil {
		fields = append(fields, organizationhistory.FieldParentOrganizationID)
	}
	if m.personal_org != nil {
		fields = append(fields, organizationhistory.FieldPersonalOrg)
	}
	if m.avatar_remote_url != nil {
		fields = append(fields, organizationhistory.FieldAvatarRemoteURL)
	}
	if m.dedicated_db != nil {
		fields = append(fields, organizationhistory.FieldDedicatedDb)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationhistory.FieldHistoryTime:
		return m.HistoryTime()
	case organizationhistory.FieldRef:
		return m.Ref()
	case organizationhistory.FieldOperation:
		return m.Operation()
	case organizationhistory.FieldCreatedAt:
		return m.CreatedAt()
	case organizationhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationhistory.FieldCreatedBy:
		return m.CreatedBy()
	case organizationhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationhistory.FieldMappingID:
		return m.MappingID()
	case organizationhistory.FieldTags:
		return m.Tags()
	case organizationhistory.FieldDeletedAt:
		return m.DeletedAt()
	case organizationhistory.FieldDeletedBy:
		return m.DeletedBy()
	case organizationhistory.FieldName:
		return m.Name()
	case organizationhistory.FieldDisplayName:
		return m.DisplayName()
	case organizationhistory.FieldDescription:
		return m.Description()
	case organizationhistory.FieldParentOrganizationID:
		return m.ParentOrganizationID()
	case organizationhistory.FieldPersonalOrg:
		return m.PersonalOrg()
	case organizationhistory.FieldAvatarRemoteURL:
		return m.AvatarRemoteURL()
	case organizationhistory.FieldDedicatedDb:
		return m.DedicatedDb()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case organizationhistory.FieldRef:
		return m.OldRef(ctx)
	case organizationhistory.FieldOperation:
		return m.OldOperation(ctx)
	case organizationhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case organizationhistory.FieldTags:
		return m.OldTags(ctx)
	case organizationhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case organizationhistory.FieldName:
		return m.OldName(ctx)
	case organizationhistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case organizationhistory.FieldDescription:
		return m.OldDescription(ctx)
	case organizationhistory.FieldParentOrganizationID:
		return m.OldParentOrganizationID(ctx)
	case organizationhistory.FieldPersonalOrg:
		return m.OldPersonalOrg(ctx)
	case organizationhistory.FieldAvatarRemoteURL:
		return m.OldAvatarRemoteURL(ctx)
	case organizationhistory.FieldDedicatedDb:
		return m.OldDedicatedDb(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case organizationhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case organizationhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case organizationhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case organizationhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case organizationhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case organizationhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationhistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case organizationhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organizationhistory.FieldParentOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentOrganizationID(v)
		return nil
	case organizationhistory.FieldPersonalOrg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalOrg(v)
		return nil
	case organizationhistory.FieldAvatarRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarRemoteURL(v)
		return nil
	case organizationhistory.FieldDedicatedDb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDedicatedDb(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationhistory.FieldRef) {
		fields = append(fields, organizationhistory.FieldRef)
	}
	if m.FieldCleared(organizationhistory.FieldCreatedAt) {
		fields = append(fields, organizationhistory.FieldCreatedAt)
	}
	if m.FieldCleared(organizationhistory.FieldUpdatedAt) {
		fields = append(fields, organizationhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(organizationhistory.FieldCreatedBy) {
		fields = append(fields, organizationhistory.FieldCreatedBy)
	}
	if m.FieldCleared(organizationhistory.FieldUpdatedBy) {
		fields = append(fields, organizationhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationhistory.FieldTags) {
		fields = append(fields, organizationhistory.FieldTags)
	}
	if m.FieldCleared(organizationhistory.FieldDeletedAt) {
		fields = append(fields, organizationhistory.FieldDeletedAt)
	}
	if m.FieldCleared(organizationhistory.FieldDeletedBy) {
		fields = append(fields, organizationhistory.FieldDeletedBy)
	}
	if m.FieldCleared(organizationhistory.FieldDescription) {
		fields = append(fields, organizationhistory.FieldDescription)
	}
	if m.FieldCleared(organizationhistory.FieldParentOrganizationID) {
		fields = append(fields, organizationhistory.FieldParentOrganizationID)
	}
	if m.FieldCleared(organizationhistory.FieldPersonalOrg) {
		fields = append(fields, organizationhistory.FieldPersonalOrg)
	}
	if m.FieldCleared(organizationhistory.FieldAvatarRemoteURL) {
		fields = append(fields, organizationhistory.FieldAvatarRemoteURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationHistoryMutation) ClearField(name string) error {
	switch name {
	case organizationhistory.FieldRef:
		m.ClearRef()
		return nil
	case organizationhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case organizationhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organizationhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organizationhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationhistory.FieldTags:
		m.ClearTags()
		return nil
	case organizationhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organizationhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case organizationhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case organizationhistory.FieldParentOrganizationID:
		m.ClearParentOrganizationID()
		return nil
	case organizationhistory.FieldPersonalOrg:
		m.ClearPersonalOrg()
		return nil
	case organizationhistory.FieldAvatarRemoteURL:
		m.ClearAvatarRemoteURL()
		return nil
	}
	return fmt.Errorf("unknown OrganizationHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationHistoryMutation) ResetField(name string) error {
	switch name {
	case organizationhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case organizationhistory.FieldRef:
		m.ResetRef()
		return nil
	case organizationhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case organizationhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case organizationhistory.FieldTags:
		m.ResetTags()
		return nil
	case organizationhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case organizationhistory.FieldName:
		m.ResetName()
		return nil
	case organizationhistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case organizationhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case organizationhistory.FieldParentOrganizationID:
		m.ResetParentOrganizationID()
		return nil
	case organizationhistory.FieldPersonalOrg:
		m.ResetPersonalOrg()
		return nil
	case organizationhistory.FieldAvatarRemoteURL:
		m.ResetAvatarRemoteURL()
		return nil
	case organizationhistory.FieldDedicatedDb:
		m.ResetDedicatedDb()
		return nil
	}
	return fmt.Errorf("unknown OrganizationHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrganizationHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrganizationHistory edge %s", name)
}

// OrganizationSettingMutation represents an operation that mutates the OrganizationSetting nodes in the graph.
type OrganizationSettingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	mapping_id          *string
	tags                *[]string
	appendtags          []string
	deleted_at          *time.Time
	deleted_by          *string
	domains             *[]string
	appenddomains       []string
	billing_contact     *string
	billing_email       *string
	billing_phone       *string
	billing_address     *string
	tax_identifier      *string
	geo_location        *enums.Region
	clearedFields       map[string]struct{}
	organization        *string
	clearedorganization bool
	files               map[string]struct{}
	removedfiles        map[string]struct{}
	clearedfiles        bool
	done                bool
	oldValue            func(context.Context) (*OrganizationSetting, error)
	predicates          []predicate.OrganizationSetting
}

var _ ent.Mutation = (*OrganizationSettingMutation)(nil)

// organizationsettingOption allows management of the mutation configuration using functional options.
type organizationsettingOption func(*OrganizationSettingMutation)

// newOrganizationSettingMutation creates new mutation for the OrganizationSetting entity.
func newOrganizationSettingMutation(c config, op Op, opts ...organizationsettingOption) *OrganizationSettingMutation {
	m := &OrganizationSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationSettingID sets the ID field of the mutation.
func withOrganizationSettingID(id string) organizationsettingOption {
	return func(m *OrganizationSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationSetting
		)
		m.oldValue = func(ctx context.Context) (*OrganizationSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationSetting sets the old OrganizationSetting of the mutation.
func withOrganizationSetting(node *OrganizationSetting) organizationsettingOption {
	return func(m *OrganizationSettingMutation) {
		m.oldValue = func(context.Context) (*OrganizationSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationSetting entities.
func (m *OrganizationSettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationSettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationSettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrganizationSettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[organizationsetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrganizationSettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationSettingMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, organizationsetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationSettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationsetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationSettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationsetting.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationSettingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationSettingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationSettingMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organizationsetting.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationSettingMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationSettingMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organizationsetting.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationSettingMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationSettingMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationSettingMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organizationsetting.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationSettingMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationSettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organizationsetting.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *OrganizationSettingMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OrganizationSettingMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OrganizationSettingMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *OrganizationSettingMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OrganizationSettingMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OrganizationSettingMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OrganizationSettingMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OrganizationSettingMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[organizationsetting.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OrganizationSettingMutation) TagsCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OrganizationSettingMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, organizationsetting.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationSettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationSettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationSettingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationsetting.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationSettingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationSettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationsetting.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrganizationSettingMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrganizationSettingMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrganizationSettingMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[organizationsetting.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrganizationSettingMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrganizationSettingMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, organizationsetting.FieldDeletedBy)
}

// SetDomains sets the "domains" field.
func (m *OrganizationSettingMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *OrganizationSettingMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *OrganizationSettingMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *OrganizationSettingMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *OrganizationSettingMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[organizationsetting.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *OrganizationSettingMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *OrganizationSettingMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, organizationsetting.FieldDomains)
}

// SetBillingContact sets the "billing_contact" field.
func (m *OrganizationSettingMutation) SetBillingContact(s string) {
	m.billing_contact = &s
}

// BillingContact returns the value of the "billing_contact" field in the mutation.
func (m *OrganizationSettingMutation) BillingContact() (r string, exists bool) {
	v := m.billing_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingContact returns the old "billing_contact" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldBillingContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingContact: %w", err)
	}
	return oldValue.BillingContact, nil
}

// ClearBillingContact clears the value of the "billing_contact" field.
func (m *OrganizationSettingMutation) ClearBillingContact() {
	m.billing_contact = nil
	m.clearedFields[organizationsetting.FieldBillingContact] = struct{}{}
}

// BillingContactCleared returns if the "billing_contact" field was cleared in this mutation.
func (m *OrganizationSettingMutation) BillingContactCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldBillingContact]
	return ok
}

// ResetBillingContact resets all changes to the "billing_contact" field.
func (m *OrganizationSettingMutation) ResetBillingContact() {
	m.billing_contact = nil
	delete(m.clearedFields, organizationsetting.FieldBillingContact)
}

// SetBillingEmail sets the "billing_email" field.
func (m *OrganizationSettingMutation) SetBillingEmail(s string) {
	m.billing_email = &s
}

// BillingEmail returns the value of the "billing_email" field in the mutation.
func (m *OrganizationSettingMutation) BillingEmail() (r string, exists bool) {
	v := m.billing_email
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEmail returns the old "billing_email" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldBillingEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEmail: %w", err)
	}
	return oldValue.BillingEmail, nil
}

// ClearBillingEmail clears the value of the "billing_email" field.
func (m *OrganizationSettingMutation) ClearBillingEmail() {
	m.billing_email = nil
	m.clearedFields[organizationsetting.FieldBillingEmail] = struct{}{}
}

// BillingEmailCleared returns if the "billing_email" field was cleared in this mutation.
func (m *OrganizationSettingMutation) BillingEmailCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldBillingEmail]
	return ok
}

// ResetBillingEmail resets all changes to the "billing_email" field.
func (m *OrganizationSettingMutation) ResetBillingEmail() {
	m.billing_email = nil
	delete(m.clearedFields, organizationsetting.FieldBillingEmail)
}

// SetBillingPhone sets the "billing_phone" field.
func (m *OrganizationSettingMutation) SetBillingPhone(s string) {
	m.billing_phone = &s
}

// BillingPhone returns the value of the "billing_phone" field in the mutation.
func (m *OrganizationSettingMutation) BillingPhone() (r string, exists bool) {
	v := m.billing_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingPhone returns the old "billing_phone" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldBillingPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingPhone: %w", err)
	}
	return oldValue.BillingPhone, nil
}

// ClearBillingPhone clears the value of the "billing_phone" field.
func (m *OrganizationSettingMutation) ClearBillingPhone() {
	m.billing_phone = nil
	m.clearedFields[organizationsetting.FieldBillingPhone] = struct{}{}
}

// BillingPhoneCleared returns if the "billing_phone" field was cleared in this mutation.
func (m *OrganizationSettingMutation) BillingPhoneCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldBillingPhone]
	return ok
}

// ResetBillingPhone resets all changes to the "billing_phone" field.
func (m *OrganizationSettingMutation) ResetBillingPhone() {
	m.billing_phone = nil
	delete(m.clearedFields, organizationsetting.FieldBillingPhone)
}

// SetBillingAddress sets the "billing_address" field.
func (m *OrganizationSettingMutation) SetBillingAddress(s string) {
	m.billing_address = &s
}

// BillingAddress returns the value of the "billing_address" field in the mutation.
func (m *OrganizationSettingMutation) BillingAddress() (r string, exists bool) {
	v := m.billing_address
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddress returns the old "billing_address" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldBillingAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddress: %w", err)
	}
	return oldValue.BillingAddress, nil
}

// ClearBillingAddress clears the value of the "billing_address" field.
func (m *OrganizationSettingMutation) ClearBillingAddress() {
	m.billing_address = nil
	m.clearedFields[organizationsetting.FieldBillingAddress] = struct{}{}
}

// BillingAddressCleared returns if the "billing_address" field was cleared in this mutation.
func (m *OrganizationSettingMutation) BillingAddressCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldBillingAddress]
	return ok
}

// ResetBillingAddress resets all changes to the "billing_address" field.
func (m *OrganizationSettingMutation) ResetBillingAddress() {
	m.billing_address = nil
	delete(m.clearedFields, organizationsetting.FieldBillingAddress)
}

// SetTaxIdentifier sets the "tax_identifier" field.
func (m *OrganizationSettingMutation) SetTaxIdentifier(s string) {
	m.tax_identifier = &s
}

// TaxIdentifier returns the value of the "tax_identifier" field in the mutation.
func (m *OrganizationSettingMutation) TaxIdentifier() (r string, exists bool) {
	v := m.tax_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxIdentifier returns the old "tax_identifier" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldTaxIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxIdentifier: %w", err)
	}
	return oldValue.TaxIdentifier, nil
}

// ClearTaxIdentifier clears the value of the "tax_identifier" field.
func (m *OrganizationSettingMutation) ClearTaxIdentifier() {
	m.tax_identifier = nil
	m.clearedFields[organizationsetting.FieldTaxIdentifier] = struct{}{}
}

// TaxIdentifierCleared returns if the "tax_identifier" field was cleared in this mutation.
func (m *OrganizationSettingMutation) TaxIdentifierCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldTaxIdentifier]
	return ok
}

// ResetTaxIdentifier resets all changes to the "tax_identifier" field.
func (m *OrganizationSettingMutation) ResetTaxIdentifier() {
	m.tax_identifier = nil
	delete(m.clearedFields, organizationsetting.FieldTaxIdentifier)
}

// SetGeoLocation sets the "geo_location" field.
func (m *OrganizationSettingMutation) SetGeoLocation(e enums.Region) {
	m.geo_location = &e
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *OrganizationSettingMutation) GeoLocation() (r enums.Region, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldGeoLocation(ctx context.Context) (v enums.Region, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *OrganizationSettingMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[organizationsetting.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *OrganizationSettingMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *OrganizationSettingMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, organizationsetting.FieldGeoLocation)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationSettingMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationSettingMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationSetting entity.
// If the OrganizationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OrganizationSettingMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[organizationsetting.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OrganizationSettingMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[organizationsetting.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationSettingMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, organizationsetting.FieldOrganizationID)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationSettingMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[organizationsetting.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationSettingMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationSettingMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationSettingMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *OrganizationSettingMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *OrganizationSettingMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *OrganizationSettingMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *OrganizationSettingMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *OrganizationSettingMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *OrganizationSettingMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *OrganizationSettingMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the OrganizationSettingMutation builder.
func (m *OrganizationSettingMutation) Where(ps ...predicate.OrganizationSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationSetting).
func (m *OrganizationSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationSettingMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, organizationsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationsetting.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organizationsetting.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationsetting.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, organizationsetting.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, organizationsetting.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationsetting.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, organizationsetting.FieldDeletedBy)
	}
	if m.domains != nil {
		fields = append(fields, organizationsetting.FieldDomains)
	}
	if m.billing_contact != nil {
		fields = append(fields, organizationsetting.FieldBillingContact)
	}
	if m.billing_email != nil {
		fields = append(fields, organizationsetting.FieldBillingEmail)
	}
	if m.billing_phone != nil {
		fields = append(fields, organizationsetting.FieldBillingPhone)
	}
	if m.billing_address != nil {
		fields = append(fields, organizationsetting.FieldBillingAddress)
	}
	if m.tax_identifier != nil {
		fields = append(fields, organizationsetting.FieldTaxIdentifier)
	}
	if m.geo_location != nil {
		fields = append(fields, organizationsetting.FieldGeoLocation)
	}
	if m.organization != nil {
		fields = append(fields, organizationsetting.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationsetting.FieldCreatedAt:
		return m.CreatedAt()
	case organizationsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationsetting.FieldCreatedBy:
		return m.CreatedBy()
	case organizationsetting.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationsetting.FieldMappingID:
		return m.MappingID()
	case organizationsetting.FieldTags:
		return m.Tags()
	case organizationsetting.FieldDeletedAt:
		return m.DeletedAt()
	case organizationsetting.FieldDeletedBy:
		return m.DeletedBy()
	case organizationsetting.FieldDomains:
		return m.Domains()
	case organizationsetting.FieldBillingContact:
		return m.BillingContact()
	case organizationsetting.FieldBillingEmail:
		return m.BillingEmail()
	case organizationsetting.FieldBillingPhone:
		return m.BillingPhone()
	case organizationsetting.FieldBillingAddress:
		return m.BillingAddress()
	case organizationsetting.FieldTaxIdentifier:
		return m.TaxIdentifier()
	case organizationsetting.FieldGeoLocation:
		return m.GeoLocation()
	case organizationsetting.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationsetting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationsetting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationsetting.FieldMappingID:
		return m.OldMappingID(ctx)
	case organizationsetting.FieldTags:
		return m.OldTags(ctx)
	case organizationsetting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationsetting.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case organizationsetting.FieldDomains:
		return m.OldDomains(ctx)
	case organizationsetting.FieldBillingContact:
		return m.OldBillingContact(ctx)
	case organizationsetting.FieldBillingEmail:
		return m.OldBillingEmail(ctx)
	case organizationsetting.FieldBillingPhone:
		return m.OldBillingPhone(ctx)
	case organizationsetting.FieldBillingAddress:
		return m.OldBillingAddress(ctx)
	case organizationsetting.FieldTaxIdentifier:
		return m.OldTaxIdentifier(ctx)
	case organizationsetting.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case organizationsetting.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationsetting.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationsetting.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationsetting.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case organizationsetting.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case organizationsetting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationsetting.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case organizationsetting.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case organizationsetting.FieldBillingContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingContact(v)
		return nil
	case organizationsetting.FieldBillingEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEmail(v)
		return nil
	case organizationsetting.FieldBillingPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingPhone(v)
		return nil
	case organizationsetting.FieldBillingAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddress(v)
		return nil
	case organizationsetting.FieldTaxIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxIdentifier(v)
		return nil
	case organizationsetting.FieldGeoLocation:
		v, ok := value.(enums.Region)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case organizationsetting.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationSettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationSettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationsetting.FieldCreatedAt) {
		fields = append(fields, organizationsetting.FieldCreatedAt)
	}
	if m.FieldCleared(organizationsetting.FieldUpdatedAt) {
		fields = append(fields, organizationsetting.FieldUpdatedAt)
	}
	if m.FieldCleared(organizationsetting.FieldCreatedBy) {
		fields = append(fields, organizationsetting.FieldCreatedBy)
	}
	if m.FieldCleared(organizationsetting.FieldUpdatedBy) {
		fields = append(fields, organizationsetting.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationsetting.FieldTags) {
		fields = append(fields, organizationsetting.FieldTags)
	}
	if m.FieldCleared(organizationsetting.FieldDeletedAt) {
		fields = append(fields, organizationsetting.FieldDeletedAt)
	}
	if m.FieldCleared(organizationsetting.FieldDeletedBy) {
		fields = append(fields, organizationsetting.FieldDeletedBy)
	}
	if m.FieldCleared(organizationsetting.FieldDomains) {
		fields = append(fields, organizationsetting.FieldDomains)
	}
	if m.FieldCleared(organizationsetting.FieldBillingContact) {
		fields = append(fields, organizationsetting.FieldBillingContact)
	}
	if m.FieldCleared(organizationsetting.FieldBillingEmail) {
		fields = append(fields, organizationsetting.FieldBillingEmail)
	}
	if m.FieldCleared(organizationsetting.FieldBillingPhone) {
		fields = append(fields, organizationsetting.FieldBillingPhone)
	}
	if m.FieldCleared(organizationsetting.FieldBillingAddress) {
		fields = append(fields, organizationsetting.FieldBillingAddress)
	}
	if m.FieldCleared(organizationsetting.FieldTaxIdentifier) {
		fields = append(fields, organizationsetting.FieldTaxIdentifier)
	}
	if m.FieldCleared(organizationsetting.FieldGeoLocation) {
		fields = append(fields, organizationsetting.FieldGeoLocation)
	}
	if m.FieldCleared(organizationsetting.FieldOrganizationID) {
		fields = append(fields, organizationsetting.FieldOrganizationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationSettingMutation) ClearField(name string) error {
	switch name {
	case organizationsetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case organizationsetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organizationsetting.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organizationsetting.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationsetting.FieldTags:
		m.ClearTags()
		return nil
	case organizationsetting.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organizationsetting.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case organizationsetting.FieldDomains:
		m.ClearDomains()
		return nil
	case organizationsetting.FieldBillingContact:
		m.ClearBillingContact()
		return nil
	case organizationsetting.FieldBillingEmail:
		m.ClearBillingEmail()
		return nil
	case organizationsetting.FieldBillingPhone:
		m.ClearBillingPhone()
		return nil
	case organizationsetting.FieldBillingAddress:
		m.ClearBillingAddress()
		return nil
	case organizationsetting.FieldTaxIdentifier:
		m.ClearTaxIdentifier()
		return nil
	case organizationsetting.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case organizationsetting.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationSettingMutation) ResetField(name string) error {
	switch name {
	case organizationsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationsetting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationsetting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationsetting.FieldMappingID:
		m.ResetMappingID()
		return nil
	case organizationsetting.FieldTags:
		m.ResetTags()
		return nil
	case organizationsetting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationsetting.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case organizationsetting.FieldDomains:
		m.ResetDomains()
		return nil
	case organizationsetting.FieldBillingContact:
		m.ResetBillingContact()
		return nil
	case organizationsetting.FieldBillingEmail:
		m.ResetBillingEmail()
		return nil
	case organizationsetting.FieldBillingPhone:
		m.ResetBillingPhone()
		return nil
	case organizationsetting.FieldBillingAddress:
		m.ResetBillingAddress()
		return nil
	case organizationsetting.FieldTaxIdentifier:
		m.ResetTaxIdentifier()
		return nil
	case organizationsetting.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case organizationsetting.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationsetting.EdgeOrganization)
	}
	if m.files != nil {
		edges = append(edges, organizationsetting.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationsetting.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationsetting.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfiles != nil {
		edges = append(edges, organizationsetting.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationSettingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organizationsetting.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationsetting.EdgeOrganization)
	}
	if m.clearedfiles {
		edges = append(edges, organizationsetting.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationsetting.EdgeOrganization:
		return m.clearedorganization
	case organizationsetting.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationSettingMutation) ClearEdge(name string) error {
	switch name {
	case organizationsetting.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationSettingMutation) ResetEdge(name string) error {
	switch name {
	case organizationsetting.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationsetting.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown OrganizationSetting edge %s", name)
}

// OrganizationSettingHistoryMutation represents an operation that mutates the OrganizationSettingHistory nodes in the graph.
type OrganizationSettingHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	history_time    *time.Time
	ref             *string
	operation       *history.OpType
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	mapping_id      *string
	tags            *[]string
	appendtags      []string
	deleted_at      *time.Time
	deleted_by      *string
	domains         *[]string
	appenddomains   []string
	billing_contact *string
	billing_email   *string
	billing_phone   *string
	billing_address *string
	tax_identifier  *string
	geo_location    *enums.Region
	organization_id *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*OrganizationSettingHistory, error)
	predicates      []predicate.OrganizationSettingHistory
}

var _ ent.Mutation = (*OrganizationSettingHistoryMutation)(nil)

// organizationsettinghistoryOption allows management of the mutation configuration using functional options.
type organizationsettinghistoryOption func(*OrganizationSettingHistoryMutation)

// newOrganizationSettingHistoryMutation creates new mutation for the OrganizationSettingHistory entity.
func newOrganizationSettingHistoryMutation(c config, op Op, opts ...organizationsettinghistoryOption) *OrganizationSettingHistoryMutation {
	m := &OrganizationSettingHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationSettingHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationSettingHistoryID sets the ID field of the mutation.
func withOrganizationSettingHistoryID(id string) organizationsettinghistoryOption {
	return func(m *OrganizationSettingHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationSettingHistory
		)
		m.oldValue = func(ctx context.Context) (*OrganizationSettingHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationSettingHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationSettingHistory sets the old OrganizationSettingHistory of the mutation.
func withOrganizationSettingHistory(node *OrganizationSettingHistory) organizationsettinghistoryOption {
	return func(m *OrganizationSettingHistoryMutation) {
		m.oldValue = func(context.Context) (*OrganizationSettingHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationSettingHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationSettingHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationSettingHistory entities.
func (m *OrganizationSettingHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationSettingHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationSettingHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationSettingHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *OrganizationSettingHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *OrganizationSettingHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *OrganizationSettingHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *OrganizationSettingHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *OrganizationSettingHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *OrganizationSettingHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[organizationsettinghistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *OrganizationSettingHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, organizationsettinghistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *OrganizationSettingHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *OrganizationSettingHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *OrganizationSettingHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationSettingHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationSettingHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrganizationSettingHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[organizationsettinghistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationSettingHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, organizationsettinghistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationSettingHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationSettingHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationSettingHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationsettinghistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationSettingHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationsettinghistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationSettingHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationSettingHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationSettingHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organizationsettinghistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationSettingHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organizationsettinghistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationSettingHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationSettingHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationSettingHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organizationsettinghistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationSettingHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organizationsettinghistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *OrganizationSettingHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *OrganizationSettingHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *OrganizationSettingHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *OrganizationSettingHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OrganizationSettingHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *OrganizationSettingHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *OrganizationSettingHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *OrganizationSettingHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[organizationsettinghistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OrganizationSettingHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, organizationsettinghistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationSettingHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationSettingHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationSettingHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationsettinghistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationSettingHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationsettinghistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *OrganizationSettingHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *OrganizationSettingHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *OrganizationSettingHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[organizationsettinghistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *OrganizationSettingHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, organizationsettinghistory.FieldDeletedBy)
}

// SetDomains sets the "domains" field.
func (m *OrganizationSettingHistoryMutation) SetDomains(s []string) {
	m.domains = &s
	m.appenddomains = nil
}

// Domains returns the value of the "domains" field in the mutation.
func (m *OrganizationSettingHistoryMutation) Domains() (r []string, exists bool) {
	v := m.domains
	if v == nil {
		return
	}
	return *v, true
}

// OldDomains returns the old "domains" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldDomains(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomains: %w", err)
	}
	return oldValue.Domains, nil
}

// AppendDomains adds s to the "domains" field.
func (m *OrganizationSettingHistoryMutation) AppendDomains(s []string) {
	m.appenddomains = append(m.appenddomains, s...)
}

// AppendedDomains returns the list of values that were appended to the "domains" field in this mutation.
func (m *OrganizationSettingHistoryMutation) AppendedDomains() ([]string, bool) {
	if len(m.appenddomains) == 0 {
		return nil, false
	}
	return m.appenddomains, true
}

// ClearDomains clears the value of the "domains" field.
func (m *OrganizationSettingHistoryMutation) ClearDomains() {
	m.domains = nil
	m.appenddomains = nil
	m.clearedFields[organizationsettinghistory.FieldDomains] = struct{}{}
}

// DomainsCleared returns if the "domains" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) DomainsCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldDomains]
	return ok
}

// ResetDomains resets all changes to the "domains" field.
func (m *OrganizationSettingHistoryMutation) ResetDomains() {
	m.domains = nil
	m.appenddomains = nil
	delete(m.clearedFields, organizationsettinghistory.FieldDomains)
}

// SetBillingContact sets the "billing_contact" field.
func (m *OrganizationSettingHistoryMutation) SetBillingContact(s string) {
	m.billing_contact = &s
}

// BillingContact returns the value of the "billing_contact" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingContact() (r string, exists bool) {
	v := m.billing_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingContact returns the old "billing_contact" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingContact: %w", err)
	}
	return oldValue.BillingContact, nil
}

// ClearBillingContact clears the value of the "billing_contact" field.
func (m *OrganizationSettingHistoryMutation) ClearBillingContact() {
	m.billing_contact = nil
	m.clearedFields[organizationsettinghistory.FieldBillingContact] = struct{}{}
}

// BillingContactCleared returns if the "billing_contact" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) BillingContactCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldBillingContact]
	return ok
}

// ResetBillingContact resets all changes to the "billing_contact" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingContact() {
	m.billing_contact = nil
	delete(m.clearedFields, organizationsettinghistory.FieldBillingContact)
}

// SetBillingEmail sets the "billing_email" field.
func (m *OrganizationSettingHistoryMutation) SetBillingEmail(s string) {
	m.billing_email = &s
}

// BillingEmail returns the value of the "billing_email" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingEmail() (r string, exists bool) {
	v := m.billing_email
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEmail returns the old "billing_email" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEmail: %w", err)
	}
	return oldValue.BillingEmail, nil
}

// ClearBillingEmail clears the value of the "billing_email" field.
func (m *OrganizationSettingHistoryMutation) ClearBillingEmail() {
	m.billing_email = nil
	m.clearedFields[organizationsettinghistory.FieldBillingEmail] = struct{}{}
}

// BillingEmailCleared returns if the "billing_email" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) BillingEmailCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldBillingEmail]
	return ok
}

// ResetBillingEmail resets all changes to the "billing_email" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingEmail() {
	m.billing_email = nil
	delete(m.clearedFields, organizationsettinghistory.FieldBillingEmail)
}

// SetBillingPhone sets the "billing_phone" field.
func (m *OrganizationSettingHistoryMutation) SetBillingPhone(s string) {
	m.billing_phone = &s
}

// BillingPhone returns the value of the "billing_phone" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingPhone() (r string, exists bool) {
	v := m.billing_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingPhone returns the old "billing_phone" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingPhone: %w", err)
	}
	return oldValue.BillingPhone, nil
}

// ClearBillingPhone clears the value of the "billing_phone" field.
func (m *OrganizationSettingHistoryMutation) ClearBillingPhone() {
	m.billing_phone = nil
	m.clearedFields[organizationsettinghistory.FieldBillingPhone] = struct{}{}
}

// BillingPhoneCleared returns if the "billing_phone" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) BillingPhoneCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldBillingPhone]
	return ok
}

// ResetBillingPhone resets all changes to the "billing_phone" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingPhone() {
	m.billing_phone = nil
	delete(m.clearedFields, organizationsettinghistory.FieldBillingPhone)
}

// SetBillingAddress sets the "billing_address" field.
func (m *OrganizationSettingHistoryMutation) SetBillingAddress(s string) {
	m.billing_address = &s
}

// BillingAddress returns the value of the "billing_address" field in the mutation.
func (m *OrganizationSettingHistoryMutation) BillingAddress() (r string, exists bool) {
	v := m.billing_address
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAddress returns the old "billing_address" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldBillingAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAddress: %w", err)
	}
	return oldValue.BillingAddress, nil
}

// ClearBillingAddress clears the value of the "billing_address" field.
func (m *OrganizationSettingHistoryMutation) ClearBillingAddress() {
	m.billing_address = nil
	m.clearedFields[organizationsettinghistory.FieldBillingAddress] = struct{}{}
}

// BillingAddressCleared returns if the "billing_address" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) BillingAddressCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldBillingAddress]
	return ok
}

// ResetBillingAddress resets all changes to the "billing_address" field.
func (m *OrganizationSettingHistoryMutation) ResetBillingAddress() {
	m.billing_address = nil
	delete(m.clearedFields, organizationsettinghistory.FieldBillingAddress)
}

// SetTaxIdentifier sets the "tax_identifier" field.
func (m *OrganizationSettingHistoryMutation) SetTaxIdentifier(s string) {
	m.tax_identifier = &s
}

// TaxIdentifier returns the value of the "tax_identifier" field in the mutation.
func (m *OrganizationSettingHistoryMutation) TaxIdentifier() (r string, exists bool) {
	v := m.tax_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxIdentifier returns the old "tax_identifier" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldTaxIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxIdentifier: %w", err)
	}
	return oldValue.TaxIdentifier, nil
}

// ClearTaxIdentifier clears the value of the "tax_identifier" field.
func (m *OrganizationSettingHistoryMutation) ClearTaxIdentifier() {
	m.tax_identifier = nil
	m.clearedFields[organizationsettinghistory.FieldTaxIdentifier] = struct{}{}
}

// TaxIdentifierCleared returns if the "tax_identifier" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) TaxIdentifierCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldTaxIdentifier]
	return ok
}

// ResetTaxIdentifier resets all changes to the "tax_identifier" field.
func (m *OrganizationSettingHistoryMutation) ResetTaxIdentifier() {
	m.tax_identifier = nil
	delete(m.clearedFields, organizationsettinghistory.FieldTaxIdentifier)
}

// SetGeoLocation sets the "geo_location" field.
func (m *OrganizationSettingHistoryMutation) SetGeoLocation(e enums.Region) {
	m.geo_location = &e
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *OrganizationSettingHistoryMutation) GeoLocation() (r enums.Region, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldGeoLocation(ctx context.Context) (v enums.Region, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *OrganizationSettingHistoryMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[organizationsettinghistory.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *OrganizationSettingHistoryMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, organizationsettinghistory.FieldGeoLocation)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationSettingHistoryMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationSettingHistoryMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationSettingHistory entity.
// If the OrganizationSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationSettingHistoryMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *OrganizationSettingHistoryMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[organizationsettinghistory.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[organizationsettinghistory.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationSettingHistoryMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, organizationsettinghistory.FieldOrganizationID)
}

// Where appends a list predicates to the OrganizationSettingHistoryMutation builder.
func (m *OrganizationSettingHistoryMutation) Where(ps ...predicate.OrganizationSettingHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationSettingHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationSettingHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationSettingHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationSettingHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationSettingHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationSettingHistory).
func (m *OrganizationSettingHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationSettingHistoryMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.history_time != nil {
		fields = append(fields, organizationsettinghistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, organizationsettinghistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, organizationsettinghistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, organizationsettinghistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationsettinghistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organizationsettinghistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationsettinghistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, organizationsettinghistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, organizationsettinghistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationsettinghistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, organizationsettinghistory.FieldDeletedBy)
	}
	if m.domains != nil {
		fields = append(fields, organizationsettinghistory.FieldDomains)
	}
	if m.billing_contact != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingContact)
	}
	if m.billing_email != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingEmail)
	}
	if m.billing_phone != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingPhone)
	}
	if m.billing_address != nil {
		fields = append(fields, organizationsettinghistory.FieldBillingAddress)
	}
	if m.tax_identifier != nil {
		fields = append(fields, organizationsettinghistory.FieldTaxIdentifier)
	}
	if m.geo_location != nil {
		fields = append(fields, organizationsettinghistory.FieldGeoLocation)
	}
	if m.organization_id != nil {
		fields = append(fields, organizationsettinghistory.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationSettingHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationsettinghistory.FieldHistoryTime:
		return m.HistoryTime()
	case organizationsettinghistory.FieldRef:
		return m.Ref()
	case organizationsettinghistory.FieldOperation:
		return m.Operation()
	case organizationsettinghistory.FieldCreatedAt:
		return m.CreatedAt()
	case organizationsettinghistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationsettinghistory.FieldCreatedBy:
		return m.CreatedBy()
	case organizationsettinghistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationsettinghistory.FieldMappingID:
		return m.MappingID()
	case organizationsettinghistory.FieldTags:
		return m.Tags()
	case organizationsettinghistory.FieldDeletedAt:
		return m.DeletedAt()
	case organizationsettinghistory.FieldDeletedBy:
		return m.DeletedBy()
	case organizationsettinghistory.FieldDomains:
		return m.Domains()
	case organizationsettinghistory.FieldBillingContact:
		return m.BillingContact()
	case organizationsettinghistory.FieldBillingEmail:
		return m.BillingEmail()
	case organizationsettinghistory.FieldBillingPhone:
		return m.BillingPhone()
	case organizationsettinghistory.FieldBillingAddress:
		return m.BillingAddress()
	case organizationsettinghistory.FieldTaxIdentifier:
		return m.TaxIdentifier()
	case organizationsettinghistory.FieldGeoLocation:
		return m.GeoLocation()
	case organizationsettinghistory.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationSettingHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationsettinghistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case organizationsettinghistory.FieldRef:
		return m.OldRef(ctx)
	case organizationsettinghistory.FieldOperation:
		return m.OldOperation(ctx)
	case organizationsettinghistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationsettinghistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationsettinghistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationsettinghistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationsettinghistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case organizationsettinghistory.FieldTags:
		return m.OldTags(ctx)
	case organizationsettinghistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationsettinghistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case organizationsettinghistory.FieldDomains:
		return m.OldDomains(ctx)
	case organizationsettinghistory.FieldBillingContact:
		return m.OldBillingContact(ctx)
	case organizationsettinghistory.FieldBillingEmail:
		return m.OldBillingEmail(ctx)
	case organizationsettinghistory.FieldBillingPhone:
		return m.OldBillingPhone(ctx)
	case organizationsettinghistory.FieldBillingAddress:
		return m.OldBillingAddress(ctx)
	case organizationsettinghistory.FieldTaxIdentifier:
		return m.OldTaxIdentifier(ctx)
	case organizationsettinghistory.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case organizationsettinghistory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationSettingHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationSettingHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationsettinghistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case organizationsettinghistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case organizationsettinghistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case organizationsettinghistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationsettinghistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationsettinghistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationsettinghistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationsettinghistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case organizationsettinghistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case organizationsettinghistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationsettinghistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case organizationsettinghistory.FieldDomains:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomains(v)
		return nil
	case organizationsettinghistory.FieldBillingContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingContact(v)
		return nil
	case organizationsettinghistory.FieldBillingEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEmail(v)
		return nil
	case organizationsettinghistory.FieldBillingPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingPhone(v)
		return nil
	case organizationsettinghistory.FieldBillingAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAddress(v)
		return nil
	case organizationsettinghistory.FieldTaxIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxIdentifier(v)
		return nil
	case organizationsettinghistory.FieldGeoLocation:
		v, ok := value.(enums.Region)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case organizationsettinghistory.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationSettingHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationSettingHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationSettingHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationSettingHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationSettingHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationSettingHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationsettinghistory.FieldRef) {
		fields = append(fields, organizationsettinghistory.FieldRef)
	}
	if m.FieldCleared(organizationsettinghistory.FieldCreatedAt) {
		fields = append(fields, organizationsettinghistory.FieldCreatedAt)
	}
	if m.FieldCleared(organizationsettinghistory.FieldUpdatedAt) {
		fields = append(fields, organizationsettinghistory.FieldUpdatedAt)
	}
	if m.FieldCleared(organizationsettinghistory.FieldCreatedBy) {
		fields = append(fields, organizationsettinghistory.FieldCreatedBy)
	}
	if m.FieldCleared(organizationsettinghistory.FieldUpdatedBy) {
		fields = append(fields, organizationsettinghistory.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationsettinghistory.FieldTags) {
		fields = append(fields, organizationsettinghistory.FieldTags)
	}
	if m.FieldCleared(organizationsettinghistory.FieldDeletedAt) {
		fields = append(fields, organizationsettinghistory.FieldDeletedAt)
	}
	if m.FieldCleared(organizationsettinghistory.FieldDeletedBy) {
		fields = append(fields, organizationsettinghistory.FieldDeletedBy)
	}
	if m.FieldCleared(organizationsettinghistory.FieldDomains) {
		fields = append(fields, organizationsettinghistory.FieldDomains)
	}
	if m.FieldCleared(organizationsettinghistory.FieldBillingContact) {
		fields = append(fields, organizationsettinghistory.FieldBillingContact)
	}
	if m.FieldCleared(organizationsettinghistory.FieldBillingEmail) {
		fields = append(fields, organizationsettinghistory.FieldBillingEmail)
	}
	if m.FieldCleared(organizationsettinghistory.FieldBillingPhone) {
		fields = append(fields, organizationsettinghistory.FieldBillingPhone)
	}
	if m.FieldCleared(organizationsettinghistory.FieldBillingAddress) {
		fields = append(fields, organizationsettinghistory.FieldBillingAddress)
	}
	if m.FieldCleared(organizationsettinghistory.FieldTaxIdentifier) {
		fields = append(fields, organizationsettinghistory.FieldTaxIdentifier)
	}
	if m.FieldCleared(organizationsettinghistory.FieldGeoLocation) {
		fields = append(fields, organizationsettinghistory.FieldGeoLocation)
	}
	if m.FieldCleared(organizationsettinghistory.FieldOrganizationID) {
		fields = append(fields, organizationsettinghistory.FieldOrganizationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationSettingHistoryMutation) ClearField(name string) error {
	switch name {
	case organizationsettinghistory.FieldRef:
		m.ClearRef()
		return nil
	case organizationsettinghistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case organizationsettinghistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organizationsettinghistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organizationsettinghistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationsettinghistory.FieldTags:
		m.ClearTags()
		return nil
	case organizationsettinghistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organizationsettinghistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case organizationsettinghistory.FieldDomains:
		m.ClearDomains()
		return nil
	case organizationsettinghistory.FieldBillingContact:
		m.ClearBillingContact()
		return nil
	case organizationsettinghistory.FieldBillingEmail:
		m.ClearBillingEmail()
		return nil
	case organizationsettinghistory.FieldBillingPhone:
		m.ClearBillingPhone()
		return nil
	case organizationsettinghistory.FieldBillingAddress:
		m.ClearBillingAddress()
		return nil
	case organizationsettinghistory.FieldTaxIdentifier:
		m.ClearTaxIdentifier()
		return nil
	case organizationsettinghistory.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case organizationsettinghistory.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationSettingHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationSettingHistoryMutation) ResetField(name string) error {
	switch name {
	case organizationsettinghistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case organizationsettinghistory.FieldRef:
		m.ResetRef()
		return nil
	case organizationsettinghistory.FieldOperation:
		m.ResetOperation()
		return nil
	case organizationsettinghistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationsettinghistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationsettinghistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationsettinghistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationsettinghistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case organizationsettinghistory.FieldTags:
		m.ResetTags()
		return nil
	case organizationsettinghistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationsettinghistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case organizationsettinghistory.FieldDomains:
		m.ResetDomains()
		return nil
	case organizationsettinghistory.FieldBillingContact:
		m.ResetBillingContact()
		return nil
	case organizationsettinghistory.FieldBillingEmail:
		m.ResetBillingEmail()
		return nil
	case organizationsettinghistory.FieldBillingPhone:
		m.ResetBillingPhone()
		return nil
	case organizationsettinghistory.FieldBillingAddress:
		m.ResetBillingAddress()
		return nil
	case organizationsettinghistory.FieldTaxIdentifier:
		m.ResetTaxIdentifier()
		return nil
	case organizationsettinghistory.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case organizationsettinghistory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationSettingHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationSettingHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationSettingHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationSettingHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationSettingHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationSettingHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationSettingHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrganizationSettingHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationSettingHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrganizationSettingHistory edge %s", name)
}

// PasswordResetTokenMutation represents an operation that mutates the PasswordResetToken nodes in the graph.
type PasswordResetTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	token         *string
	ttl           *time.Time
	email         *string
	secret        *[]byte
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PasswordResetToken, error)
	predicates    []predicate.PasswordResetToken
}

var _ ent.Mutation = (*PasswordResetTokenMutation)(nil)

// passwordresettokenOption allows management of the mutation configuration using functional options.
type passwordresettokenOption func(*PasswordResetTokenMutation)

// newPasswordResetTokenMutation creates new mutation for the PasswordResetToken entity.
func newPasswordResetTokenMutation(c config, op Op, opts ...passwordresettokenOption) *PasswordResetTokenMutation {
	m := &PasswordResetTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordResetToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordResetTokenID sets the ID field of the mutation.
func withPasswordResetTokenID(id string) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordResetToken
		)
		m.oldValue = func(ctx context.Context) (*PasswordResetToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordResetToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordResetToken sets the old PasswordResetToken of the mutation.
func withPasswordResetToken(node *PasswordResetToken) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		m.oldValue = func(context.Context) (*PasswordResetToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordResetTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordResetTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PasswordResetToken entities.
func (m *PasswordResetTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordResetTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordResetTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordResetToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordResetTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordResetTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PasswordResetTokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[passwordresettoken.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordResetTokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, passwordresettoken.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasswordResetTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasswordResetTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PasswordResetTokenMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[passwordresettoken.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasswordResetTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, passwordresettoken.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PasswordResetTokenMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PasswordResetTokenMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PasswordResetTokenMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[passwordresettoken.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PasswordResetTokenMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, passwordresettoken.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PasswordResetTokenMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PasswordResetTokenMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PasswordResetTokenMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[passwordresettoken.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PasswordResetTokenMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, passwordresettoken.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *PasswordResetTokenMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *PasswordResetTokenMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *PasswordResetTokenMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PasswordResetTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PasswordResetTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PasswordResetTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[passwordresettoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PasswordResetTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, passwordresettoken.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PasswordResetTokenMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PasswordResetTokenMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PasswordResetTokenMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[passwordresettoken.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PasswordResetTokenMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, passwordresettoken.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *PasswordResetTokenMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *PasswordResetTokenMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *PasswordResetTokenMutation) ResetOwnerID() {
	m.owner = nil
}

// SetToken sets the "token" field.
func (m *PasswordResetTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *PasswordResetTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *PasswordResetTokenMutation) ResetToken() {
	m.token = nil
}

// SetTTL sets the "ttl" field.
func (m *PasswordResetTokenMutation) SetTTL(t time.Time) {
	m.ttl = &t
}

// TTL returns the value of the "ttl" field in the mutation.
func (m *PasswordResetTokenMutation) TTL() (r time.Time, exists bool) {
	v := m.ttl
	if v == nil {
		return
	}
	return *v, true
}

// OldTTL returns the old "ttl" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldTTL(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTTL: %w", err)
	}
	return oldValue.TTL, nil
}

// ResetTTL resets all changes to the "ttl" field.
func (m *PasswordResetTokenMutation) ResetTTL() {
	m.ttl = nil
}

// SetEmail sets the "email" field.
func (m *PasswordResetTokenMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PasswordResetTokenMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PasswordResetTokenMutation) ResetEmail() {
	m.email = nil
}

// SetSecret sets the "secret" field.
func (m *PasswordResetTokenMutation) SetSecret(b []byte) {
	m.secret = &b
}

// Secret returns the value of the "secret" field in the mutation.
func (m *PasswordResetTokenMutation) Secret() (r []byte, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldSecret(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *PasswordResetTokenMutation) ResetSecret() {
	m.secret = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *PasswordResetTokenMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[passwordresettoken.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *PasswordResetTokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PasswordResetTokenMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PasswordResetTokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PasswordResetTokenMutation builder.
func (m *PasswordResetTokenMutation) Where(ps ...predicate.PasswordResetToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordResetTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordResetTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordResetToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordResetTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordResetTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordResetToken).
func (m *PasswordResetTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordResetTokenMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, passwordresettoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passwordresettoken.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, passwordresettoken.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, passwordresettoken.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, passwordresettoken.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, passwordresettoken.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, passwordresettoken.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, passwordresettoken.FieldOwnerID)
	}
	if m.token != nil {
		fields = append(fields, passwordresettoken.FieldToken)
	}
	if m.ttl != nil {
		fields = append(fields, passwordresettoken.FieldTTL)
	}
	if m.email != nil {
		fields = append(fields, passwordresettoken.FieldEmail)
	}
	if m.secret != nil {
		fields = append(fields, passwordresettoken.FieldSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordResetTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		return m.CreatedAt()
	case passwordresettoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case passwordresettoken.FieldCreatedBy:
		return m.CreatedBy()
	case passwordresettoken.FieldUpdatedBy:
		return m.UpdatedBy()
	case passwordresettoken.FieldMappingID:
		return m.MappingID()
	case passwordresettoken.FieldDeletedAt:
		return m.DeletedAt()
	case passwordresettoken.FieldDeletedBy:
		return m.DeletedBy()
	case passwordresettoken.FieldOwnerID:
		return m.OwnerID()
	case passwordresettoken.FieldToken:
		return m.Token()
	case passwordresettoken.FieldTTL:
		return m.TTL()
	case passwordresettoken.FieldEmail:
		return m.Email()
	case passwordresettoken.FieldSecret:
		return m.Secret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordResetTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passwordresettoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passwordresettoken.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case passwordresettoken.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case passwordresettoken.FieldMappingID:
		return m.OldMappingID(ctx)
	case passwordresettoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case passwordresettoken.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case passwordresettoken.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case passwordresettoken.FieldToken:
		return m.OldToken(ctx)
	case passwordresettoken.FieldTTL:
		return m.OldTTL(ctx)
	case passwordresettoken.FieldEmail:
		return m.OldEmail(ctx)
	case passwordresettoken.FieldSecret:
		return m.OldSecret(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passwordresettoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passwordresettoken.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case passwordresettoken.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case passwordresettoken.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case passwordresettoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case passwordresettoken.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case passwordresettoken.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case passwordresettoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case passwordresettoken.FieldTTL:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTTL(v)
		return nil
	case passwordresettoken.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case passwordresettoken.FieldSecret:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordResetTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordResetTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordResetToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordResetTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passwordresettoken.FieldCreatedAt) {
		fields = append(fields, passwordresettoken.FieldCreatedAt)
	}
	if m.FieldCleared(passwordresettoken.FieldUpdatedAt) {
		fields = append(fields, passwordresettoken.FieldUpdatedAt)
	}
	if m.FieldCleared(passwordresettoken.FieldCreatedBy) {
		fields = append(fields, passwordresettoken.FieldCreatedBy)
	}
	if m.FieldCleared(passwordresettoken.FieldUpdatedBy) {
		fields = append(fields, passwordresettoken.FieldUpdatedBy)
	}
	if m.FieldCleared(passwordresettoken.FieldDeletedAt) {
		fields = append(fields, passwordresettoken.FieldDeletedAt)
	}
	if m.FieldCleared(passwordresettoken.FieldDeletedBy) {
		fields = append(fields, passwordresettoken.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordResetTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearField(name string) error {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case passwordresettoken.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case passwordresettoken.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case passwordresettoken.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case passwordresettoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case passwordresettoken.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetField(name string) error {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passwordresettoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passwordresettoken.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case passwordresettoken.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case passwordresettoken.FieldMappingID:
		m.ResetMappingID()
		return nil
	case passwordresettoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case passwordresettoken.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case passwordresettoken.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case passwordresettoken.FieldToken:
		m.ResetToken()
		return nil
	case passwordresettoken.FieldTTL:
		m.ResetTTL()
		return nil
	case passwordresettoken.FieldEmail:
		m.ResetEmail()
		return nil
	case passwordresettoken.FieldSecret:
		m.ResetSecret()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordResetTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, passwordresettoken.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordResetTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordresettoken.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordResetTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordResetTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordResetTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, passwordresettoken.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordResetTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordresettoken.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken edge %s", name)
}

// PersonalAccessTokenMutation represents an operation that mutates the PersonalAccessToken nodes in the graph.
type PersonalAccessTokenMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	deleted_at           *time.Time
	deleted_by           *string
	mapping_id           *string
	tags                 *[]string
	appendtags           []string
	name                 *string
	token                *string
	expires_at           *time.Time
	description          *string
	scopes               *[]string
	appendscopes         []string
	last_used_at         *time.Time
	clearedFields        map[string]struct{}
	owner                *string
	clearedowner         bool
	organizations        map[string]struct{}
	removedorganizations map[string]struct{}
	clearedorganizations bool
	events               map[string]struct{}
	removedevents        map[string]struct{}
	clearedevents        bool
	done                 bool
	oldValue             func(context.Context) (*PersonalAccessToken, error)
	predicates           []predicate.PersonalAccessToken
}

var _ ent.Mutation = (*PersonalAccessTokenMutation)(nil)

// personalaccesstokenOption allows management of the mutation configuration using functional options.
type personalaccesstokenOption func(*PersonalAccessTokenMutation)

// newPersonalAccessTokenMutation creates new mutation for the PersonalAccessToken entity.
func newPersonalAccessTokenMutation(c config, op Op, opts ...personalaccesstokenOption) *PersonalAccessTokenMutation {
	m := &PersonalAccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalAccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalAccessTokenID sets the ID field of the mutation.
func withPersonalAccessTokenID(id string) personalaccesstokenOption {
	return func(m *PersonalAccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalAccessToken
		)
		m.oldValue = func(ctx context.Context) (*PersonalAccessToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalAccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalAccessToken sets the old PersonalAccessToken of the mutation.
func withPersonalAccessToken(node *PersonalAccessToken) personalaccesstokenOption {
	return func(m *PersonalAccessTokenMutation) {
		m.oldValue = func(context.Context) (*PersonalAccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalAccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalAccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonalAccessToken entities.
func (m *PersonalAccessTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalAccessTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalAccessTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalAccessToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonalAccessTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonalAccessTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PersonalAccessTokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[personalaccesstoken.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonalAccessTokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, personalaccesstoken.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonalAccessTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonalAccessTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PersonalAccessTokenMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[personalaccesstoken.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonalAccessTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, personalaccesstoken.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *PersonalAccessTokenMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PersonalAccessTokenMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PersonalAccessTokenMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[personalaccesstoken.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PersonalAccessTokenMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, personalaccesstoken.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PersonalAccessTokenMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PersonalAccessTokenMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PersonalAccessTokenMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[personalaccesstoken.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PersonalAccessTokenMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, personalaccesstoken.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PersonalAccessTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PersonalAccessTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PersonalAccessTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[personalaccesstoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PersonalAccessTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, personalaccesstoken.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *PersonalAccessTokenMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *PersonalAccessTokenMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *PersonalAccessTokenMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[personalaccesstoken.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *PersonalAccessTokenMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, personalaccesstoken.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *PersonalAccessTokenMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *PersonalAccessTokenMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *PersonalAccessTokenMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *PersonalAccessTokenMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *PersonalAccessTokenMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *PersonalAccessTokenMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *PersonalAccessTokenMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *PersonalAccessTokenMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[personalaccesstoken.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) TagsCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *PersonalAccessTokenMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, personalaccesstoken.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *PersonalAccessTokenMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *PersonalAccessTokenMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *PersonalAccessTokenMutation) ResetOwnerID() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *PersonalAccessTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonalAccessTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonalAccessTokenMutation) ResetName() {
	m.name = nil
}

// SetToken sets the "token" field.
func (m *PersonalAccessTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *PersonalAccessTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *PersonalAccessTokenMutation) ResetToken() {
	m.token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *PersonalAccessTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PersonalAccessTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *PersonalAccessTokenMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[personalaccesstoken.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PersonalAccessTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, personalaccesstoken.FieldExpiresAt)
}

// SetDescription sets the "description" field.
func (m *PersonalAccessTokenMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PersonalAccessTokenMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PersonalAccessTokenMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[personalaccesstoken.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PersonalAccessTokenMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, personalaccesstoken.FieldDescription)
}

// SetScopes sets the "scopes" field.
func (m *PersonalAccessTokenMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *PersonalAccessTokenMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *PersonalAccessTokenMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *PersonalAccessTokenMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *PersonalAccessTokenMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[personalaccesstoken.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *PersonalAccessTokenMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, personalaccesstoken.FieldScopes)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *PersonalAccessTokenMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *PersonalAccessTokenMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *PersonalAccessTokenMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[personalaccesstoken.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *PersonalAccessTokenMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, personalaccesstoken.FieldLastUsedAt)
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *PersonalAccessTokenMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[personalaccesstoken.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *PersonalAccessTokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PersonalAccessTokenMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PersonalAccessTokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *PersonalAccessTokenMutation) AddOrganizationIDs(ids ...string) {
	if m.organizations == nil {
		m.organizations = make(map[string]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *PersonalAccessTokenMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *PersonalAccessTokenMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *PersonalAccessTokenMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *PersonalAccessTokenMutation) RemovedOrganizationsIDs() (ids []string) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *PersonalAccessTokenMutation) OrganizationsIDs() (ids []string) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *PersonalAccessTokenMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *PersonalAccessTokenMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *PersonalAccessTokenMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *PersonalAccessTokenMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *PersonalAccessTokenMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *PersonalAccessTokenMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *PersonalAccessTokenMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *PersonalAccessTokenMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the PersonalAccessTokenMutation builder.
func (m *PersonalAccessTokenMutation) Where(ps ...predicate.PersonalAccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalAccessTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalAccessTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonalAccessToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalAccessTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalAccessTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonalAccessToken).
func (m *PersonalAccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalAccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, personalaccesstoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, personalaccesstoken.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, personalaccesstoken.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, personalaccesstoken.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, personalaccesstoken.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, personalaccesstoken.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, personalaccesstoken.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, personalaccesstoken.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, personalaccesstoken.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, personalaccesstoken.FieldName)
	}
	if m.token != nil {
		fields = append(fields, personalaccesstoken.FieldToken)
	}
	if m.expires_at != nil {
		fields = append(fields, personalaccesstoken.FieldExpiresAt)
	}
	if m.description != nil {
		fields = append(fields, personalaccesstoken.FieldDescription)
	}
	if m.scopes != nil {
		fields = append(fields, personalaccesstoken.FieldScopes)
	}
	if m.last_used_at != nil {
		fields = append(fields, personalaccesstoken.FieldLastUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalAccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		return m.CreatedAt()
	case personalaccesstoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case personalaccesstoken.FieldCreatedBy:
		return m.CreatedBy()
	case personalaccesstoken.FieldUpdatedBy:
		return m.UpdatedBy()
	case personalaccesstoken.FieldDeletedAt:
		return m.DeletedAt()
	case personalaccesstoken.FieldDeletedBy:
		return m.DeletedBy()
	case personalaccesstoken.FieldMappingID:
		return m.MappingID()
	case personalaccesstoken.FieldTags:
		return m.Tags()
	case personalaccesstoken.FieldOwnerID:
		return m.OwnerID()
	case personalaccesstoken.FieldName:
		return m.Name()
	case personalaccesstoken.FieldToken:
		return m.Token()
	case personalaccesstoken.FieldExpiresAt:
		return m.ExpiresAt()
	case personalaccesstoken.FieldDescription:
		return m.Description()
	case personalaccesstoken.FieldScopes:
		return m.Scopes()
	case personalaccesstoken.FieldLastUsedAt:
		return m.LastUsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalAccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case personalaccesstoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case personalaccesstoken.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case personalaccesstoken.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case personalaccesstoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case personalaccesstoken.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case personalaccesstoken.FieldMappingID:
		return m.OldMappingID(ctx)
	case personalaccesstoken.FieldTags:
		return m.OldTags(ctx)
	case personalaccesstoken.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case personalaccesstoken.FieldName:
		return m.OldName(ctx)
	case personalaccesstoken.FieldToken:
		return m.OldToken(ctx)
	case personalaccesstoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case personalaccesstoken.FieldDescription:
		return m.OldDescription(ctx)
	case personalaccesstoken.FieldScopes:
		return m.OldScopes(ctx)
	case personalaccesstoken.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalAccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personalaccesstoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case personalaccesstoken.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case personalaccesstoken.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case personalaccesstoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case personalaccesstoken.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case personalaccesstoken.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case personalaccesstoken.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case personalaccesstoken.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case personalaccesstoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case personalaccesstoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case personalaccesstoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case personalaccesstoken.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case personalaccesstoken.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case personalaccesstoken.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalAccessTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalAccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalAccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonalAccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalAccessTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personalaccesstoken.FieldCreatedAt) {
		fields = append(fields, personalaccesstoken.FieldCreatedAt)
	}
	if m.FieldCleared(personalaccesstoken.FieldUpdatedAt) {
		fields = append(fields, personalaccesstoken.FieldUpdatedAt)
	}
	if m.FieldCleared(personalaccesstoken.FieldCreatedBy) {
		fields = append(fields, personalaccesstoken.FieldCreatedBy)
	}
	if m.FieldCleared(personalaccesstoken.FieldUpdatedBy) {
		fields = append(fields, personalaccesstoken.FieldUpdatedBy)
	}
	if m.FieldCleared(personalaccesstoken.FieldDeletedAt) {
		fields = append(fields, personalaccesstoken.FieldDeletedAt)
	}
	if m.FieldCleared(personalaccesstoken.FieldDeletedBy) {
		fields = append(fields, personalaccesstoken.FieldDeletedBy)
	}
	if m.FieldCleared(personalaccesstoken.FieldTags) {
		fields = append(fields, personalaccesstoken.FieldTags)
	}
	if m.FieldCleared(personalaccesstoken.FieldExpiresAt) {
		fields = append(fields, personalaccesstoken.FieldExpiresAt)
	}
	if m.FieldCleared(personalaccesstoken.FieldDescription) {
		fields = append(fields, personalaccesstoken.FieldDescription)
	}
	if m.FieldCleared(personalaccesstoken.FieldScopes) {
		fields = append(fields, personalaccesstoken.FieldScopes)
	}
	if m.FieldCleared(personalaccesstoken.FieldLastUsedAt) {
		fields = append(fields, personalaccesstoken.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalAccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalAccessTokenMutation) ClearField(name string) error {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case personalaccesstoken.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case personalaccesstoken.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case personalaccesstoken.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case personalaccesstoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case personalaccesstoken.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case personalaccesstoken.FieldTags:
		m.ClearTags()
		return nil
	case personalaccesstoken.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case personalaccesstoken.FieldDescription:
		m.ClearDescription()
		return nil
	case personalaccesstoken.FieldScopes:
		m.ClearScopes()
		return nil
	case personalaccesstoken.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalAccessTokenMutation) ResetField(name string) error {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personalaccesstoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case personalaccesstoken.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case personalaccesstoken.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case personalaccesstoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case personalaccesstoken.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case personalaccesstoken.FieldMappingID:
		m.ResetMappingID()
		return nil
	case personalaccesstoken.FieldTags:
		m.ResetTags()
		return nil
	case personalaccesstoken.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case personalaccesstoken.FieldName:
		m.ResetName()
		return nil
	case personalaccesstoken.FieldToken:
		m.ResetToken()
		return nil
	case personalaccesstoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case personalaccesstoken.FieldDescription:
		m.ResetDescription()
		return nil
	case personalaccesstoken.FieldScopes:
		m.ResetScopes()
		return nil
	case personalaccesstoken.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalAccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, personalaccesstoken.EdgeOwner)
	}
	if m.organizations != nil {
		edges = append(edges, personalaccesstoken.EdgeOrganizations)
	}
	if m.events != nil {
		edges = append(edges, personalaccesstoken.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalAccessTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personalaccesstoken.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case personalaccesstoken.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case personalaccesstoken.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalAccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorganizations != nil {
		edges = append(edges, personalaccesstoken.EdgeOrganizations)
	}
	if m.removedevents != nil {
		edges = append(edges, personalaccesstoken.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalAccessTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case personalaccesstoken.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case personalaccesstoken.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalAccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, personalaccesstoken.EdgeOwner)
	}
	if m.clearedorganizations {
		edges = append(edges, personalaccesstoken.EdgeOrganizations)
	}
	if m.clearedevents {
		edges = append(edges, personalaccesstoken.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalAccessTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case personalaccesstoken.EdgeOwner:
		return m.clearedowner
	case personalaccesstoken.EdgeOrganizations:
		return m.clearedorganizations
	case personalaccesstoken.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalAccessTokenMutation) ClearEdge(name string) error {
	switch name {
	case personalaccesstoken.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalAccessTokenMutation) ResetEdge(name string) error {
	switch name {
	case personalaccesstoken.EdgeOwner:
		m.ResetOwner()
		return nil
	case personalaccesstoken.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case personalaccesstoken.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken edge %s", name)
}

// ProcedureMutation represents an operation that mutates the Procedure nodes in the graph.
type ProcedureMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	created_by            *string
	updated_by            *string
	deleted_at            *time.Time
	deleted_by            *string
	mapping_id            *string
	tags                  *[]string
	appendtags            []string
	name                  *string
	description           *string
	status                *string
	procedure_type        *string
	version               *string
	purpose_and_scope     *string
	background            *string
	satisfies             *string
	details               *map[string]interface{}
	clearedFields         map[string]struct{}
	control               map[string]struct{}
	removedcontrol        map[string]struct{}
	clearedcontrol        bool
	internalpolicy        map[string]struct{}
	removedinternalpolicy map[string]struct{}
	clearedinternalpolicy bool
	narratives            map[string]struct{}
	removednarratives     map[string]struct{}
	clearednarratives     bool
	risks                 map[string]struct{}
	removedrisks          map[string]struct{}
	clearedrisks          bool
	tasks                 map[string]struct{}
	removedtasks          map[string]struct{}
	clearedtasks          bool
	programs              map[string]struct{}
	removedprograms       map[string]struct{}
	clearedprograms       bool
	done                  bool
	oldValue              func(context.Context) (*Procedure, error)
	predicates            []predicate.Procedure
}

var _ ent.Mutation = (*ProcedureMutation)(nil)

// procedureOption allows management of the mutation configuration using functional options.
type procedureOption func(*ProcedureMutation)

// newProcedureMutation creates new mutation for the Procedure entity.
func newProcedureMutation(c config, op Op, opts ...procedureOption) *ProcedureMutation {
	m := &ProcedureMutation{
		config:        c,
		op:            op,
		typ:           TypeProcedure,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcedureID sets the ID field of the mutation.
func withProcedureID(id string) procedureOption {
	return func(m *ProcedureMutation) {
		var (
			err   error
			once  sync.Once
			value *Procedure
		)
		m.oldValue = func(ctx context.Context) (*Procedure, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Procedure.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcedure sets the old Procedure of the mutation.
func withProcedure(node *Procedure) procedureOption {
	return func(m *ProcedureMutation) {
		m.oldValue = func(context.Context) (*Procedure, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcedureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcedureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Procedure entities.
func (m *ProcedureMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcedureMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcedureMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Procedure.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcedureMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcedureMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProcedureMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[procedure.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProcedureMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[procedure.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcedureMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, procedure.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcedureMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcedureMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProcedureMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[procedure.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProcedureMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[procedure.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcedureMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, procedure.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProcedureMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProcedureMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProcedureMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[procedure.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProcedureMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[procedure.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProcedureMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, procedure.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProcedureMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProcedureMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProcedureMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[procedure.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProcedureMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[procedure.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProcedureMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, procedure.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProcedureMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProcedureMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProcedureMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[procedure.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProcedureMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[procedure.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProcedureMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, procedure.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ProcedureMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ProcedureMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ProcedureMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[procedure.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ProcedureMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[procedure.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ProcedureMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, procedure.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ProcedureMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ProcedureMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ProcedureMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *ProcedureMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ProcedureMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ProcedureMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ProcedureMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ProcedureMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[procedure.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ProcedureMutation) TagsCleared() bool {
	_, ok := m.clearedFields[procedure.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ProcedureMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, procedure.FieldTags)
}

// SetName sets the "name" field.
func (m *ProcedureMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcedureMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProcedureMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProcedureMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProcedureMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProcedureMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[procedure.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProcedureMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[procedure.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProcedureMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, procedure.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ProcedureMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcedureMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ProcedureMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[procedure.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProcedureMutation) StatusCleared() bool {
	_, ok := m.clearedFields[procedure.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcedureMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, procedure.FieldStatus)
}

// SetProcedureType sets the "procedure_type" field.
func (m *ProcedureMutation) SetProcedureType(s string) {
	m.procedure_type = &s
}

// ProcedureType returns the value of the "procedure_type" field in the mutation.
func (m *ProcedureMutation) ProcedureType() (r string, exists bool) {
	v := m.procedure_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProcedureType returns the old "procedure_type" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldProcedureType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcedureType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcedureType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcedureType: %w", err)
	}
	return oldValue.ProcedureType, nil
}

// ClearProcedureType clears the value of the "procedure_type" field.
func (m *ProcedureMutation) ClearProcedureType() {
	m.procedure_type = nil
	m.clearedFields[procedure.FieldProcedureType] = struct{}{}
}

// ProcedureTypeCleared returns if the "procedure_type" field was cleared in this mutation.
func (m *ProcedureMutation) ProcedureTypeCleared() bool {
	_, ok := m.clearedFields[procedure.FieldProcedureType]
	return ok
}

// ResetProcedureType resets all changes to the "procedure_type" field.
func (m *ProcedureMutation) ResetProcedureType() {
	m.procedure_type = nil
	delete(m.clearedFields, procedure.FieldProcedureType)
}

// SetVersion sets the "version" field.
func (m *ProcedureMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ProcedureMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ProcedureMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[procedure.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ProcedureMutation) VersionCleared() bool {
	_, ok := m.clearedFields[procedure.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ProcedureMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, procedure.FieldVersion)
}

// SetPurposeAndScope sets the "purpose_and_scope" field.
func (m *ProcedureMutation) SetPurposeAndScope(s string) {
	m.purpose_and_scope = &s
}

// PurposeAndScope returns the value of the "purpose_and_scope" field in the mutation.
func (m *ProcedureMutation) PurposeAndScope() (r string, exists bool) {
	v := m.purpose_and_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldPurposeAndScope returns the old "purpose_and_scope" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldPurposeAndScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurposeAndScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurposeAndScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurposeAndScope: %w", err)
	}
	return oldValue.PurposeAndScope, nil
}

// ClearPurposeAndScope clears the value of the "purpose_and_scope" field.
func (m *ProcedureMutation) ClearPurposeAndScope() {
	m.purpose_and_scope = nil
	m.clearedFields[procedure.FieldPurposeAndScope] = struct{}{}
}

// PurposeAndScopeCleared returns if the "purpose_and_scope" field was cleared in this mutation.
func (m *ProcedureMutation) PurposeAndScopeCleared() bool {
	_, ok := m.clearedFields[procedure.FieldPurposeAndScope]
	return ok
}

// ResetPurposeAndScope resets all changes to the "purpose_and_scope" field.
func (m *ProcedureMutation) ResetPurposeAndScope() {
	m.purpose_and_scope = nil
	delete(m.clearedFields, procedure.FieldPurposeAndScope)
}

// SetBackground sets the "background" field.
func (m *ProcedureMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *ProcedureMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *ProcedureMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[procedure.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *ProcedureMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[procedure.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *ProcedureMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, procedure.FieldBackground)
}

// SetSatisfies sets the "satisfies" field.
func (m *ProcedureMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *ProcedureMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *ProcedureMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[procedure.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *ProcedureMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[procedure.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *ProcedureMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, procedure.FieldSatisfies)
}

// SetDetails sets the "details" field.
func (m *ProcedureMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *ProcedureMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Procedure entity.
// If the Procedure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ProcedureMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[procedure.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ProcedureMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[procedure.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ProcedureMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, procedure.FieldDetails)
}

// AddControlIDs adds the "control" edge to the Control entity by ids.
func (m *ProcedureMutation) AddControlIDs(ids ...string) {
	if m.control == nil {
		m.control = make(map[string]struct{})
	}
	for i := range ids {
		m.control[ids[i]] = struct{}{}
	}
}

// ClearControl clears the "control" edge to the Control entity.
func (m *ProcedureMutation) ClearControl() {
	m.clearedcontrol = true
}

// ControlCleared reports if the "control" edge to the Control entity was cleared.
func (m *ProcedureMutation) ControlCleared() bool {
	return m.clearedcontrol
}

// RemoveControlIDs removes the "control" edge to the Control entity by IDs.
func (m *ProcedureMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrol == nil {
		m.removedcontrol = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.control, ids[i])
		m.removedcontrol[ids[i]] = struct{}{}
	}
}

// RemovedControl returns the removed IDs of the "control" edge to the Control entity.
func (m *ProcedureMutation) RemovedControlIDs() (ids []string) {
	for id := range m.removedcontrol {
		ids = append(ids, id)
	}
	return
}

// ControlIDs returns the "control" edge IDs in the mutation.
func (m *ProcedureMutation) ControlIDs() (ids []string) {
	for id := range m.control {
		ids = append(ids, id)
	}
	return
}

// ResetControl resets all changes to the "control" edge.
func (m *ProcedureMutation) ResetControl() {
	m.control = nil
	m.clearedcontrol = false
	m.removedcontrol = nil
}

// AddInternalpolicyIDs adds the "internalpolicy" edge to the InternalPolicy entity by ids.
func (m *ProcedureMutation) AddInternalpolicyIDs(ids ...string) {
	if m.internalpolicy == nil {
		m.internalpolicy = make(map[string]struct{})
	}
	for i := range ids {
		m.internalpolicy[ids[i]] = struct{}{}
	}
}

// ClearInternalpolicy clears the "internalpolicy" edge to the InternalPolicy entity.
func (m *ProcedureMutation) ClearInternalpolicy() {
	m.clearedinternalpolicy = true
}

// InternalpolicyCleared reports if the "internalpolicy" edge to the InternalPolicy entity was cleared.
func (m *ProcedureMutation) InternalpolicyCleared() bool {
	return m.clearedinternalpolicy
}

// RemoveInternalpolicyIDs removes the "internalpolicy" edge to the InternalPolicy entity by IDs.
func (m *ProcedureMutation) RemoveInternalpolicyIDs(ids ...string) {
	if m.removedinternalpolicy == nil {
		m.removedinternalpolicy = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.internalpolicy, ids[i])
		m.removedinternalpolicy[ids[i]] = struct{}{}
	}
}

// RemovedInternalpolicy returns the removed IDs of the "internalpolicy" edge to the InternalPolicy entity.
func (m *ProcedureMutation) RemovedInternalpolicyIDs() (ids []string) {
	for id := range m.removedinternalpolicy {
		ids = append(ids, id)
	}
	return
}

// InternalpolicyIDs returns the "internalpolicy" edge IDs in the mutation.
func (m *ProcedureMutation) InternalpolicyIDs() (ids []string) {
	for id := range m.internalpolicy {
		ids = append(ids, id)
	}
	return
}

// ResetInternalpolicy resets all changes to the "internalpolicy" edge.
func (m *ProcedureMutation) ResetInternalpolicy() {
	m.internalpolicy = nil
	m.clearedinternalpolicy = false
	m.removedinternalpolicy = nil
}

// AddNarrativeIDs adds the "narratives" edge to the Narrative entity by ids.
func (m *ProcedureMutation) AddNarrativeIDs(ids ...string) {
	if m.narratives == nil {
		m.narratives = make(map[string]struct{})
	}
	for i := range ids {
		m.narratives[ids[i]] = struct{}{}
	}
}

// ClearNarratives clears the "narratives" edge to the Narrative entity.
func (m *ProcedureMutation) ClearNarratives() {
	m.clearednarratives = true
}

// NarrativesCleared reports if the "narratives" edge to the Narrative entity was cleared.
func (m *ProcedureMutation) NarrativesCleared() bool {
	return m.clearednarratives
}

// RemoveNarrativeIDs removes the "narratives" edge to the Narrative entity by IDs.
func (m *ProcedureMutation) RemoveNarrativeIDs(ids ...string) {
	if m.removednarratives == nil {
		m.removednarratives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.narratives, ids[i])
		m.removednarratives[ids[i]] = struct{}{}
	}
}

// RemovedNarratives returns the removed IDs of the "narratives" edge to the Narrative entity.
func (m *ProcedureMutation) RemovedNarrativesIDs() (ids []string) {
	for id := range m.removednarratives {
		ids = append(ids, id)
	}
	return
}

// NarrativesIDs returns the "narratives" edge IDs in the mutation.
func (m *ProcedureMutation) NarrativesIDs() (ids []string) {
	for id := range m.narratives {
		ids = append(ids, id)
	}
	return
}

// ResetNarratives resets all changes to the "narratives" edge.
func (m *ProcedureMutation) ResetNarratives() {
	m.narratives = nil
	m.clearednarratives = false
	m.removednarratives = nil
}

// AddRiskIDs adds the "risks" edge to the Risk entity by ids.
func (m *ProcedureMutation) AddRiskIDs(ids ...string) {
	if m.risks == nil {
		m.risks = make(map[string]struct{})
	}
	for i := range ids {
		m.risks[ids[i]] = struct{}{}
	}
}

// ClearRisks clears the "risks" edge to the Risk entity.
func (m *ProcedureMutation) ClearRisks() {
	m.clearedrisks = true
}

// RisksCleared reports if the "risks" edge to the Risk entity was cleared.
func (m *ProcedureMutation) RisksCleared() bool {
	return m.clearedrisks
}

// RemoveRiskIDs removes the "risks" edge to the Risk entity by IDs.
func (m *ProcedureMutation) RemoveRiskIDs(ids ...string) {
	if m.removedrisks == nil {
		m.removedrisks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.risks, ids[i])
		m.removedrisks[ids[i]] = struct{}{}
	}
}

// RemovedRisks returns the removed IDs of the "risks" edge to the Risk entity.
func (m *ProcedureMutation) RemovedRisksIDs() (ids []string) {
	for id := range m.removedrisks {
		ids = append(ids, id)
	}
	return
}

// RisksIDs returns the "risks" edge IDs in the mutation.
func (m *ProcedureMutation) RisksIDs() (ids []string) {
	for id := range m.risks {
		ids = append(ids, id)
	}
	return
}

// ResetRisks resets all changes to the "risks" edge.
func (m *ProcedureMutation) ResetRisks() {
	m.risks = nil
	m.clearedrisks = false
	m.removedrisks = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ProcedureMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ProcedureMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ProcedureMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ProcedureMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ProcedureMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProcedureMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProcedureMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *ProcedureMutation) AddProgramIDs(ids ...string) {
	if m.programs == nil {
		m.programs = make(map[string]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *ProcedureMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *ProcedureMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *ProcedureMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *ProcedureMutation) RemovedProgramsIDs() (ids []string) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *ProcedureMutation) ProgramsIDs() (ids []string) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *ProcedureMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// Where appends a list predicates to the ProcedureMutation builder.
func (m *ProcedureMutation) Where(ps ...predicate.Procedure) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcedureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcedureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Procedure, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcedureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcedureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Procedure).
func (m *ProcedureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcedureMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, procedure.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, procedure.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, procedure.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, procedure.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, procedure.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, procedure.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, procedure.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, procedure.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, procedure.FieldName)
	}
	if m.description != nil {
		fields = append(fields, procedure.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, procedure.FieldStatus)
	}
	if m.procedure_type != nil {
		fields = append(fields, procedure.FieldProcedureType)
	}
	if m.version != nil {
		fields = append(fields, procedure.FieldVersion)
	}
	if m.purpose_and_scope != nil {
		fields = append(fields, procedure.FieldPurposeAndScope)
	}
	if m.background != nil {
		fields = append(fields, procedure.FieldBackground)
	}
	if m.satisfies != nil {
		fields = append(fields, procedure.FieldSatisfies)
	}
	if m.details != nil {
		fields = append(fields, procedure.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcedureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case procedure.FieldCreatedAt:
		return m.CreatedAt()
	case procedure.FieldUpdatedAt:
		return m.UpdatedAt()
	case procedure.FieldCreatedBy:
		return m.CreatedBy()
	case procedure.FieldUpdatedBy:
		return m.UpdatedBy()
	case procedure.FieldDeletedAt:
		return m.DeletedAt()
	case procedure.FieldDeletedBy:
		return m.DeletedBy()
	case procedure.FieldMappingID:
		return m.MappingID()
	case procedure.FieldTags:
		return m.Tags()
	case procedure.FieldName:
		return m.Name()
	case procedure.FieldDescription:
		return m.Description()
	case procedure.FieldStatus:
		return m.Status()
	case procedure.FieldProcedureType:
		return m.ProcedureType()
	case procedure.FieldVersion:
		return m.Version()
	case procedure.FieldPurposeAndScope:
		return m.PurposeAndScope()
	case procedure.FieldBackground:
		return m.Background()
	case procedure.FieldSatisfies:
		return m.Satisfies()
	case procedure.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcedureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case procedure.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case procedure.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case procedure.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case procedure.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case procedure.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case procedure.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case procedure.FieldMappingID:
		return m.OldMappingID(ctx)
	case procedure.FieldTags:
		return m.OldTags(ctx)
	case procedure.FieldName:
		return m.OldName(ctx)
	case procedure.FieldDescription:
		return m.OldDescription(ctx)
	case procedure.FieldStatus:
		return m.OldStatus(ctx)
	case procedure.FieldProcedureType:
		return m.OldProcedureType(ctx)
	case procedure.FieldVersion:
		return m.OldVersion(ctx)
	case procedure.FieldPurposeAndScope:
		return m.OldPurposeAndScope(ctx)
	case procedure.FieldBackground:
		return m.OldBackground(ctx)
	case procedure.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case procedure.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Procedure field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case procedure.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case procedure.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case procedure.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case procedure.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case procedure.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case procedure.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case procedure.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case procedure.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case procedure.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case procedure.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case procedure.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case procedure.FieldProcedureType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcedureType(v)
		return nil
	case procedure.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case procedure.FieldPurposeAndScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurposeAndScope(v)
		return nil
	case procedure.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case procedure.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case procedure.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Procedure field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcedureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcedureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Procedure numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcedureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(procedure.FieldCreatedAt) {
		fields = append(fields, procedure.FieldCreatedAt)
	}
	if m.FieldCleared(procedure.FieldUpdatedAt) {
		fields = append(fields, procedure.FieldUpdatedAt)
	}
	if m.FieldCleared(procedure.FieldCreatedBy) {
		fields = append(fields, procedure.FieldCreatedBy)
	}
	if m.FieldCleared(procedure.FieldUpdatedBy) {
		fields = append(fields, procedure.FieldUpdatedBy)
	}
	if m.FieldCleared(procedure.FieldDeletedAt) {
		fields = append(fields, procedure.FieldDeletedAt)
	}
	if m.FieldCleared(procedure.FieldDeletedBy) {
		fields = append(fields, procedure.FieldDeletedBy)
	}
	if m.FieldCleared(procedure.FieldTags) {
		fields = append(fields, procedure.FieldTags)
	}
	if m.FieldCleared(procedure.FieldDescription) {
		fields = append(fields, procedure.FieldDescription)
	}
	if m.FieldCleared(procedure.FieldStatus) {
		fields = append(fields, procedure.FieldStatus)
	}
	if m.FieldCleared(procedure.FieldProcedureType) {
		fields = append(fields, procedure.FieldProcedureType)
	}
	if m.FieldCleared(procedure.FieldVersion) {
		fields = append(fields, procedure.FieldVersion)
	}
	if m.FieldCleared(procedure.FieldPurposeAndScope) {
		fields = append(fields, procedure.FieldPurposeAndScope)
	}
	if m.FieldCleared(procedure.FieldBackground) {
		fields = append(fields, procedure.FieldBackground)
	}
	if m.FieldCleared(procedure.FieldSatisfies) {
		fields = append(fields, procedure.FieldSatisfies)
	}
	if m.FieldCleared(procedure.FieldDetails) {
		fields = append(fields, procedure.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcedureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcedureMutation) ClearField(name string) error {
	switch name {
	case procedure.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case procedure.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case procedure.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case procedure.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case procedure.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case procedure.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case procedure.FieldTags:
		m.ClearTags()
		return nil
	case procedure.FieldDescription:
		m.ClearDescription()
		return nil
	case procedure.FieldStatus:
		m.ClearStatus()
		return nil
	case procedure.FieldProcedureType:
		m.ClearProcedureType()
		return nil
	case procedure.FieldVersion:
		m.ClearVersion()
		return nil
	case procedure.FieldPurposeAndScope:
		m.ClearPurposeAndScope()
		return nil
	case procedure.FieldBackground:
		m.ClearBackground()
		return nil
	case procedure.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case procedure.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Procedure nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcedureMutation) ResetField(name string) error {
	switch name {
	case procedure.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case procedure.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case procedure.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case procedure.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case procedure.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case procedure.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case procedure.FieldMappingID:
		m.ResetMappingID()
		return nil
	case procedure.FieldTags:
		m.ResetTags()
		return nil
	case procedure.FieldName:
		m.ResetName()
		return nil
	case procedure.FieldDescription:
		m.ResetDescription()
		return nil
	case procedure.FieldStatus:
		m.ResetStatus()
		return nil
	case procedure.FieldProcedureType:
		m.ResetProcedureType()
		return nil
	case procedure.FieldVersion:
		m.ResetVersion()
		return nil
	case procedure.FieldPurposeAndScope:
		m.ResetPurposeAndScope()
		return nil
	case procedure.FieldBackground:
		m.ResetBackground()
		return nil
	case procedure.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case procedure.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Procedure field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcedureMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.control != nil {
		edges = append(edges, procedure.EdgeControl)
	}
	if m.internalpolicy != nil {
		edges = append(edges, procedure.EdgeInternalpolicy)
	}
	if m.narratives != nil {
		edges = append(edges, procedure.EdgeNarratives)
	}
	if m.risks != nil {
		edges = append(edges, procedure.EdgeRisks)
	}
	if m.tasks != nil {
		edges = append(edges, procedure.EdgeTasks)
	}
	if m.programs != nil {
		edges = append(edges, procedure.EdgePrograms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcedureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case procedure.EdgeControl:
		ids := make([]ent.Value, 0, len(m.control))
		for id := range m.control {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgeInternalpolicy:
		ids := make([]ent.Value, 0, len(m.internalpolicy))
		for id := range m.internalpolicy {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.narratives))
		for id := range m.narratives {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgeRisks:
		ids := make([]ent.Value, 0, len(m.risks))
		for id := range m.risks {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcedureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcontrol != nil {
		edges = append(edges, procedure.EdgeControl)
	}
	if m.removedinternalpolicy != nil {
		edges = append(edges, procedure.EdgeInternalpolicy)
	}
	if m.removednarratives != nil {
		edges = append(edges, procedure.EdgeNarratives)
	}
	if m.removedrisks != nil {
		edges = append(edges, procedure.EdgeRisks)
	}
	if m.removedtasks != nil {
		edges = append(edges, procedure.EdgeTasks)
	}
	if m.removedprograms != nil {
		edges = append(edges, procedure.EdgePrograms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcedureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case procedure.EdgeControl:
		ids := make([]ent.Value, 0, len(m.removedcontrol))
		for id := range m.removedcontrol {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgeInternalpolicy:
		ids := make([]ent.Value, 0, len(m.removedinternalpolicy))
		for id := range m.removedinternalpolicy {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.removednarratives))
		for id := range m.removednarratives {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgeRisks:
		ids := make([]ent.Value, 0, len(m.removedrisks))
		for id := range m.removedrisks {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case procedure.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcedureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcontrol {
		edges = append(edges, procedure.EdgeControl)
	}
	if m.clearedinternalpolicy {
		edges = append(edges, procedure.EdgeInternalpolicy)
	}
	if m.clearednarratives {
		edges = append(edges, procedure.EdgeNarratives)
	}
	if m.clearedrisks {
		edges = append(edges, procedure.EdgeRisks)
	}
	if m.clearedtasks {
		edges = append(edges, procedure.EdgeTasks)
	}
	if m.clearedprograms {
		edges = append(edges, procedure.EdgePrograms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcedureMutation) EdgeCleared(name string) bool {
	switch name {
	case procedure.EdgeControl:
		return m.clearedcontrol
	case procedure.EdgeInternalpolicy:
		return m.clearedinternalpolicy
	case procedure.EdgeNarratives:
		return m.clearednarratives
	case procedure.EdgeRisks:
		return m.clearedrisks
	case procedure.EdgeTasks:
		return m.clearedtasks
	case procedure.EdgePrograms:
		return m.clearedprograms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcedureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Procedure unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcedureMutation) ResetEdge(name string) error {
	switch name {
	case procedure.EdgeControl:
		m.ResetControl()
		return nil
	case procedure.EdgeInternalpolicy:
		m.ResetInternalpolicy()
		return nil
	case procedure.EdgeNarratives:
		m.ResetNarratives()
		return nil
	case procedure.EdgeRisks:
		m.ResetRisks()
		return nil
	case procedure.EdgeTasks:
		m.ResetTasks()
		return nil
	case procedure.EdgePrograms:
		m.ResetPrograms()
		return nil
	}
	return fmt.Errorf("unknown Procedure edge %s", name)
}

// ProcedureHistoryMutation represents an operation that mutates the ProcedureHistory nodes in the graph.
type ProcedureHistoryMutation struct {
	config
	op                Op
	typ               string
	id                *string
	history_time      *time.Time
	ref               *string
	operation         *history.OpType
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	deleted_at        *time.Time
	deleted_by        *string
	mapping_id        *string
	tags              *[]string
	appendtags        []string
	name              *string
	description       *string
	status            *string
	procedure_type    *string
	version           *string
	purpose_and_scope *string
	background        *string
	satisfies         *string
	details           *map[string]interface{}
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ProcedureHistory, error)
	predicates        []predicate.ProcedureHistory
}

var _ ent.Mutation = (*ProcedureHistoryMutation)(nil)

// procedurehistoryOption allows management of the mutation configuration using functional options.
type procedurehistoryOption func(*ProcedureHistoryMutation)

// newProcedureHistoryMutation creates new mutation for the ProcedureHistory entity.
func newProcedureHistoryMutation(c config, op Op, opts ...procedurehistoryOption) *ProcedureHistoryMutation {
	m := &ProcedureHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProcedureHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcedureHistoryID sets the ID field of the mutation.
func withProcedureHistoryID(id string) procedurehistoryOption {
	return func(m *ProcedureHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcedureHistory
		)
		m.oldValue = func(ctx context.Context) (*ProcedureHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcedureHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcedureHistory sets the old ProcedureHistory of the mutation.
func withProcedureHistory(node *ProcedureHistory) procedurehistoryOption {
	return func(m *ProcedureHistoryMutation) {
		m.oldValue = func(context.Context) (*ProcedureHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcedureHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcedureHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProcedureHistory entities.
func (m *ProcedureHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcedureHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcedureHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcedureHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ProcedureHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ProcedureHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ProcedureHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ProcedureHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ProcedureHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ProcedureHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[procedurehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ProcedureHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, procedurehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ProcedureHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ProcedureHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ProcedureHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcedureHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcedureHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProcedureHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[procedurehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcedureHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, procedurehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcedureHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcedureHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProcedureHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[procedurehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcedureHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, procedurehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProcedureHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProcedureHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProcedureHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[procedurehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProcedureHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, procedurehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProcedureHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProcedureHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProcedureHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[procedurehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProcedureHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, procedurehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProcedureHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProcedureHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProcedureHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[procedurehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProcedureHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, procedurehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ProcedureHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ProcedureHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ProcedureHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[procedurehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ProcedureHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, procedurehistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ProcedureHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ProcedureHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ProcedureHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *ProcedureHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ProcedureHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ProcedureHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ProcedureHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ProcedureHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[procedurehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ProcedureHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, procedurehistory.FieldTags)
}

// SetName sets the "name" field.
func (m *ProcedureHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcedureHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProcedureHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProcedureHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProcedureHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProcedureHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[procedurehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProcedureHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, procedurehistory.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ProcedureHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcedureHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *ProcedureHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[procedurehistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcedureHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, procedurehistory.FieldStatus)
}

// SetProcedureType sets the "procedure_type" field.
func (m *ProcedureHistoryMutation) SetProcedureType(s string) {
	m.procedure_type = &s
}

// ProcedureType returns the value of the "procedure_type" field in the mutation.
func (m *ProcedureHistoryMutation) ProcedureType() (r string, exists bool) {
	v := m.procedure_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProcedureType returns the old "procedure_type" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldProcedureType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcedureType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcedureType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcedureType: %w", err)
	}
	return oldValue.ProcedureType, nil
}

// ClearProcedureType clears the value of the "procedure_type" field.
func (m *ProcedureHistoryMutation) ClearProcedureType() {
	m.procedure_type = nil
	m.clearedFields[procedurehistory.FieldProcedureType] = struct{}{}
}

// ProcedureTypeCleared returns if the "procedure_type" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) ProcedureTypeCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldProcedureType]
	return ok
}

// ResetProcedureType resets all changes to the "procedure_type" field.
func (m *ProcedureHistoryMutation) ResetProcedureType() {
	m.procedure_type = nil
	delete(m.clearedFields, procedurehistory.FieldProcedureType)
}

// SetVersion sets the "version" field.
func (m *ProcedureHistoryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ProcedureHistoryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ProcedureHistoryMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[procedurehistory.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) VersionCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ProcedureHistoryMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, procedurehistory.FieldVersion)
}

// SetPurposeAndScope sets the "purpose_and_scope" field.
func (m *ProcedureHistoryMutation) SetPurposeAndScope(s string) {
	m.purpose_and_scope = &s
}

// PurposeAndScope returns the value of the "purpose_and_scope" field in the mutation.
func (m *ProcedureHistoryMutation) PurposeAndScope() (r string, exists bool) {
	v := m.purpose_and_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldPurposeAndScope returns the old "purpose_and_scope" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldPurposeAndScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurposeAndScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurposeAndScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurposeAndScope: %w", err)
	}
	return oldValue.PurposeAndScope, nil
}

// ClearPurposeAndScope clears the value of the "purpose_and_scope" field.
func (m *ProcedureHistoryMutation) ClearPurposeAndScope() {
	m.purpose_and_scope = nil
	m.clearedFields[procedurehistory.FieldPurposeAndScope] = struct{}{}
}

// PurposeAndScopeCleared returns if the "purpose_and_scope" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) PurposeAndScopeCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldPurposeAndScope]
	return ok
}

// ResetPurposeAndScope resets all changes to the "purpose_and_scope" field.
func (m *ProcedureHistoryMutation) ResetPurposeAndScope() {
	m.purpose_and_scope = nil
	delete(m.clearedFields, procedurehistory.FieldPurposeAndScope)
}

// SetBackground sets the "background" field.
func (m *ProcedureHistoryMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *ProcedureHistoryMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *ProcedureHistoryMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[procedurehistory.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *ProcedureHistoryMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, procedurehistory.FieldBackground)
}

// SetSatisfies sets the "satisfies" field.
func (m *ProcedureHistoryMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *ProcedureHistoryMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *ProcedureHistoryMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[procedurehistory.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *ProcedureHistoryMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, procedurehistory.FieldSatisfies)
}

// SetDetails sets the "details" field.
func (m *ProcedureHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *ProcedureHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the ProcedureHistory entity.
// If the ProcedureHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcedureHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *ProcedureHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[procedurehistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *ProcedureHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[procedurehistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *ProcedureHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, procedurehistory.FieldDetails)
}

// Where appends a list predicates to the ProcedureHistoryMutation builder.
func (m *ProcedureHistoryMutation) Where(ps ...predicate.ProcedureHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcedureHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcedureHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcedureHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcedureHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcedureHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcedureHistory).
func (m *ProcedureHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcedureHistoryMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.history_time != nil {
		fields = append(fields, procedurehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, procedurehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, procedurehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, procedurehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, procedurehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, procedurehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, procedurehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, procedurehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, procedurehistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, procedurehistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, procedurehistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, procedurehistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, procedurehistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, procedurehistory.FieldStatus)
	}
	if m.procedure_type != nil {
		fields = append(fields, procedurehistory.FieldProcedureType)
	}
	if m.version != nil {
		fields = append(fields, procedurehistory.FieldVersion)
	}
	if m.purpose_and_scope != nil {
		fields = append(fields, procedurehistory.FieldPurposeAndScope)
	}
	if m.background != nil {
		fields = append(fields, procedurehistory.FieldBackground)
	}
	if m.satisfies != nil {
		fields = append(fields, procedurehistory.FieldSatisfies)
	}
	if m.details != nil {
		fields = append(fields, procedurehistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcedureHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case procedurehistory.FieldHistoryTime:
		return m.HistoryTime()
	case procedurehistory.FieldRef:
		return m.Ref()
	case procedurehistory.FieldOperation:
		return m.Operation()
	case procedurehistory.FieldCreatedAt:
		return m.CreatedAt()
	case procedurehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case procedurehistory.FieldCreatedBy:
		return m.CreatedBy()
	case procedurehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case procedurehistory.FieldDeletedAt:
		return m.DeletedAt()
	case procedurehistory.FieldDeletedBy:
		return m.DeletedBy()
	case procedurehistory.FieldMappingID:
		return m.MappingID()
	case procedurehistory.FieldTags:
		return m.Tags()
	case procedurehistory.FieldName:
		return m.Name()
	case procedurehistory.FieldDescription:
		return m.Description()
	case procedurehistory.FieldStatus:
		return m.Status()
	case procedurehistory.FieldProcedureType:
		return m.ProcedureType()
	case procedurehistory.FieldVersion:
		return m.Version()
	case procedurehistory.FieldPurposeAndScope:
		return m.PurposeAndScope()
	case procedurehistory.FieldBackground:
		return m.Background()
	case procedurehistory.FieldSatisfies:
		return m.Satisfies()
	case procedurehistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcedureHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case procedurehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case procedurehistory.FieldRef:
		return m.OldRef(ctx)
	case procedurehistory.FieldOperation:
		return m.OldOperation(ctx)
	case procedurehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case procedurehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case procedurehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case procedurehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case procedurehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case procedurehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case procedurehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case procedurehistory.FieldTags:
		return m.OldTags(ctx)
	case procedurehistory.FieldName:
		return m.OldName(ctx)
	case procedurehistory.FieldDescription:
		return m.OldDescription(ctx)
	case procedurehistory.FieldStatus:
		return m.OldStatus(ctx)
	case procedurehistory.FieldProcedureType:
		return m.OldProcedureType(ctx)
	case procedurehistory.FieldVersion:
		return m.OldVersion(ctx)
	case procedurehistory.FieldPurposeAndScope:
		return m.OldPurposeAndScope(ctx)
	case procedurehistory.FieldBackground:
		return m.OldBackground(ctx)
	case procedurehistory.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case procedurehistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown ProcedureHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case procedurehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case procedurehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case procedurehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case procedurehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case procedurehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case procedurehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case procedurehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case procedurehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case procedurehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case procedurehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case procedurehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case procedurehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case procedurehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case procedurehistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case procedurehistory.FieldProcedureType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcedureType(v)
		return nil
	case procedurehistory.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case procedurehistory.FieldPurposeAndScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurposeAndScope(v)
		return nil
	case procedurehistory.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case procedurehistory.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case procedurehistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown ProcedureHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcedureHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcedureHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcedureHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProcedureHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcedureHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(procedurehistory.FieldRef) {
		fields = append(fields, procedurehistory.FieldRef)
	}
	if m.FieldCleared(procedurehistory.FieldCreatedAt) {
		fields = append(fields, procedurehistory.FieldCreatedAt)
	}
	if m.FieldCleared(procedurehistory.FieldUpdatedAt) {
		fields = append(fields, procedurehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(procedurehistory.FieldCreatedBy) {
		fields = append(fields, procedurehistory.FieldCreatedBy)
	}
	if m.FieldCleared(procedurehistory.FieldUpdatedBy) {
		fields = append(fields, procedurehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(procedurehistory.FieldDeletedAt) {
		fields = append(fields, procedurehistory.FieldDeletedAt)
	}
	if m.FieldCleared(procedurehistory.FieldDeletedBy) {
		fields = append(fields, procedurehistory.FieldDeletedBy)
	}
	if m.FieldCleared(procedurehistory.FieldTags) {
		fields = append(fields, procedurehistory.FieldTags)
	}
	if m.FieldCleared(procedurehistory.FieldDescription) {
		fields = append(fields, procedurehistory.FieldDescription)
	}
	if m.FieldCleared(procedurehistory.FieldStatus) {
		fields = append(fields, procedurehistory.FieldStatus)
	}
	if m.FieldCleared(procedurehistory.FieldProcedureType) {
		fields = append(fields, procedurehistory.FieldProcedureType)
	}
	if m.FieldCleared(procedurehistory.FieldVersion) {
		fields = append(fields, procedurehistory.FieldVersion)
	}
	if m.FieldCleared(procedurehistory.FieldPurposeAndScope) {
		fields = append(fields, procedurehistory.FieldPurposeAndScope)
	}
	if m.FieldCleared(procedurehistory.FieldBackground) {
		fields = append(fields, procedurehistory.FieldBackground)
	}
	if m.FieldCleared(procedurehistory.FieldSatisfies) {
		fields = append(fields, procedurehistory.FieldSatisfies)
	}
	if m.FieldCleared(procedurehistory.FieldDetails) {
		fields = append(fields, procedurehistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcedureHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcedureHistoryMutation) ClearField(name string) error {
	switch name {
	case procedurehistory.FieldRef:
		m.ClearRef()
		return nil
	case procedurehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case procedurehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case procedurehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case procedurehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case procedurehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case procedurehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case procedurehistory.FieldTags:
		m.ClearTags()
		return nil
	case procedurehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case procedurehistory.FieldStatus:
		m.ClearStatus()
		return nil
	case procedurehistory.FieldProcedureType:
		m.ClearProcedureType()
		return nil
	case procedurehistory.FieldVersion:
		m.ClearVersion()
		return nil
	case procedurehistory.FieldPurposeAndScope:
		m.ClearPurposeAndScope()
		return nil
	case procedurehistory.FieldBackground:
		m.ClearBackground()
		return nil
	case procedurehistory.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case procedurehistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown ProcedureHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcedureHistoryMutation) ResetField(name string) error {
	switch name {
	case procedurehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case procedurehistory.FieldRef:
		m.ResetRef()
		return nil
	case procedurehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case procedurehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case procedurehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case procedurehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case procedurehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case procedurehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case procedurehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case procedurehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case procedurehistory.FieldTags:
		m.ResetTags()
		return nil
	case procedurehistory.FieldName:
		m.ResetName()
		return nil
	case procedurehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case procedurehistory.FieldStatus:
		m.ResetStatus()
		return nil
	case procedurehistory.FieldProcedureType:
		m.ResetProcedureType()
		return nil
	case procedurehistory.FieldVersion:
		m.ResetVersion()
		return nil
	case procedurehistory.FieldPurposeAndScope:
		m.ResetPurposeAndScope()
		return nil
	case procedurehistory.FieldBackground:
		m.ResetBackground()
		return nil
	case procedurehistory.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case procedurehistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown ProcedureHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcedureHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcedureHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcedureHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcedureHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcedureHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcedureHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcedureHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcedureHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcedureHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcedureHistory edge %s", name)
}

// ProgramMutation represents an operation that mutates the Program nodes in the graph.
type ProgramMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	mapping_id               *string
	deleted_at               *time.Time
	deleted_by               *string
	tags                     *[]string
	appendtags               []string
	name                     *string
	description              *string
	status                   *enums.ProgramStatus
	start_date               *time.Time
	end_date                 *time.Time
	auditor_ready            *bool
	auditor_write_comments   *bool
	auditor_read_comments    *bool
	clearedFields            map[string]struct{}
	organization             *string
	clearedorganization      bool
	controls                 map[string]struct{}
	removedcontrols          map[string]struct{}
	clearedcontrols          bool
	subcontrols              map[string]struct{}
	removedsubcontrols       map[string]struct{}
	clearedsubcontrols       bool
	controlobjectives        map[string]struct{}
	removedcontrolobjectives map[string]struct{}
	clearedcontrolobjectives bool
	policies                 map[string]struct{}
	removedpolicies          map[string]struct{}
	clearedpolicies          bool
	procedures               map[string]struct{}
	removedprocedures        map[string]struct{}
	clearedprocedures        bool
	risks                    map[string]struct{}
	removedrisks             map[string]struct{}
	clearedrisks             bool
	tasks                    map[string]struct{}
	removedtasks             map[string]struct{}
	clearedtasks             bool
	notes                    map[string]struct{}
	removednotes             map[string]struct{}
	clearednotes             bool
	files                    map[string]struct{}
	removedfiles             map[string]struct{}
	clearedfiles             bool
	narratives               map[string]struct{}
	removednarratives        map[string]struct{}
	clearednarratives        bool
	actionplans              map[string]struct{}
	removedactionplans       map[string]struct{}
	clearedactionplans       bool
	standards                map[string]struct{}
	removedstandards         map[string]struct{}
	clearedstandards         bool
	users                    map[string]struct{}
	removedusers             map[string]struct{}
	clearedusers             bool
	done                     bool
	oldValue                 func(context.Context) (*Program, error)
	predicates               []predicate.Program
}

var _ ent.Mutation = (*ProgramMutation)(nil)

// programOption allows management of the mutation configuration using functional options.
type programOption func(*ProgramMutation)

// newProgramMutation creates new mutation for the Program entity.
func newProgramMutation(c config, op Op, opts ...programOption) *ProgramMutation {
	m := &ProgramMutation{
		config:        c,
		op:            op,
		typ:           TypeProgram,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramID sets the ID field of the mutation.
func withProgramID(id string) programOption {
	return func(m *ProgramMutation) {
		var (
			err   error
			once  sync.Once
			value *Program
		)
		m.oldValue = func(ctx context.Context) (*Program, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Program.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgram sets the old Program of the mutation.
func withProgram(node *Program) programOption {
	return func(m *ProgramMutation) {
		m.oldValue = func(context.Context) (*Program, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Program entities.
func (m *ProgramMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Program.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProgramMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProgramMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProgramMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[program.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProgramMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[program.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProgramMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, program.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProgramMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProgramMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProgramMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[program.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProgramMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[program.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProgramMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, program.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProgramMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProgramMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProgramMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[program.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProgramMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[program.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProgramMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, program.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProgramMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProgramMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProgramMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[program.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProgramMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[program.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProgramMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, program.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ProgramMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ProgramMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ProgramMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProgramMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProgramMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProgramMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[program.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProgramMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[program.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProgramMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, program.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ProgramMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ProgramMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ProgramMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[program.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ProgramMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[program.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ProgramMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, program.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ProgramMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ProgramMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ProgramMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ProgramMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ProgramMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[program.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ProgramMutation) TagsCleared() bool {
	_, ok := m.clearedFields[program.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ProgramMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, program.FieldTags)
}

// SetName sets the "name" field.
func (m *ProgramMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProgramMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProgramMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProgramMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProgramMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProgramMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[program.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProgramMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[program.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProgramMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, program.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ProgramMutation) SetStatus(es enums.ProgramStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ProgramMutation) Status() (r enums.ProgramStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldStatus(ctx context.Context) (v enums.ProgramStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProgramMutation) ResetStatus() {
	m.status = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProgramMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProgramMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ProgramMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[program.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ProgramMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[program.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProgramMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, program.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ProgramMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProgramMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProgramMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[program.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProgramMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[program.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProgramMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, program.FieldEndDate)
}

// SetOrganizationID sets the "organization_id" field.
func (m *ProgramMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ProgramMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ProgramMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetAuditorReady sets the "auditor_ready" field.
func (m *ProgramMutation) SetAuditorReady(b bool) {
	m.auditor_ready = &b
}

// AuditorReady returns the value of the "auditor_ready" field in the mutation.
func (m *ProgramMutation) AuditorReady() (r bool, exists bool) {
	v := m.auditor_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorReady returns the old "auditor_ready" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldAuditorReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorReady: %w", err)
	}
	return oldValue.AuditorReady, nil
}

// ResetAuditorReady resets all changes to the "auditor_ready" field.
func (m *ProgramMutation) ResetAuditorReady() {
	m.auditor_ready = nil
}

// SetAuditorWriteComments sets the "auditor_write_comments" field.
func (m *ProgramMutation) SetAuditorWriteComments(b bool) {
	m.auditor_write_comments = &b
}

// AuditorWriteComments returns the value of the "auditor_write_comments" field in the mutation.
func (m *ProgramMutation) AuditorWriteComments() (r bool, exists bool) {
	v := m.auditor_write_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorWriteComments returns the old "auditor_write_comments" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldAuditorWriteComments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorWriteComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorWriteComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorWriteComments: %w", err)
	}
	return oldValue.AuditorWriteComments, nil
}

// ResetAuditorWriteComments resets all changes to the "auditor_write_comments" field.
func (m *ProgramMutation) ResetAuditorWriteComments() {
	m.auditor_write_comments = nil
}

// SetAuditorReadComments sets the "auditor_read_comments" field.
func (m *ProgramMutation) SetAuditorReadComments(b bool) {
	m.auditor_read_comments = &b
}

// AuditorReadComments returns the value of the "auditor_read_comments" field in the mutation.
func (m *ProgramMutation) AuditorReadComments() (r bool, exists bool) {
	v := m.auditor_read_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorReadComments returns the old "auditor_read_comments" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldAuditorReadComments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorReadComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorReadComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorReadComments: %w", err)
	}
	return oldValue.AuditorReadComments, nil
}

// ResetAuditorReadComments resets all changes to the "auditor_read_comments" field.
func (m *ProgramMutation) ResetAuditorReadComments() {
	m.auditor_read_comments = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ProgramMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[program.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ProgramMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ProgramMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ProgramMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddControlIDs adds the "controls" edge to the Control entity by ids.
func (m *ProgramMutation) AddControlIDs(ids ...string) {
	if m.controls == nil {
		m.controls = make(map[string]struct{})
	}
	for i := range ids {
		m.controls[ids[i]] = struct{}{}
	}
}

// ClearControls clears the "controls" edge to the Control entity.
func (m *ProgramMutation) ClearControls() {
	m.clearedcontrols = true
}

// ControlsCleared reports if the "controls" edge to the Control entity was cleared.
func (m *ProgramMutation) ControlsCleared() bool {
	return m.clearedcontrols
}

// RemoveControlIDs removes the "controls" edge to the Control entity by IDs.
func (m *ProgramMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrols == nil {
		m.removedcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controls, ids[i])
		m.removedcontrols[ids[i]] = struct{}{}
	}
}

// RemovedControls returns the removed IDs of the "controls" edge to the Control entity.
func (m *ProgramMutation) RemovedControlsIDs() (ids []string) {
	for id := range m.removedcontrols {
		ids = append(ids, id)
	}
	return
}

// ControlsIDs returns the "controls" edge IDs in the mutation.
func (m *ProgramMutation) ControlsIDs() (ids []string) {
	for id := range m.controls {
		ids = append(ids, id)
	}
	return
}

// ResetControls resets all changes to the "controls" edge.
func (m *ProgramMutation) ResetControls() {
	m.controls = nil
	m.clearedcontrols = false
	m.removedcontrols = nil
}

// AddSubcontrolIDs adds the "subcontrols" edge to the Subcontrol entity by ids.
func (m *ProgramMutation) AddSubcontrolIDs(ids ...string) {
	if m.subcontrols == nil {
		m.subcontrols = make(map[string]struct{})
	}
	for i := range ids {
		m.subcontrols[ids[i]] = struct{}{}
	}
}

// ClearSubcontrols clears the "subcontrols" edge to the Subcontrol entity.
func (m *ProgramMutation) ClearSubcontrols() {
	m.clearedsubcontrols = true
}

// SubcontrolsCleared reports if the "subcontrols" edge to the Subcontrol entity was cleared.
func (m *ProgramMutation) SubcontrolsCleared() bool {
	return m.clearedsubcontrols
}

// RemoveSubcontrolIDs removes the "subcontrols" edge to the Subcontrol entity by IDs.
func (m *ProgramMutation) RemoveSubcontrolIDs(ids ...string) {
	if m.removedsubcontrols == nil {
		m.removedsubcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subcontrols, ids[i])
		m.removedsubcontrols[ids[i]] = struct{}{}
	}
}

// RemovedSubcontrols returns the removed IDs of the "subcontrols" edge to the Subcontrol entity.
func (m *ProgramMutation) RemovedSubcontrolsIDs() (ids []string) {
	for id := range m.removedsubcontrols {
		ids = append(ids, id)
	}
	return
}

// SubcontrolsIDs returns the "subcontrols" edge IDs in the mutation.
func (m *ProgramMutation) SubcontrolsIDs() (ids []string) {
	for id := range m.subcontrols {
		ids = append(ids, id)
	}
	return
}

// ResetSubcontrols resets all changes to the "subcontrols" edge.
func (m *ProgramMutation) ResetSubcontrols() {
	m.subcontrols = nil
	m.clearedsubcontrols = false
	m.removedsubcontrols = nil
}

// AddControlobjectiveIDs adds the "controlobjectives" edge to the ControlObjective entity by ids.
func (m *ProgramMutation) AddControlobjectiveIDs(ids ...string) {
	if m.controlobjectives == nil {
		m.controlobjectives = make(map[string]struct{})
	}
	for i := range ids {
		m.controlobjectives[ids[i]] = struct{}{}
	}
}

// ClearControlobjectives clears the "controlobjectives" edge to the ControlObjective entity.
func (m *ProgramMutation) ClearControlobjectives() {
	m.clearedcontrolobjectives = true
}

// ControlobjectivesCleared reports if the "controlobjectives" edge to the ControlObjective entity was cleared.
func (m *ProgramMutation) ControlobjectivesCleared() bool {
	return m.clearedcontrolobjectives
}

// RemoveControlobjectiveIDs removes the "controlobjectives" edge to the ControlObjective entity by IDs.
func (m *ProgramMutation) RemoveControlobjectiveIDs(ids ...string) {
	if m.removedcontrolobjectives == nil {
		m.removedcontrolobjectives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controlobjectives, ids[i])
		m.removedcontrolobjectives[ids[i]] = struct{}{}
	}
}

// RemovedControlobjectives returns the removed IDs of the "controlobjectives" edge to the ControlObjective entity.
func (m *ProgramMutation) RemovedControlobjectivesIDs() (ids []string) {
	for id := range m.removedcontrolobjectives {
		ids = append(ids, id)
	}
	return
}

// ControlobjectivesIDs returns the "controlobjectives" edge IDs in the mutation.
func (m *ProgramMutation) ControlobjectivesIDs() (ids []string) {
	for id := range m.controlobjectives {
		ids = append(ids, id)
	}
	return
}

// ResetControlobjectives resets all changes to the "controlobjectives" edge.
func (m *ProgramMutation) ResetControlobjectives() {
	m.controlobjectives = nil
	m.clearedcontrolobjectives = false
	m.removedcontrolobjectives = nil
}

// AddPolicyIDs adds the "policies" edge to the InternalPolicy entity by ids.
func (m *ProgramMutation) AddPolicyIDs(ids ...string) {
	if m.policies == nil {
		m.policies = make(map[string]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the InternalPolicy entity.
func (m *ProgramMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the InternalPolicy entity was cleared.
func (m *ProgramMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the InternalPolicy entity by IDs.
func (m *ProgramMutation) RemovePolicyIDs(ids ...string) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the InternalPolicy entity.
func (m *ProgramMutation) RemovedPoliciesIDs() (ids []string) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *ProgramMutation) PoliciesIDs() (ids []string) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *ProgramMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// AddProcedureIDs adds the "procedures" edge to the Procedure entity by ids.
func (m *ProgramMutation) AddProcedureIDs(ids ...string) {
	if m.procedures == nil {
		m.procedures = make(map[string]struct{})
	}
	for i := range ids {
		m.procedures[ids[i]] = struct{}{}
	}
}

// ClearProcedures clears the "procedures" edge to the Procedure entity.
func (m *ProgramMutation) ClearProcedures() {
	m.clearedprocedures = true
}

// ProceduresCleared reports if the "procedures" edge to the Procedure entity was cleared.
func (m *ProgramMutation) ProceduresCleared() bool {
	return m.clearedprocedures
}

// RemoveProcedureIDs removes the "procedures" edge to the Procedure entity by IDs.
func (m *ProgramMutation) RemoveProcedureIDs(ids ...string) {
	if m.removedprocedures == nil {
		m.removedprocedures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.procedures, ids[i])
		m.removedprocedures[ids[i]] = struct{}{}
	}
}

// RemovedProcedures returns the removed IDs of the "procedures" edge to the Procedure entity.
func (m *ProgramMutation) RemovedProceduresIDs() (ids []string) {
	for id := range m.removedprocedures {
		ids = append(ids, id)
	}
	return
}

// ProceduresIDs returns the "procedures" edge IDs in the mutation.
func (m *ProgramMutation) ProceduresIDs() (ids []string) {
	for id := range m.procedures {
		ids = append(ids, id)
	}
	return
}

// ResetProcedures resets all changes to the "procedures" edge.
func (m *ProgramMutation) ResetProcedures() {
	m.procedures = nil
	m.clearedprocedures = false
	m.removedprocedures = nil
}

// AddRiskIDs adds the "risks" edge to the Risk entity by ids.
func (m *ProgramMutation) AddRiskIDs(ids ...string) {
	if m.risks == nil {
		m.risks = make(map[string]struct{})
	}
	for i := range ids {
		m.risks[ids[i]] = struct{}{}
	}
}

// ClearRisks clears the "risks" edge to the Risk entity.
func (m *ProgramMutation) ClearRisks() {
	m.clearedrisks = true
}

// RisksCleared reports if the "risks" edge to the Risk entity was cleared.
func (m *ProgramMutation) RisksCleared() bool {
	return m.clearedrisks
}

// RemoveRiskIDs removes the "risks" edge to the Risk entity by IDs.
func (m *ProgramMutation) RemoveRiskIDs(ids ...string) {
	if m.removedrisks == nil {
		m.removedrisks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.risks, ids[i])
		m.removedrisks[ids[i]] = struct{}{}
	}
}

// RemovedRisks returns the removed IDs of the "risks" edge to the Risk entity.
func (m *ProgramMutation) RemovedRisksIDs() (ids []string) {
	for id := range m.removedrisks {
		ids = append(ids, id)
	}
	return
}

// RisksIDs returns the "risks" edge IDs in the mutation.
func (m *ProgramMutation) RisksIDs() (ids []string) {
	for id := range m.risks {
		ids = append(ids, id)
	}
	return
}

// ResetRisks resets all changes to the "risks" edge.
func (m *ProgramMutation) ResetRisks() {
	m.risks = nil
	m.clearedrisks = false
	m.removedrisks = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ProgramMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ProgramMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ProgramMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ProgramMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ProgramMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProgramMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProgramMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddNoteIDs adds the "notes" edge to the Note entity by ids.
func (m *ProgramMutation) AddNoteIDs(ids ...string) {
	if m.notes == nil {
		m.notes = make(map[string]struct{})
	}
	for i := range ids {
		m.notes[ids[i]] = struct{}{}
	}
}

// ClearNotes clears the "notes" edge to the Note entity.
func (m *ProgramMutation) ClearNotes() {
	m.clearednotes = true
}

// NotesCleared reports if the "notes" edge to the Note entity was cleared.
func (m *ProgramMutation) NotesCleared() bool {
	return m.clearednotes
}

// RemoveNoteIDs removes the "notes" edge to the Note entity by IDs.
func (m *ProgramMutation) RemoveNoteIDs(ids ...string) {
	if m.removednotes == nil {
		m.removednotes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notes, ids[i])
		m.removednotes[ids[i]] = struct{}{}
	}
}

// RemovedNotes returns the removed IDs of the "notes" edge to the Note entity.
func (m *ProgramMutation) RemovedNotesIDs() (ids []string) {
	for id := range m.removednotes {
		ids = append(ids, id)
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
func (m *ProgramMutation) NotesIDs() (ids []string) {
	for id := range m.notes {
		ids = append(ids, id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *ProgramMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
	m.removednotes = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *ProgramMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *ProgramMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *ProgramMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *ProgramMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *ProgramMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *ProgramMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *ProgramMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddNarrativeIDs adds the "narratives" edge to the Narrative entity by ids.
func (m *ProgramMutation) AddNarrativeIDs(ids ...string) {
	if m.narratives == nil {
		m.narratives = make(map[string]struct{})
	}
	for i := range ids {
		m.narratives[ids[i]] = struct{}{}
	}
}

// ClearNarratives clears the "narratives" edge to the Narrative entity.
func (m *ProgramMutation) ClearNarratives() {
	m.clearednarratives = true
}

// NarrativesCleared reports if the "narratives" edge to the Narrative entity was cleared.
func (m *ProgramMutation) NarrativesCleared() bool {
	return m.clearednarratives
}

// RemoveNarrativeIDs removes the "narratives" edge to the Narrative entity by IDs.
func (m *ProgramMutation) RemoveNarrativeIDs(ids ...string) {
	if m.removednarratives == nil {
		m.removednarratives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.narratives, ids[i])
		m.removednarratives[ids[i]] = struct{}{}
	}
}

// RemovedNarratives returns the removed IDs of the "narratives" edge to the Narrative entity.
func (m *ProgramMutation) RemovedNarrativesIDs() (ids []string) {
	for id := range m.removednarratives {
		ids = append(ids, id)
	}
	return
}

// NarrativesIDs returns the "narratives" edge IDs in the mutation.
func (m *ProgramMutation) NarrativesIDs() (ids []string) {
	for id := range m.narratives {
		ids = append(ids, id)
	}
	return
}

// ResetNarratives resets all changes to the "narratives" edge.
func (m *ProgramMutation) ResetNarratives() {
	m.narratives = nil
	m.clearednarratives = false
	m.removednarratives = nil
}

// AddActionplanIDs adds the "actionplans" edge to the ActionPlan entity by ids.
func (m *ProgramMutation) AddActionplanIDs(ids ...string) {
	if m.actionplans == nil {
		m.actionplans = make(map[string]struct{})
	}
	for i := range ids {
		m.actionplans[ids[i]] = struct{}{}
	}
}

// ClearActionplans clears the "actionplans" edge to the ActionPlan entity.
func (m *ProgramMutation) ClearActionplans() {
	m.clearedactionplans = true
}

// ActionplansCleared reports if the "actionplans" edge to the ActionPlan entity was cleared.
func (m *ProgramMutation) ActionplansCleared() bool {
	return m.clearedactionplans
}

// RemoveActionplanIDs removes the "actionplans" edge to the ActionPlan entity by IDs.
func (m *ProgramMutation) RemoveActionplanIDs(ids ...string) {
	if m.removedactionplans == nil {
		m.removedactionplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.actionplans, ids[i])
		m.removedactionplans[ids[i]] = struct{}{}
	}
}

// RemovedActionplans returns the removed IDs of the "actionplans" edge to the ActionPlan entity.
func (m *ProgramMutation) RemovedActionplansIDs() (ids []string) {
	for id := range m.removedactionplans {
		ids = append(ids, id)
	}
	return
}

// ActionplansIDs returns the "actionplans" edge IDs in the mutation.
func (m *ProgramMutation) ActionplansIDs() (ids []string) {
	for id := range m.actionplans {
		ids = append(ids, id)
	}
	return
}

// ResetActionplans resets all changes to the "actionplans" edge.
func (m *ProgramMutation) ResetActionplans() {
	m.actionplans = nil
	m.clearedactionplans = false
	m.removedactionplans = nil
}

// AddStandardIDs adds the "standards" edge to the Standard entity by ids.
func (m *ProgramMutation) AddStandardIDs(ids ...string) {
	if m.standards == nil {
		m.standards = make(map[string]struct{})
	}
	for i := range ids {
		m.standards[ids[i]] = struct{}{}
	}
}

// ClearStandards clears the "standards" edge to the Standard entity.
func (m *ProgramMutation) ClearStandards() {
	m.clearedstandards = true
}

// StandardsCleared reports if the "standards" edge to the Standard entity was cleared.
func (m *ProgramMutation) StandardsCleared() bool {
	return m.clearedstandards
}

// RemoveStandardIDs removes the "standards" edge to the Standard entity by IDs.
func (m *ProgramMutation) RemoveStandardIDs(ids ...string) {
	if m.removedstandards == nil {
		m.removedstandards = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.standards, ids[i])
		m.removedstandards[ids[i]] = struct{}{}
	}
}

// RemovedStandards returns the removed IDs of the "standards" edge to the Standard entity.
func (m *ProgramMutation) RemovedStandardsIDs() (ids []string) {
	for id := range m.removedstandards {
		ids = append(ids, id)
	}
	return
}

// StandardsIDs returns the "standards" edge IDs in the mutation.
func (m *ProgramMutation) StandardsIDs() (ids []string) {
	for id := range m.standards {
		ids = append(ids, id)
	}
	return
}

// ResetStandards resets all changes to the "standards" edge.
func (m *ProgramMutation) ResetStandards() {
	m.standards = nil
	m.clearedstandards = false
	m.removedstandards = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ProgramMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ProgramMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ProgramMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ProgramMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ProgramMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ProgramMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ProgramMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the ProgramMutation builder.
func (m *ProgramMutation) Where(ps ...predicate.Program) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Program, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Program).
func (m *ProgramMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, program.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, program.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, program.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, program.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, program.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, program.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, program.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, program.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, program.FieldName)
	}
	if m.description != nil {
		fields = append(fields, program.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, program.FieldStatus)
	}
	if m.start_date != nil {
		fields = append(fields, program.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, program.FieldEndDate)
	}
	if m.organization != nil {
		fields = append(fields, program.FieldOrganizationID)
	}
	if m.auditor_ready != nil {
		fields = append(fields, program.FieldAuditorReady)
	}
	if m.auditor_write_comments != nil {
		fields = append(fields, program.FieldAuditorWriteComments)
	}
	if m.auditor_read_comments != nil {
		fields = append(fields, program.FieldAuditorReadComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case program.FieldCreatedAt:
		return m.CreatedAt()
	case program.FieldUpdatedAt:
		return m.UpdatedAt()
	case program.FieldCreatedBy:
		return m.CreatedBy()
	case program.FieldUpdatedBy:
		return m.UpdatedBy()
	case program.FieldMappingID:
		return m.MappingID()
	case program.FieldDeletedAt:
		return m.DeletedAt()
	case program.FieldDeletedBy:
		return m.DeletedBy()
	case program.FieldTags:
		return m.Tags()
	case program.FieldName:
		return m.Name()
	case program.FieldDescription:
		return m.Description()
	case program.FieldStatus:
		return m.Status()
	case program.FieldStartDate:
		return m.StartDate()
	case program.FieldEndDate:
		return m.EndDate()
	case program.FieldOrganizationID:
		return m.OrganizationID()
	case program.FieldAuditorReady:
		return m.AuditorReady()
	case program.FieldAuditorWriteComments:
		return m.AuditorWriteComments()
	case program.FieldAuditorReadComments:
		return m.AuditorReadComments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case program.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case program.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case program.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case program.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case program.FieldMappingID:
		return m.OldMappingID(ctx)
	case program.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case program.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case program.FieldTags:
		return m.OldTags(ctx)
	case program.FieldName:
		return m.OldName(ctx)
	case program.FieldDescription:
		return m.OldDescription(ctx)
	case program.FieldStatus:
		return m.OldStatus(ctx)
	case program.FieldStartDate:
		return m.OldStartDate(ctx)
	case program.FieldEndDate:
		return m.OldEndDate(ctx)
	case program.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case program.FieldAuditorReady:
		return m.OldAuditorReady(ctx)
	case program.FieldAuditorWriteComments:
		return m.OldAuditorWriteComments(ctx)
	case program.FieldAuditorReadComments:
		return m.OldAuditorReadComments(ctx)
	}
	return nil, fmt.Errorf("unknown Program field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramMutation) SetField(name string, value ent.Value) error {
	switch name {
	case program.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case program.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case program.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case program.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case program.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case program.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case program.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case program.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case program.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case program.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case program.FieldStatus:
		v, ok := value.(enums.ProgramStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case program.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case program.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case program.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case program.FieldAuditorReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorReady(v)
		return nil
	case program.FieldAuditorWriteComments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorWriteComments(v)
		return nil
	case program.FieldAuditorReadComments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorReadComments(v)
		return nil
	}
	return fmt.Errorf("unknown Program field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Program numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(program.FieldCreatedAt) {
		fields = append(fields, program.FieldCreatedAt)
	}
	if m.FieldCleared(program.FieldUpdatedAt) {
		fields = append(fields, program.FieldUpdatedAt)
	}
	if m.FieldCleared(program.FieldCreatedBy) {
		fields = append(fields, program.FieldCreatedBy)
	}
	if m.FieldCleared(program.FieldUpdatedBy) {
		fields = append(fields, program.FieldUpdatedBy)
	}
	if m.FieldCleared(program.FieldDeletedAt) {
		fields = append(fields, program.FieldDeletedAt)
	}
	if m.FieldCleared(program.FieldDeletedBy) {
		fields = append(fields, program.FieldDeletedBy)
	}
	if m.FieldCleared(program.FieldTags) {
		fields = append(fields, program.FieldTags)
	}
	if m.FieldCleared(program.FieldDescription) {
		fields = append(fields, program.FieldDescription)
	}
	if m.FieldCleared(program.FieldStartDate) {
		fields = append(fields, program.FieldStartDate)
	}
	if m.FieldCleared(program.FieldEndDate) {
		fields = append(fields, program.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramMutation) ClearField(name string) error {
	switch name {
	case program.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case program.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case program.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case program.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case program.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case program.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case program.FieldTags:
		m.ClearTags()
		return nil
	case program.FieldDescription:
		m.ClearDescription()
		return nil
	case program.FieldStartDate:
		m.ClearStartDate()
		return nil
	case program.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Program nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramMutation) ResetField(name string) error {
	switch name {
	case program.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case program.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case program.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case program.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case program.FieldMappingID:
		m.ResetMappingID()
		return nil
	case program.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case program.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case program.FieldTags:
		m.ResetTags()
		return nil
	case program.FieldName:
		m.ResetName()
		return nil
	case program.FieldDescription:
		m.ResetDescription()
		return nil
	case program.FieldStatus:
		m.ResetStatus()
		return nil
	case program.FieldStartDate:
		m.ResetStartDate()
		return nil
	case program.FieldEndDate:
		m.ResetEndDate()
		return nil
	case program.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case program.FieldAuditorReady:
		m.ResetAuditorReady()
		return nil
	case program.FieldAuditorWriteComments:
		m.ResetAuditorWriteComments()
		return nil
	case program.FieldAuditorReadComments:
		m.ResetAuditorReadComments()
		return nil
	}
	return fmt.Errorf("unknown Program field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.organization != nil {
		edges = append(edges, program.EdgeOrganization)
	}
	if m.controls != nil {
		edges = append(edges, program.EdgeControls)
	}
	if m.subcontrols != nil {
		edges = append(edges, program.EdgeSubcontrols)
	}
	if m.controlobjectives != nil {
		edges = append(edges, program.EdgeControlobjectives)
	}
	if m.policies != nil {
		edges = append(edges, program.EdgePolicies)
	}
	if m.procedures != nil {
		edges = append(edges, program.EdgeProcedures)
	}
	if m.risks != nil {
		edges = append(edges, program.EdgeRisks)
	}
	if m.tasks != nil {
		edges = append(edges, program.EdgeTasks)
	}
	if m.notes != nil {
		edges = append(edges, program.EdgeNotes)
	}
	if m.files != nil {
		edges = append(edges, program.EdgeFiles)
	}
	if m.narratives != nil {
		edges = append(edges, program.EdgeNarratives)
	}
	if m.actionplans != nil {
		edges = append(edges, program.EdgeActionplans)
	}
	if m.standards != nil {
		edges = append(edges, program.EdgeStandards)
	}
	if m.users != nil {
		edges = append(edges, program.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case program.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case program.EdgeControls:
		ids := make([]ent.Value, 0, len(m.controls))
		for id := range m.controls {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.subcontrols))
		for id := range m.subcontrols {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeControlobjectives:
		ids := make([]ent.Value, 0, len(m.controlobjectives))
		for id := range m.controlobjectives {
			ids = append(ids, id)
		}
		return ids
	case program.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.procedures))
		for id := range m.procedures {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeRisks:
		ids := make([]ent.Value, 0, len(m.risks))
		for id := range m.risks {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.notes))
		for id := range m.notes {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.narratives))
		for id := range m.narratives {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.actionplans))
		for id := range m.actionplans {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeStandards:
		ids := make([]ent.Value, 0, len(m.standards))
		for id := range m.standards {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedcontrols != nil {
		edges = append(edges, program.EdgeControls)
	}
	if m.removedsubcontrols != nil {
		edges = append(edges, program.EdgeSubcontrols)
	}
	if m.removedcontrolobjectives != nil {
		edges = append(edges, program.EdgeControlobjectives)
	}
	if m.removedpolicies != nil {
		edges = append(edges, program.EdgePolicies)
	}
	if m.removedprocedures != nil {
		edges = append(edges, program.EdgeProcedures)
	}
	if m.removedrisks != nil {
		edges = append(edges, program.EdgeRisks)
	}
	if m.removedtasks != nil {
		edges = append(edges, program.EdgeTasks)
	}
	if m.removednotes != nil {
		edges = append(edges, program.EdgeNotes)
	}
	if m.removedfiles != nil {
		edges = append(edges, program.EdgeFiles)
	}
	if m.removednarratives != nil {
		edges = append(edges, program.EdgeNarratives)
	}
	if m.removedactionplans != nil {
		edges = append(edges, program.EdgeActionplans)
	}
	if m.removedstandards != nil {
		edges = append(edges, program.EdgeStandards)
	}
	if m.removedusers != nil {
		edges = append(edges, program.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case program.EdgeControls:
		ids := make([]ent.Value, 0, len(m.removedcontrols))
		for id := range m.removedcontrols {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.removedsubcontrols))
		for id := range m.removedsubcontrols {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeControlobjectives:
		ids := make([]ent.Value, 0, len(m.removedcontrolobjectives))
		for id := range m.removedcontrolobjectives {
			ids = append(ids, id)
		}
		return ids
	case program.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.removedprocedures))
		for id := range m.removedprocedures {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeRisks:
		ids := make([]ent.Value, 0, len(m.removedrisks))
		for id := range m.removedrisks {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.removednotes))
		for id := range m.removednotes {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeNarratives:
		ids := make([]ent.Value, 0, len(m.removednarratives))
		for id := range m.removednarratives {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.removedactionplans))
		for id := range m.removedactionplans {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeStandards:
		ids := make([]ent.Value, 0, len(m.removedstandards))
		for id := range m.removedstandards {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedorganization {
		edges = append(edges, program.EdgeOrganization)
	}
	if m.clearedcontrols {
		edges = append(edges, program.EdgeControls)
	}
	if m.clearedsubcontrols {
		edges = append(edges, program.EdgeSubcontrols)
	}
	if m.clearedcontrolobjectives {
		edges = append(edges, program.EdgeControlobjectives)
	}
	if m.clearedpolicies {
		edges = append(edges, program.EdgePolicies)
	}
	if m.clearedprocedures {
		edges = append(edges, program.EdgeProcedures)
	}
	if m.clearedrisks {
		edges = append(edges, program.EdgeRisks)
	}
	if m.clearedtasks {
		edges = append(edges, program.EdgeTasks)
	}
	if m.clearednotes {
		edges = append(edges, program.EdgeNotes)
	}
	if m.clearedfiles {
		edges = append(edges, program.EdgeFiles)
	}
	if m.clearednarratives {
		edges = append(edges, program.EdgeNarratives)
	}
	if m.clearedactionplans {
		edges = append(edges, program.EdgeActionplans)
	}
	if m.clearedstandards {
		edges = append(edges, program.EdgeStandards)
	}
	if m.clearedusers {
		edges = append(edges, program.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramMutation) EdgeCleared(name string) bool {
	switch name {
	case program.EdgeOrganization:
		return m.clearedorganization
	case program.EdgeControls:
		return m.clearedcontrols
	case program.EdgeSubcontrols:
		return m.clearedsubcontrols
	case program.EdgeControlobjectives:
		return m.clearedcontrolobjectives
	case program.EdgePolicies:
		return m.clearedpolicies
	case program.EdgeProcedures:
		return m.clearedprocedures
	case program.EdgeRisks:
		return m.clearedrisks
	case program.EdgeTasks:
		return m.clearedtasks
	case program.EdgeNotes:
		return m.clearednotes
	case program.EdgeFiles:
		return m.clearedfiles
	case program.EdgeNarratives:
		return m.clearednarratives
	case program.EdgeActionplans:
		return m.clearedactionplans
	case program.EdgeStandards:
		return m.clearedstandards
	case program.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramMutation) ClearEdge(name string) error {
	switch name {
	case program.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Program unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramMutation) ResetEdge(name string) error {
	switch name {
	case program.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case program.EdgeControls:
		m.ResetControls()
		return nil
	case program.EdgeSubcontrols:
		m.ResetSubcontrols()
		return nil
	case program.EdgeControlobjectives:
		m.ResetControlobjectives()
		return nil
	case program.EdgePolicies:
		m.ResetPolicies()
		return nil
	case program.EdgeProcedures:
		m.ResetProcedures()
		return nil
	case program.EdgeRisks:
		m.ResetRisks()
		return nil
	case program.EdgeTasks:
		m.ResetTasks()
		return nil
	case program.EdgeNotes:
		m.ResetNotes()
		return nil
	case program.EdgeFiles:
		m.ResetFiles()
		return nil
	case program.EdgeNarratives:
		m.ResetNarratives()
		return nil
	case program.EdgeActionplans:
		m.ResetActionplans()
		return nil
	case program.EdgeStandards:
		m.ResetStandards()
		return nil
	case program.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Program edge %s", name)
}

// ProgramHistoryMutation represents an operation that mutates the ProgramHistory nodes in the graph.
type ProgramHistoryMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	history_time           *time.Time
	ref                    *string
	operation              *history.OpType
	created_at             *time.Time
	updated_at             *time.Time
	created_by             *string
	updated_by             *string
	mapping_id             *string
	deleted_at             *time.Time
	deleted_by             *string
	tags                   *[]string
	appendtags             []string
	name                   *string
	description            *string
	status                 *enums.ProgramStatus
	start_date             *time.Time
	end_date               *time.Time
	organization_id        *string
	auditor_ready          *bool
	auditor_write_comments *bool
	auditor_read_comments  *bool
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ProgramHistory, error)
	predicates             []predicate.ProgramHistory
}

var _ ent.Mutation = (*ProgramHistoryMutation)(nil)

// programhistoryOption allows management of the mutation configuration using functional options.
type programhistoryOption func(*ProgramHistoryMutation)

// newProgramHistoryMutation creates new mutation for the ProgramHistory entity.
func newProgramHistoryMutation(c config, op Op, opts ...programhistoryOption) *ProgramHistoryMutation {
	m := &ProgramHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProgramHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramHistoryID sets the ID field of the mutation.
func withProgramHistoryID(id string) programhistoryOption {
	return func(m *ProgramHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProgramHistory
		)
		m.oldValue = func(ctx context.Context) (*ProgramHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProgramHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgramHistory sets the old ProgramHistory of the mutation.
func withProgramHistory(node *ProgramHistory) programhistoryOption {
	return func(m *ProgramHistoryMutation) {
		m.oldValue = func(context.Context) (*ProgramHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProgramHistory entities.
func (m *ProgramHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProgramHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *ProgramHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *ProgramHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *ProgramHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *ProgramHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *ProgramHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *ProgramHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[programhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *ProgramHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *ProgramHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, programhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *ProgramHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *ProgramHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *ProgramHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProgramHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProgramHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProgramHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[programhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProgramHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProgramHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, programhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProgramHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProgramHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProgramHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[programhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProgramHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProgramHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, programhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ProgramHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProgramHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProgramHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[programhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProgramHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProgramHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, programhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProgramHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProgramHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProgramHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[programhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProgramHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProgramHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, programhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *ProgramHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *ProgramHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *ProgramHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProgramHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProgramHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProgramHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[programhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProgramHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProgramHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, programhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ProgramHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ProgramHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ProgramHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[programhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ProgramHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ProgramHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, programhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *ProgramHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ProgramHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ProgramHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ProgramHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ProgramHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[programhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ProgramHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ProgramHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, programhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *ProgramHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProgramHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProgramHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProgramHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProgramHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProgramHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[programhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProgramHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProgramHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, programhistory.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ProgramHistoryMutation) SetStatus(es enums.ProgramStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *ProgramHistoryMutation) Status() (r enums.ProgramStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldStatus(ctx context.Context) (v enums.ProgramStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProgramHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProgramHistoryMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProgramHistoryMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ProgramHistoryMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[programhistory.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ProgramHistoryMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProgramHistoryMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, programhistory.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ProgramHistoryMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProgramHistoryMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProgramHistoryMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[programhistory.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProgramHistoryMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[programhistory.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProgramHistoryMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, programhistory.FieldEndDate)
}

// SetOrganizationID sets the "organization_id" field.
func (m *ProgramHistoryMutation) SetOrganizationID(s string) {
	m.organization_id = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ProgramHistoryMutation) OrganizationID() (r string, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ProgramHistoryMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetAuditorReady sets the "auditor_ready" field.
func (m *ProgramHistoryMutation) SetAuditorReady(b bool) {
	m.auditor_ready = &b
}

// AuditorReady returns the value of the "auditor_ready" field in the mutation.
func (m *ProgramHistoryMutation) AuditorReady() (r bool, exists bool) {
	v := m.auditor_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorReady returns the old "auditor_ready" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditorReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorReady: %w", err)
	}
	return oldValue.AuditorReady, nil
}

// ResetAuditorReady resets all changes to the "auditor_ready" field.
func (m *ProgramHistoryMutation) ResetAuditorReady() {
	m.auditor_ready = nil
}

// SetAuditorWriteComments sets the "auditor_write_comments" field.
func (m *ProgramHistoryMutation) SetAuditorWriteComments(b bool) {
	m.auditor_write_comments = &b
}

// AuditorWriteComments returns the value of the "auditor_write_comments" field in the mutation.
func (m *ProgramHistoryMutation) AuditorWriteComments() (r bool, exists bool) {
	v := m.auditor_write_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorWriteComments returns the old "auditor_write_comments" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditorWriteComments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorWriteComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorWriteComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorWriteComments: %w", err)
	}
	return oldValue.AuditorWriteComments, nil
}

// ResetAuditorWriteComments resets all changes to the "auditor_write_comments" field.
func (m *ProgramHistoryMutation) ResetAuditorWriteComments() {
	m.auditor_write_comments = nil
}

// SetAuditorReadComments sets the "auditor_read_comments" field.
func (m *ProgramHistoryMutation) SetAuditorReadComments(b bool) {
	m.auditor_read_comments = &b
}

// AuditorReadComments returns the value of the "auditor_read_comments" field in the mutation.
func (m *ProgramHistoryMutation) AuditorReadComments() (r bool, exists bool) {
	v := m.auditor_read_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditorReadComments returns the old "auditor_read_comments" field's value of the ProgramHistory entity.
// If the ProgramHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramHistoryMutation) OldAuditorReadComments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditorReadComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditorReadComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditorReadComments: %w", err)
	}
	return oldValue.AuditorReadComments, nil
}

// ResetAuditorReadComments resets all changes to the "auditor_read_comments" field.
func (m *ProgramHistoryMutation) ResetAuditorReadComments() {
	m.auditor_read_comments = nil
}

// Where appends a list predicates to the ProgramHistoryMutation builder.
func (m *ProgramHistoryMutation) Where(ps ...predicate.ProgramHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProgramHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProgramHistory).
func (m *ProgramHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramHistoryMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.history_time != nil {
		fields = append(fields, programhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, programhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, programhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, programhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, programhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, programhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, programhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, programhistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, programhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, programhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, programhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, programhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, programhistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, programhistory.FieldStatus)
	}
	if m.start_date != nil {
		fields = append(fields, programhistory.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, programhistory.FieldEndDate)
	}
	if m.organization_id != nil {
		fields = append(fields, programhistory.FieldOrganizationID)
	}
	if m.auditor_ready != nil {
		fields = append(fields, programhistory.FieldAuditorReady)
	}
	if m.auditor_write_comments != nil {
		fields = append(fields, programhistory.FieldAuditorWriteComments)
	}
	if m.auditor_read_comments != nil {
		fields = append(fields, programhistory.FieldAuditorReadComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case programhistory.FieldHistoryTime:
		return m.HistoryTime()
	case programhistory.FieldRef:
		return m.Ref()
	case programhistory.FieldOperation:
		return m.Operation()
	case programhistory.FieldCreatedAt:
		return m.CreatedAt()
	case programhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case programhistory.FieldCreatedBy:
		return m.CreatedBy()
	case programhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case programhistory.FieldMappingID:
		return m.MappingID()
	case programhistory.FieldDeletedAt:
		return m.DeletedAt()
	case programhistory.FieldDeletedBy:
		return m.DeletedBy()
	case programhistory.FieldTags:
		return m.Tags()
	case programhistory.FieldName:
		return m.Name()
	case programhistory.FieldDescription:
		return m.Description()
	case programhistory.FieldStatus:
		return m.Status()
	case programhistory.FieldStartDate:
		return m.StartDate()
	case programhistory.FieldEndDate:
		return m.EndDate()
	case programhistory.FieldOrganizationID:
		return m.OrganizationID()
	case programhistory.FieldAuditorReady:
		return m.AuditorReady()
	case programhistory.FieldAuditorWriteComments:
		return m.AuditorWriteComments()
	case programhistory.FieldAuditorReadComments:
		return m.AuditorReadComments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case programhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case programhistory.FieldRef:
		return m.OldRef(ctx)
	case programhistory.FieldOperation:
		return m.OldOperation(ctx)
	case programhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case programhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case programhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case programhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case programhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case programhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case programhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case programhistory.FieldTags:
		return m.OldTags(ctx)
	case programhistory.FieldName:
		return m.OldName(ctx)
	case programhistory.FieldDescription:
		return m.OldDescription(ctx)
	case programhistory.FieldStatus:
		return m.OldStatus(ctx)
	case programhistory.FieldStartDate:
		return m.OldStartDate(ctx)
	case programhistory.FieldEndDate:
		return m.OldEndDate(ctx)
	case programhistory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case programhistory.FieldAuditorReady:
		return m.OldAuditorReady(ctx)
	case programhistory.FieldAuditorWriteComments:
		return m.OldAuditorWriteComments(ctx)
	case programhistory.FieldAuditorReadComments:
		return m.OldAuditorReadComments(ctx)
	}
	return nil, fmt.Errorf("unknown ProgramHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case programhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case programhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case programhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case programhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case programhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case programhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case programhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case programhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case programhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case programhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case programhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case programhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case programhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case programhistory.FieldStatus:
		v, ok := value.(enums.ProgramStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case programhistory.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case programhistory.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case programhistory.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case programhistory.FieldAuditorReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorReady(v)
		return nil
	case programhistory.FieldAuditorWriteComments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorWriteComments(v)
		return nil
	case programhistory.FieldAuditorReadComments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditorReadComments(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProgramHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(programhistory.FieldRef) {
		fields = append(fields, programhistory.FieldRef)
	}
	if m.FieldCleared(programhistory.FieldCreatedAt) {
		fields = append(fields, programhistory.FieldCreatedAt)
	}
	if m.FieldCleared(programhistory.FieldUpdatedAt) {
		fields = append(fields, programhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(programhistory.FieldCreatedBy) {
		fields = append(fields, programhistory.FieldCreatedBy)
	}
	if m.FieldCleared(programhistory.FieldUpdatedBy) {
		fields = append(fields, programhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(programhistory.FieldDeletedAt) {
		fields = append(fields, programhistory.FieldDeletedAt)
	}
	if m.FieldCleared(programhistory.FieldDeletedBy) {
		fields = append(fields, programhistory.FieldDeletedBy)
	}
	if m.FieldCleared(programhistory.FieldTags) {
		fields = append(fields, programhistory.FieldTags)
	}
	if m.FieldCleared(programhistory.FieldDescription) {
		fields = append(fields, programhistory.FieldDescription)
	}
	if m.FieldCleared(programhistory.FieldStartDate) {
		fields = append(fields, programhistory.FieldStartDate)
	}
	if m.FieldCleared(programhistory.FieldEndDate) {
		fields = append(fields, programhistory.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramHistoryMutation) ClearField(name string) error {
	switch name {
	case programhistory.FieldRef:
		m.ClearRef()
		return nil
	case programhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case programhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case programhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case programhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case programhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case programhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case programhistory.FieldTags:
		m.ClearTags()
		return nil
	case programhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case programhistory.FieldStartDate:
		m.ClearStartDate()
		return nil
	case programhistory.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown ProgramHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramHistoryMutation) ResetField(name string) error {
	switch name {
	case programhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case programhistory.FieldRef:
		m.ResetRef()
		return nil
	case programhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case programhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case programhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case programhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case programhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case programhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case programhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case programhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case programhistory.FieldTags:
		m.ResetTags()
		return nil
	case programhistory.FieldName:
		m.ResetName()
		return nil
	case programhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case programhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case programhistory.FieldStartDate:
		m.ResetStartDate()
		return nil
	case programhistory.FieldEndDate:
		m.ResetEndDate()
		return nil
	case programhistory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case programhistory.FieldAuditorReady:
		m.ResetAuditorReady()
		return nil
	case programhistory.FieldAuditorWriteComments:
		m.ResetAuditorWriteComments()
		return nil
	case programhistory.FieldAuditorReadComments:
		m.ResetAuditorReadComments()
		return nil
	}
	return fmt.Errorf("unknown ProgramHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProgramHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProgramHistory edge %s", name)
}

// RiskMutation represents an operation that mutates the Risk nodes in the graph.
type RiskMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	created_by         *string
	updated_by         *string
	deleted_at         *time.Time
	deleted_by         *string
	mapping_id         *string
	tags               *[]string
	appendtags         []string
	name               *string
	description        *string
	status             *string
	risk_type          *string
	business_costs     *string
	impact             *enums.RiskImpact
	likelihood         *enums.RiskLikelihood
	mitigation         *string
	satisfies          *string
	details            *map[string]interface{}
	clearedFields      map[string]struct{}
	control            map[string]struct{}
	removedcontrol     map[string]struct{}
	clearedcontrol     bool
	procedure          map[string]struct{}
	removedprocedure   map[string]struct{}
	clearedprocedure   bool
	actionplans        map[string]struct{}
	removedactionplans map[string]struct{}
	clearedactionplans bool
	program            map[string]struct{}
	removedprogram     map[string]struct{}
	clearedprogram     bool
	done               bool
	oldValue           func(context.Context) (*Risk, error)
	predicates         []predicate.Risk
}

var _ ent.Mutation = (*RiskMutation)(nil)

// riskOption allows management of the mutation configuration using functional options.
type riskOption func(*RiskMutation)

// newRiskMutation creates new mutation for the Risk entity.
func newRiskMutation(c config, op Op, opts ...riskOption) *RiskMutation {
	m := &RiskMutation{
		config:        c,
		op:            op,
		typ:           TypeRisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskID sets the ID field of the mutation.
func withRiskID(id string) riskOption {
	return func(m *RiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Risk
		)
		m.oldValue = func(ctx context.Context) (*Risk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Risk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRisk sets the old Risk of the mutation.
func withRisk(node *Risk) riskOption {
	return func(m *RiskMutation) {
		m.oldValue = func(context.Context) (*Risk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Risk entities.
func (m *RiskMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Risk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RiskMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[risk.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RiskMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[risk.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, risk.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RiskMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[risk.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RiskMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[risk.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, risk.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RiskMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[risk.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RiskMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[risk.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, risk.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RiskMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[risk.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RiskMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[risk.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, risk.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[risk.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[risk.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, risk.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RiskMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RiskMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RiskMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[risk.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RiskMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[risk.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RiskMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, risk.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *RiskMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *RiskMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *RiskMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *RiskMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *RiskMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *RiskMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *RiskMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *RiskMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[risk.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *RiskMutation) TagsCleared() bool {
	_, ok := m.clearedFields[risk.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *RiskMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, risk.FieldTags)
}

// SetName sets the "name" field.
func (m *RiskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RiskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RiskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RiskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[risk.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RiskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[risk.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RiskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, risk.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *RiskMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RiskMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *RiskMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[risk.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RiskMutation) StatusCleared() bool {
	_, ok := m.clearedFields[risk.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RiskMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, risk.FieldStatus)
}

// SetRiskType sets the "risk_type" field.
func (m *RiskMutation) SetRiskType(s string) {
	m.risk_type = &s
}

// RiskType returns the value of the "risk_type" field in the mutation.
func (m *RiskMutation) RiskType() (r string, exists bool) {
	v := m.risk_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskType returns the old "risk_type" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskType: %w", err)
	}
	return oldValue.RiskType, nil
}

// ClearRiskType clears the value of the "risk_type" field.
func (m *RiskMutation) ClearRiskType() {
	m.risk_type = nil
	m.clearedFields[risk.FieldRiskType] = struct{}{}
}

// RiskTypeCleared returns if the "risk_type" field was cleared in this mutation.
func (m *RiskMutation) RiskTypeCleared() bool {
	_, ok := m.clearedFields[risk.FieldRiskType]
	return ok
}

// ResetRiskType resets all changes to the "risk_type" field.
func (m *RiskMutation) ResetRiskType() {
	m.risk_type = nil
	delete(m.clearedFields, risk.FieldRiskType)
}

// SetBusinessCosts sets the "business_costs" field.
func (m *RiskMutation) SetBusinessCosts(s string) {
	m.business_costs = &s
}

// BusinessCosts returns the value of the "business_costs" field in the mutation.
func (m *RiskMutation) BusinessCosts() (r string, exists bool) {
	v := m.business_costs
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessCosts returns the old "business_costs" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldBusinessCosts(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessCosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessCosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessCosts: %w", err)
	}
	return oldValue.BusinessCosts, nil
}

// ClearBusinessCosts clears the value of the "business_costs" field.
func (m *RiskMutation) ClearBusinessCosts() {
	m.business_costs = nil
	m.clearedFields[risk.FieldBusinessCosts] = struct{}{}
}

// BusinessCostsCleared returns if the "business_costs" field was cleared in this mutation.
func (m *RiskMutation) BusinessCostsCleared() bool {
	_, ok := m.clearedFields[risk.FieldBusinessCosts]
	return ok
}

// ResetBusinessCosts resets all changes to the "business_costs" field.
func (m *RiskMutation) ResetBusinessCosts() {
	m.business_costs = nil
	delete(m.clearedFields, risk.FieldBusinessCosts)
}

// SetImpact sets the "impact" field.
func (m *RiskMutation) SetImpact(ei enums.RiskImpact) {
	m.impact = &ei
}

// Impact returns the value of the "impact" field in the mutation.
func (m *RiskMutation) Impact() (r enums.RiskImpact, exists bool) {
	v := m.impact
	if v == nil {
		return
	}
	return *v, true
}

// OldImpact returns the old "impact" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldImpact(ctx context.Context) (v enums.RiskImpact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpact: %w", err)
	}
	return oldValue.Impact, nil
}

// ClearImpact clears the value of the "impact" field.
func (m *RiskMutation) ClearImpact() {
	m.impact = nil
	m.clearedFields[risk.FieldImpact] = struct{}{}
}

// ImpactCleared returns if the "impact" field was cleared in this mutation.
func (m *RiskMutation) ImpactCleared() bool {
	_, ok := m.clearedFields[risk.FieldImpact]
	return ok
}

// ResetImpact resets all changes to the "impact" field.
func (m *RiskMutation) ResetImpact() {
	m.impact = nil
	delete(m.clearedFields, risk.FieldImpact)
}

// SetLikelihood sets the "likelihood" field.
func (m *RiskMutation) SetLikelihood(el enums.RiskLikelihood) {
	m.likelihood = &el
}

// Likelihood returns the value of the "likelihood" field in the mutation.
func (m *RiskMutation) Likelihood() (r enums.RiskLikelihood, exists bool) {
	v := m.likelihood
	if v == nil {
		return
	}
	return *v, true
}

// OldLikelihood returns the old "likelihood" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldLikelihood(ctx context.Context) (v enums.RiskLikelihood, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikelihood is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikelihood requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikelihood: %w", err)
	}
	return oldValue.Likelihood, nil
}

// ClearLikelihood clears the value of the "likelihood" field.
func (m *RiskMutation) ClearLikelihood() {
	m.likelihood = nil
	m.clearedFields[risk.FieldLikelihood] = struct{}{}
}

// LikelihoodCleared returns if the "likelihood" field was cleared in this mutation.
func (m *RiskMutation) LikelihoodCleared() bool {
	_, ok := m.clearedFields[risk.FieldLikelihood]
	return ok
}

// ResetLikelihood resets all changes to the "likelihood" field.
func (m *RiskMutation) ResetLikelihood() {
	m.likelihood = nil
	delete(m.clearedFields, risk.FieldLikelihood)
}

// SetMitigation sets the "mitigation" field.
func (m *RiskMutation) SetMitigation(s string) {
	m.mitigation = &s
}

// Mitigation returns the value of the "mitigation" field in the mutation.
func (m *RiskMutation) Mitigation() (r string, exists bool) {
	v := m.mitigation
	if v == nil {
		return
	}
	return *v, true
}

// OldMitigation returns the old "mitigation" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMitigation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMitigation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMitigation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMitigation: %w", err)
	}
	return oldValue.Mitigation, nil
}

// ClearMitigation clears the value of the "mitigation" field.
func (m *RiskMutation) ClearMitigation() {
	m.mitigation = nil
	m.clearedFields[risk.FieldMitigation] = struct{}{}
}

// MitigationCleared returns if the "mitigation" field was cleared in this mutation.
func (m *RiskMutation) MitigationCleared() bool {
	_, ok := m.clearedFields[risk.FieldMitigation]
	return ok
}

// ResetMitigation resets all changes to the "mitigation" field.
func (m *RiskMutation) ResetMitigation() {
	m.mitigation = nil
	delete(m.clearedFields, risk.FieldMitigation)
}

// SetSatisfies sets the "satisfies" field.
func (m *RiskMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *RiskMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *RiskMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[risk.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *RiskMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[risk.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *RiskMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, risk.FieldSatisfies)
}

// SetDetails sets the "details" field.
func (m *RiskMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *RiskMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *RiskMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[risk.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *RiskMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[risk.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *RiskMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, risk.FieldDetails)
}

// AddControlIDs adds the "control" edge to the Control entity by ids.
func (m *RiskMutation) AddControlIDs(ids ...string) {
	if m.control == nil {
		m.control = make(map[string]struct{})
	}
	for i := range ids {
		m.control[ids[i]] = struct{}{}
	}
}

// ClearControl clears the "control" edge to the Control entity.
func (m *RiskMutation) ClearControl() {
	m.clearedcontrol = true
}

// ControlCleared reports if the "control" edge to the Control entity was cleared.
func (m *RiskMutation) ControlCleared() bool {
	return m.clearedcontrol
}

// RemoveControlIDs removes the "control" edge to the Control entity by IDs.
func (m *RiskMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrol == nil {
		m.removedcontrol = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.control, ids[i])
		m.removedcontrol[ids[i]] = struct{}{}
	}
}

// RemovedControl returns the removed IDs of the "control" edge to the Control entity.
func (m *RiskMutation) RemovedControlIDs() (ids []string) {
	for id := range m.removedcontrol {
		ids = append(ids, id)
	}
	return
}

// ControlIDs returns the "control" edge IDs in the mutation.
func (m *RiskMutation) ControlIDs() (ids []string) {
	for id := range m.control {
		ids = append(ids, id)
	}
	return
}

// ResetControl resets all changes to the "control" edge.
func (m *RiskMutation) ResetControl() {
	m.control = nil
	m.clearedcontrol = false
	m.removedcontrol = nil
}

// AddProcedureIDs adds the "procedure" edge to the Procedure entity by ids.
func (m *RiskMutation) AddProcedureIDs(ids ...string) {
	if m.procedure == nil {
		m.procedure = make(map[string]struct{})
	}
	for i := range ids {
		m.procedure[ids[i]] = struct{}{}
	}
}

// ClearProcedure clears the "procedure" edge to the Procedure entity.
func (m *RiskMutation) ClearProcedure() {
	m.clearedprocedure = true
}

// ProcedureCleared reports if the "procedure" edge to the Procedure entity was cleared.
func (m *RiskMutation) ProcedureCleared() bool {
	return m.clearedprocedure
}

// RemoveProcedureIDs removes the "procedure" edge to the Procedure entity by IDs.
func (m *RiskMutation) RemoveProcedureIDs(ids ...string) {
	if m.removedprocedure == nil {
		m.removedprocedure = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.procedure, ids[i])
		m.removedprocedure[ids[i]] = struct{}{}
	}
}

// RemovedProcedure returns the removed IDs of the "procedure" edge to the Procedure entity.
func (m *RiskMutation) RemovedProcedureIDs() (ids []string) {
	for id := range m.removedprocedure {
		ids = append(ids, id)
	}
	return
}

// ProcedureIDs returns the "procedure" edge IDs in the mutation.
func (m *RiskMutation) ProcedureIDs() (ids []string) {
	for id := range m.procedure {
		ids = append(ids, id)
	}
	return
}

// ResetProcedure resets all changes to the "procedure" edge.
func (m *RiskMutation) ResetProcedure() {
	m.procedure = nil
	m.clearedprocedure = false
	m.removedprocedure = nil
}

// AddActionplanIDs adds the "actionplans" edge to the ActionPlan entity by ids.
func (m *RiskMutation) AddActionplanIDs(ids ...string) {
	if m.actionplans == nil {
		m.actionplans = make(map[string]struct{})
	}
	for i := range ids {
		m.actionplans[ids[i]] = struct{}{}
	}
}

// ClearActionplans clears the "actionplans" edge to the ActionPlan entity.
func (m *RiskMutation) ClearActionplans() {
	m.clearedactionplans = true
}

// ActionplansCleared reports if the "actionplans" edge to the ActionPlan entity was cleared.
func (m *RiskMutation) ActionplansCleared() bool {
	return m.clearedactionplans
}

// RemoveActionplanIDs removes the "actionplans" edge to the ActionPlan entity by IDs.
func (m *RiskMutation) RemoveActionplanIDs(ids ...string) {
	if m.removedactionplans == nil {
		m.removedactionplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.actionplans, ids[i])
		m.removedactionplans[ids[i]] = struct{}{}
	}
}

// RemovedActionplans returns the removed IDs of the "actionplans" edge to the ActionPlan entity.
func (m *RiskMutation) RemovedActionplansIDs() (ids []string) {
	for id := range m.removedactionplans {
		ids = append(ids, id)
	}
	return
}

// ActionplansIDs returns the "actionplans" edge IDs in the mutation.
func (m *RiskMutation) ActionplansIDs() (ids []string) {
	for id := range m.actionplans {
		ids = append(ids, id)
	}
	return
}

// ResetActionplans resets all changes to the "actionplans" edge.
func (m *RiskMutation) ResetActionplans() {
	m.actionplans = nil
	m.clearedactionplans = false
	m.removedactionplans = nil
}

// AddProgramIDs adds the "program" edge to the Program entity by ids.
func (m *RiskMutation) AddProgramIDs(ids ...string) {
	if m.program == nil {
		m.program = make(map[string]struct{})
	}
	for i := range ids {
		m.program[ids[i]] = struct{}{}
	}
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *RiskMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *RiskMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// RemoveProgramIDs removes the "program" edge to the Program entity by IDs.
func (m *RiskMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprogram == nil {
		m.removedprogram = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.program, ids[i])
		m.removedprogram[ids[i]] = struct{}{}
	}
}

// RemovedProgram returns the removed IDs of the "program" edge to the Program entity.
func (m *RiskMutation) RemovedProgramIDs() (ids []string) {
	for id := range m.removedprogram {
		ids = append(ids, id)
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
func (m *RiskMutation) ProgramIDs() (ids []string) {
	for id := range m.program {
		ids = append(ids, id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *RiskMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
	m.removedprogram = nil
}

// Where appends a list predicates to the RiskMutation builder.
func (m *RiskMutation) Where(ps ...predicate.Risk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Risk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Risk).
func (m *RiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, risk.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, risk.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, risk.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, risk.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, risk.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, risk.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, risk.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, risk.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, risk.FieldName)
	}
	if m.description != nil {
		fields = append(fields, risk.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, risk.FieldStatus)
	}
	if m.risk_type != nil {
		fields = append(fields, risk.FieldRiskType)
	}
	if m.business_costs != nil {
		fields = append(fields, risk.FieldBusinessCosts)
	}
	if m.impact != nil {
		fields = append(fields, risk.FieldImpact)
	}
	if m.likelihood != nil {
		fields = append(fields, risk.FieldLikelihood)
	}
	if m.mitigation != nil {
		fields = append(fields, risk.FieldMitigation)
	}
	if m.satisfies != nil {
		fields = append(fields, risk.FieldSatisfies)
	}
	if m.details != nil {
		fields = append(fields, risk.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldCreatedAt:
		return m.CreatedAt()
	case risk.FieldUpdatedAt:
		return m.UpdatedAt()
	case risk.FieldCreatedBy:
		return m.CreatedBy()
	case risk.FieldUpdatedBy:
		return m.UpdatedBy()
	case risk.FieldDeletedAt:
		return m.DeletedAt()
	case risk.FieldDeletedBy:
		return m.DeletedBy()
	case risk.FieldMappingID:
		return m.MappingID()
	case risk.FieldTags:
		return m.Tags()
	case risk.FieldName:
		return m.Name()
	case risk.FieldDescription:
		return m.Description()
	case risk.FieldStatus:
		return m.Status()
	case risk.FieldRiskType:
		return m.RiskType()
	case risk.FieldBusinessCosts:
		return m.BusinessCosts()
	case risk.FieldImpact:
		return m.Impact()
	case risk.FieldLikelihood:
		return m.Likelihood()
	case risk.FieldMitigation:
		return m.Mitigation()
	case risk.FieldSatisfies:
		return m.Satisfies()
	case risk.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case risk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case risk.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case risk.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case risk.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case risk.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case risk.FieldMappingID:
		return m.OldMappingID(ctx)
	case risk.FieldTags:
		return m.OldTags(ctx)
	case risk.FieldName:
		return m.OldName(ctx)
	case risk.FieldDescription:
		return m.OldDescription(ctx)
	case risk.FieldStatus:
		return m.OldStatus(ctx)
	case risk.FieldRiskType:
		return m.OldRiskType(ctx)
	case risk.FieldBusinessCosts:
		return m.OldBusinessCosts(ctx)
	case risk.FieldImpact:
		return m.OldImpact(ctx)
	case risk.FieldLikelihood:
		return m.OldLikelihood(ctx)
	case risk.FieldMitigation:
		return m.OldMitigation(ctx)
	case risk.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case risk.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Risk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case risk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case risk.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case risk.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case risk.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case risk.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case risk.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case risk.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case risk.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case risk.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case risk.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case risk.FieldRiskType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskType(v)
		return nil
	case risk.FieldBusinessCosts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessCosts(v)
		return nil
	case risk.FieldImpact:
		v, ok := value.(enums.RiskImpact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpact(v)
		return nil
	case risk.FieldLikelihood:
		v, ok := value.(enums.RiskLikelihood)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikelihood(v)
		return nil
	case risk.FieldMitigation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMitigation(v)
		return nil
	case risk.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case risk.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Risk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risk.FieldCreatedAt) {
		fields = append(fields, risk.FieldCreatedAt)
	}
	if m.FieldCleared(risk.FieldUpdatedAt) {
		fields = append(fields, risk.FieldUpdatedAt)
	}
	if m.FieldCleared(risk.FieldCreatedBy) {
		fields = append(fields, risk.FieldCreatedBy)
	}
	if m.FieldCleared(risk.FieldUpdatedBy) {
		fields = append(fields, risk.FieldUpdatedBy)
	}
	if m.FieldCleared(risk.FieldDeletedAt) {
		fields = append(fields, risk.FieldDeletedAt)
	}
	if m.FieldCleared(risk.FieldDeletedBy) {
		fields = append(fields, risk.FieldDeletedBy)
	}
	if m.FieldCleared(risk.FieldTags) {
		fields = append(fields, risk.FieldTags)
	}
	if m.FieldCleared(risk.FieldDescription) {
		fields = append(fields, risk.FieldDescription)
	}
	if m.FieldCleared(risk.FieldStatus) {
		fields = append(fields, risk.FieldStatus)
	}
	if m.FieldCleared(risk.FieldRiskType) {
		fields = append(fields, risk.FieldRiskType)
	}
	if m.FieldCleared(risk.FieldBusinessCosts) {
		fields = append(fields, risk.FieldBusinessCosts)
	}
	if m.FieldCleared(risk.FieldImpact) {
		fields = append(fields, risk.FieldImpact)
	}
	if m.FieldCleared(risk.FieldLikelihood) {
		fields = append(fields, risk.FieldLikelihood)
	}
	if m.FieldCleared(risk.FieldMitigation) {
		fields = append(fields, risk.FieldMitigation)
	}
	if m.FieldCleared(risk.FieldSatisfies) {
		fields = append(fields, risk.FieldSatisfies)
	}
	if m.FieldCleared(risk.FieldDetails) {
		fields = append(fields, risk.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskMutation) ClearField(name string) error {
	switch name {
	case risk.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case risk.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case risk.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case risk.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case risk.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case risk.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case risk.FieldTags:
		m.ClearTags()
		return nil
	case risk.FieldDescription:
		m.ClearDescription()
		return nil
	case risk.FieldStatus:
		m.ClearStatus()
		return nil
	case risk.FieldRiskType:
		m.ClearRiskType()
		return nil
	case risk.FieldBusinessCosts:
		m.ClearBusinessCosts()
		return nil
	case risk.FieldImpact:
		m.ClearImpact()
		return nil
	case risk.FieldLikelihood:
		m.ClearLikelihood()
		return nil
	case risk.FieldMitigation:
		m.ClearMitigation()
		return nil
	case risk.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case risk.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Risk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskMutation) ResetField(name string) error {
	switch name {
	case risk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case risk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case risk.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case risk.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case risk.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case risk.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case risk.FieldMappingID:
		m.ResetMappingID()
		return nil
	case risk.FieldTags:
		m.ResetTags()
		return nil
	case risk.FieldName:
		m.ResetName()
		return nil
	case risk.FieldDescription:
		m.ResetDescription()
		return nil
	case risk.FieldStatus:
		m.ResetStatus()
		return nil
	case risk.FieldRiskType:
		m.ResetRiskType()
		return nil
	case risk.FieldBusinessCosts:
		m.ResetBusinessCosts()
		return nil
	case risk.FieldImpact:
		m.ResetImpact()
		return nil
	case risk.FieldLikelihood:
		m.ResetLikelihood()
		return nil
	case risk.FieldMitigation:
		m.ResetMitigation()
		return nil
	case risk.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case risk.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.control != nil {
		edges = append(edges, risk.EdgeControl)
	}
	if m.procedure != nil {
		edges = append(edges, risk.EdgeProcedure)
	}
	if m.actionplans != nil {
		edges = append(edges, risk.EdgeActionplans)
	}
	if m.program != nil {
		edges = append(edges, risk.EdgeProgram)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risk.EdgeControl:
		ids := make([]ent.Value, 0, len(m.control))
		for id := range m.control {
			ids = append(ids, id)
		}
		return ids
	case risk.EdgeProcedure:
		ids := make([]ent.Value, 0, len(m.procedure))
		for id := range m.procedure {
			ids = append(ids, id)
		}
		return ids
	case risk.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.actionplans))
		for id := range m.actionplans {
			ids = append(ids, id)
		}
		return ids
	case risk.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.program))
		for id := range m.program {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcontrol != nil {
		edges = append(edges, risk.EdgeControl)
	}
	if m.removedprocedure != nil {
		edges = append(edges, risk.EdgeProcedure)
	}
	if m.removedactionplans != nil {
		edges = append(edges, risk.EdgeActionplans)
	}
	if m.removedprogram != nil {
		edges = append(edges, risk.EdgeProgram)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case risk.EdgeControl:
		ids := make([]ent.Value, 0, len(m.removedcontrol))
		for id := range m.removedcontrol {
			ids = append(ids, id)
		}
		return ids
	case risk.EdgeProcedure:
		ids := make([]ent.Value, 0, len(m.removedprocedure))
		for id := range m.removedprocedure {
			ids = append(ids, id)
		}
		return ids
	case risk.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.removedactionplans))
		for id := range m.removedactionplans {
			ids = append(ids, id)
		}
		return ids
	case risk.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.removedprogram))
		for id := range m.removedprogram {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcontrol {
		edges = append(edges, risk.EdgeControl)
	}
	if m.clearedprocedure {
		edges = append(edges, risk.EdgeProcedure)
	}
	if m.clearedactionplans {
		edges = append(edges, risk.EdgeActionplans)
	}
	if m.clearedprogram {
		edges = append(edges, risk.EdgeProgram)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskMutation) EdgeCleared(name string) bool {
	switch name {
	case risk.EdgeControl:
		return m.clearedcontrol
	case risk.EdgeProcedure:
		return m.clearedprocedure
	case risk.EdgeActionplans:
		return m.clearedactionplans
	case risk.EdgeProgram:
		return m.clearedprogram
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Risk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskMutation) ResetEdge(name string) error {
	switch name {
	case risk.EdgeControl:
		m.ResetControl()
		return nil
	case risk.EdgeProcedure:
		m.ResetProcedure()
		return nil
	case risk.EdgeActionplans:
		m.ResetActionplans()
		return nil
	case risk.EdgeProgram:
		m.ResetProgram()
		return nil
	}
	return fmt.Errorf("unknown Risk edge %s", name)
}

// RiskHistoryMutation represents an operation that mutates the RiskHistory nodes in the graph.
type RiskHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *string
	history_time   *time.Time
	ref            *string
	operation      *history.OpType
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	deleted_at     *time.Time
	deleted_by     *string
	mapping_id     *string
	tags           *[]string
	appendtags     []string
	name           *string
	description    *string
	status         *string
	risk_type      *string
	business_costs *string
	impact         *enums.RiskImpact
	likelihood     *enums.RiskLikelihood
	mitigation     *string
	satisfies      *string
	details        *map[string]interface{}
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*RiskHistory, error)
	predicates     []predicate.RiskHistory
}

var _ ent.Mutation = (*RiskHistoryMutation)(nil)

// riskhistoryOption allows management of the mutation configuration using functional options.
type riskhistoryOption func(*RiskHistoryMutation)

// newRiskHistoryMutation creates new mutation for the RiskHistory entity.
func newRiskHistoryMutation(c config, op Op, opts ...riskhistoryOption) *RiskHistoryMutation {
	m := &RiskHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskHistoryID sets the ID field of the mutation.
func withRiskHistoryID(id string) riskhistoryOption {
	return func(m *RiskHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskHistory
		)
		m.oldValue = func(ctx context.Context) (*RiskHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskHistory sets the old RiskHistory of the mutation.
func withRiskHistory(node *RiskHistory) riskhistoryOption {
	return func(m *RiskHistoryMutation) {
		m.oldValue = func(context.Context) (*RiskHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RiskHistory entities.
func (m *RiskHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *RiskHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *RiskHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *RiskHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *RiskHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *RiskHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *RiskHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[riskhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *RiskHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *RiskHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, riskhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *RiskHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *RiskHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *RiskHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RiskHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[riskhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RiskHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, riskhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RiskHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[riskhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RiskHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, riskhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RiskHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[riskhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RiskHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, riskhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RiskHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[riskhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RiskHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, riskhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[riskhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, riskhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *RiskHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *RiskHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *RiskHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[riskhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *RiskHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *RiskHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, riskhistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *RiskHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *RiskHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *RiskHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *RiskHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *RiskHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *RiskHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *RiskHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *RiskHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[riskhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *RiskHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *RiskHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, riskhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *RiskHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RiskHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RiskHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RiskHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[riskhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RiskHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RiskHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, riskhistory.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *RiskHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RiskHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *RiskHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[riskhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RiskHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RiskHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, riskhistory.FieldStatus)
}

// SetRiskType sets the "risk_type" field.
func (m *RiskHistoryMutation) SetRiskType(s string) {
	m.risk_type = &s
}

// RiskType returns the value of the "risk_type" field in the mutation.
func (m *RiskHistoryMutation) RiskType() (r string, exists bool) {
	v := m.risk_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskType returns the old "risk_type" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldRiskType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskType: %w", err)
	}
	return oldValue.RiskType, nil
}

// ClearRiskType clears the value of the "risk_type" field.
func (m *RiskHistoryMutation) ClearRiskType() {
	m.risk_type = nil
	m.clearedFields[riskhistory.FieldRiskType] = struct{}{}
}

// RiskTypeCleared returns if the "risk_type" field was cleared in this mutation.
func (m *RiskHistoryMutation) RiskTypeCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldRiskType]
	return ok
}

// ResetRiskType resets all changes to the "risk_type" field.
func (m *RiskHistoryMutation) ResetRiskType() {
	m.risk_type = nil
	delete(m.clearedFields, riskhistory.FieldRiskType)
}

// SetBusinessCosts sets the "business_costs" field.
func (m *RiskHistoryMutation) SetBusinessCosts(s string) {
	m.business_costs = &s
}

// BusinessCosts returns the value of the "business_costs" field in the mutation.
func (m *RiskHistoryMutation) BusinessCosts() (r string, exists bool) {
	v := m.business_costs
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessCosts returns the old "business_costs" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldBusinessCosts(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessCosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessCosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessCosts: %w", err)
	}
	return oldValue.BusinessCosts, nil
}

// ClearBusinessCosts clears the value of the "business_costs" field.
func (m *RiskHistoryMutation) ClearBusinessCosts() {
	m.business_costs = nil
	m.clearedFields[riskhistory.FieldBusinessCosts] = struct{}{}
}

// BusinessCostsCleared returns if the "business_costs" field was cleared in this mutation.
func (m *RiskHistoryMutation) BusinessCostsCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldBusinessCosts]
	return ok
}

// ResetBusinessCosts resets all changes to the "business_costs" field.
func (m *RiskHistoryMutation) ResetBusinessCosts() {
	m.business_costs = nil
	delete(m.clearedFields, riskhistory.FieldBusinessCosts)
}

// SetImpact sets the "impact" field.
func (m *RiskHistoryMutation) SetImpact(ei enums.RiskImpact) {
	m.impact = &ei
}

// Impact returns the value of the "impact" field in the mutation.
func (m *RiskHistoryMutation) Impact() (r enums.RiskImpact, exists bool) {
	v := m.impact
	if v == nil {
		return
	}
	return *v, true
}

// OldImpact returns the old "impact" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldImpact(ctx context.Context) (v enums.RiskImpact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpact: %w", err)
	}
	return oldValue.Impact, nil
}

// ClearImpact clears the value of the "impact" field.
func (m *RiskHistoryMutation) ClearImpact() {
	m.impact = nil
	m.clearedFields[riskhistory.FieldImpact] = struct{}{}
}

// ImpactCleared returns if the "impact" field was cleared in this mutation.
func (m *RiskHistoryMutation) ImpactCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldImpact]
	return ok
}

// ResetImpact resets all changes to the "impact" field.
func (m *RiskHistoryMutation) ResetImpact() {
	m.impact = nil
	delete(m.clearedFields, riskhistory.FieldImpact)
}

// SetLikelihood sets the "likelihood" field.
func (m *RiskHistoryMutation) SetLikelihood(el enums.RiskLikelihood) {
	m.likelihood = &el
}

// Likelihood returns the value of the "likelihood" field in the mutation.
func (m *RiskHistoryMutation) Likelihood() (r enums.RiskLikelihood, exists bool) {
	v := m.likelihood
	if v == nil {
		return
	}
	return *v, true
}

// OldLikelihood returns the old "likelihood" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldLikelihood(ctx context.Context) (v enums.RiskLikelihood, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikelihood is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikelihood requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikelihood: %w", err)
	}
	return oldValue.Likelihood, nil
}

// ClearLikelihood clears the value of the "likelihood" field.
func (m *RiskHistoryMutation) ClearLikelihood() {
	m.likelihood = nil
	m.clearedFields[riskhistory.FieldLikelihood] = struct{}{}
}

// LikelihoodCleared returns if the "likelihood" field was cleared in this mutation.
func (m *RiskHistoryMutation) LikelihoodCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldLikelihood]
	return ok
}

// ResetLikelihood resets all changes to the "likelihood" field.
func (m *RiskHistoryMutation) ResetLikelihood() {
	m.likelihood = nil
	delete(m.clearedFields, riskhistory.FieldLikelihood)
}

// SetMitigation sets the "mitigation" field.
func (m *RiskHistoryMutation) SetMitigation(s string) {
	m.mitigation = &s
}

// Mitigation returns the value of the "mitigation" field in the mutation.
func (m *RiskHistoryMutation) Mitigation() (r string, exists bool) {
	v := m.mitigation
	if v == nil {
		return
	}
	return *v, true
}

// OldMitigation returns the old "mitigation" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldMitigation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMitigation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMitigation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMitigation: %w", err)
	}
	return oldValue.Mitigation, nil
}

// ClearMitigation clears the value of the "mitigation" field.
func (m *RiskHistoryMutation) ClearMitigation() {
	m.mitigation = nil
	m.clearedFields[riskhistory.FieldMitigation] = struct{}{}
}

// MitigationCleared returns if the "mitigation" field was cleared in this mutation.
func (m *RiskHistoryMutation) MitigationCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldMitigation]
	return ok
}

// ResetMitigation resets all changes to the "mitigation" field.
func (m *RiskHistoryMutation) ResetMitigation() {
	m.mitigation = nil
	delete(m.clearedFields, riskhistory.FieldMitigation)
}

// SetSatisfies sets the "satisfies" field.
func (m *RiskHistoryMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *RiskHistoryMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *RiskHistoryMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[riskhistory.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *RiskHistoryMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *RiskHistoryMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, riskhistory.FieldSatisfies)
}

// SetDetails sets the "details" field.
func (m *RiskHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *RiskHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the RiskHistory entity.
// If the RiskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *RiskHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[riskhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *RiskHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[riskhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *RiskHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, riskhistory.FieldDetails)
}

// Where appends a list predicates to the RiskHistoryMutation builder.
func (m *RiskHistoryMutation) Where(ps ...predicate.RiskHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskHistory).
func (m *RiskHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskHistoryMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.history_time != nil {
		fields = append(fields, riskhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, riskhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, riskhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, riskhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, riskhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, riskhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, riskhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, riskhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, riskhistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, riskhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, riskhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, riskhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, riskhistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, riskhistory.FieldStatus)
	}
	if m.risk_type != nil {
		fields = append(fields, riskhistory.FieldRiskType)
	}
	if m.business_costs != nil {
		fields = append(fields, riskhistory.FieldBusinessCosts)
	}
	if m.impact != nil {
		fields = append(fields, riskhistory.FieldImpact)
	}
	if m.likelihood != nil {
		fields = append(fields, riskhistory.FieldLikelihood)
	}
	if m.mitigation != nil {
		fields = append(fields, riskhistory.FieldMitigation)
	}
	if m.satisfies != nil {
		fields = append(fields, riskhistory.FieldSatisfies)
	}
	if m.details != nil {
		fields = append(fields, riskhistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case riskhistory.FieldHistoryTime:
		return m.HistoryTime()
	case riskhistory.FieldRef:
		return m.Ref()
	case riskhistory.FieldOperation:
		return m.Operation()
	case riskhistory.FieldCreatedAt:
		return m.CreatedAt()
	case riskhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case riskhistory.FieldCreatedBy:
		return m.CreatedBy()
	case riskhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case riskhistory.FieldDeletedAt:
		return m.DeletedAt()
	case riskhistory.FieldDeletedBy:
		return m.DeletedBy()
	case riskhistory.FieldMappingID:
		return m.MappingID()
	case riskhistory.FieldTags:
		return m.Tags()
	case riskhistory.FieldName:
		return m.Name()
	case riskhistory.FieldDescription:
		return m.Description()
	case riskhistory.FieldStatus:
		return m.Status()
	case riskhistory.FieldRiskType:
		return m.RiskType()
	case riskhistory.FieldBusinessCosts:
		return m.BusinessCosts()
	case riskhistory.FieldImpact:
		return m.Impact()
	case riskhistory.FieldLikelihood:
		return m.Likelihood()
	case riskhistory.FieldMitigation:
		return m.Mitigation()
	case riskhistory.FieldSatisfies:
		return m.Satisfies()
	case riskhistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case riskhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case riskhistory.FieldRef:
		return m.OldRef(ctx)
	case riskhistory.FieldOperation:
		return m.OldOperation(ctx)
	case riskhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case riskhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case riskhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case riskhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case riskhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case riskhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case riskhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case riskhistory.FieldTags:
		return m.OldTags(ctx)
	case riskhistory.FieldName:
		return m.OldName(ctx)
	case riskhistory.FieldDescription:
		return m.OldDescription(ctx)
	case riskhistory.FieldStatus:
		return m.OldStatus(ctx)
	case riskhistory.FieldRiskType:
		return m.OldRiskType(ctx)
	case riskhistory.FieldBusinessCosts:
		return m.OldBusinessCosts(ctx)
	case riskhistory.FieldImpact:
		return m.OldImpact(ctx)
	case riskhistory.FieldLikelihood:
		return m.OldLikelihood(ctx)
	case riskhistory.FieldMitigation:
		return m.OldMitigation(ctx)
	case riskhistory.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case riskhistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown RiskHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case riskhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case riskhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case riskhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case riskhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case riskhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case riskhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case riskhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case riskhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case riskhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case riskhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case riskhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case riskhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case riskhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case riskhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case riskhistory.FieldRiskType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskType(v)
		return nil
	case riskhistory.FieldBusinessCosts:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessCosts(v)
		return nil
	case riskhistory.FieldImpact:
		v, ok := value.(enums.RiskImpact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpact(v)
		return nil
	case riskhistory.FieldLikelihood:
		v, ok := value.(enums.RiskLikelihood)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikelihood(v)
		return nil
	case riskhistory.FieldMitigation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMitigation(v)
		return nil
	case riskhistory.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case riskhistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown RiskHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RiskHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(riskhistory.FieldRef) {
		fields = append(fields, riskhistory.FieldRef)
	}
	if m.FieldCleared(riskhistory.FieldCreatedAt) {
		fields = append(fields, riskhistory.FieldCreatedAt)
	}
	if m.FieldCleared(riskhistory.FieldUpdatedAt) {
		fields = append(fields, riskhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(riskhistory.FieldCreatedBy) {
		fields = append(fields, riskhistory.FieldCreatedBy)
	}
	if m.FieldCleared(riskhistory.FieldUpdatedBy) {
		fields = append(fields, riskhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(riskhistory.FieldDeletedAt) {
		fields = append(fields, riskhistory.FieldDeletedAt)
	}
	if m.FieldCleared(riskhistory.FieldDeletedBy) {
		fields = append(fields, riskhistory.FieldDeletedBy)
	}
	if m.FieldCleared(riskhistory.FieldTags) {
		fields = append(fields, riskhistory.FieldTags)
	}
	if m.FieldCleared(riskhistory.FieldDescription) {
		fields = append(fields, riskhistory.FieldDescription)
	}
	if m.FieldCleared(riskhistory.FieldStatus) {
		fields = append(fields, riskhistory.FieldStatus)
	}
	if m.FieldCleared(riskhistory.FieldRiskType) {
		fields = append(fields, riskhistory.FieldRiskType)
	}
	if m.FieldCleared(riskhistory.FieldBusinessCosts) {
		fields = append(fields, riskhistory.FieldBusinessCosts)
	}
	if m.FieldCleared(riskhistory.FieldImpact) {
		fields = append(fields, riskhistory.FieldImpact)
	}
	if m.FieldCleared(riskhistory.FieldLikelihood) {
		fields = append(fields, riskhistory.FieldLikelihood)
	}
	if m.FieldCleared(riskhistory.FieldMitigation) {
		fields = append(fields, riskhistory.FieldMitigation)
	}
	if m.FieldCleared(riskhistory.FieldSatisfies) {
		fields = append(fields, riskhistory.FieldSatisfies)
	}
	if m.FieldCleared(riskhistory.FieldDetails) {
		fields = append(fields, riskhistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskHistoryMutation) ClearField(name string) error {
	switch name {
	case riskhistory.FieldRef:
		m.ClearRef()
		return nil
	case riskhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case riskhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case riskhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case riskhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case riskhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case riskhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case riskhistory.FieldTags:
		m.ClearTags()
		return nil
	case riskhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case riskhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case riskhistory.FieldRiskType:
		m.ClearRiskType()
		return nil
	case riskhistory.FieldBusinessCosts:
		m.ClearBusinessCosts()
		return nil
	case riskhistory.FieldImpact:
		m.ClearImpact()
		return nil
	case riskhistory.FieldLikelihood:
		m.ClearLikelihood()
		return nil
	case riskhistory.FieldMitigation:
		m.ClearMitigation()
		return nil
	case riskhistory.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case riskhistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown RiskHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskHistoryMutation) ResetField(name string) error {
	switch name {
	case riskhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case riskhistory.FieldRef:
		m.ResetRef()
		return nil
	case riskhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case riskhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case riskhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case riskhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case riskhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case riskhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case riskhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case riskhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case riskhistory.FieldTags:
		m.ResetTags()
		return nil
	case riskhistory.FieldName:
		m.ResetName()
		return nil
	case riskhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case riskhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case riskhistory.FieldRiskType:
		m.ResetRiskType()
		return nil
	case riskhistory.FieldBusinessCosts:
		m.ResetBusinessCosts()
		return nil
	case riskhistory.FieldImpact:
		m.ResetImpact()
		return nil
	case riskhistory.FieldLikelihood:
		m.ResetLikelihood()
		return nil
	case riskhistory.FieldMitigation:
		m.ResetMitigation()
		return nil
	case riskhistory.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case riskhistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown RiskHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RiskHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RiskHistory edge %s", name)
}

// StandardMutation represents an operation that mutates the Standard nodes in the graph.
type StandardMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	deleted_at               *time.Time
	deleted_by               *string
	mapping_id               *string
	tags                     *[]string
	appendtags               []string
	name                     *string
	description              *string
	family                   *string
	status                   *string
	standard_type            *string
	version                  *string
	purpose_and_scope        *string
	background               *string
	satisfies                *string
	details                  *map[string]interface{}
	clearedFields            map[string]struct{}
	controlobjectives        map[string]struct{}
	removedcontrolobjectives map[string]struct{}
	clearedcontrolobjectives bool
	controls                 map[string]struct{}
	removedcontrols          map[string]struct{}
	clearedcontrols          bool
	procedures               map[string]struct{}
	removedprocedures        map[string]struct{}
	clearedprocedures        bool
	actionplans              map[string]struct{}
	removedactionplans       map[string]struct{}
	clearedactionplans       bool
	programs                 map[string]struct{}
	removedprograms          map[string]struct{}
	clearedprograms          bool
	done                     bool
	oldValue                 func(context.Context) (*Standard, error)
	predicates               []predicate.Standard
}

var _ ent.Mutation = (*StandardMutation)(nil)

// standardOption allows management of the mutation configuration using functional options.
type standardOption func(*StandardMutation)

// newStandardMutation creates new mutation for the Standard entity.
func newStandardMutation(c config, op Op, opts ...standardOption) *StandardMutation {
	m := &StandardMutation{
		config:        c,
		op:            op,
		typ:           TypeStandard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStandardID sets the ID field of the mutation.
func withStandardID(id string) standardOption {
	return func(m *StandardMutation) {
		var (
			err   error
			once  sync.Once
			value *Standard
		)
		m.oldValue = func(ctx context.Context) (*Standard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Standard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStandard sets the old Standard of the mutation.
func withStandard(node *Standard) standardOption {
	return func(m *StandardMutation) {
		m.oldValue = func(context.Context) (*Standard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StandardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StandardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Standard entities.
func (m *StandardMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StandardMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StandardMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Standard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StandardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StandardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *StandardMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[standard.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *StandardMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[standard.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StandardMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, standard.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StandardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StandardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StandardMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[standard.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StandardMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[standard.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StandardMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, standard.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *StandardMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StandardMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StandardMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[standard.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StandardMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[standard.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StandardMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, standard.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StandardMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StandardMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StandardMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[standard.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StandardMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[standard.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StandardMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, standard.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StandardMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StandardMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StandardMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[standard.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StandardMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[standard.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StandardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, standard.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *StandardMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *StandardMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *StandardMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[standard.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *StandardMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[standard.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *StandardMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, standard.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *StandardMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *StandardMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *StandardMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *StandardMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *StandardMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *StandardMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *StandardMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *StandardMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[standard.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *StandardMutation) TagsCleared() bool {
	_, ok := m.clearedFields[standard.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *StandardMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, standard.FieldTags)
}

// SetName sets the "name" field.
func (m *StandardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StandardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StandardMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *StandardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StandardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StandardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[standard.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StandardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[standard.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StandardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, standard.FieldDescription)
}

// SetFamily sets the "family" field.
func (m *StandardMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *StandardMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ClearFamily clears the value of the "family" field.
func (m *StandardMutation) ClearFamily() {
	m.family = nil
	m.clearedFields[standard.FieldFamily] = struct{}{}
}

// FamilyCleared returns if the "family" field was cleared in this mutation.
func (m *StandardMutation) FamilyCleared() bool {
	_, ok := m.clearedFields[standard.FieldFamily]
	return ok
}

// ResetFamily resets all changes to the "family" field.
func (m *StandardMutation) ResetFamily() {
	m.family = nil
	delete(m.clearedFields, standard.FieldFamily)
}

// SetStatus sets the "status" field.
func (m *StandardMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StandardMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *StandardMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[standard.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *StandardMutation) StatusCleared() bool {
	_, ok := m.clearedFields[standard.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *StandardMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, standard.FieldStatus)
}

// SetStandardType sets the "standard_type" field.
func (m *StandardMutation) SetStandardType(s string) {
	m.standard_type = &s
}

// StandardType returns the value of the "standard_type" field in the mutation.
func (m *StandardMutation) StandardType() (r string, exists bool) {
	v := m.standard_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStandardType returns the old "standard_type" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldStandardType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStandardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStandardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandardType: %w", err)
	}
	return oldValue.StandardType, nil
}

// ClearStandardType clears the value of the "standard_type" field.
func (m *StandardMutation) ClearStandardType() {
	m.standard_type = nil
	m.clearedFields[standard.FieldStandardType] = struct{}{}
}

// StandardTypeCleared returns if the "standard_type" field was cleared in this mutation.
func (m *StandardMutation) StandardTypeCleared() bool {
	_, ok := m.clearedFields[standard.FieldStandardType]
	return ok
}

// ResetStandardType resets all changes to the "standard_type" field.
func (m *StandardMutation) ResetStandardType() {
	m.standard_type = nil
	delete(m.clearedFields, standard.FieldStandardType)
}

// SetVersion sets the "version" field.
func (m *StandardMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *StandardMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *StandardMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[standard.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *StandardMutation) VersionCleared() bool {
	_, ok := m.clearedFields[standard.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *StandardMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, standard.FieldVersion)
}

// SetPurposeAndScope sets the "purpose_and_scope" field.
func (m *StandardMutation) SetPurposeAndScope(s string) {
	m.purpose_and_scope = &s
}

// PurposeAndScope returns the value of the "purpose_and_scope" field in the mutation.
func (m *StandardMutation) PurposeAndScope() (r string, exists bool) {
	v := m.purpose_and_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldPurposeAndScope returns the old "purpose_and_scope" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldPurposeAndScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurposeAndScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurposeAndScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurposeAndScope: %w", err)
	}
	return oldValue.PurposeAndScope, nil
}

// ClearPurposeAndScope clears the value of the "purpose_and_scope" field.
func (m *StandardMutation) ClearPurposeAndScope() {
	m.purpose_and_scope = nil
	m.clearedFields[standard.FieldPurposeAndScope] = struct{}{}
}

// PurposeAndScopeCleared returns if the "purpose_and_scope" field was cleared in this mutation.
func (m *StandardMutation) PurposeAndScopeCleared() bool {
	_, ok := m.clearedFields[standard.FieldPurposeAndScope]
	return ok
}

// ResetPurposeAndScope resets all changes to the "purpose_and_scope" field.
func (m *StandardMutation) ResetPurposeAndScope() {
	m.purpose_and_scope = nil
	delete(m.clearedFields, standard.FieldPurposeAndScope)
}

// SetBackground sets the "background" field.
func (m *StandardMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *StandardMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *StandardMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[standard.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *StandardMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[standard.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *StandardMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, standard.FieldBackground)
}

// SetSatisfies sets the "satisfies" field.
func (m *StandardMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *StandardMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *StandardMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[standard.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *StandardMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[standard.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *StandardMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, standard.FieldSatisfies)
}

// SetDetails sets the "details" field.
func (m *StandardMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *StandardMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Standard entity.
// If the Standard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *StandardMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[standard.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *StandardMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[standard.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *StandardMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, standard.FieldDetails)
}

// AddControlobjectiveIDs adds the "controlobjectives" edge to the ControlObjective entity by ids.
func (m *StandardMutation) AddControlobjectiveIDs(ids ...string) {
	if m.controlobjectives == nil {
		m.controlobjectives = make(map[string]struct{})
	}
	for i := range ids {
		m.controlobjectives[ids[i]] = struct{}{}
	}
}

// ClearControlobjectives clears the "controlobjectives" edge to the ControlObjective entity.
func (m *StandardMutation) ClearControlobjectives() {
	m.clearedcontrolobjectives = true
}

// ControlobjectivesCleared reports if the "controlobjectives" edge to the ControlObjective entity was cleared.
func (m *StandardMutation) ControlobjectivesCleared() bool {
	return m.clearedcontrolobjectives
}

// RemoveControlobjectiveIDs removes the "controlobjectives" edge to the ControlObjective entity by IDs.
func (m *StandardMutation) RemoveControlobjectiveIDs(ids ...string) {
	if m.removedcontrolobjectives == nil {
		m.removedcontrolobjectives = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controlobjectives, ids[i])
		m.removedcontrolobjectives[ids[i]] = struct{}{}
	}
}

// RemovedControlobjectives returns the removed IDs of the "controlobjectives" edge to the ControlObjective entity.
func (m *StandardMutation) RemovedControlobjectivesIDs() (ids []string) {
	for id := range m.removedcontrolobjectives {
		ids = append(ids, id)
	}
	return
}

// ControlobjectivesIDs returns the "controlobjectives" edge IDs in the mutation.
func (m *StandardMutation) ControlobjectivesIDs() (ids []string) {
	for id := range m.controlobjectives {
		ids = append(ids, id)
	}
	return
}

// ResetControlobjectives resets all changes to the "controlobjectives" edge.
func (m *StandardMutation) ResetControlobjectives() {
	m.controlobjectives = nil
	m.clearedcontrolobjectives = false
	m.removedcontrolobjectives = nil
}

// AddControlIDs adds the "controls" edge to the Control entity by ids.
func (m *StandardMutation) AddControlIDs(ids ...string) {
	if m.controls == nil {
		m.controls = make(map[string]struct{})
	}
	for i := range ids {
		m.controls[ids[i]] = struct{}{}
	}
}

// ClearControls clears the "controls" edge to the Control entity.
func (m *StandardMutation) ClearControls() {
	m.clearedcontrols = true
}

// ControlsCleared reports if the "controls" edge to the Control entity was cleared.
func (m *StandardMutation) ControlsCleared() bool {
	return m.clearedcontrols
}

// RemoveControlIDs removes the "controls" edge to the Control entity by IDs.
func (m *StandardMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrols == nil {
		m.removedcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.controls, ids[i])
		m.removedcontrols[ids[i]] = struct{}{}
	}
}

// RemovedControls returns the removed IDs of the "controls" edge to the Control entity.
func (m *StandardMutation) RemovedControlsIDs() (ids []string) {
	for id := range m.removedcontrols {
		ids = append(ids, id)
	}
	return
}

// ControlsIDs returns the "controls" edge IDs in the mutation.
func (m *StandardMutation) ControlsIDs() (ids []string) {
	for id := range m.controls {
		ids = append(ids, id)
	}
	return
}

// ResetControls resets all changes to the "controls" edge.
func (m *StandardMutation) ResetControls() {
	m.controls = nil
	m.clearedcontrols = false
	m.removedcontrols = nil
}

// AddProcedureIDs adds the "procedures" edge to the Procedure entity by ids.
func (m *StandardMutation) AddProcedureIDs(ids ...string) {
	if m.procedures == nil {
		m.procedures = make(map[string]struct{})
	}
	for i := range ids {
		m.procedures[ids[i]] = struct{}{}
	}
}

// ClearProcedures clears the "procedures" edge to the Procedure entity.
func (m *StandardMutation) ClearProcedures() {
	m.clearedprocedures = true
}

// ProceduresCleared reports if the "procedures" edge to the Procedure entity was cleared.
func (m *StandardMutation) ProceduresCleared() bool {
	return m.clearedprocedures
}

// RemoveProcedureIDs removes the "procedures" edge to the Procedure entity by IDs.
func (m *StandardMutation) RemoveProcedureIDs(ids ...string) {
	if m.removedprocedures == nil {
		m.removedprocedures = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.procedures, ids[i])
		m.removedprocedures[ids[i]] = struct{}{}
	}
}

// RemovedProcedures returns the removed IDs of the "procedures" edge to the Procedure entity.
func (m *StandardMutation) RemovedProceduresIDs() (ids []string) {
	for id := range m.removedprocedures {
		ids = append(ids, id)
	}
	return
}

// ProceduresIDs returns the "procedures" edge IDs in the mutation.
func (m *StandardMutation) ProceduresIDs() (ids []string) {
	for id := range m.procedures {
		ids = append(ids, id)
	}
	return
}

// ResetProcedures resets all changes to the "procedures" edge.
func (m *StandardMutation) ResetProcedures() {
	m.procedures = nil
	m.clearedprocedures = false
	m.removedprocedures = nil
}

// AddActionplanIDs adds the "actionplans" edge to the ActionPlan entity by ids.
func (m *StandardMutation) AddActionplanIDs(ids ...string) {
	if m.actionplans == nil {
		m.actionplans = make(map[string]struct{})
	}
	for i := range ids {
		m.actionplans[ids[i]] = struct{}{}
	}
}

// ClearActionplans clears the "actionplans" edge to the ActionPlan entity.
func (m *StandardMutation) ClearActionplans() {
	m.clearedactionplans = true
}

// ActionplansCleared reports if the "actionplans" edge to the ActionPlan entity was cleared.
func (m *StandardMutation) ActionplansCleared() bool {
	return m.clearedactionplans
}

// RemoveActionplanIDs removes the "actionplans" edge to the ActionPlan entity by IDs.
func (m *StandardMutation) RemoveActionplanIDs(ids ...string) {
	if m.removedactionplans == nil {
		m.removedactionplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.actionplans, ids[i])
		m.removedactionplans[ids[i]] = struct{}{}
	}
}

// RemovedActionplans returns the removed IDs of the "actionplans" edge to the ActionPlan entity.
func (m *StandardMutation) RemovedActionplansIDs() (ids []string) {
	for id := range m.removedactionplans {
		ids = append(ids, id)
	}
	return
}

// ActionplansIDs returns the "actionplans" edge IDs in the mutation.
func (m *StandardMutation) ActionplansIDs() (ids []string) {
	for id := range m.actionplans {
		ids = append(ids, id)
	}
	return
}

// ResetActionplans resets all changes to the "actionplans" edge.
func (m *StandardMutation) ResetActionplans() {
	m.actionplans = nil
	m.clearedactionplans = false
	m.removedactionplans = nil
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *StandardMutation) AddProgramIDs(ids ...string) {
	if m.programs == nil {
		m.programs = make(map[string]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *StandardMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *StandardMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *StandardMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *StandardMutation) RemovedProgramsIDs() (ids []string) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *StandardMutation) ProgramsIDs() (ids []string) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *StandardMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// Where appends a list predicates to the StandardMutation builder.
func (m *StandardMutation) Where(ps ...predicate.Standard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StandardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StandardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Standard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StandardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StandardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Standard).
func (m *StandardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StandardMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, standard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, standard.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, standard.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, standard.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, standard.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, standard.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, standard.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, standard.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, standard.FieldName)
	}
	if m.description != nil {
		fields = append(fields, standard.FieldDescription)
	}
	if m.family != nil {
		fields = append(fields, standard.FieldFamily)
	}
	if m.status != nil {
		fields = append(fields, standard.FieldStatus)
	}
	if m.standard_type != nil {
		fields = append(fields, standard.FieldStandardType)
	}
	if m.version != nil {
		fields = append(fields, standard.FieldVersion)
	}
	if m.purpose_and_scope != nil {
		fields = append(fields, standard.FieldPurposeAndScope)
	}
	if m.background != nil {
		fields = append(fields, standard.FieldBackground)
	}
	if m.satisfies != nil {
		fields = append(fields, standard.FieldSatisfies)
	}
	if m.details != nil {
		fields = append(fields, standard.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StandardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case standard.FieldCreatedAt:
		return m.CreatedAt()
	case standard.FieldUpdatedAt:
		return m.UpdatedAt()
	case standard.FieldCreatedBy:
		return m.CreatedBy()
	case standard.FieldUpdatedBy:
		return m.UpdatedBy()
	case standard.FieldDeletedAt:
		return m.DeletedAt()
	case standard.FieldDeletedBy:
		return m.DeletedBy()
	case standard.FieldMappingID:
		return m.MappingID()
	case standard.FieldTags:
		return m.Tags()
	case standard.FieldName:
		return m.Name()
	case standard.FieldDescription:
		return m.Description()
	case standard.FieldFamily:
		return m.Family()
	case standard.FieldStatus:
		return m.Status()
	case standard.FieldStandardType:
		return m.StandardType()
	case standard.FieldVersion:
		return m.Version()
	case standard.FieldPurposeAndScope:
		return m.PurposeAndScope()
	case standard.FieldBackground:
		return m.Background()
	case standard.FieldSatisfies:
		return m.Satisfies()
	case standard.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StandardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case standard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case standard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case standard.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case standard.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case standard.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case standard.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case standard.FieldMappingID:
		return m.OldMappingID(ctx)
	case standard.FieldTags:
		return m.OldTags(ctx)
	case standard.FieldName:
		return m.OldName(ctx)
	case standard.FieldDescription:
		return m.OldDescription(ctx)
	case standard.FieldFamily:
		return m.OldFamily(ctx)
	case standard.FieldStatus:
		return m.OldStatus(ctx)
	case standard.FieldStandardType:
		return m.OldStandardType(ctx)
	case standard.FieldVersion:
		return m.OldVersion(ctx)
	case standard.FieldPurposeAndScope:
		return m.OldPurposeAndScope(ctx)
	case standard.FieldBackground:
		return m.OldBackground(ctx)
	case standard.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case standard.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Standard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case standard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case standard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case standard.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case standard.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case standard.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case standard.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case standard.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case standard.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case standard.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case standard.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case standard.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case standard.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case standard.FieldStandardType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandardType(v)
		return nil
	case standard.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case standard.FieldPurposeAndScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurposeAndScope(v)
		return nil
	case standard.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case standard.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case standard.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Standard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StandardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StandardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Standard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StandardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(standard.FieldCreatedAt) {
		fields = append(fields, standard.FieldCreatedAt)
	}
	if m.FieldCleared(standard.FieldUpdatedAt) {
		fields = append(fields, standard.FieldUpdatedAt)
	}
	if m.FieldCleared(standard.FieldCreatedBy) {
		fields = append(fields, standard.FieldCreatedBy)
	}
	if m.FieldCleared(standard.FieldUpdatedBy) {
		fields = append(fields, standard.FieldUpdatedBy)
	}
	if m.FieldCleared(standard.FieldDeletedAt) {
		fields = append(fields, standard.FieldDeletedAt)
	}
	if m.FieldCleared(standard.FieldDeletedBy) {
		fields = append(fields, standard.FieldDeletedBy)
	}
	if m.FieldCleared(standard.FieldTags) {
		fields = append(fields, standard.FieldTags)
	}
	if m.FieldCleared(standard.FieldDescription) {
		fields = append(fields, standard.FieldDescription)
	}
	if m.FieldCleared(standard.FieldFamily) {
		fields = append(fields, standard.FieldFamily)
	}
	if m.FieldCleared(standard.FieldStatus) {
		fields = append(fields, standard.FieldStatus)
	}
	if m.FieldCleared(standard.FieldStandardType) {
		fields = append(fields, standard.FieldStandardType)
	}
	if m.FieldCleared(standard.FieldVersion) {
		fields = append(fields, standard.FieldVersion)
	}
	if m.FieldCleared(standard.FieldPurposeAndScope) {
		fields = append(fields, standard.FieldPurposeAndScope)
	}
	if m.FieldCleared(standard.FieldBackground) {
		fields = append(fields, standard.FieldBackground)
	}
	if m.FieldCleared(standard.FieldSatisfies) {
		fields = append(fields, standard.FieldSatisfies)
	}
	if m.FieldCleared(standard.FieldDetails) {
		fields = append(fields, standard.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StandardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StandardMutation) ClearField(name string) error {
	switch name {
	case standard.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case standard.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case standard.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case standard.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case standard.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case standard.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case standard.FieldTags:
		m.ClearTags()
		return nil
	case standard.FieldDescription:
		m.ClearDescription()
		return nil
	case standard.FieldFamily:
		m.ClearFamily()
		return nil
	case standard.FieldStatus:
		m.ClearStatus()
		return nil
	case standard.FieldStandardType:
		m.ClearStandardType()
		return nil
	case standard.FieldVersion:
		m.ClearVersion()
		return nil
	case standard.FieldPurposeAndScope:
		m.ClearPurposeAndScope()
		return nil
	case standard.FieldBackground:
		m.ClearBackground()
		return nil
	case standard.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case standard.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Standard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StandardMutation) ResetField(name string) error {
	switch name {
	case standard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case standard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case standard.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case standard.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case standard.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case standard.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case standard.FieldMappingID:
		m.ResetMappingID()
		return nil
	case standard.FieldTags:
		m.ResetTags()
		return nil
	case standard.FieldName:
		m.ResetName()
		return nil
	case standard.FieldDescription:
		m.ResetDescription()
		return nil
	case standard.FieldFamily:
		m.ResetFamily()
		return nil
	case standard.FieldStatus:
		m.ResetStatus()
		return nil
	case standard.FieldStandardType:
		m.ResetStandardType()
		return nil
	case standard.FieldVersion:
		m.ResetVersion()
		return nil
	case standard.FieldPurposeAndScope:
		m.ResetPurposeAndScope()
		return nil
	case standard.FieldBackground:
		m.ResetBackground()
		return nil
	case standard.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case standard.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Standard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StandardMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.controlobjectives != nil {
		edges = append(edges, standard.EdgeControlobjectives)
	}
	if m.controls != nil {
		edges = append(edges, standard.EdgeControls)
	}
	if m.procedures != nil {
		edges = append(edges, standard.EdgeProcedures)
	}
	if m.actionplans != nil {
		edges = append(edges, standard.EdgeActionplans)
	}
	if m.programs != nil {
		edges = append(edges, standard.EdgePrograms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StandardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case standard.EdgeControlobjectives:
		ids := make([]ent.Value, 0, len(m.controlobjectives))
		for id := range m.controlobjectives {
			ids = append(ids, id)
		}
		return ids
	case standard.EdgeControls:
		ids := make([]ent.Value, 0, len(m.controls))
		for id := range m.controls {
			ids = append(ids, id)
		}
		return ids
	case standard.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.procedures))
		for id := range m.procedures {
			ids = append(ids, id)
		}
		return ids
	case standard.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.actionplans))
		for id := range m.actionplans {
			ids = append(ids, id)
		}
		return ids
	case standard.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StandardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcontrolobjectives != nil {
		edges = append(edges, standard.EdgeControlobjectives)
	}
	if m.removedcontrols != nil {
		edges = append(edges, standard.EdgeControls)
	}
	if m.removedprocedures != nil {
		edges = append(edges, standard.EdgeProcedures)
	}
	if m.removedactionplans != nil {
		edges = append(edges, standard.EdgeActionplans)
	}
	if m.removedprograms != nil {
		edges = append(edges, standard.EdgePrograms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StandardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case standard.EdgeControlobjectives:
		ids := make([]ent.Value, 0, len(m.removedcontrolobjectives))
		for id := range m.removedcontrolobjectives {
			ids = append(ids, id)
		}
		return ids
	case standard.EdgeControls:
		ids := make([]ent.Value, 0, len(m.removedcontrols))
		for id := range m.removedcontrols {
			ids = append(ids, id)
		}
		return ids
	case standard.EdgeProcedures:
		ids := make([]ent.Value, 0, len(m.removedprocedures))
		for id := range m.removedprocedures {
			ids = append(ids, id)
		}
		return ids
	case standard.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.removedactionplans))
		for id := range m.removedactionplans {
			ids = append(ids, id)
		}
		return ids
	case standard.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StandardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcontrolobjectives {
		edges = append(edges, standard.EdgeControlobjectives)
	}
	if m.clearedcontrols {
		edges = append(edges, standard.EdgeControls)
	}
	if m.clearedprocedures {
		edges = append(edges, standard.EdgeProcedures)
	}
	if m.clearedactionplans {
		edges = append(edges, standard.EdgeActionplans)
	}
	if m.clearedprograms {
		edges = append(edges, standard.EdgePrograms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StandardMutation) EdgeCleared(name string) bool {
	switch name {
	case standard.EdgeControlobjectives:
		return m.clearedcontrolobjectives
	case standard.EdgeControls:
		return m.clearedcontrols
	case standard.EdgeProcedures:
		return m.clearedprocedures
	case standard.EdgeActionplans:
		return m.clearedactionplans
	case standard.EdgePrograms:
		return m.clearedprograms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StandardMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Standard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StandardMutation) ResetEdge(name string) error {
	switch name {
	case standard.EdgeControlobjectives:
		m.ResetControlobjectives()
		return nil
	case standard.EdgeControls:
		m.ResetControls()
		return nil
	case standard.EdgeProcedures:
		m.ResetProcedures()
		return nil
	case standard.EdgeActionplans:
		m.ResetActionplans()
		return nil
	case standard.EdgePrograms:
		m.ResetPrograms()
		return nil
	}
	return fmt.Errorf("unknown Standard edge %s", name)
}

// StandardHistoryMutation represents an operation that mutates the StandardHistory nodes in the graph.
type StandardHistoryMutation struct {
	config
	op                Op
	typ               string
	id                *string
	history_time      *time.Time
	ref               *string
	operation         *history.OpType
	created_at        *time.Time
	updated_at        *time.Time
	created_by        *string
	updated_by        *string
	deleted_at        *time.Time
	deleted_by        *string
	mapping_id        *string
	tags              *[]string
	appendtags        []string
	name              *string
	description       *string
	family            *string
	status            *string
	standard_type     *string
	version           *string
	purpose_and_scope *string
	background        *string
	satisfies         *string
	details           *map[string]interface{}
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*StandardHistory, error)
	predicates        []predicate.StandardHistory
}

var _ ent.Mutation = (*StandardHistoryMutation)(nil)

// standardhistoryOption allows management of the mutation configuration using functional options.
type standardhistoryOption func(*StandardHistoryMutation)

// newStandardHistoryMutation creates new mutation for the StandardHistory entity.
func newStandardHistoryMutation(c config, op Op, opts ...standardhistoryOption) *StandardHistoryMutation {
	m := &StandardHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeStandardHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStandardHistoryID sets the ID field of the mutation.
func withStandardHistoryID(id string) standardhistoryOption {
	return func(m *StandardHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *StandardHistory
		)
		m.oldValue = func(ctx context.Context) (*StandardHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StandardHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStandardHistory sets the old StandardHistory of the mutation.
func withStandardHistory(node *StandardHistory) standardhistoryOption {
	return func(m *StandardHistoryMutation) {
		m.oldValue = func(context.Context) (*StandardHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StandardHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StandardHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StandardHistory entities.
func (m *StandardHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StandardHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StandardHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StandardHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *StandardHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *StandardHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *StandardHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *StandardHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *StandardHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *StandardHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[standardhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *StandardHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *StandardHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, standardhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *StandardHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *StandardHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *StandardHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StandardHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StandardHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *StandardHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[standardhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *StandardHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StandardHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, standardhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StandardHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StandardHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *StandardHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[standardhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *StandardHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StandardHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, standardhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *StandardHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StandardHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StandardHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[standardhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StandardHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StandardHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, standardhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StandardHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StandardHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StandardHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[standardhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StandardHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StandardHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, standardhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StandardHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StandardHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StandardHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[standardhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StandardHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StandardHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, standardhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *StandardHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *StandardHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *StandardHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[standardhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *StandardHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *StandardHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, standardhistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *StandardHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *StandardHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *StandardHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *StandardHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *StandardHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *StandardHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *StandardHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *StandardHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[standardhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *StandardHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *StandardHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, standardhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *StandardHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StandardHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StandardHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *StandardHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StandardHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StandardHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[standardhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StandardHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StandardHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, standardhistory.FieldDescription)
}

// SetFamily sets the "family" field.
func (m *StandardHistoryMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *StandardHistoryMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ClearFamily clears the value of the "family" field.
func (m *StandardHistoryMutation) ClearFamily() {
	m.family = nil
	m.clearedFields[standardhistory.FieldFamily] = struct{}{}
}

// FamilyCleared returns if the "family" field was cleared in this mutation.
func (m *StandardHistoryMutation) FamilyCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldFamily]
	return ok
}

// ResetFamily resets all changes to the "family" field.
func (m *StandardHistoryMutation) ResetFamily() {
	m.family = nil
	delete(m.clearedFields, standardhistory.FieldFamily)
}

// SetStatus sets the "status" field.
func (m *StandardHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StandardHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *StandardHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[standardhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *StandardHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *StandardHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, standardhistory.FieldStatus)
}

// SetStandardType sets the "standard_type" field.
func (m *StandardHistoryMutation) SetStandardType(s string) {
	m.standard_type = &s
}

// StandardType returns the value of the "standard_type" field in the mutation.
func (m *StandardHistoryMutation) StandardType() (r string, exists bool) {
	v := m.standard_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStandardType returns the old "standard_type" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldStandardType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStandardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStandardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandardType: %w", err)
	}
	return oldValue.StandardType, nil
}

// ClearStandardType clears the value of the "standard_type" field.
func (m *StandardHistoryMutation) ClearStandardType() {
	m.standard_type = nil
	m.clearedFields[standardhistory.FieldStandardType] = struct{}{}
}

// StandardTypeCleared returns if the "standard_type" field was cleared in this mutation.
func (m *StandardHistoryMutation) StandardTypeCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldStandardType]
	return ok
}

// ResetStandardType resets all changes to the "standard_type" field.
func (m *StandardHistoryMutation) ResetStandardType() {
	m.standard_type = nil
	delete(m.clearedFields, standardhistory.FieldStandardType)
}

// SetVersion sets the "version" field.
func (m *StandardHistoryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *StandardHistoryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *StandardHistoryMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[standardhistory.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *StandardHistoryMutation) VersionCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *StandardHistoryMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, standardhistory.FieldVersion)
}

// SetPurposeAndScope sets the "purpose_and_scope" field.
func (m *StandardHistoryMutation) SetPurposeAndScope(s string) {
	m.purpose_and_scope = &s
}

// PurposeAndScope returns the value of the "purpose_and_scope" field in the mutation.
func (m *StandardHistoryMutation) PurposeAndScope() (r string, exists bool) {
	v := m.purpose_and_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldPurposeAndScope returns the old "purpose_and_scope" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldPurposeAndScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurposeAndScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurposeAndScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurposeAndScope: %w", err)
	}
	return oldValue.PurposeAndScope, nil
}

// ClearPurposeAndScope clears the value of the "purpose_and_scope" field.
func (m *StandardHistoryMutation) ClearPurposeAndScope() {
	m.purpose_and_scope = nil
	m.clearedFields[standardhistory.FieldPurposeAndScope] = struct{}{}
}

// PurposeAndScopeCleared returns if the "purpose_and_scope" field was cleared in this mutation.
func (m *StandardHistoryMutation) PurposeAndScopeCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldPurposeAndScope]
	return ok
}

// ResetPurposeAndScope resets all changes to the "purpose_and_scope" field.
func (m *StandardHistoryMutation) ResetPurposeAndScope() {
	m.purpose_and_scope = nil
	delete(m.clearedFields, standardhistory.FieldPurposeAndScope)
}

// SetBackground sets the "background" field.
func (m *StandardHistoryMutation) SetBackground(s string) {
	m.background = &s
}

// Background returns the value of the "background" field in the mutation.
func (m *StandardHistoryMutation) Background() (r string, exists bool) {
	v := m.background
	if v == nil {
		return
	}
	return *v, true
}

// OldBackground returns the old "background" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldBackground(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackground: %w", err)
	}
	return oldValue.Background, nil
}

// ClearBackground clears the value of the "background" field.
func (m *StandardHistoryMutation) ClearBackground() {
	m.background = nil
	m.clearedFields[standardhistory.FieldBackground] = struct{}{}
}

// BackgroundCleared returns if the "background" field was cleared in this mutation.
func (m *StandardHistoryMutation) BackgroundCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldBackground]
	return ok
}

// ResetBackground resets all changes to the "background" field.
func (m *StandardHistoryMutation) ResetBackground() {
	m.background = nil
	delete(m.clearedFields, standardhistory.FieldBackground)
}

// SetSatisfies sets the "satisfies" field.
func (m *StandardHistoryMutation) SetSatisfies(s string) {
	m.satisfies = &s
}

// Satisfies returns the value of the "satisfies" field in the mutation.
func (m *StandardHistoryMutation) Satisfies() (r string, exists bool) {
	v := m.satisfies
	if v == nil {
		return
	}
	return *v, true
}

// OldSatisfies returns the old "satisfies" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldSatisfies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSatisfies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSatisfies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSatisfies: %w", err)
	}
	return oldValue.Satisfies, nil
}

// ClearSatisfies clears the value of the "satisfies" field.
func (m *StandardHistoryMutation) ClearSatisfies() {
	m.satisfies = nil
	m.clearedFields[standardhistory.FieldSatisfies] = struct{}{}
}

// SatisfiesCleared returns if the "satisfies" field was cleared in this mutation.
func (m *StandardHistoryMutation) SatisfiesCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldSatisfies]
	return ok
}

// ResetSatisfies resets all changes to the "satisfies" field.
func (m *StandardHistoryMutation) ResetSatisfies() {
	m.satisfies = nil
	delete(m.clearedFields, standardhistory.FieldSatisfies)
}

// SetDetails sets the "details" field.
func (m *StandardHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *StandardHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the StandardHistory entity.
// If the StandardHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandardHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *StandardHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[standardhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *StandardHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[standardhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *StandardHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, standardhistory.FieldDetails)
}

// Where appends a list predicates to the StandardHistoryMutation builder.
func (m *StandardHistoryMutation) Where(ps ...predicate.StandardHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StandardHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StandardHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StandardHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StandardHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StandardHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StandardHistory).
func (m *StandardHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StandardHistoryMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.history_time != nil {
		fields = append(fields, standardhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, standardhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, standardhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, standardhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, standardhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, standardhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, standardhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, standardhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, standardhistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, standardhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, standardhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, standardhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, standardhistory.FieldDescription)
	}
	if m.family != nil {
		fields = append(fields, standardhistory.FieldFamily)
	}
	if m.status != nil {
		fields = append(fields, standardhistory.FieldStatus)
	}
	if m.standard_type != nil {
		fields = append(fields, standardhistory.FieldStandardType)
	}
	if m.version != nil {
		fields = append(fields, standardhistory.FieldVersion)
	}
	if m.purpose_and_scope != nil {
		fields = append(fields, standardhistory.FieldPurposeAndScope)
	}
	if m.background != nil {
		fields = append(fields, standardhistory.FieldBackground)
	}
	if m.satisfies != nil {
		fields = append(fields, standardhistory.FieldSatisfies)
	}
	if m.details != nil {
		fields = append(fields, standardhistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StandardHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case standardhistory.FieldHistoryTime:
		return m.HistoryTime()
	case standardhistory.FieldRef:
		return m.Ref()
	case standardhistory.FieldOperation:
		return m.Operation()
	case standardhistory.FieldCreatedAt:
		return m.CreatedAt()
	case standardhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case standardhistory.FieldCreatedBy:
		return m.CreatedBy()
	case standardhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case standardhistory.FieldDeletedAt:
		return m.DeletedAt()
	case standardhistory.FieldDeletedBy:
		return m.DeletedBy()
	case standardhistory.FieldMappingID:
		return m.MappingID()
	case standardhistory.FieldTags:
		return m.Tags()
	case standardhistory.FieldName:
		return m.Name()
	case standardhistory.FieldDescription:
		return m.Description()
	case standardhistory.FieldFamily:
		return m.Family()
	case standardhistory.FieldStatus:
		return m.Status()
	case standardhistory.FieldStandardType:
		return m.StandardType()
	case standardhistory.FieldVersion:
		return m.Version()
	case standardhistory.FieldPurposeAndScope:
		return m.PurposeAndScope()
	case standardhistory.FieldBackground:
		return m.Background()
	case standardhistory.FieldSatisfies:
		return m.Satisfies()
	case standardhistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StandardHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case standardhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case standardhistory.FieldRef:
		return m.OldRef(ctx)
	case standardhistory.FieldOperation:
		return m.OldOperation(ctx)
	case standardhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case standardhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case standardhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case standardhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case standardhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case standardhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case standardhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case standardhistory.FieldTags:
		return m.OldTags(ctx)
	case standardhistory.FieldName:
		return m.OldName(ctx)
	case standardhistory.FieldDescription:
		return m.OldDescription(ctx)
	case standardhistory.FieldFamily:
		return m.OldFamily(ctx)
	case standardhistory.FieldStatus:
		return m.OldStatus(ctx)
	case standardhistory.FieldStandardType:
		return m.OldStandardType(ctx)
	case standardhistory.FieldVersion:
		return m.OldVersion(ctx)
	case standardhistory.FieldPurposeAndScope:
		return m.OldPurposeAndScope(ctx)
	case standardhistory.FieldBackground:
		return m.OldBackground(ctx)
	case standardhistory.FieldSatisfies:
		return m.OldSatisfies(ctx)
	case standardhistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown StandardHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case standardhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case standardhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case standardhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case standardhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case standardhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case standardhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case standardhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case standardhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case standardhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case standardhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case standardhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case standardhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case standardhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case standardhistory.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case standardhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case standardhistory.FieldStandardType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandardType(v)
		return nil
	case standardhistory.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case standardhistory.FieldPurposeAndScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurposeAndScope(v)
		return nil
	case standardhistory.FieldBackground:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackground(v)
		return nil
	case standardhistory.FieldSatisfies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSatisfies(v)
		return nil
	case standardhistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown StandardHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StandardHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StandardHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandardHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StandardHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StandardHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(standardhistory.FieldRef) {
		fields = append(fields, standardhistory.FieldRef)
	}
	if m.FieldCleared(standardhistory.FieldCreatedAt) {
		fields = append(fields, standardhistory.FieldCreatedAt)
	}
	if m.FieldCleared(standardhistory.FieldUpdatedAt) {
		fields = append(fields, standardhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(standardhistory.FieldCreatedBy) {
		fields = append(fields, standardhistory.FieldCreatedBy)
	}
	if m.FieldCleared(standardhistory.FieldUpdatedBy) {
		fields = append(fields, standardhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(standardhistory.FieldDeletedAt) {
		fields = append(fields, standardhistory.FieldDeletedAt)
	}
	if m.FieldCleared(standardhistory.FieldDeletedBy) {
		fields = append(fields, standardhistory.FieldDeletedBy)
	}
	if m.FieldCleared(standardhistory.FieldTags) {
		fields = append(fields, standardhistory.FieldTags)
	}
	if m.FieldCleared(standardhistory.FieldDescription) {
		fields = append(fields, standardhistory.FieldDescription)
	}
	if m.FieldCleared(standardhistory.FieldFamily) {
		fields = append(fields, standardhistory.FieldFamily)
	}
	if m.FieldCleared(standardhistory.FieldStatus) {
		fields = append(fields, standardhistory.FieldStatus)
	}
	if m.FieldCleared(standardhistory.FieldStandardType) {
		fields = append(fields, standardhistory.FieldStandardType)
	}
	if m.FieldCleared(standardhistory.FieldVersion) {
		fields = append(fields, standardhistory.FieldVersion)
	}
	if m.FieldCleared(standardhistory.FieldPurposeAndScope) {
		fields = append(fields, standardhistory.FieldPurposeAndScope)
	}
	if m.FieldCleared(standardhistory.FieldBackground) {
		fields = append(fields, standardhistory.FieldBackground)
	}
	if m.FieldCleared(standardhistory.FieldSatisfies) {
		fields = append(fields, standardhistory.FieldSatisfies)
	}
	if m.FieldCleared(standardhistory.FieldDetails) {
		fields = append(fields, standardhistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StandardHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StandardHistoryMutation) ClearField(name string) error {
	switch name {
	case standardhistory.FieldRef:
		m.ClearRef()
		return nil
	case standardhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case standardhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case standardhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case standardhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case standardhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case standardhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case standardhistory.FieldTags:
		m.ClearTags()
		return nil
	case standardhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case standardhistory.FieldFamily:
		m.ClearFamily()
		return nil
	case standardhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case standardhistory.FieldStandardType:
		m.ClearStandardType()
		return nil
	case standardhistory.FieldVersion:
		m.ClearVersion()
		return nil
	case standardhistory.FieldPurposeAndScope:
		m.ClearPurposeAndScope()
		return nil
	case standardhistory.FieldBackground:
		m.ClearBackground()
		return nil
	case standardhistory.FieldSatisfies:
		m.ClearSatisfies()
		return nil
	case standardhistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown StandardHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StandardHistoryMutation) ResetField(name string) error {
	switch name {
	case standardhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case standardhistory.FieldRef:
		m.ResetRef()
		return nil
	case standardhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case standardhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case standardhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case standardhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case standardhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case standardhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case standardhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case standardhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case standardhistory.FieldTags:
		m.ResetTags()
		return nil
	case standardhistory.FieldName:
		m.ResetName()
		return nil
	case standardhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case standardhistory.FieldFamily:
		m.ResetFamily()
		return nil
	case standardhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case standardhistory.FieldStandardType:
		m.ResetStandardType()
		return nil
	case standardhistory.FieldVersion:
		m.ResetVersion()
		return nil
	case standardhistory.FieldPurposeAndScope:
		m.ResetPurposeAndScope()
		return nil
	case standardhistory.FieldBackground:
		m.ResetBackground()
		return nil
	case standardhistory.FieldSatisfies:
		m.ResetSatisfies()
		return nil
	case standardhistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown StandardHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StandardHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StandardHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StandardHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StandardHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StandardHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StandardHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StandardHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StandardHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StandardHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StandardHistory edge %s", name)
}

// SubcontrolMutation represents an operation that mutates the Subcontrol nodes in the graph.
type SubcontrolMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	created_at                       *time.Time
	updated_at                       *time.Time
	created_by                       *string
	updated_by                       *string
	deleted_at                       *time.Time
	deleted_by                       *string
	mapping_id                       *string
	tags                             *[]string
	appendtags                       []string
	name                             *string
	description                      *string
	status                           *string
	subcontrol_type                  *string
	version                          *string
	subcontrol_number                *string
	family                           *string
	class                            *string
	source                           *string
	mapped_frameworks                *string
	implementation_evidence          *string
	implementation_status            *string
	implementation_date              *time.Time
	implementation_verification      *string
	implementation_verification_date *time.Time
	details                          *map[string]interface{}
	clearedFields                    map[string]struct{}
	control                          map[string]struct{}
	removedcontrol                   map[string]struct{}
	clearedcontrol                   bool
	user                             map[string]struct{}
	removeduser                      map[string]struct{}
	cleareduser                      bool
	tasks                            map[string]struct{}
	removedtasks                     map[string]struct{}
	clearedtasks                     bool
	notes                            *string
	clearednotes                     bool
	programs                         map[string]struct{}
	removedprograms                  map[string]struct{}
	clearedprograms                  bool
	done                             bool
	oldValue                         func(context.Context) (*Subcontrol, error)
	predicates                       []predicate.Subcontrol
}

var _ ent.Mutation = (*SubcontrolMutation)(nil)

// subcontrolOption allows management of the mutation configuration using functional options.
type subcontrolOption func(*SubcontrolMutation)

// newSubcontrolMutation creates new mutation for the Subcontrol entity.
func newSubcontrolMutation(c config, op Op, opts ...subcontrolOption) *SubcontrolMutation {
	m := &SubcontrolMutation{
		config:        c,
		op:            op,
		typ:           TypeSubcontrol,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubcontrolID sets the ID field of the mutation.
func withSubcontrolID(id string) subcontrolOption {
	return func(m *SubcontrolMutation) {
		var (
			err   error
			once  sync.Once
			value *Subcontrol
		)
		m.oldValue = func(ctx context.Context) (*Subcontrol, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subcontrol.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubcontrol sets the old Subcontrol of the mutation.
func withSubcontrol(node *Subcontrol) subcontrolOption {
	return func(m *SubcontrolMutation) {
		m.oldValue = func(context.Context) (*Subcontrol, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubcontrolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubcontrolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subcontrol entities.
func (m *SubcontrolMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubcontrolMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubcontrolMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subcontrol.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubcontrolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubcontrolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SubcontrolMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[subcontrol.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SubcontrolMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubcontrolMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, subcontrol.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubcontrolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubcontrolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SubcontrolMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[subcontrol.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SubcontrolMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubcontrolMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, subcontrol.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *SubcontrolMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SubcontrolMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SubcontrolMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[subcontrol.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SubcontrolMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SubcontrolMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, subcontrol.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SubcontrolMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SubcontrolMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SubcontrolMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[subcontrol.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SubcontrolMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SubcontrolMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, subcontrol.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubcontrolMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubcontrolMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubcontrolMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subcontrol.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubcontrolMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubcontrolMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subcontrol.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *SubcontrolMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *SubcontrolMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *SubcontrolMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[subcontrol.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *SubcontrolMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *SubcontrolMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, subcontrol.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *SubcontrolMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *SubcontrolMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *SubcontrolMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *SubcontrolMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *SubcontrolMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *SubcontrolMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *SubcontrolMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *SubcontrolMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[subcontrol.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *SubcontrolMutation) TagsCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *SubcontrolMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, subcontrol.FieldTags)
}

// SetName sets the "name" field.
func (m *SubcontrolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubcontrolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubcontrolMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubcontrolMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubcontrolMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubcontrolMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subcontrol.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubcontrolMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubcontrolMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subcontrol.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *SubcontrolMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SubcontrolMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *SubcontrolMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[subcontrol.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SubcontrolMutation) StatusCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SubcontrolMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, subcontrol.FieldStatus)
}

// SetSubcontrolType sets the "subcontrol_type" field.
func (m *SubcontrolMutation) SetSubcontrolType(s string) {
	m.subcontrol_type = &s
}

// SubcontrolType returns the value of the "subcontrol_type" field in the mutation.
func (m *SubcontrolMutation) SubcontrolType() (r string, exists bool) {
	v := m.subcontrol_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcontrolType returns the old "subcontrol_type" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldSubcontrolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcontrolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcontrolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcontrolType: %w", err)
	}
	return oldValue.SubcontrolType, nil
}

// ClearSubcontrolType clears the value of the "subcontrol_type" field.
func (m *SubcontrolMutation) ClearSubcontrolType() {
	m.subcontrol_type = nil
	m.clearedFields[subcontrol.FieldSubcontrolType] = struct{}{}
}

// SubcontrolTypeCleared returns if the "subcontrol_type" field was cleared in this mutation.
func (m *SubcontrolMutation) SubcontrolTypeCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldSubcontrolType]
	return ok
}

// ResetSubcontrolType resets all changes to the "subcontrol_type" field.
func (m *SubcontrolMutation) ResetSubcontrolType() {
	m.subcontrol_type = nil
	delete(m.clearedFields, subcontrol.FieldSubcontrolType)
}

// SetVersion sets the "version" field.
func (m *SubcontrolMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *SubcontrolMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *SubcontrolMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[subcontrol.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *SubcontrolMutation) VersionCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *SubcontrolMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, subcontrol.FieldVersion)
}

// SetSubcontrolNumber sets the "subcontrol_number" field.
func (m *SubcontrolMutation) SetSubcontrolNumber(s string) {
	m.subcontrol_number = &s
}

// SubcontrolNumber returns the value of the "subcontrol_number" field in the mutation.
func (m *SubcontrolMutation) SubcontrolNumber() (r string, exists bool) {
	v := m.subcontrol_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcontrolNumber returns the old "subcontrol_number" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldSubcontrolNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcontrolNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcontrolNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcontrolNumber: %w", err)
	}
	return oldValue.SubcontrolNumber, nil
}

// ClearSubcontrolNumber clears the value of the "subcontrol_number" field.
func (m *SubcontrolMutation) ClearSubcontrolNumber() {
	m.subcontrol_number = nil
	m.clearedFields[subcontrol.FieldSubcontrolNumber] = struct{}{}
}

// SubcontrolNumberCleared returns if the "subcontrol_number" field was cleared in this mutation.
func (m *SubcontrolMutation) SubcontrolNumberCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldSubcontrolNumber]
	return ok
}

// ResetSubcontrolNumber resets all changes to the "subcontrol_number" field.
func (m *SubcontrolMutation) ResetSubcontrolNumber() {
	m.subcontrol_number = nil
	delete(m.clearedFields, subcontrol.FieldSubcontrolNumber)
}

// SetFamily sets the "family" field.
func (m *SubcontrolMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *SubcontrolMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ClearFamily clears the value of the "family" field.
func (m *SubcontrolMutation) ClearFamily() {
	m.family = nil
	m.clearedFields[subcontrol.FieldFamily] = struct{}{}
}

// FamilyCleared returns if the "family" field was cleared in this mutation.
func (m *SubcontrolMutation) FamilyCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldFamily]
	return ok
}

// ResetFamily resets all changes to the "family" field.
func (m *SubcontrolMutation) ResetFamily() {
	m.family = nil
	delete(m.clearedFields, subcontrol.FieldFamily)
}

// SetClass sets the "class" field.
func (m *SubcontrolMutation) SetClass(s string) {
	m.class = &s
}

// Class returns the value of the "class" field in the mutation.
func (m *SubcontrolMutation) Class() (r string, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ClearClass clears the value of the "class" field.
func (m *SubcontrolMutation) ClearClass() {
	m.class = nil
	m.clearedFields[subcontrol.FieldClass] = struct{}{}
}

// ClassCleared returns if the "class" field was cleared in this mutation.
func (m *SubcontrolMutation) ClassCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldClass]
	return ok
}

// ResetClass resets all changes to the "class" field.
func (m *SubcontrolMutation) ResetClass() {
	m.class = nil
	delete(m.clearedFields, subcontrol.FieldClass)
}

// SetSource sets the "source" field.
func (m *SubcontrolMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *SubcontrolMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *SubcontrolMutation) ClearSource() {
	m.source = nil
	m.clearedFields[subcontrol.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *SubcontrolMutation) SourceCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *SubcontrolMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, subcontrol.FieldSource)
}

// SetMappedFrameworks sets the "mapped_frameworks" field.
func (m *SubcontrolMutation) SetMappedFrameworks(s string) {
	m.mapped_frameworks = &s
}

// MappedFrameworks returns the value of the "mapped_frameworks" field in the mutation.
func (m *SubcontrolMutation) MappedFrameworks() (r string, exists bool) {
	v := m.mapped_frameworks
	if v == nil {
		return
	}
	return *v, true
}

// OldMappedFrameworks returns the old "mapped_frameworks" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldMappedFrameworks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappedFrameworks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappedFrameworks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappedFrameworks: %w", err)
	}
	return oldValue.MappedFrameworks, nil
}

// ClearMappedFrameworks clears the value of the "mapped_frameworks" field.
func (m *SubcontrolMutation) ClearMappedFrameworks() {
	m.mapped_frameworks = nil
	m.clearedFields[subcontrol.FieldMappedFrameworks] = struct{}{}
}

// MappedFrameworksCleared returns if the "mapped_frameworks" field was cleared in this mutation.
func (m *SubcontrolMutation) MappedFrameworksCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldMappedFrameworks]
	return ok
}

// ResetMappedFrameworks resets all changes to the "mapped_frameworks" field.
func (m *SubcontrolMutation) ResetMappedFrameworks() {
	m.mapped_frameworks = nil
	delete(m.clearedFields, subcontrol.FieldMappedFrameworks)
}

// SetImplementationEvidence sets the "implementation_evidence" field.
func (m *SubcontrolMutation) SetImplementationEvidence(s string) {
	m.implementation_evidence = &s
}

// ImplementationEvidence returns the value of the "implementation_evidence" field in the mutation.
func (m *SubcontrolMutation) ImplementationEvidence() (r string, exists bool) {
	v := m.implementation_evidence
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationEvidence returns the old "implementation_evidence" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldImplementationEvidence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationEvidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationEvidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationEvidence: %w", err)
	}
	return oldValue.ImplementationEvidence, nil
}

// ClearImplementationEvidence clears the value of the "implementation_evidence" field.
func (m *SubcontrolMutation) ClearImplementationEvidence() {
	m.implementation_evidence = nil
	m.clearedFields[subcontrol.FieldImplementationEvidence] = struct{}{}
}

// ImplementationEvidenceCleared returns if the "implementation_evidence" field was cleared in this mutation.
func (m *SubcontrolMutation) ImplementationEvidenceCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldImplementationEvidence]
	return ok
}

// ResetImplementationEvidence resets all changes to the "implementation_evidence" field.
func (m *SubcontrolMutation) ResetImplementationEvidence() {
	m.implementation_evidence = nil
	delete(m.clearedFields, subcontrol.FieldImplementationEvidence)
}

// SetImplementationStatus sets the "implementation_status" field.
func (m *SubcontrolMutation) SetImplementationStatus(s string) {
	m.implementation_status = &s
}

// ImplementationStatus returns the value of the "implementation_status" field in the mutation.
func (m *SubcontrolMutation) ImplementationStatus() (r string, exists bool) {
	v := m.implementation_status
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationStatus returns the old "implementation_status" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldImplementationStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationStatus: %w", err)
	}
	return oldValue.ImplementationStatus, nil
}

// ClearImplementationStatus clears the value of the "implementation_status" field.
func (m *SubcontrolMutation) ClearImplementationStatus() {
	m.implementation_status = nil
	m.clearedFields[subcontrol.FieldImplementationStatus] = struct{}{}
}

// ImplementationStatusCleared returns if the "implementation_status" field was cleared in this mutation.
func (m *SubcontrolMutation) ImplementationStatusCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldImplementationStatus]
	return ok
}

// ResetImplementationStatus resets all changes to the "implementation_status" field.
func (m *SubcontrolMutation) ResetImplementationStatus() {
	m.implementation_status = nil
	delete(m.clearedFields, subcontrol.FieldImplementationStatus)
}

// SetImplementationDate sets the "implementation_date" field.
func (m *SubcontrolMutation) SetImplementationDate(t time.Time) {
	m.implementation_date = &t
}

// ImplementationDate returns the value of the "implementation_date" field in the mutation.
func (m *SubcontrolMutation) ImplementationDate() (r time.Time, exists bool) {
	v := m.implementation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationDate returns the old "implementation_date" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldImplementationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationDate: %w", err)
	}
	return oldValue.ImplementationDate, nil
}

// ClearImplementationDate clears the value of the "implementation_date" field.
func (m *SubcontrolMutation) ClearImplementationDate() {
	m.implementation_date = nil
	m.clearedFields[subcontrol.FieldImplementationDate] = struct{}{}
}

// ImplementationDateCleared returns if the "implementation_date" field was cleared in this mutation.
func (m *SubcontrolMutation) ImplementationDateCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldImplementationDate]
	return ok
}

// ResetImplementationDate resets all changes to the "implementation_date" field.
func (m *SubcontrolMutation) ResetImplementationDate() {
	m.implementation_date = nil
	delete(m.clearedFields, subcontrol.FieldImplementationDate)
}

// SetImplementationVerification sets the "implementation_verification" field.
func (m *SubcontrolMutation) SetImplementationVerification(s string) {
	m.implementation_verification = &s
}

// ImplementationVerification returns the value of the "implementation_verification" field in the mutation.
func (m *SubcontrolMutation) ImplementationVerification() (r string, exists bool) {
	v := m.implementation_verification
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationVerification returns the old "implementation_verification" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldImplementationVerification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationVerification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationVerification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationVerification: %w", err)
	}
	return oldValue.ImplementationVerification, nil
}

// ClearImplementationVerification clears the value of the "implementation_verification" field.
func (m *SubcontrolMutation) ClearImplementationVerification() {
	m.implementation_verification = nil
	m.clearedFields[subcontrol.FieldImplementationVerification] = struct{}{}
}

// ImplementationVerificationCleared returns if the "implementation_verification" field was cleared in this mutation.
func (m *SubcontrolMutation) ImplementationVerificationCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldImplementationVerification]
	return ok
}

// ResetImplementationVerification resets all changes to the "implementation_verification" field.
func (m *SubcontrolMutation) ResetImplementationVerification() {
	m.implementation_verification = nil
	delete(m.clearedFields, subcontrol.FieldImplementationVerification)
}

// SetImplementationVerificationDate sets the "implementation_verification_date" field.
func (m *SubcontrolMutation) SetImplementationVerificationDate(t time.Time) {
	m.implementation_verification_date = &t
}

// ImplementationVerificationDate returns the value of the "implementation_verification_date" field in the mutation.
func (m *SubcontrolMutation) ImplementationVerificationDate() (r time.Time, exists bool) {
	v := m.implementation_verification_date
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationVerificationDate returns the old "implementation_verification_date" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldImplementationVerificationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationVerificationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationVerificationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationVerificationDate: %w", err)
	}
	return oldValue.ImplementationVerificationDate, nil
}

// ClearImplementationVerificationDate clears the value of the "implementation_verification_date" field.
func (m *SubcontrolMutation) ClearImplementationVerificationDate() {
	m.implementation_verification_date = nil
	m.clearedFields[subcontrol.FieldImplementationVerificationDate] = struct{}{}
}

// ImplementationVerificationDateCleared returns if the "implementation_verification_date" field was cleared in this mutation.
func (m *SubcontrolMutation) ImplementationVerificationDateCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldImplementationVerificationDate]
	return ok
}

// ResetImplementationVerificationDate resets all changes to the "implementation_verification_date" field.
func (m *SubcontrolMutation) ResetImplementationVerificationDate() {
	m.implementation_verification_date = nil
	delete(m.clearedFields, subcontrol.FieldImplementationVerificationDate)
}

// SetDetails sets the "details" field.
func (m *SubcontrolMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *SubcontrolMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Subcontrol entity.
// If the Subcontrol object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *SubcontrolMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[subcontrol.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *SubcontrolMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[subcontrol.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *SubcontrolMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, subcontrol.FieldDetails)
}

// AddControlIDs adds the "control" edge to the Control entity by ids.
func (m *SubcontrolMutation) AddControlIDs(ids ...string) {
	if m.control == nil {
		m.control = make(map[string]struct{})
	}
	for i := range ids {
		m.control[ids[i]] = struct{}{}
	}
}

// ClearControl clears the "control" edge to the Control entity.
func (m *SubcontrolMutation) ClearControl() {
	m.clearedcontrol = true
}

// ControlCleared reports if the "control" edge to the Control entity was cleared.
func (m *SubcontrolMutation) ControlCleared() bool {
	return m.clearedcontrol
}

// RemoveControlIDs removes the "control" edge to the Control entity by IDs.
func (m *SubcontrolMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrol == nil {
		m.removedcontrol = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.control, ids[i])
		m.removedcontrol[ids[i]] = struct{}{}
	}
}

// RemovedControl returns the removed IDs of the "control" edge to the Control entity.
func (m *SubcontrolMutation) RemovedControlIDs() (ids []string) {
	for id := range m.removedcontrol {
		ids = append(ids, id)
	}
	return
}

// ControlIDs returns the "control" edge IDs in the mutation.
func (m *SubcontrolMutation) ControlIDs() (ids []string) {
	for id := range m.control {
		ids = append(ids, id)
	}
	return
}

// ResetControl resets all changes to the "control" edge.
func (m *SubcontrolMutation) ResetControl() {
	m.control = nil
	m.clearedcontrol = false
	m.removedcontrol = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *SubcontrolMutation) AddUserIDs(ids ...string) {
	if m.user == nil {
		m.user = make(map[string]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *SubcontrolMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SubcontrolMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *SubcontrolMutation) RemoveUserIDs(ids ...string) {
	if m.removeduser == nil {
		m.removeduser = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *SubcontrolMutation) RemovedUserIDs() (ids []string) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *SubcontrolMutation) UserIDs() (ids []string) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SubcontrolMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *SubcontrolMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *SubcontrolMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *SubcontrolMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *SubcontrolMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *SubcontrolMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *SubcontrolMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *SubcontrolMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// SetNotesID sets the "notes" edge to the Note entity by id.
func (m *SubcontrolMutation) SetNotesID(id string) {
	m.notes = &id
}

// ClearNotes clears the "notes" edge to the Note entity.
func (m *SubcontrolMutation) ClearNotes() {
	m.clearednotes = true
}

// NotesCleared reports if the "notes" edge to the Note entity was cleared.
func (m *SubcontrolMutation) NotesCleared() bool {
	return m.clearednotes
}

// NotesID returns the "notes" edge ID in the mutation.
func (m *SubcontrolMutation) NotesID() (id string, exists bool) {
	if m.notes != nil {
		return *m.notes, true
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotesID instead. It exists only for internal usage by the builders.
func (m *SubcontrolMutation) NotesIDs() (ids []string) {
	if id := m.notes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *SubcontrolMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *SubcontrolMutation) AddProgramIDs(ids ...string) {
	if m.programs == nil {
		m.programs = make(map[string]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *SubcontrolMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *SubcontrolMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *SubcontrolMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *SubcontrolMutation) RemovedProgramsIDs() (ids []string) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *SubcontrolMutation) ProgramsIDs() (ids []string) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *SubcontrolMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// Where appends a list predicates to the SubcontrolMutation builder.
func (m *SubcontrolMutation) Where(ps ...predicate.Subcontrol) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubcontrolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubcontrolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subcontrol, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubcontrolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubcontrolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subcontrol).
func (m *SubcontrolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubcontrolMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, subcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subcontrol.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, subcontrol.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, subcontrol.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, subcontrol.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, subcontrol.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, subcontrol.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, subcontrol.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, subcontrol.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subcontrol.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, subcontrol.FieldStatus)
	}
	if m.subcontrol_type != nil {
		fields = append(fields, subcontrol.FieldSubcontrolType)
	}
	if m.version != nil {
		fields = append(fields, subcontrol.FieldVersion)
	}
	if m.subcontrol_number != nil {
		fields = append(fields, subcontrol.FieldSubcontrolNumber)
	}
	if m.family != nil {
		fields = append(fields, subcontrol.FieldFamily)
	}
	if m.class != nil {
		fields = append(fields, subcontrol.FieldClass)
	}
	if m.source != nil {
		fields = append(fields, subcontrol.FieldSource)
	}
	if m.mapped_frameworks != nil {
		fields = append(fields, subcontrol.FieldMappedFrameworks)
	}
	if m.implementation_evidence != nil {
		fields = append(fields, subcontrol.FieldImplementationEvidence)
	}
	if m.implementation_status != nil {
		fields = append(fields, subcontrol.FieldImplementationStatus)
	}
	if m.implementation_date != nil {
		fields = append(fields, subcontrol.FieldImplementationDate)
	}
	if m.implementation_verification != nil {
		fields = append(fields, subcontrol.FieldImplementationVerification)
	}
	if m.implementation_verification_date != nil {
		fields = append(fields, subcontrol.FieldImplementationVerificationDate)
	}
	if m.details != nil {
		fields = append(fields, subcontrol.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubcontrolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case subcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case subcontrol.FieldCreatedBy:
		return m.CreatedBy()
	case subcontrol.FieldUpdatedBy:
		return m.UpdatedBy()
	case subcontrol.FieldDeletedAt:
		return m.DeletedAt()
	case subcontrol.FieldDeletedBy:
		return m.DeletedBy()
	case subcontrol.FieldMappingID:
		return m.MappingID()
	case subcontrol.FieldTags:
		return m.Tags()
	case subcontrol.FieldName:
		return m.Name()
	case subcontrol.FieldDescription:
		return m.Description()
	case subcontrol.FieldStatus:
		return m.Status()
	case subcontrol.FieldSubcontrolType:
		return m.SubcontrolType()
	case subcontrol.FieldVersion:
		return m.Version()
	case subcontrol.FieldSubcontrolNumber:
		return m.SubcontrolNumber()
	case subcontrol.FieldFamily:
		return m.Family()
	case subcontrol.FieldClass:
		return m.Class()
	case subcontrol.FieldSource:
		return m.Source()
	case subcontrol.FieldMappedFrameworks:
		return m.MappedFrameworks()
	case subcontrol.FieldImplementationEvidence:
		return m.ImplementationEvidence()
	case subcontrol.FieldImplementationStatus:
		return m.ImplementationStatus()
	case subcontrol.FieldImplementationDate:
		return m.ImplementationDate()
	case subcontrol.FieldImplementationVerification:
		return m.ImplementationVerification()
	case subcontrol.FieldImplementationVerificationDate:
		return m.ImplementationVerificationDate()
	case subcontrol.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubcontrolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subcontrol.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case subcontrol.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case subcontrol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subcontrol.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case subcontrol.FieldMappingID:
		return m.OldMappingID(ctx)
	case subcontrol.FieldTags:
		return m.OldTags(ctx)
	case subcontrol.FieldName:
		return m.OldName(ctx)
	case subcontrol.FieldDescription:
		return m.OldDescription(ctx)
	case subcontrol.FieldStatus:
		return m.OldStatus(ctx)
	case subcontrol.FieldSubcontrolType:
		return m.OldSubcontrolType(ctx)
	case subcontrol.FieldVersion:
		return m.OldVersion(ctx)
	case subcontrol.FieldSubcontrolNumber:
		return m.OldSubcontrolNumber(ctx)
	case subcontrol.FieldFamily:
		return m.OldFamily(ctx)
	case subcontrol.FieldClass:
		return m.OldClass(ctx)
	case subcontrol.FieldSource:
		return m.OldSource(ctx)
	case subcontrol.FieldMappedFrameworks:
		return m.OldMappedFrameworks(ctx)
	case subcontrol.FieldImplementationEvidence:
		return m.OldImplementationEvidence(ctx)
	case subcontrol.FieldImplementationStatus:
		return m.OldImplementationStatus(ctx)
	case subcontrol.FieldImplementationDate:
		return m.OldImplementationDate(ctx)
	case subcontrol.FieldImplementationVerification:
		return m.OldImplementationVerification(ctx)
	case subcontrol.FieldImplementationVerificationDate:
		return m.OldImplementationVerificationDate(ctx)
	case subcontrol.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Subcontrol field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubcontrolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subcontrol.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case subcontrol.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case subcontrol.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subcontrol.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case subcontrol.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case subcontrol.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case subcontrol.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subcontrol.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subcontrol.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subcontrol.FieldSubcontrolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcontrolType(v)
		return nil
	case subcontrol.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case subcontrol.FieldSubcontrolNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcontrolNumber(v)
		return nil
	case subcontrol.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case subcontrol.FieldClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case subcontrol.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case subcontrol.FieldMappedFrameworks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappedFrameworks(v)
		return nil
	case subcontrol.FieldImplementationEvidence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationEvidence(v)
		return nil
	case subcontrol.FieldImplementationStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationStatus(v)
		return nil
	case subcontrol.FieldImplementationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationDate(v)
		return nil
	case subcontrol.FieldImplementationVerification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationVerification(v)
		return nil
	case subcontrol.FieldImplementationVerificationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationVerificationDate(v)
		return nil
	case subcontrol.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Subcontrol field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubcontrolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubcontrolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubcontrolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subcontrol numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubcontrolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subcontrol.FieldCreatedAt) {
		fields = append(fields, subcontrol.FieldCreatedAt)
	}
	if m.FieldCleared(subcontrol.FieldUpdatedAt) {
		fields = append(fields, subcontrol.FieldUpdatedAt)
	}
	if m.FieldCleared(subcontrol.FieldCreatedBy) {
		fields = append(fields, subcontrol.FieldCreatedBy)
	}
	if m.FieldCleared(subcontrol.FieldUpdatedBy) {
		fields = append(fields, subcontrol.FieldUpdatedBy)
	}
	if m.FieldCleared(subcontrol.FieldDeletedAt) {
		fields = append(fields, subcontrol.FieldDeletedAt)
	}
	if m.FieldCleared(subcontrol.FieldDeletedBy) {
		fields = append(fields, subcontrol.FieldDeletedBy)
	}
	if m.FieldCleared(subcontrol.FieldTags) {
		fields = append(fields, subcontrol.FieldTags)
	}
	if m.FieldCleared(subcontrol.FieldDescription) {
		fields = append(fields, subcontrol.FieldDescription)
	}
	if m.FieldCleared(subcontrol.FieldStatus) {
		fields = append(fields, subcontrol.FieldStatus)
	}
	if m.FieldCleared(subcontrol.FieldSubcontrolType) {
		fields = append(fields, subcontrol.FieldSubcontrolType)
	}
	if m.FieldCleared(subcontrol.FieldVersion) {
		fields = append(fields, subcontrol.FieldVersion)
	}
	if m.FieldCleared(subcontrol.FieldSubcontrolNumber) {
		fields = append(fields, subcontrol.FieldSubcontrolNumber)
	}
	if m.FieldCleared(subcontrol.FieldFamily) {
		fields = append(fields, subcontrol.FieldFamily)
	}
	if m.FieldCleared(subcontrol.FieldClass) {
		fields = append(fields, subcontrol.FieldClass)
	}
	if m.FieldCleared(subcontrol.FieldSource) {
		fields = append(fields, subcontrol.FieldSource)
	}
	if m.FieldCleared(subcontrol.FieldMappedFrameworks) {
		fields = append(fields, subcontrol.FieldMappedFrameworks)
	}
	if m.FieldCleared(subcontrol.FieldImplementationEvidence) {
		fields = append(fields, subcontrol.FieldImplementationEvidence)
	}
	if m.FieldCleared(subcontrol.FieldImplementationStatus) {
		fields = append(fields, subcontrol.FieldImplementationStatus)
	}
	if m.FieldCleared(subcontrol.FieldImplementationDate) {
		fields = append(fields, subcontrol.FieldImplementationDate)
	}
	if m.FieldCleared(subcontrol.FieldImplementationVerification) {
		fields = append(fields, subcontrol.FieldImplementationVerification)
	}
	if m.FieldCleared(subcontrol.FieldImplementationVerificationDate) {
		fields = append(fields, subcontrol.FieldImplementationVerificationDate)
	}
	if m.FieldCleared(subcontrol.FieldDetails) {
		fields = append(fields, subcontrol.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubcontrolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubcontrolMutation) ClearField(name string) error {
	switch name {
	case subcontrol.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case subcontrol.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case subcontrol.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case subcontrol.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case subcontrol.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subcontrol.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case subcontrol.FieldTags:
		m.ClearTags()
		return nil
	case subcontrol.FieldDescription:
		m.ClearDescription()
		return nil
	case subcontrol.FieldStatus:
		m.ClearStatus()
		return nil
	case subcontrol.FieldSubcontrolType:
		m.ClearSubcontrolType()
		return nil
	case subcontrol.FieldVersion:
		m.ClearVersion()
		return nil
	case subcontrol.FieldSubcontrolNumber:
		m.ClearSubcontrolNumber()
		return nil
	case subcontrol.FieldFamily:
		m.ClearFamily()
		return nil
	case subcontrol.FieldClass:
		m.ClearClass()
		return nil
	case subcontrol.FieldSource:
		m.ClearSource()
		return nil
	case subcontrol.FieldMappedFrameworks:
		m.ClearMappedFrameworks()
		return nil
	case subcontrol.FieldImplementationEvidence:
		m.ClearImplementationEvidence()
		return nil
	case subcontrol.FieldImplementationStatus:
		m.ClearImplementationStatus()
		return nil
	case subcontrol.FieldImplementationDate:
		m.ClearImplementationDate()
		return nil
	case subcontrol.FieldImplementationVerification:
		m.ClearImplementationVerification()
		return nil
	case subcontrol.FieldImplementationVerificationDate:
		m.ClearImplementationVerificationDate()
		return nil
	case subcontrol.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Subcontrol nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubcontrolMutation) ResetField(name string) error {
	switch name {
	case subcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subcontrol.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case subcontrol.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case subcontrol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subcontrol.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case subcontrol.FieldMappingID:
		m.ResetMappingID()
		return nil
	case subcontrol.FieldTags:
		m.ResetTags()
		return nil
	case subcontrol.FieldName:
		m.ResetName()
		return nil
	case subcontrol.FieldDescription:
		m.ResetDescription()
		return nil
	case subcontrol.FieldStatus:
		m.ResetStatus()
		return nil
	case subcontrol.FieldSubcontrolType:
		m.ResetSubcontrolType()
		return nil
	case subcontrol.FieldVersion:
		m.ResetVersion()
		return nil
	case subcontrol.FieldSubcontrolNumber:
		m.ResetSubcontrolNumber()
		return nil
	case subcontrol.FieldFamily:
		m.ResetFamily()
		return nil
	case subcontrol.FieldClass:
		m.ResetClass()
		return nil
	case subcontrol.FieldSource:
		m.ResetSource()
		return nil
	case subcontrol.FieldMappedFrameworks:
		m.ResetMappedFrameworks()
		return nil
	case subcontrol.FieldImplementationEvidence:
		m.ResetImplementationEvidence()
		return nil
	case subcontrol.FieldImplementationStatus:
		m.ResetImplementationStatus()
		return nil
	case subcontrol.FieldImplementationDate:
		m.ResetImplementationDate()
		return nil
	case subcontrol.FieldImplementationVerification:
		m.ResetImplementationVerification()
		return nil
	case subcontrol.FieldImplementationVerificationDate:
		m.ResetImplementationVerificationDate()
		return nil
	case subcontrol.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Subcontrol field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubcontrolMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.control != nil {
		edges = append(edges, subcontrol.EdgeControl)
	}
	if m.user != nil {
		edges = append(edges, subcontrol.EdgeUser)
	}
	if m.tasks != nil {
		edges = append(edges, subcontrol.EdgeTasks)
	}
	if m.notes != nil {
		edges = append(edges, subcontrol.EdgeNotes)
	}
	if m.programs != nil {
		edges = append(edges, subcontrol.EdgePrograms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubcontrolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subcontrol.EdgeControl:
		ids := make([]ent.Value, 0, len(m.control))
		for id := range m.control {
			ids = append(ids, id)
		}
		return ids
	case subcontrol.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case subcontrol.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case subcontrol.EdgeNotes:
		if id := m.notes; id != nil {
			return []ent.Value{*id}
		}
	case subcontrol.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubcontrolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcontrol != nil {
		edges = append(edges, subcontrol.EdgeControl)
	}
	if m.removeduser != nil {
		edges = append(edges, subcontrol.EdgeUser)
	}
	if m.removedtasks != nil {
		edges = append(edges, subcontrol.EdgeTasks)
	}
	if m.removedprograms != nil {
		edges = append(edges, subcontrol.EdgePrograms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubcontrolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subcontrol.EdgeControl:
		ids := make([]ent.Value, 0, len(m.removedcontrol))
		for id := range m.removedcontrol {
			ids = append(ids, id)
		}
		return ids
	case subcontrol.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case subcontrol.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case subcontrol.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubcontrolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcontrol {
		edges = append(edges, subcontrol.EdgeControl)
	}
	if m.cleareduser {
		edges = append(edges, subcontrol.EdgeUser)
	}
	if m.clearedtasks {
		edges = append(edges, subcontrol.EdgeTasks)
	}
	if m.clearednotes {
		edges = append(edges, subcontrol.EdgeNotes)
	}
	if m.clearedprograms {
		edges = append(edges, subcontrol.EdgePrograms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubcontrolMutation) EdgeCleared(name string) bool {
	switch name {
	case subcontrol.EdgeControl:
		return m.clearedcontrol
	case subcontrol.EdgeUser:
		return m.cleareduser
	case subcontrol.EdgeTasks:
		return m.clearedtasks
	case subcontrol.EdgeNotes:
		return m.clearednotes
	case subcontrol.EdgePrograms:
		return m.clearedprograms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubcontrolMutation) ClearEdge(name string) error {
	switch name {
	case subcontrol.EdgeNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown Subcontrol unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubcontrolMutation) ResetEdge(name string) error {
	switch name {
	case subcontrol.EdgeControl:
		m.ResetControl()
		return nil
	case subcontrol.EdgeUser:
		m.ResetUser()
		return nil
	case subcontrol.EdgeTasks:
		m.ResetTasks()
		return nil
	case subcontrol.EdgeNotes:
		m.ResetNotes()
		return nil
	case subcontrol.EdgePrograms:
		m.ResetPrograms()
		return nil
	}
	return fmt.Errorf("unknown Subcontrol edge %s", name)
}

// SubcontrolHistoryMutation represents an operation that mutates the SubcontrolHistory nodes in the graph.
type SubcontrolHistoryMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	history_time                     *time.Time
	ref                              *string
	operation                        *history.OpType
	created_at                       *time.Time
	updated_at                       *time.Time
	created_by                       *string
	updated_by                       *string
	deleted_at                       *time.Time
	deleted_by                       *string
	mapping_id                       *string
	tags                             *[]string
	appendtags                       []string
	name                             *string
	description                      *string
	status                           *string
	subcontrol_type                  *string
	version                          *string
	subcontrol_number                *string
	family                           *string
	class                            *string
	source                           *string
	mapped_frameworks                *string
	implementation_evidence          *string
	implementation_status            *string
	implementation_date              *time.Time
	implementation_verification      *string
	implementation_verification_date *time.Time
	details                          *map[string]interface{}
	clearedFields                    map[string]struct{}
	done                             bool
	oldValue                         func(context.Context) (*SubcontrolHistory, error)
	predicates                       []predicate.SubcontrolHistory
}

var _ ent.Mutation = (*SubcontrolHistoryMutation)(nil)

// subcontrolhistoryOption allows management of the mutation configuration using functional options.
type subcontrolhistoryOption func(*SubcontrolHistoryMutation)

// newSubcontrolHistoryMutation creates new mutation for the SubcontrolHistory entity.
func newSubcontrolHistoryMutation(c config, op Op, opts ...subcontrolhistoryOption) *SubcontrolHistoryMutation {
	m := &SubcontrolHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSubcontrolHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubcontrolHistoryID sets the ID field of the mutation.
func withSubcontrolHistoryID(id string) subcontrolhistoryOption {
	return func(m *SubcontrolHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SubcontrolHistory
		)
		m.oldValue = func(ctx context.Context) (*SubcontrolHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubcontrolHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubcontrolHistory sets the old SubcontrolHistory of the mutation.
func withSubcontrolHistory(node *SubcontrolHistory) subcontrolhistoryOption {
	return func(m *SubcontrolHistoryMutation) {
		m.oldValue = func(context.Context) (*SubcontrolHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubcontrolHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubcontrolHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubcontrolHistory entities.
func (m *SubcontrolHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubcontrolHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubcontrolHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubcontrolHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *SubcontrolHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *SubcontrolHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *SubcontrolHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *SubcontrolHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *SubcontrolHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *SubcontrolHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[subcontrolhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *SubcontrolHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, subcontrolhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *SubcontrolHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *SubcontrolHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *SubcontrolHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SubcontrolHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubcontrolHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SubcontrolHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[subcontrolhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubcontrolHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, subcontrolhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubcontrolHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubcontrolHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SubcontrolHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[subcontrolhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubcontrolHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, subcontrolhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *SubcontrolHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SubcontrolHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SubcontrolHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[subcontrolhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SubcontrolHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, subcontrolhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SubcontrolHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SubcontrolHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SubcontrolHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[subcontrolhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SubcontrolHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, subcontrolhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubcontrolHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubcontrolHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubcontrolHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subcontrolhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubcontrolHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subcontrolhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *SubcontrolHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *SubcontrolHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *SubcontrolHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[subcontrolhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *SubcontrolHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, subcontrolhistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *SubcontrolHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *SubcontrolHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *SubcontrolHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *SubcontrolHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *SubcontrolHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *SubcontrolHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *SubcontrolHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *SubcontrolHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[subcontrolhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *SubcontrolHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, subcontrolhistory.FieldTags)
}

// SetName sets the "name" field.
func (m *SubcontrolHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubcontrolHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubcontrolHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SubcontrolHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubcontrolHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubcontrolHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subcontrolhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubcontrolHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subcontrolhistory.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *SubcontrolHistoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SubcontrolHistoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *SubcontrolHistoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[subcontrolhistory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SubcontrolHistoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, subcontrolhistory.FieldStatus)
}

// SetSubcontrolType sets the "subcontrol_type" field.
func (m *SubcontrolHistoryMutation) SetSubcontrolType(s string) {
	m.subcontrol_type = &s
}

// SubcontrolType returns the value of the "subcontrol_type" field in the mutation.
func (m *SubcontrolHistoryMutation) SubcontrolType() (r string, exists bool) {
	v := m.subcontrol_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcontrolType returns the old "subcontrol_type" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSubcontrolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcontrolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcontrolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcontrolType: %w", err)
	}
	return oldValue.SubcontrolType, nil
}

// ClearSubcontrolType clears the value of the "subcontrol_type" field.
func (m *SubcontrolHistoryMutation) ClearSubcontrolType() {
	m.subcontrol_type = nil
	m.clearedFields[subcontrolhistory.FieldSubcontrolType] = struct{}{}
}

// SubcontrolTypeCleared returns if the "subcontrol_type" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SubcontrolTypeCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSubcontrolType]
	return ok
}

// ResetSubcontrolType resets all changes to the "subcontrol_type" field.
func (m *SubcontrolHistoryMutation) ResetSubcontrolType() {
	m.subcontrol_type = nil
	delete(m.clearedFields, subcontrolhistory.FieldSubcontrolType)
}

// SetVersion sets the "version" field.
func (m *SubcontrolHistoryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *SubcontrolHistoryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *SubcontrolHistoryMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[subcontrolhistory.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) VersionCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *SubcontrolHistoryMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, subcontrolhistory.FieldVersion)
}

// SetSubcontrolNumber sets the "subcontrol_number" field.
func (m *SubcontrolHistoryMutation) SetSubcontrolNumber(s string) {
	m.subcontrol_number = &s
}

// SubcontrolNumber returns the value of the "subcontrol_number" field in the mutation.
func (m *SubcontrolHistoryMutation) SubcontrolNumber() (r string, exists bool) {
	v := m.subcontrol_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcontrolNumber returns the old "subcontrol_number" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSubcontrolNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcontrolNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcontrolNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcontrolNumber: %w", err)
	}
	return oldValue.SubcontrolNumber, nil
}

// ClearSubcontrolNumber clears the value of the "subcontrol_number" field.
func (m *SubcontrolHistoryMutation) ClearSubcontrolNumber() {
	m.subcontrol_number = nil
	m.clearedFields[subcontrolhistory.FieldSubcontrolNumber] = struct{}{}
}

// SubcontrolNumberCleared returns if the "subcontrol_number" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SubcontrolNumberCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSubcontrolNumber]
	return ok
}

// ResetSubcontrolNumber resets all changes to the "subcontrol_number" field.
func (m *SubcontrolHistoryMutation) ResetSubcontrolNumber() {
	m.subcontrol_number = nil
	delete(m.clearedFields, subcontrolhistory.FieldSubcontrolNumber)
}

// SetFamily sets the "family" field.
func (m *SubcontrolHistoryMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *SubcontrolHistoryMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ClearFamily clears the value of the "family" field.
func (m *SubcontrolHistoryMutation) ClearFamily() {
	m.family = nil
	m.clearedFields[subcontrolhistory.FieldFamily] = struct{}{}
}

// FamilyCleared returns if the "family" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) FamilyCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldFamily]
	return ok
}

// ResetFamily resets all changes to the "family" field.
func (m *SubcontrolHistoryMutation) ResetFamily() {
	m.family = nil
	delete(m.clearedFields, subcontrolhistory.FieldFamily)
}

// SetClass sets the "class" field.
func (m *SubcontrolHistoryMutation) SetClass(s string) {
	m.class = &s
}

// Class returns the value of the "class" field in the mutation.
func (m *SubcontrolHistoryMutation) Class() (r string, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ClearClass clears the value of the "class" field.
func (m *SubcontrolHistoryMutation) ClearClass() {
	m.class = nil
	m.clearedFields[subcontrolhistory.FieldClass] = struct{}{}
}

// ClassCleared returns if the "class" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ClassCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldClass]
	return ok
}

// ResetClass resets all changes to the "class" field.
func (m *SubcontrolHistoryMutation) ResetClass() {
	m.class = nil
	delete(m.clearedFields, subcontrolhistory.FieldClass)
}

// SetSource sets the "source" field.
func (m *SubcontrolHistoryMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *SubcontrolHistoryMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *SubcontrolHistoryMutation) ClearSource() {
	m.source = nil
	m.clearedFields[subcontrolhistory.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) SourceCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *SubcontrolHistoryMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, subcontrolhistory.FieldSource)
}

// SetMappedFrameworks sets the "mapped_frameworks" field.
func (m *SubcontrolHistoryMutation) SetMappedFrameworks(s string) {
	m.mapped_frameworks = &s
}

// MappedFrameworks returns the value of the "mapped_frameworks" field in the mutation.
func (m *SubcontrolHistoryMutation) MappedFrameworks() (r string, exists bool) {
	v := m.mapped_frameworks
	if v == nil {
		return
	}
	return *v, true
}

// OldMappedFrameworks returns the old "mapped_frameworks" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldMappedFrameworks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappedFrameworks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappedFrameworks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappedFrameworks: %w", err)
	}
	return oldValue.MappedFrameworks, nil
}

// ClearMappedFrameworks clears the value of the "mapped_frameworks" field.
func (m *SubcontrolHistoryMutation) ClearMappedFrameworks() {
	m.mapped_frameworks = nil
	m.clearedFields[subcontrolhistory.FieldMappedFrameworks] = struct{}{}
}

// MappedFrameworksCleared returns if the "mapped_frameworks" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) MappedFrameworksCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldMappedFrameworks]
	return ok
}

// ResetMappedFrameworks resets all changes to the "mapped_frameworks" field.
func (m *SubcontrolHistoryMutation) ResetMappedFrameworks() {
	m.mapped_frameworks = nil
	delete(m.clearedFields, subcontrolhistory.FieldMappedFrameworks)
}

// SetImplementationEvidence sets the "implementation_evidence" field.
func (m *SubcontrolHistoryMutation) SetImplementationEvidence(s string) {
	m.implementation_evidence = &s
}

// ImplementationEvidence returns the value of the "implementation_evidence" field in the mutation.
func (m *SubcontrolHistoryMutation) ImplementationEvidence() (r string, exists bool) {
	v := m.implementation_evidence
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationEvidence returns the old "implementation_evidence" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldImplementationEvidence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationEvidence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationEvidence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationEvidence: %w", err)
	}
	return oldValue.ImplementationEvidence, nil
}

// ClearImplementationEvidence clears the value of the "implementation_evidence" field.
func (m *SubcontrolHistoryMutation) ClearImplementationEvidence() {
	m.implementation_evidence = nil
	m.clearedFields[subcontrolhistory.FieldImplementationEvidence] = struct{}{}
}

// ImplementationEvidenceCleared returns if the "implementation_evidence" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ImplementationEvidenceCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldImplementationEvidence]
	return ok
}

// ResetImplementationEvidence resets all changes to the "implementation_evidence" field.
func (m *SubcontrolHistoryMutation) ResetImplementationEvidence() {
	m.implementation_evidence = nil
	delete(m.clearedFields, subcontrolhistory.FieldImplementationEvidence)
}

// SetImplementationStatus sets the "implementation_status" field.
func (m *SubcontrolHistoryMutation) SetImplementationStatus(s string) {
	m.implementation_status = &s
}

// ImplementationStatus returns the value of the "implementation_status" field in the mutation.
func (m *SubcontrolHistoryMutation) ImplementationStatus() (r string, exists bool) {
	v := m.implementation_status
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationStatus returns the old "implementation_status" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldImplementationStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationStatus: %w", err)
	}
	return oldValue.ImplementationStatus, nil
}

// ClearImplementationStatus clears the value of the "implementation_status" field.
func (m *SubcontrolHistoryMutation) ClearImplementationStatus() {
	m.implementation_status = nil
	m.clearedFields[subcontrolhistory.FieldImplementationStatus] = struct{}{}
}

// ImplementationStatusCleared returns if the "implementation_status" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ImplementationStatusCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldImplementationStatus]
	return ok
}

// ResetImplementationStatus resets all changes to the "implementation_status" field.
func (m *SubcontrolHistoryMutation) ResetImplementationStatus() {
	m.implementation_status = nil
	delete(m.clearedFields, subcontrolhistory.FieldImplementationStatus)
}

// SetImplementationDate sets the "implementation_date" field.
func (m *SubcontrolHistoryMutation) SetImplementationDate(t time.Time) {
	m.implementation_date = &t
}

// ImplementationDate returns the value of the "implementation_date" field in the mutation.
func (m *SubcontrolHistoryMutation) ImplementationDate() (r time.Time, exists bool) {
	v := m.implementation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationDate returns the old "implementation_date" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldImplementationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationDate: %w", err)
	}
	return oldValue.ImplementationDate, nil
}

// ClearImplementationDate clears the value of the "implementation_date" field.
func (m *SubcontrolHistoryMutation) ClearImplementationDate() {
	m.implementation_date = nil
	m.clearedFields[subcontrolhistory.FieldImplementationDate] = struct{}{}
}

// ImplementationDateCleared returns if the "implementation_date" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ImplementationDateCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldImplementationDate]
	return ok
}

// ResetImplementationDate resets all changes to the "implementation_date" field.
func (m *SubcontrolHistoryMutation) ResetImplementationDate() {
	m.implementation_date = nil
	delete(m.clearedFields, subcontrolhistory.FieldImplementationDate)
}

// SetImplementationVerification sets the "implementation_verification" field.
func (m *SubcontrolHistoryMutation) SetImplementationVerification(s string) {
	m.implementation_verification = &s
}

// ImplementationVerification returns the value of the "implementation_verification" field in the mutation.
func (m *SubcontrolHistoryMutation) ImplementationVerification() (r string, exists bool) {
	v := m.implementation_verification
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationVerification returns the old "implementation_verification" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldImplementationVerification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationVerification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationVerification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationVerification: %w", err)
	}
	return oldValue.ImplementationVerification, nil
}

// ClearImplementationVerification clears the value of the "implementation_verification" field.
func (m *SubcontrolHistoryMutation) ClearImplementationVerification() {
	m.implementation_verification = nil
	m.clearedFields[subcontrolhistory.FieldImplementationVerification] = struct{}{}
}

// ImplementationVerificationCleared returns if the "implementation_verification" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ImplementationVerificationCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldImplementationVerification]
	return ok
}

// ResetImplementationVerification resets all changes to the "implementation_verification" field.
func (m *SubcontrolHistoryMutation) ResetImplementationVerification() {
	m.implementation_verification = nil
	delete(m.clearedFields, subcontrolhistory.FieldImplementationVerification)
}

// SetImplementationVerificationDate sets the "implementation_verification_date" field.
func (m *SubcontrolHistoryMutation) SetImplementationVerificationDate(t time.Time) {
	m.implementation_verification_date = &t
}

// ImplementationVerificationDate returns the value of the "implementation_verification_date" field in the mutation.
func (m *SubcontrolHistoryMutation) ImplementationVerificationDate() (r time.Time, exists bool) {
	v := m.implementation_verification_date
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementationVerificationDate returns the old "implementation_verification_date" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldImplementationVerificationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementationVerificationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementationVerificationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementationVerificationDate: %w", err)
	}
	return oldValue.ImplementationVerificationDate, nil
}

// ClearImplementationVerificationDate clears the value of the "implementation_verification_date" field.
func (m *SubcontrolHistoryMutation) ClearImplementationVerificationDate() {
	m.implementation_verification_date = nil
	m.clearedFields[subcontrolhistory.FieldImplementationVerificationDate] = struct{}{}
}

// ImplementationVerificationDateCleared returns if the "implementation_verification_date" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) ImplementationVerificationDateCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldImplementationVerificationDate]
	return ok
}

// ResetImplementationVerificationDate resets all changes to the "implementation_verification_date" field.
func (m *SubcontrolHistoryMutation) ResetImplementationVerificationDate() {
	m.implementation_verification_date = nil
	delete(m.clearedFields, subcontrolhistory.FieldImplementationVerificationDate)
}

// SetDetails sets the "details" field.
func (m *SubcontrolHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *SubcontrolHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the SubcontrolHistory entity.
// If the SubcontrolHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubcontrolHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *SubcontrolHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[subcontrolhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *SubcontrolHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[subcontrolhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *SubcontrolHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, subcontrolhistory.FieldDetails)
}

// Where appends a list predicates to the SubcontrolHistoryMutation builder.
func (m *SubcontrolHistoryMutation) Where(ps ...predicate.SubcontrolHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubcontrolHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubcontrolHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubcontrolHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubcontrolHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubcontrolHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubcontrolHistory).
func (m *SubcontrolHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubcontrolHistoryMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.history_time != nil {
		fields = append(fields, subcontrolhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, subcontrolhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, subcontrolhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, subcontrolhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subcontrolhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, subcontrolhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, subcontrolhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, subcontrolhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, subcontrolhistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, subcontrolhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, subcontrolhistory.FieldTags)
	}
	if m.name != nil {
		fields = append(fields, subcontrolhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, subcontrolhistory.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, subcontrolhistory.FieldStatus)
	}
	if m.subcontrol_type != nil {
		fields = append(fields, subcontrolhistory.FieldSubcontrolType)
	}
	if m.version != nil {
		fields = append(fields, subcontrolhistory.FieldVersion)
	}
	if m.subcontrol_number != nil {
		fields = append(fields, subcontrolhistory.FieldSubcontrolNumber)
	}
	if m.family != nil {
		fields = append(fields, subcontrolhistory.FieldFamily)
	}
	if m.class != nil {
		fields = append(fields, subcontrolhistory.FieldClass)
	}
	if m.source != nil {
		fields = append(fields, subcontrolhistory.FieldSource)
	}
	if m.mapped_frameworks != nil {
		fields = append(fields, subcontrolhistory.FieldMappedFrameworks)
	}
	if m.implementation_evidence != nil {
		fields = append(fields, subcontrolhistory.FieldImplementationEvidence)
	}
	if m.implementation_status != nil {
		fields = append(fields, subcontrolhistory.FieldImplementationStatus)
	}
	if m.implementation_date != nil {
		fields = append(fields, subcontrolhistory.FieldImplementationDate)
	}
	if m.implementation_verification != nil {
		fields = append(fields, subcontrolhistory.FieldImplementationVerification)
	}
	if m.implementation_verification_date != nil {
		fields = append(fields, subcontrolhistory.FieldImplementationVerificationDate)
	}
	if m.details != nil {
		fields = append(fields, subcontrolhistory.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubcontrolHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subcontrolhistory.FieldHistoryTime:
		return m.HistoryTime()
	case subcontrolhistory.FieldRef:
		return m.Ref()
	case subcontrolhistory.FieldOperation:
		return m.Operation()
	case subcontrolhistory.FieldCreatedAt:
		return m.CreatedAt()
	case subcontrolhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case subcontrolhistory.FieldCreatedBy:
		return m.CreatedBy()
	case subcontrolhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case subcontrolhistory.FieldDeletedAt:
		return m.DeletedAt()
	case subcontrolhistory.FieldDeletedBy:
		return m.DeletedBy()
	case subcontrolhistory.FieldMappingID:
		return m.MappingID()
	case subcontrolhistory.FieldTags:
		return m.Tags()
	case subcontrolhistory.FieldName:
		return m.Name()
	case subcontrolhistory.FieldDescription:
		return m.Description()
	case subcontrolhistory.FieldStatus:
		return m.Status()
	case subcontrolhistory.FieldSubcontrolType:
		return m.SubcontrolType()
	case subcontrolhistory.FieldVersion:
		return m.Version()
	case subcontrolhistory.FieldSubcontrolNumber:
		return m.SubcontrolNumber()
	case subcontrolhistory.FieldFamily:
		return m.Family()
	case subcontrolhistory.FieldClass:
		return m.Class()
	case subcontrolhistory.FieldSource:
		return m.Source()
	case subcontrolhistory.FieldMappedFrameworks:
		return m.MappedFrameworks()
	case subcontrolhistory.FieldImplementationEvidence:
		return m.ImplementationEvidence()
	case subcontrolhistory.FieldImplementationStatus:
		return m.ImplementationStatus()
	case subcontrolhistory.FieldImplementationDate:
		return m.ImplementationDate()
	case subcontrolhistory.FieldImplementationVerification:
		return m.ImplementationVerification()
	case subcontrolhistory.FieldImplementationVerificationDate:
		return m.ImplementationVerificationDate()
	case subcontrolhistory.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubcontrolHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subcontrolhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case subcontrolhistory.FieldRef:
		return m.OldRef(ctx)
	case subcontrolhistory.FieldOperation:
		return m.OldOperation(ctx)
	case subcontrolhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subcontrolhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subcontrolhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case subcontrolhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case subcontrolhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subcontrolhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case subcontrolhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case subcontrolhistory.FieldTags:
		return m.OldTags(ctx)
	case subcontrolhistory.FieldName:
		return m.OldName(ctx)
	case subcontrolhistory.FieldDescription:
		return m.OldDescription(ctx)
	case subcontrolhistory.FieldStatus:
		return m.OldStatus(ctx)
	case subcontrolhistory.FieldSubcontrolType:
		return m.OldSubcontrolType(ctx)
	case subcontrolhistory.FieldVersion:
		return m.OldVersion(ctx)
	case subcontrolhistory.FieldSubcontrolNumber:
		return m.OldSubcontrolNumber(ctx)
	case subcontrolhistory.FieldFamily:
		return m.OldFamily(ctx)
	case subcontrolhistory.FieldClass:
		return m.OldClass(ctx)
	case subcontrolhistory.FieldSource:
		return m.OldSource(ctx)
	case subcontrolhistory.FieldMappedFrameworks:
		return m.OldMappedFrameworks(ctx)
	case subcontrolhistory.FieldImplementationEvidence:
		return m.OldImplementationEvidence(ctx)
	case subcontrolhistory.FieldImplementationStatus:
		return m.OldImplementationStatus(ctx)
	case subcontrolhistory.FieldImplementationDate:
		return m.OldImplementationDate(ctx)
	case subcontrolhistory.FieldImplementationVerification:
		return m.OldImplementationVerification(ctx)
	case subcontrolhistory.FieldImplementationVerificationDate:
		return m.OldImplementationVerificationDate(ctx)
	case subcontrolhistory.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown SubcontrolHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubcontrolHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subcontrolhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case subcontrolhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case subcontrolhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case subcontrolhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subcontrolhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subcontrolhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case subcontrolhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case subcontrolhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subcontrolhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case subcontrolhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case subcontrolhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case subcontrolhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subcontrolhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case subcontrolhistory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subcontrolhistory.FieldSubcontrolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcontrolType(v)
		return nil
	case subcontrolhistory.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case subcontrolhistory.FieldSubcontrolNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcontrolNumber(v)
		return nil
	case subcontrolhistory.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case subcontrolhistory.FieldClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case subcontrolhistory.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case subcontrolhistory.FieldMappedFrameworks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappedFrameworks(v)
		return nil
	case subcontrolhistory.FieldImplementationEvidence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationEvidence(v)
		return nil
	case subcontrolhistory.FieldImplementationStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationStatus(v)
		return nil
	case subcontrolhistory.FieldImplementationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationDate(v)
		return nil
	case subcontrolhistory.FieldImplementationVerification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationVerification(v)
		return nil
	case subcontrolhistory.FieldImplementationVerificationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementationVerificationDate(v)
		return nil
	case subcontrolhistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown SubcontrolHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubcontrolHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubcontrolHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubcontrolHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubcontrolHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubcontrolHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subcontrolhistory.FieldRef) {
		fields = append(fields, subcontrolhistory.FieldRef)
	}
	if m.FieldCleared(subcontrolhistory.FieldCreatedAt) {
		fields = append(fields, subcontrolhistory.FieldCreatedAt)
	}
	if m.FieldCleared(subcontrolhistory.FieldUpdatedAt) {
		fields = append(fields, subcontrolhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(subcontrolhistory.FieldCreatedBy) {
		fields = append(fields, subcontrolhistory.FieldCreatedBy)
	}
	if m.FieldCleared(subcontrolhistory.FieldUpdatedBy) {
		fields = append(fields, subcontrolhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(subcontrolhistory.FieldDeletedAt) {
		fields = append(fields, subcontrolhistory.FieldDeletedAt)
	}
	if m.FieldCleared(subcontrolhistory.FieldDeletedBy) {
		fields = append(fields, subcontrolhistory.FieldDeletedBy)
	}
	if m.FieldCleared(subcontrolhistory.FieldTags) {
		fields = append(fields, subcontrolhistory.FieldTags)
	}
	if m.FieldCleared(subcontrolhistory.FieldDescription) {
		fields = append(fields, subcontrolhistory.FieldDescription)
	}
	if m.FieldCleared(subcontrolhistory.FieldStatus) {
		fields = append(fields, subcontrolhistory.FieldStatus)
	}
	if m.FieldCleared(subcontrolhistory.FieldSubcontrolType) {
		fields = append(fields, subcontrolhistory.FieldSubcontrolType)
	}
	if m.FieldCleared(subcontrolhistory.FieldVersion) {
		fields = append(fields, subcontrolhistory.FieldVersion)
	}
	if m.FieldCleared(subcontrolhistory.FieldSubcontrolNumber) {
		fields = append(fields, subcontrolhistory.FieldSubcontrolNumber)
	}
	if m.FieldCleared(subcontrolhistory.FieldFamily) {
		fields = append(fields, subcontrolhistory.FieldFamily)
	}
	if m.FieldCleared(subcontrolhistory.FieldClass) {
		fields = append(fields, subcontrolhistory.FieldClass)
	}
	if m.FieldCleared(subcontrolhistory.FieldSource) {
		fields = append(fields, subcontrolhistory.FieldSource)
	}
	if m.FieldCleared(subcontrolhistory.FieldMappedFrameworks) {
		fields = append(fields, subcontrolhistory.FieldMappedFrameworks)
	}
	if m.FieldCleared(subcontrolhistory.FieldImplementationEvidence) {
		fields = append(fields, subcontrolhistory.FieldImplementationEvidence)
	}
	if m.FieldCleared(subcontrolhistory.FieldImplementationStatus) {
		fields = append(fields, subcontrolhistory.FieldImplementationStatus)
	}
	if m.FieldCleared(subcontrolhistory.FieldImplementationDate) {
		fields = append(fields, subcontrolhistory.FieldImplementationDate)
	}
	if m.FieldCleared(subcontrolhistory.FieldImplementationVerification) {
		fields = append(fields, subcontrolhistory.FieldImplementationVerification)
	}
	if m.FieldCleared(subcontrolhistory.FieldImplementationVerificationDate) {
		fields = append(fields, subcontrolhistory.FieldImplementationVerificationDate)
	}
	if m.FieldCleared(subcontrolhistory.FieldDetails) {
		fields = append(fields, subcontrolhistory.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubcontrolHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubcontrolHistoryMutation) ClearField(name string) error {
	switch name {
	case subcontrolhistory.FieldRef:
		m.ClearRef()
		return nil
	case subcontrolhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case subcontrolhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case subcontrolhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case subcontrolhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case subcontrolhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subcontrolhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case subcontrolhistory.FieldTags:
		m.ClearTags()
		return nil
	case subcontrolhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case subcontrolhistory.FieldStatus:
		m.ClearStatus()
		return nil
	case subcontrolhistory.FieldSubcontrolType:
		m.ClearSubcontrolType()
		return nil
	case subcontrolhistory.FieldVersion:
		m.ClearVersion()
		return nil
	case subcontrolhistory.FieldSubcontrolNumber:
		m.ClearSubcontrolNumber()
		return nil
	case subcontrolhistory.FieldFamily:
		m.ClearFamily()
		return nil
	case subcontrolhistory.FieldClass:
		m.ClearClass()
		return nil
	case subcontrolhistory.FieldSource:
		m.ClearSource()
		return nil
	case subcontrolhistory.FieldMappedFrameworks:
		m.ClearMappedFrameworks()
		return nil
	case subcontrolhistory.FieldImplementationEvidence:
		m.ClearImplementationEvidence()
		return nil
	case subcontrolhistory.FieldImplementationStatus:
		m.ClearImplementationStatus()
		return nil
	case subcontrolhistory.FieldImplementationDate:
		m.ClearImplementationDate()
		return nil
	case subcontrolhistory.FieldImplementationVerification:
		m.ClearImplementationVerification()
		return nil
	case subcontrolhistory.FieldImplementationVerificationDate:
		m.ClearImplementationVerificationDate()
		return nil
	case subcontrolhistory.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown SubcontrolHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubcontrolHistoryMutation) ResetField(name string) error {
	switch name {
	case subcontrolhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case subcontrolhistory.FieldRef:
		m.ResetRef()
		return nil
	case subcontrolhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case subcontrolhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subcontrolhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subcontrolhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case subcontrolhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case subcontrolhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subcontrolhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case subcontrolhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case subcontrolhistory.FieldTags:
		m.ResetTags()
		return nil
	case subcontrolhistory.FieldName:
		m.ResetName()
		return nil
	case subcontrolhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case subcontrolhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case subcontrolhistory.FieldSubcontrolType:
		m.ResetSubcontrolType()
		return nil
	case subcontrolhistory.FieldVersion:
		m.ResetVersion()
		return nil
	case subcontrolhistory.FieldSubcontrolNumber:
		m.ResetSubcontrolNumber()
		return nil
	case subcontrolhistory.FieldFamily:
		m.ResetFamily()
		return nil
	case subcontrolhistory.FieldClass:
		m.ResetClass()
		return nil
	case subcontrolhistory.FieldSource:
		m.ResetSource()
		return nil
	case subcontrolhistory.FieldMappedFrameworks:
		m.ResetMappedFrameworks()
		return nil
	case subcontrolhistory.FieldImplementationEvidence:
		m.ResetImplementationEvidence()
		return nil
	case subcontrolhistory.FieldImplementationStatus:
		m.ResetImplementationStatus()
		return nil
	case subcontrolhistory.FieldImplementationDate:
		m.ResetImplementationDate()
		return nil
	case subcontrolhistory.FieldImplementationVerification:
		m.ResetImplementationVerification()
		return nil
	case subcontrolhistory.FieldImplementationVerificationDate:
		m.ResetImplementationVerificationDate()
		return nil
	case subcontrolhistory.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown SubcontrolHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubcontrolHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubcontrolHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubcontrolHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubcontrolHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubcontrolHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubcontrolHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubcontrolHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SubcontrolHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubcontrolHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SubcontrolHistory edge %s", name)
}

// SubscriberMutation represents an operation that mutates the Subscriber nodes in the graph.
type SubscriberMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	created_by     *string
	updated_by     *string
	mapping_id     *string
	tags           *[]string
	appendtags     []string
	deleted_at     *time.Time
	deleted_by     *string
	email          *string
	phone_number   *string
	verified_email *bool
	verified_phone *bool
	active         *bool
	token          *string
	ttl            *time.Time
	secret         *[]byte
	clearedFields  map[string]struct{}
	owner          *string
	clearedowner   bool
	events         map[string]struct{}
	removedevents  map[string]struct{}
	clearedevents  bool
	done           bool
	oldValue       func(context.Context) (*Subscriber, error)
	predicates     []predicate.Subscriber
}

var _ ent.Mutation = (*SubscriberMutation)(nil)

// subscriberOption allows management of the mutation configuration using functional options.
type subscriberOption func(*SubscriberMutation)

// newSubscriberMutation creates new mutation for the Subscriber entity.
func newSubscriberMutation(c config, op Op, opts ...subscriberOption) *SubscriberMutation {
	m := &SubscriberMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriber,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriberID sets the ID field of the mutation.
func withSubscriberID(id string) subscriberOption {
	return func(m *SubscriberMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscriber
		)
		m.oldValue = func(ctx context.Context) (*Subscriber, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscriber.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriber sets the old Subscriber of the mutation.
func withSubscriber(node *Subscriber) subscriberOption {
	return func(m *SubscriberMutation) {
		m.oldValue = func(context.Context) (*Subscriber, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscriber entities.
func (m *SubscriberMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriberMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriberMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscriber.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SubscriberMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[subscriber.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SubscriberMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriberMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, subscriber.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SubscriberMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[subscriber.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SubscriberMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriberMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, subscriber.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *SubscriberMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SubscriberMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SubscriberMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[subscriber.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SubscriberMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SubscriberMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, subscriber.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SubscriberMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SubscriberMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SubscriberMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[subscriber.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SubscriberMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SubscriberMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, subscriber.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *SubscriberMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *SubscriberMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *SubscriberMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *SubscriberMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *SubscriberMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *SubscriberMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *SubscriberMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *SubscriberMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[subscriber.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *SubscriberMutation) TagsCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *SubscriberMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, subscriber.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscriberMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscriberMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscriberMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscriber.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscriberMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscriberMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscriber.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *SubscriberMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *SubscriberMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *SubscriberMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[subscriber.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *SubscriberMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *SubscriberMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, subscriber.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *SubscriberMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *SubscriberMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *SubscriberMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[subscriber.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *SubscriberMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *SubscriberMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, subscriber.FieldOwnerID)
}

// SetEmail sets the "email" field.
func (m *SubscriberMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SubscriberMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *SubscriberMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *SubscriberMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *SubscriberMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *SubscriberMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[subscriber.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *SubscriberMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[subscriber.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *SubscriberMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, subscriber.FieldPhoneNumber)
}

// SetVerifiedEmail sets the "verified_email" field.
func (m *SubscriberMutation) SetVerifiedEmail(b bool) {
	m.verified_email = &b
}

// VerifiedEmail returns the value of the "verified_email" field in the mutation.
func (m *SubscriberMutation) VerifiedEmail() (r bool, exists bool) {
	v := m.verified_email
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedEmail returns the old "verified_email" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldVerifiedEmail(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedEmail: %w", err)
	}
	return oldValue.VerifiedEmail, nil
}

// ResetVerifiedEmail resets all changes to the "verified_email" field.
func (m *SubscriberMutation) ResetVerifiedEmail() {
	m.verified_email = nil
}

// SetVerifiedPhone sets the "verified_phone" field.
func (m *SubscriberMutation) SetVerifiedPhone(b bool) {
	m.verified_phone = &b
}

// VerifiedPhone returns the value of the "verified_phone" field in the mutation.
func (m *SubscriberMutation) VerifiedPhone() (r bool, exists bool) {
	v := m.verified_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedPhone returns the old "verified_phone" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldVerifiedPhone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedPhone: %w", err)
	}
	return oldValue.VerifiedPhone, nil
}

// ResetVerifiedPhone resets all changes to the "verified_phone" field.
func (m *SubscriberMutation) ResetVerifiedPhone() {
	m.verified_phone = nil
}

// SetActive sets the "active" field.
func (m *SubscriberMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *SubscriberMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *SubscriberMutation) ResetActive() {
	m.active = nil
}

// SetToken sets the "token" field.
func (m *SubscriberMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SubscriberMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SubscriberMutation) ResetToken() {
	m.token = nil
}

// SetTTL sets the "ttl" field.
func (m *SubscriberMutation) SetTTL(t time.Time) {
	m.ttl = &t
}

// TTL returns the value of the "ttl" field in the mutation.
func (m *SubscriberMutation) TTL() (r time.Time, exists bool) {
	v := m.ttl
	if v == nil {
		return
	}
	return *v, true
}

// OldTTL returns the old "ttl" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldTTL(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTTL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTTL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTTL: %w", err)
	}
	return oldValue.TTL, nil
}

// ResetTTL resets all changes to the "ttl" field.
func (m *SubscriberMutation) ResetTTL() {
	m.ttl = nil
}

// SetSecret sets the "secret" field.
func (m *SubscriberMutation) SetSecret(b []byte) {
	m.secret = &b
}

// Secret returns the value of the "secret" field in the mutation.
func (m *SubscriberMutation) Secret() (r []byte, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Subscriber entity.
// If the Subscriber object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriberMutation) OldSecret(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *SubscriberMutation) ResetSecret() {
	m.secret = nil
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *SubscriberMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[subscriber.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *SubscriberMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SubscriberMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SubscriberMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *SubscriberMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *SubscriberMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *SubscriberMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *SubscriberMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *SubscriberMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *SubscriberMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *SubscriberMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the SubscriberMutation builder.
func (m *SubscriberMutation) Where(ps ...predicate.Subscriber) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscriber, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscriber).
func (m *SubscriberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriberMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, subscriber.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscriber.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, subscriber.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, subscriber.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, subscriber.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, subscriber.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscriber.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, subscriber.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, subscriber.FieldOwnerID)
	}
	if m.email != nil {
		fields = append(fields, subscriber.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, subscriber.FieldPhoneNumber)
	}
	if m.verified_email != nil {
		fields = append(fields, subscriber.FieldVerifiedEmail)
	}
	if m.verified_phone != nil {
		fields = append(fields, subscriber.FieldVerifiedPhone)
	}
	if m.active != nil {
		fields = append(fields, subscriber.FieldActive)
	}
	if m.token != nil {
		fields = append(fields, subscriber.FieldToken)
	}
	if m.ttl != nil {
		fields = append(fields, subscriber.FieldTTL)
	}
	if m.secret != nil {
		fields = append(fields, subscriber.FieldSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriber.FieldCreatedAt:
		return m.CreatedAt()
	case subscriber.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscriber.FieldCreatedBy:
		return m.CreatedBy()
	case subscriber.FieldUpdatedBy:
		return m.UpdatedBy()
	case subscriber.FieldMappingID:
		return m.MappingID()
	case subscriber.FieldTags:
		return m.Tags()
	case subscriber.FieldDeletedAt:
		return m.DeletedAt()
	case subscriber.FieldDeletedBy:
		return m.DeletedBy()
	case subscriber.FieldOwnerID:
		return m.OwnerID()
	case subscriber.FieldEmail:
		return m.Email()
	case subscriber.FieldPhoneNumber:
		return m.PhoneNumber()
	case subscriber.FieldVerifiedEmail:
		return m.VerifiedEmail()
	case subscriber.FieldVerifiedPhone:
		return m.VerifiedPhone()
	case subscriber.FieldActive:
		return m.Active()
	case subscriber.FieldToken:
		return m.Token()
	case subscriber.FieldTTL:
		return m.TTL()
	case subscriber.FieldSecret:
		return m.Secret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriber.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscriber.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscriber.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case subscriber.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case subscriber.FieldMappingID:
		return m.OldMappingID(ctx)
	case subscriber.FieldTags:
		return m.OldTags(ctx)
	case subscriber.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscriber.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case subscriber.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case subscriber.FieldEmail:
		return m.OldEmail(ctx)
	case subscriber.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case subscriber.FieldVerifiedEmail:
		return m.OldVerifiedEmail(ctx)
	case subscriber.FieldVerifiedPhone:
		return m.OldVerifiedPhone(ctx)
	case subscriber.FieldActive:
		return m.OldActive(ctx)
	case subscriber.FieldToken:
		return m.OldToken(ctx)
	case subscriber.FieldTTL:
		return m.OldTTL(ctx)
	case subscriber.FieldSecret:
		return m.OldSecret(ctx)
	}
	return nil, fmt.Errorf("unknown Subscriber field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriber.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscriber.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscriber.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case subscriber.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case subscriber.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case subscriber.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case subscriber.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscriber.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case subscriber.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case subscriber.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case subscriber.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case subscriber.FieldVerifiedEmail:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedEmail(v)
		return nil
	case subscriber.FieldVerifiedPhone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedPhone(v)
		return nil
	case subscriber.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case subscriber.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case subscriber.FieldTTL:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTTL(v)
		return nil
	case subscriber.FieldSecret:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	}
	return fmt.Errorf("unknown Subscriber field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscriber numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriber.FieldCreatedAt) {
		fields = append(fields, subscriber.FieldCreatedAt)
	}
	if m.FieldCleared(subscriber.FieldUpdatedAt) {
		fields = append(fields, subscriber.FieldUpdatedAt)
	}
	if m.FieldCleared(subscriber.FieldCreatedBy) {
		fields = append(fields, subscriber.FieldCreatedBy)
	}
	if m.FieldCleared(subscriber.FieldUpdatedBy) {
		fields = append(fields, subscriber.FieldUpdatedBy)
	}
	if m.FieldCleared(subscriber.FieldTags) {
		fields = append(fields, subscriber.FieldTags)
	}
	if m.FieldCleared(subscriber.FieldDeletedAt) {
		fields = append(fields, subscriber.FieldDeletedAt)
	}
	if m.FieldCleared(subscriber.FieldDeletedBy) {
		fields = append(fields, subscriber.FieldDeletedBy)
	}
	if m.FieldCleared(subscriber.FieldOwnerID) {
		fields = append(fields, subscriber.FieldOwnerID)
	}
	if m.FieldCleared(subscriber.FieldPhoneNumber) {
		fields = append(fields, subscriber.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriberMutation) ClearField(name string) error {
	switch name {
	case subscriber.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case subscriber.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case subscriber.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case subscriber.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case subscriber.FieldTags:
		m.ClearTags()
		return nil
	case subscriber.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscriber.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case subscriber.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case subscriber.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown Subscriber nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriberMutation) ResetField(name string) error {
	switch name {
	case subscriber.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscriber.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscriber.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case subscriber.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case subscriber.FieldMappingID:
		m.ResetMappingID()
		return nil
	case subscriber.FieldTags:
		m.ResetTags()
		return nil
	case subscriber.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscriber.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case subscriber.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case subscriber.FieldEmail:
		m.ResetEmail()
		return nil
	case subscriber.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case subscriber.FieldVerifiedEmail:
		m.ResetVerifiedEmail()
		return nil
	case subscriber.FieldVerifiedPhone:
		m.ResetVerifiedPhone()
		return nil
	case subscriber.FieldActive:
		m.ResetActive()
		return nil
	case subscriber.FieldToken:
		m.ResetToken()
		return nil
	case subscriber.FieldTTL:
		m.ResetTTL()
		return nil
	case subscriber.FieldSecret:
		m.ResetSecret()
		return nil
	}
	return fmt.Errorf("unknown Subscriber field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, subscriber.EdgeOwner)
	}
	if m.events != nil {
		edges = append(edges, subscriber.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriber.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case subscriber.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, subscriber.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscriber.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, subscriber.EdgeOwner)
	}
	if m.clearedevents {
		edges = append(edges, subscriber.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriberMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriber.EdgeOwner:
		return m.clearedowner
	case subscriber.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriberMutation) ClearEdge(name string) error {
	switch name {
	case subscriber.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Subscriber unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriberMutation) ResetEdge(name string) error {
	switch name {
	case subscriber.EdgeOwner:
		m.ResetOwner()
		return nil
	case subscriber.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Subscriber edge %s", name)
}

// TFASettingMutation represents an operation that mutates the TFASetting nodes in the graph.
type TFASettingMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	mapping_id           *string
	deleted_at           *time.Time
	deleted_by           *string
	tags                 *[]string
	appendtags           []string
	tfa_secret           *string
	verified             *bool
	recovery_codes       *[]string
	appendrecovery_codes []string
	phone_otp_allowed    *bool
	email_otp_allowed    *bool
	totp_allowed         *bool
	clearedFields        map[string]struct{}
	owner                *string
	clearedowner         bool
	done                 bool
	oldValue             func(context.Context) (*TFASetting, error)
	predicates           []predicate.TFASetting
}

var _ ent.Mutation = (*TFASettingMutation)(nil)

// tfasettingOption allows management of the mutation configuration using functional options.
type tfasettingOption func(*TFASettingMutation)

// newTFASettingMutation creates new mutation for the TFASetting entity.
func newTFASettingMutation(c config, op Op, opts ...tfasettingOption) *TFASettingMutation {
	m := &TFASettingMutation{
		config:        c,
		op:            op,
		typ:           TypeTFASetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTFASettingID sets the ID field of the mutation.
func withTFASettingID(id string) tfasettingOption {
	return func(m *TFASettingMutation) {
		var (
			err   error
			once  sync.Once
			value *TFASetting
		)
		m.oldValue = func(ctx context.Context) (*TFASetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TFASetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTFASetting sets the old TFASetting of the mutation.
func withTFASetting(node *TFASetting) tfasettingOption {
	return func(m *TFASettingMutation) {
		m.oldValue = func(context.Context) (*TFASetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TFASettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TFASettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TFASetting entities.
func (m *TFASettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TFASettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TFASettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TFASetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TFASettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TFASettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TFASettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[tfasetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TFASettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TFASettingMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, tfasetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TFASettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TFASettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TFASettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[tfasetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TFASettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TFASettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, tfasetting.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TFASettingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TFASettingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TFASettingMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[tfasetting.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TFASettingMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TFASettingMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, tfasetting.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TFASettingMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TFASettingMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TFASettingMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[tfasetting.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TFASettingMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TFASettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, tfasetting.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *TFASettingMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *TFASettingMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *TFASettingMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TFASettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TFASettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TFASettingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tfasetting.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TFASettingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TFASettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tfasetting.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TFASettingMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TFASettingMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TFASettingMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[tfasetting.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TFASettingMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TFASettingMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, tfasetting.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *TFASettingMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TFASettingMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TFASettingMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TFASettingMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TFASettingMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[tfasetting.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TFASettingMutation) TagsCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TFASettingMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, tfasetting.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *TFASettingMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TFASettingMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *TFASettingMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[tfasetting.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *TFASettingMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TFASettingMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, tfasetting.FieldOwnerID)
}

// SetTfaSecret sets the "tfa_secret" field.
func (m *TFASettingMutation) SetTfaSecret(s string) {
	m.tfa_secret = &s
}

// TfaSecret returns the value of the "tfa_secret" field in the mutation.
func (m *TFASettingMutation) TfaSecret() (r string, exists bool) {
	v := m.tfa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTfaSecret returns the old "tfa_secret" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldTfaSecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTfaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTfaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTfaSecret: %w", err)
	}
	return oldValue.TfaSecret, nil
}

// ClearTfaSecret clears the value of the "tfa_secret" field.
func (m *TFASettingMutation) ClearTfaSecret() {
	m.tfa_secret = nil
	m.clearedFields[tfasetting.FieldTfaSecret] = struct{}{}
}

// TfaSecretCleared returns if the "tfa_secret" field was cleared in this mutation.
func (m *TFASettingMutation) TfaSecretCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldTfaSecret]
	return ok
}

// ResetTfaSecret resets all changes to the "tfa_secret" field.
func (m *TFASettingMutation) ResetTfaSecret() {
	m.tfa_secret = nil
	delete(m.clearedFields, tfasetting.FieldTfaSecret)
}

// SetVerified sets the "verified" field.
func (m *TFASettingMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *TFASettingMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *TFASettingMutation) ResetVerified() {
	m.verified = nil
}

// SetRecoveryCodes sets the "recovery_codes" field.
func (m *TFASettingMutation) SetRecoveryCodes(s []string) {
	m.recovery_codes = &s
	m.appendrecovery_codes = nil
}

// RecoveryCodes returns the value of the "recovery_codes" field in the mutation.
func (m *TFASettingMutation) RecoveryCodes() (r []string, exists bool) {
	v := m.recovery_codes
	if v == nil {
		return
	}
	return *v, true
}

// OldRecoveryCodes returns the old "recovery_codes" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldRecoveryCodes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecoveryCodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecoveryCodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecoveryCodes: %w", err)
	}
	return oldValue.RecoveryCodes, nil
}

// AppendRecoveryCodes adds s to the "recovery_codes" field.
func (m *TFASettingMutation) AppendRecoveryCodes(s []string) {
	m.appendrecovery_codes = append(m.appendrecovery_codes, s...)
}

// AppendedRecoveryCodes returns the list of values that were appended to the "recovery_codes" field in this mutation.
func (m *TFASettingMutation) AppendedRecoveryCodes() ([]string, bool) {
	if len(m.appendrecovery_codes) == 0 {
		return nil, false
	}
	return m.appendrecovery_codes, true
}

// ClearRecoveryCodes clears the value of the "recovery_codes" field.
func (m *TFASettingMutation) ClearRecoveryCodes() {
	m.recovery_codes = nil
	m.appendrecovery_codes = nil
	m.clearedFields[tfasetting.FieldRecoveryCodes] = struct{}{}
}

// RecoveryCodesCleared returns if the "recovery_codes" field was cleared in this mutation.
func (m *TFASettingMutation) RecoveryCodesCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldRecoveryCodes]
	return ok
}

// ResetRecoveryCodes resets all changes to the "recovery_codes" field.
func (m *TFASettingMutation) ResetRecoveryCodes() {
	m.recovery_codes = nil
	m.appendrecovery_codes = nil
	delete(m.clearedFields, tfasetting.FieldRecoveryCodes)
}

// SetPhoneOtpAllowed sets the "phone_otp_allowed" field.
func (m *TFASettingMutation) SetPhoneOtpAllowed(b bool) {
	m.phone_otp_allowed = &b
}

// PhoneOtpAllowed returns the value of the "phone_otp_allowed" field in the mutation.
func (m *TFASettingMutation) PhoneOtpAllowed() (r bool, exists bool) {
	v := m.phone_otp_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneOtpAllowed returns the old "phone_otp_allowed" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldPhoneOtpAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneOtpAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneOtpAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneOtpAllowed: %w", err)
	}
	return oldValue.PhoneOtpAllowed, nil
}

// ClearPhoneOtpAllowed clears the value of the "phone_otp_allowed" field.
func (m *TFASettingMutation) ClearPhoneOtpAllowed() {
	m.phone_otp_allowed = nil
	m.clearedFields[tfasetting.FieldPhoneOtpAllowed] = struct{}{}
}

// PhoneOtpAllowedCleared returns if the "phone_otp_allowed" field was cleared in this mutation.
func (m *TFASettingMutation) PhoneOtpAllowedCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldPhoneOtpAllowed]
	return ok
}

// ResetPhoneOtpAllowed resets all changes to the "phone_otp_allowed" field.
func (m *TFASettingMutation) ResetPhoneOtpAllowed() {
	m.phone_otp_allowed = nil
	delete(m.clearedFields, tfasetting.FieldPhoneOtpAllowed)
}

// SetEmailOtpAllowed sets the "email_otp_allowed" field.
func (m *TFASettingMutation) SetEmailOtpAllowed(b bool) {
	m.email_otp_allowed = &b
}

// EmailOtpAllowed returns the value of the "email_otp_allowed" field in the mutation.
func (m *TFASettingMutation) EmailOtpAllowed() (r bool, exists bool) {
	v := m.email_otp_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailOtpAllowed returns the old "email_otp_allowed" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldEmailOtpAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailOtpAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailOtpAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailOtpAllowed: %w", err)
	}
	return oldValue.EmailOtpAllowed, nil
}

// ClearEmailOtpAllowed clears the value of the "email_otp_allowed" field.
func (m *TFASettingMutation) ClearEmailOtpAllowed() {
	m.email_otp_allowed = nil
	m.clearedFields[tfasetting.FieldEmailOtpAllowed] = struct{}{}
}

// EmailOtpAllowedCleared returns if the "email_otp_allowed" field was cleared in this mutation.
func (m *TFASettingMutation) EmailOtpAllowedCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldEmailOtpAllowed]
	return ok
}

// ResetEmailOtpAllowed resets all changes to the "email_otp_allowed" field.
func (m *TFASettingMutation) ResetEmailOtpAllowed() {
	m.email_otp_allowed = nil
	delete(m.clearedFields, tfasetting.FieldEmailOtpAllowed)
}

// SetTotpAllowed sets the "totp_allowed" field.
func (m *TFASettingMutation) SetTotpAllowed(b bool) {
	m.totp_allowed = &b
}

// TotpAllowed returns the value of the "totp_allowed" field in the mutation.
func (m *TFASettingMutation) TotpAllowed() (r bool, exists bool) {
	v := m.totp_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpAllowed returns the old "totp_allowed" field's value of the TFASetting entity.
// If the TFASetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TFASettingMutation) OldTotpAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpAllowed: %w", err)
	}
	return oldValue.TotpAllowed, nil
}

// ClearTotpAllowed clears the value of the "totp_allowed" field.
func (m *TFASettingMutation) ClearTotpAllowed() {
	m.totp_allowed = nil
	m.clearedFields[tfasetting.FieldTotpAllowed] = struct{}{}
}

// TotpAllowedCleared returns if the "totp_allowed" field was cleared in this mutation.
func (m *TFASettingMutation) TotpAllowedCleared() bool {
	_, ok := m.clearedFields[tfasetting.FieldTotpAllowed]
	return ok
}

// ResetTotpAllowed resets all changes to the "totp_allowed" field.
func (m *TFASettingMutation) ResetTotpAllowed() {
	m.totp_allowed = nil
	delete(m.clearedFields, tfasetting.FieldTotpAllowed)
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TFASettingMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[tfasetting.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TFASettingMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TFASettingMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TFASettingMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TFASettingMutation builder.
func (m *TFASettingMutation) Where(ps ...predicate.TFASetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TFASettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TFASettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TFASetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TFASettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TFASettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TFASetting).
func (m *TFASettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TFASettingMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, tfasetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tfasetting.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, tfasetting.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, tfasetting.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, tfasetting.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, tfasetting.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, tfasetting.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, tfasetting.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, tfasetting.FieldOwnerID)
	}
	if m.tfa_secret != nil {
		fields = append(fields, tfasetting.FieldTfaSecret)
	}
	if m.verified != nil {
		fields = append(fields, tfasetting.FieldVerified)
	}
	if m.recovery_codes != nil {
		fields = append(fields, tfasetting.FieldRecoveryCodes)
	}
	if m.phone_otp_allowed != nil {
		fields = append(fields, tfasetting.FieldPhoneOtpAllowed)
	}
	if m.email_otp_allowed != nil {
		fields = append(fields, tfasetting.FieldEmailOtpAllowed)
	}
	if m.totp_allowed != nil {
		fields = append(fields, tfasetting.FieldTotpAllowed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TFASettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tfasetting.FieldCreatedAt:
		return m.CreatedAt()
	case tfasetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case tfasetting.FieldCreatedBy:
		return m.CreatedBy()
	case tfasetting.FieldUpdatedBy:
		return m.UpdatedBy()
	case tfasetting.FieldMappingID:
		return m.MappingID()
	case tfasetting.FieldDeletedAt:
		return m.DeletedAt()
	case tfasetting.FieldDeletedBy:
		return m.DeletedBy()
	case tfasetting.FieldTags:
		return m.Tags()
	case tfasetting.FieldOwnerID:
		return m.OwnerID()
	case tfasetting.FieldTfaSecret:
		return m.TfaSecret()
	case tfasetting.FieldVerified:
		return m.Verified()
	case tfasetting.FieldRecoveryCodes:
		return m.RecoveryCodes()
	case tfasetting.FieldPhoneOtpAllowed:
		return m.PhoneOtpAllowed()
	case tfasetting.FieldEmailOtpAllowed:
		return m.EmailOtpAllowed()
	case tfasetting.FieldTotpAllowed:
		return m.TotpAllowed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TFASettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tfasetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tfasetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tfasetting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tfasetting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tfasetting.FieldMappingID:
		return m.OldMappingID(ctx)
	case tfasetting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tfasetting.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case tfasetting.FieldTags:
		return m.OldTags(ctx)
	case tfasetting.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case tfasetting.FieldTfaSecret:
		return m.OldTfaSecret(ctx)
	case tfasetting.FieldVerified:
		return m.OldVerified(ctx)
	case tfasetting.FieldRecoveryCodes:
		return m.OldRecoveryCodes(ctx)
	case tfasetting.FieldPhoneOtpAllowed:
		return m.OldPhoneOtpAllowed(ctx)
	case tfasetting.FieldEmailOtpAllowed:
		return m.OldEmailOtpAllowed(ctx)
	case tfasetting.FieldTotpAllowed:
		return m.OldTotpAllowed(ctx)
	}
	return nil, fmt.Errorf("unknown TFASetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TFASettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tfasetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tfasetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tfasetting.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tfasetting.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tfasetting.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case tfasetting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tfasetting.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case tfasetting.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case tfasetting.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case tfasetting.FieldTfaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTfaSecret(v)
		return nil
	case tfasetting.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case tfasetting.FieldRecoveryCodes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecoveryCodes(v)
		return nil
	case tfasetting.FieldPhoneOtpAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneOtpAllowed(v)
		return nil
	case tfasetting.FieldEmailOtpAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailOtpAllowed(v)
		return nil
	case tfasetting.FieldTotpAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpAllowed(v)
		return nil
	}
	return fmt.Errorf("unknown TFASetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TFASettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TFASettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TFASettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TFASetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TFASettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tfasetting.FieldCreatedAt) {
		fields = append(fields, tfasetting.FieldCreatedAt)
	}
	if m.FieldCleared(tfasetting.FieldUpdatedAt) {
		fields = append(fields, tfasetting.FieldUpdatedAt)
	}
	if m.FieldCleared(tfasetting.FieldCreatedBy) {
		fields = append(fields, tfasetting.FieldCreatedBy)
	}
	if m.FieldCleared(tfasetting.FieldUpdatedBy) {
		fields = append(fields, tfasetting.FieldUpdatedBy)
	}
	if m.FieldCleared(tfasetting.FieldDeletedAt) {
		fields = append(fields, tfasetting.FieldDeletedAt)
	}
	if m.FieldCleared(tfasetting.FieldDeletedBy) {
		fields = append(fields, tfasetting.FieldDeletedBy)
	}
	if m.FieldCleared(tfasetting.FieldTags) {
		fields = append(fields, tfasetting.FieldTags)
	}
	if m.FieldCleared(tfasetting.FieldOwnerID) {
		fields = append(fields, tfasetting.FieldOwnerID)
	}
	if m.FieldCleared(tfasetting.FieldTfaSecret) {
		fields = append(fields, tfasetting.FieldTfaSecret)
	}
	if m.FieldCleared(tfasetting.FieldRecoveryCodes) {
		fields = append(fields, tfasetting.FieldRecoveryCodes)
	}
	if m.FieldCleared(tfasetting.FieldPhoneOtpAllowed) {
		fields = append(fields, tfasetting.FieldPhoneOtpAllowed)
	}
	if m.FieldCleared(tfasetting.FieldEmailOtpAllowed) {
		fields = append(fields, tfasetting.FieldEmailOtpAllowed)
	}
	if m.FieldCleared(tfasetting.FieldTotpAllowed) {
		fields = append(fields, tfasetting.FieldTotpAllowed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TFASettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TFASettingMutation) ClearField(name string) error {
	switch name {
	case tfasetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case tfasetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case tfasetting.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tfasetting.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tfasetting.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tfasetting.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case tfasetting.FieldTags:
		m.ClearTags()
		return nil
	case tfasetting.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case tfasetting.FieldTfaSecret:
		m.ClearTfaSecret()
		return nil
	case tfasetting.FieldRecoveryCodes:
		m.ClearRecoveryCodes()
		return nil
	case tfasetting.FieldPhoneOtpAllowed:
		m.ClearPhoneOtpAllowed()
		return nil
	case tfasetting.FieldEmailOtpAllowed:
		m.ClearEmailOtpAllowed()
		return nil
	case tfasetting.FieldTotpAllowed:
		m.ClearTotpAllowed()
		return nil
	}
	return fmt.Errorf("unknown TFASetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TFASettingMutation) ResetField(name string) error {
	switch name {
	case tfasetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tfasetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tfasetting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tfasetting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tfasetting.FieldMappingID:
		m.ResetMappingID()
		return nil
	case tfasetting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tfasetting.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case tfasetting.FieldTags:
		m.ResetTags()
		return nil
	case tfasetting.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case tfasetting.FieldTfaSecret:
		m.ResetTfaSecret()
		return nil
	case tfasetting.FieldVerified:
		m.ResetVerified()
		return nil
	case tfasetting.FieldRecoveryCodes:
		m.ResetRecoveryCodes()
		return nil
	case tfasetting.FieldPhoneOtpAllowed:
		m.ResetPhoneOtpAllowed()
		return nil
	case tfasetting.FieldEmailOtpAllowed:
		m.ResetEmailOtpAllowed()
		return nil
	case tfasetting.FieldTotpAllowed:
		m.ResetTotpAllowed()
		return nil
	}
	return fmt.Errorf("unknown TFASetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TFASettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, tfasetting.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TFASettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tfasetting.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TFASettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TFASettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TFASettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, tfasetting.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TFASettingMutation) EdgeCleared(name string) bool {
	switch name {
	case tfasetting.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TFASettingMutation) ClearEdge(name string) error {
	switch name {
	case tfasetting.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown TFASetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TFASettingMutation) ResetEdge(name string) error {
	switch name {
	case tfasetting.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown TFASetting edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	created_by               *string
	updated_by               *string
	mapping_id               *string
	deleted_at               *time.Time
	deleted_by               *string
	tags                     *[]string
	appendtags               []string
	title                    *string
	description              *string
	details                  *map[string]interface{}
	status                   *enums.TaskStatus
	due                      *time.Time
	completed                *time.Time
	clearedFields            map[string]struct{}
	assigner                 *string
	clearedassigner          bool
	assignee                 *string
	clearedassignee          bool
	organization             map[string]struct{}
	removedorganization      map[string]struct{}
	clearedorganization      bool
	group                    map[string]struct{}
	removedgroup             map[string]struct{}
	clearedgroup             bool
	policy                   map[string]struct{}
	removedpolicy            map[string]struct{}
	clearedpolicy            bool
	procedure                map[string]struct{}
	removedprocedure         map[string]struct{}
	clearedprocedure         bool
	control                  map[string]struct{}
	removedcontrol           map[string]struct{}
	clearedcontrol           bool
	control_objective        map[string]struct{}
	removedcontrol_objective map[string]struct{}
	clearedcontrol_objective bool
	subcontrol               map[string]struct{}
	removedsubcontrol        map[string]struct{}
	clearedsubcontrol        bool
	program                  map[string]struct{}
	removedprogram           map[string]struct{}
	clearedprogram           bool
	done                     bool
	oldValue                 func(context.Context) (*Task, error)
	predicates               []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id string) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[task.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, task.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[task.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, task.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[task.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, task.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[task.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, task.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *TaskMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *TaskMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *TaskMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[task.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, task.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TaskMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TaskMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TaskMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[task.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TaskMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[task.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TaskMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, task.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *TaskMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TaskMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TaskMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TaskMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TaskMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[task.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TaskMutation) TagsCleared() bool {
	_, ok := m.clearedFields[task.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TaskMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, task.FieldTags)
}

// SetTitle sets the "title" field.
func (m *TaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[task.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[task.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, task.FieldDescription)
}

// SetDetails sets the "details" field.
func (m *TaskMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *TaskMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *TaskMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[task.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *TaskMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[task.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *TaskMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, task.FieldDetails)
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(es enums.TaskStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r enums.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v enums.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetDue sets the "due" field.
func (m *TaskMutation) SetDue(t time.Time) {
	m.due = &t
}

// Due returns the value of the "due" field in the mutation.
func (m *TaskMutation) Due() (r time.Time, exists bool) {
	v := m.due
	if v == nil {
		return
	}
	return *v, true
}

// OldDue returns the old "due" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDue(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDue: %w", err)
	}
	return oldValue.Due, nil
}

// ClearDue clears the value of the "due" field.
func (m *TaskMutation) ClearDue() {
	m.due = nil
	m.clearedFields[task.FieldDue] = struct{}{}
}

// DueCleared returns if the "due" field was cleared in this mutation.
func (m *TaskMutation) DueCleared() bool {
	_, ok := m.clearedFields[task.FieldDue]
	return ok
}

// ResetDue resets all changes to the "due" field.
func (m *TaskMutation) ResetDue() {
	m.due = nil
	delete(m.clearedFields, task.FieldDue)
}

// SetCompleted sets the "completed" field.
func (m *TaskMutation) SetCompleted(t time.Time) {
	m.completed = &t
}

// Completed returns the value of the "completed" field in the mutation.
func (m *TaskMutation) Completed() (r time.Time, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCompleted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ClearCompleted clears the value of the "completed" field.
func (m *TaskMutation) ClearCompleted() {
	m.completed = nil
	m.clearedFields[task.FieldCompleted] = struct{}{}
}

// CompletedCleared returns if the "completed" field was cleared in this mutation.
func (m *TaskMutation) CompletedCleared() bool {
	_, ok := m.clearedFields[task.FieldCompleted]
	return ok
}

// ResetCompleted resets all changes to the "completed" field.
func (m *TaskMutation) ResetCompleted() {
	m.completed = nil
	delete(m.clearedFields, task.FieldCompleted)
}

// SetAssignerID sets the "assigner" edge to the User entity by id.
func (m *TaskMutation) SetAssignerID(id string) {
	m.assigner = &id
}

// ClearAssigner clears the "assigner" edge to the User entity.
func (m *TaskMutation) ClearAssigner() {
	m.clearedassigner = true
}

// AssignerCleared reports if the "assigner" edge to the User entity was cleared.
func (m *TaskMutation) AssignerCleared() bool {
	return m.clearedassigner
}

// AssignerID returns the "assigner" edge ID in the mutation.
func (m *TaskMutation) AssignerID() (id string, exists bool) {
	if m.assigner != nil {
		return *m.assigner, true
	}
	return
}

// AssignerIDs returns the "assigner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignerID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) AssignerIDs() (ids []string) {
	if id := m.assigner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssigner resets all changes to the "assigner" edge.
func (m *TaskMutation) ResetAssigner() {
	m.assigner = nil
	m.clearedassigner = false
}

// SetAssigneeID sets the "assignee" edge to the User entity by id.
func (m *TaskMutation) SetAssigneeID(id string) {
	m.assignee = &id
}

// ClearAssignee clears the "assignee" edge to the User entity.
func (m *TaskMutation) ClearAssignee() {
	m.clearedassignee = true
}

// AssigneeCleared reports if the "assignee" edge to the User entity was cleared.
func (m *TaskMutation) AssigneeCleared() bool {
	return m.clearedassignee
}

// AssigneeID returns the "assignee" edge ID in the mutation.
func (m *TaskMutation) AssigneeID() (id string, exists bool) {
	if m.assignee != nil {
		return *m.assignee, true
	}
	return
}

// AssigneeIDs returns the "assignee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) AssigneeIDs() (ids []string) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee resets all changes to the "assignee" edge.
func (m *TaskMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *TaskMutation) AddOrganizationIDs(ids ...string) {
	if m.organization == nil {
		m.organization = make(map[string]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TaskMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TaskMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *TaskMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organization, ids[i])
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *TaskMutation) RemovedOrganizationIDs() (ids []string) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *TaskMutation) OrganizationIDs() (ids []string) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TaskMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// AddGroupIDs adds the "group" edge to the Group entity by ids.
func (m *TaskMutation) AddGroupIDs(ids ...string) {
	if m.group == nil {
		m.group = make(map[string]struct{})
	}
	for i := range ids {
		m.group[ids[i]] = struct{}{}
	}
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *TaskMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *TaskMutation) GroupCleared() bool {
	return m.clearedgroup
}

// RemoveGroupIDs removes the "group" edge to the Group entity by IDs.
func (m *TaskMutation) RemoveGroupIDs(ids ...string) {
	if m.removedgroup == nil {
		m.removedgroup = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.group, ids[i])
		m.removedgroup[ids[i]] = struct{}{}
	}
}

// RemovedGroup returns the removed IDs of the "group" edge to the Group entity.
func (m *TaskMutation) RemovedGroupIDs() (ids []string) {
	for id := range m.removedgroup {
		ids = append(ids, id)
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
func (m *TaskMutation) GroupIDs() (ids []string) {
	for id := range m.group {
		ids = append(ids, id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *TaskMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
	m.removedgroup = nil
}

// AddPolicyIDs adds the "policy" edge to the InternalPolicy entity by ids.
func (m *TaskMutation) AddPolicyIDs(ids ...string) {
	if m.policy == nil {
		m.policy = make(map[string]struct{})
	}
	for i := range ids {
		m.policy[ids[i]] = struct{}{}
	}
}

// ClearPolicy clears the "policy" edge to the InternalPolicy entity.
func (m *TaskMutation) ClearPolicy() {
	m.clearedpolicy = true
}

// PolicyCleared reports if the "policy" edge to the InternalPolicy entity was cleared.
func (m *TaskMutation) PolicyCleared() bool {
	return m.clearedpolicy
}

// RemovePolicyIDs removes the "policy" edge to the InternalPolicy entity by IDs.
func (m *TaskMutation) RemovePolicyIDs(ids ...string) {
	if m.removedpolicy == nil {
		m.removedpolicy = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.policy, ids[i])
		m.removedpolicy[ids[i]] = struct{}{}
	}
}

// RemovedPolicy returns the removed IDs of the "policy" edge to the InternalPolicy entity.
func (m *TaskMutation) RemovedPolicyIDs() (ids []string) {
	for id := range m.removedpolicy {
		ids = append(ids, id)
	}
	return
}

// PolicyIDs returns the "policy" edge IDs in the mutation.
func (m *TaskMutation) PolicyIDs() (ids []string) {
	for id := range m.policy {
		ids = append(ids, id)
	}
	return
}

// ResetPolicy resets all changes to the "policy" edge.
func (m *TaskMutation) ResetPolicy() {
	m.policy = nil
	m.clearedpolicy = false
	m.removedpolicy = nil
}

// AddProcedureIDs adds the "procedure" edge to the Procedure entity by ids.
func (m *TaskMutation) AddProcedureIDs(ids ...string) {
	if m.procedure == nil {
		m.procedure = make(map[string]struct{})
	}
	for i := range ids {
		m.procedure[ids[i]] = struct{}{}
	}
}

// ClearProcedure clears the "procedure" edge to the Procedure entity.
func (m *TaskMutation) ClearProcedure() {
	m.clearedprocedure = true
}

// ProcedureCleared reports if the "procedure" edge to the Procedure entity was cleared.
func (m *TaskMutation) ProcedureCleared() bool {
	return m.clearedprocedure
}

// RemoveProcedureIDs removes the "procedure" edge to the Procedure entity by IDs.
func (m *TaskMutation) RemoveProcedureIDs(ids ...string) {
	if m.removedprocedure == nil {
		m.removedprocedure = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.procedure, ids[i])
		m.removedprocedure[ids[i]] = struct{}{}
	}
}

// RemovedProcedure returns the removed IDs of the "procedure" edge to the Procedure entity.
func (m *TaskMutation) RemovedProcedureIDs() (ids []string) {
	for id := range m.removedprocedure {
		ids = append(ids, id)
	}
	return
}

// ProcedureIDs returns the "procedure" edge IDs in the mutation.
func (m *TaskMutation) ProcedureIDs() (ids []string) {
	for id := range m.procedure {
		ids = append(ids, id)
	}
	return
}

// ResetProcedure resets all changes to the "procedure" edge.
func (m *TaskMutation) ResetProcedure() {
	m.procedure = nil
	m.clearedprocedure = false
	m.removedprocedure = nil
}

// AddControlIDs adds the "control" edge to the Control entity by ids.
func (m *TaskMutation) AddControlIDs(ids ...string) {
	if m.control == nil {
		m.control = make(map[string]struct{})
	}
	for i := range ids {
		m.control[ids[i]] = struct{}{}
	}
}

// ClearControl clears the "control" edge to the Control entity.
func (m *TaskMutation) ClearControl() {
	m.clearedcontrol = true
}

// ControlCleared reports if the "control" edge to the Control entity was cleared.
func (m *TaskMutation) ControlCleared() bool {
	return m.clearedcontrol
}

// RemoveControlIDs removes the "control" edge to the Control entity by IDs.
func (m *TaskMutation) RemoveControlIDs(ids ...string) {
	if m.removedcontrol == nil {
		m.removedcontrol = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.control, ids[i])
		m.removedcontrol[ids[i]] = struct{}{}
	}
}

// RemovedControl returns the removed IDs of the "control" edge to the Control entity.
func (m *TaskMutation) RemovedControlIDs() (ids []string) {
	for id := range m.removedcontrol {
		ids = append(ids, id)
	}
	return
}

// ControlIDs returns the "control" edge IDs in the mutation.
func (m *TaskMutation) ControlIDs() (ids []string) {
	for id := range m.control {
		ids = append(ids, id)
	}
	return
}

// ResetControl resets all changes to the "control" edge.
func (m *TaskMutation) ResetControl() {
	m.control = nil
	m.clearedcontrol = false
	m.removedcontrol = nil
}

// AddControlObjectiveIDs adds the "control_objective" edge to the ControlObjective entity by ids.
func (m *TaskMutation) AddControlObjectiveIDs(ids ...string) {
	if m.control_objective == nil {
		m.control_objective = make(map[string]struct{})
	}
	for i := range ids {
		m.control_objective[ids[i]] = struct{}{}
	}
}

// ClearControlObjective clears the "control_objective" edge to the ControlObjective entity.
func (m *TaskMutation) ClearControlObjective() {
	m.clearedcontrol_objective = true
}

// ControlObjectiveCleared reports if the "control_objective" edge to the ControlObjective entity was cleared.
func (m *TaskMutation) ControlObjectiveCleared() bool {
	return m.clearedcontrol_objective
}

// RemoveControlObjectiveIDs removes the "control_objective" edge to the ControlObjective entity by IDs.
func (m *TaskMutation) RemoveControlObjectiveIDs(ids ...string) {
	if m.removedcontrol_objective == nil {
		m.removedcontrol_objective = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.control_objective, ids[i])
		m.removedcontrol_objective[ids[i]] = struct{}{}
	}
}

// RemovedControlObjective returns the removed IDs of the "control_objective" edge to the ControlObjective entity.
func (m *TaskMutation) RemovedControlObjectiveIDs() (ids []string) {
	for id := range m.removedcontrol_objective {
		ids = append(ids, id)
	}
	return
}

// ControlObjectiveIDs returns the "control_objective" edge IDs in the mutation.
func (m *TaskMutation) ControlObjectiveIDs() (ids []string) {
	for id := range m.control_objective {
		ids = append(ids, id)
	}
	return
}

// ResetControlObjective resets all changes to the "control_objective" edge.
func (m *TaskMutation) ResetControlObjective() {
	m.control_objective = nil
	m.clearedcontrol_objective = false
	m.removedcontrol_objective = nil
}

// AddSubcontrolIDs adds the "subcontrol" edge to the Subcontrol entity by ids.
func (m *TaskMutation) AddSubcontrolIDs(ids ...string) {
	if m.subcontrol == nil {
		m.subcontrol = make(map[string]struct{})
	}
	for i := range ids {
		m.subcontrol[ids[i]] = struct{}{}
	}
}

// ClearSubcontrol clears the "subcontrol" edge to the Subcontrol entity.
func (m *TaskMutation) ClearSubcontrol() {
	m.clearedsubcontrol = true
}

// SubcontrolCleared reports if the "subcontrol" edge to the Subcontrol entity was cleared.
func (m *TaskMutation) SubcontrolCleared() bool {
	return m.clearedsubcontrol
}

// RemoveSubcontrolIDs removes the "subcontrol" edge to the Subcontrol entity by IDs.
func (m *TaskMutation) RemoveSubcontrolIDs(ids ...string) {
	if m.removedsubcontrol == nil {
		m.removedsubcontrol = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subcontrol, ids[i])
		m.removedsubcontrol[ids[i]] = struct{}{}
	}
}

// RemovedSubcontrol returns the removed IDs of the "subcontrol" edge to the Subcontrol entity.
func (m *TaskMutation) RemovedSubcontrolIDs() (ids []string) {
	for id := range m.removedsubcontrol {
		ids = append(ids, id)
	}
	return
}

// SubcontrolIDs returns the "subcontrol" edge IDs in the mutation.
func (m *TaskMutation) SubcontrolIDs() (ids []string) {
	for id := range m.subcontrol {
		ids = append(ids, id)
	}
	return
}

// ResetSubcontrol resets all changes to the "subcontrol" edge.
func (m *TaskMutation) ResetSubcontrol() {
	m.subcontrol = nil
	m.clearedsubcontrol = false
	m.removedsubcontrol = nil
}

// AddProgramIDs adds the "program" edge to the Program entity by ids.
func (m *TaskMutation) AddProgramIDs(ids ...string) {
	if m.program == nil {
		m.program = make(map[string]struct{})
	}
	for i := range ids {
		m.program[ids[i]] = struct{}{}
	}
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *TaskMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *TaskMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// RemoveProgramIDs removes the "program" edge to the Program entity by IDs.
func (m *TaskMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprogram == nil {
		m.removedprogram = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.program, ids[i])
		m.removedprogram[ids[i]] = struct{}{}
	}
}

// RemovedProgram returns the removed IDs of the "program" edge to the Program entity.
func (m *TaskMutation) RemovedProgramIDs() (ids []string) {
	for id := range m.removedprogram {
		ids = append(ids, id)
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
func (m *TaskMutation) ProgramIDs() (ids []string) {
	for id := range m.program {
		ids = append(ids, id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *TaskMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
	m.removedprogram = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, task.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, task.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, task.FieldTags)
	}
	if m.title != nil {
		fields = append(fields, task.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, task.FieldDescription)
	}
	if m.details != nil {
		fields = append(fields, task.FieldDetails)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.due != nil {
		fields = append(fields, task.FieldDue)
	}
	if m.completed != nil {
		fields = append(fields, task.FieldCompleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldCreatedBy:
		return m.CreatedBy()
	case task.FieldUpdatedBy:
		return m.UpdatedBy()
	case task.FieldMappingID:
		return m.MappingID()
	case task.FieldDeletedAt:
		return m.DeletedAt()
	case task.FieldDeletedBy:
		return m.DeletedBy()
	case task.FieldTags:
		return m.Tags()
	case task.FieldTitle:
		return m.Title()
	case task.FieldDescription:
		return m.Description()
	case task.FieldDetails:
		return m.Details()
	case task.FieldStatus:
		return m.Status()
	case task.FieldDue:
		return m.Due()
	case task.FieldCompleted:
		return m.Completed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case task.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case task.FieldMappingID:
		return m.OldMappingID(ctx)
	case task.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case task.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case task.FieldTags:
		return m.OldTags(ctx)
	case task.FieldTitle:
		return m.OldTitle(ctx)
	case task.FieldDescription:
		return m.OldDescription(ctx)
	case task.FieldDetails:
		return m.OldDetails(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldDue:
		return m.OldDue(ctx)
	case task.FieldCompleted:
		return m.OldCompleted(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case task.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case task.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case task.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case task.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case task.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case task.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case task.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case task.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(enums.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldDue:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDue(v)
		return nil
	case task.FieldCompleted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldCreatedAt) {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.FieldCleared(task.FieldUpdatedAt) {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.FieldCleared(task.FieldCreatedBy) {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.FieldCleared(task.FieldUpdatedBy) {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.FieldCleared(task.FieldDeletedAt) {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.FieldCleared(task.FieldDeletedBy) {
		fields = append(fields, task.FieldDeletedBy)
	}
	if m.FieldCleared(task.FieldTags) {
		fields = append(fields, task.FieldTags)
	}
	if m.FieldCleared(task.FieldDescription) {
		fields = append(fields, task.FieldDescription)
	}
	if m.FieldCleared(task.FieldDetails) {
		fields = append(fields, task.FieldDetails)
	}
	if m.FieldCleared(task.FieldDue) {
		fields = append(fields, task.FieldDue)
	}
	if m.FieldCleared(task.FieldCompleted) {
		fields = append(fields, task.FieldCompleted)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case task.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case task.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case task.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case task.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case task.FieldTags:
		m.ClearTags()
		return nil
	case task.FieldDescription:
		m.ClearDescription()
		return nil
	case task.FieldDetails:
		m.ClearDetails()
		return nil
	case task.FieldDue:
		m.ClearDue()
		return nil
	case task.FieldCompleted:
		m.ClearCompleted()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case task.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case task.FieldMappingID:
		m.ResetMappingID()
		return nil
	case task.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case task.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case task.FieldTags:
		m.ResetTags()
		return nil
	case task.FieldTitle:
		m.ResetTitle()
		return nil
	case task.FieldDescription:
		m.ResetDescription()
		return nil
	case task.FieldDetails:
		m.ResetDetails()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldDue:
		m.ResetDue()
		return nil
	case task.FieldCompleted:
		m.ResetCompleted()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.assigner != nil {
		edges = append(edges, task.EdgeAssigner)
	}
	if m.assignee != nil {
		edges = append(edges, task.EdgeAssignee)
	}
	if m.organization != nil {
		edges = append(edges, task.EdgeOrganization)
	}
	if m.group != nil {
		edges = append(edges, task.EdgeGroup)
	}
	if m.policy != nil {
		edges = append(edges, task.EdgePolicy)
	}
	if m.procedure != nil {
		edges = append(edges, task.EdgeProcedure)
	}
	if m.control != nil {
		edges = append(edges, task.EdgeControl)
	}
	if m.control_objective != nil {
		edges = append(edges, task.EdgeControlObjective)
	}
	if m.subcontrol != nil {
		edges = append(edges, task.EdgeSubcontrol)
	}
	if m.program != nil {
		edges = append(edges, task.EdgeProgram)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeAssigner:
		if id := m.assigner; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.group))
		for id := range m.group {
			ids = append(ids, id)
		}
		return ids
	case task.EdgePolicy:
		ids := make([]ent.Value, 0, len(m.policy))
		for id := range m.policy {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProcedure:
		ids := make([]ent.Value, 0, len(m.procedure))
		for id := range m.procedure {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeControl:
		ids := make([]ent.Value, 0, len(m.control))
		for id := range m.control {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeControlObjective:
		ids := make([]ent.Value, 0, len(m.control_objective))
		for id := range m.control_objective {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeSubcontrol:
		ids := make([]ent.Value, 0, len(m.subcontrol))
		for id := range m.subcontrol {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.program))
		for id := range m.program {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedorganization != nil {
		edges = append(edges, task.EdgeOrganization)
	}
	if m.removedgroup != nil {
		edges = append(edges, task.EdgeGroup)
	}
	if m.removedpolicy != nil {
		edges = append(edges, task.EdgePolicy)
	}
	if m.removedprocedure != nil {
		edges = append(edges, task.EdgeProcedure)
	}
	if m.removedcontrol != nil {
		edges = append(edges, task.EdgeControl)
	}
	if m.removedcontrol_objective != nil {
		edges = append(edges, task.EdgeControlObjective)
	}
	if m.removedsubcontrol != nil {
		edges = append(edges, task.EdgeSubcontrol)
	}
	if m.removedprogram != nil {
		edges = append(edges, task.EdgeProgram)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeGroup:
		ids := make([]ent.Value, 0, len(m.removedgroup))
		for id := range m.removedgroup {
			ids = append(ids, id)
		}
		return ids
	case task.EdgePolicy:
		ids := make([]ent.Value, 0, len(m.removedpolicy))
		for id := range m.removedpolicy {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProcedure:
		ids := make([]ent.Value, 0, len(m.removedprocedure))
		for id := range m.removedprocedure {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeControl:
		ids := make([]ent.Value, 0, len(m.removedcontrol))
		for id := range m.removedcontrol {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeControlObjective:
		ids := make([]ent.Value, 0, len(m.removedcontrol_objective))
		for id := range m.removedcontrol_objective {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeSubcontrol:
		ids := make([]ent.Value, 0, len(m.removedsubcontrol))
		for id := range m.removedsubcontrol {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProgram:
		ids := make([]ent.Value, 0, len(m.removedprogram))
		for id := range m.removedprogram {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedassigner {
		edges = append(edges, task.EdgeAssigner)
	}
	if m.clearedassignee {
		edges = append(edges, task.EdgeAssignee)
	}
	if m.clearedorganization {
		edges = append(edges, task.EdgeOrganization)
	}
	if m.clearedgroup {
		edges = append(edges, task.EdgeGroup)
	}
	if m.clearedpolicy {
		edges = append(edges, task.EdgePolicy)
	}
	if m.clearedprocedure {
		edges = append(edges, task.EdgeProcedure)
	}
	if m.clearedcontrol {
		edges = append(edges, task.EdgeControl)
	}
	if m.clearedcontrol_objective {
		edges = append(edges, task.EdgeControlObjective)
	}
	if m.clearedsubcontrol {
		edges = append(edges, task.EdgeSubcontrol)
	}
	if m.clearedprogram {
		edges = append(edges, task.EdgeProgram)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeAssigner:
		return m.clearedassigner
	case task.EdgeAssignee:
		return m.clearedassignee
	case task.EdgeOrganization:
		return m.clearedorganization
	case task.EdgeGroup:
		return m.clearedgroup
	case task.EdgePolicy:
		return m.clearedpolicy
	case task.EdgeProcedure:
		return m.clearedprocedure
	case task.EdgeControl:
		return m.clearedcontrol
	case task.EdgeControlObjective:
		return m.clearedcontrol_objective
	case task.EdgeSubcontrol:
		return m.clearedsubcontrol
	case task.EdgeProgram:
		return m.clearedprogram
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeAssigner:
		m.ClearAssigner()
		return nil
	case task.EdgeAssignee:
		m.ClearAssignee()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeAssigner:
		m.ResetAssigner()
		return nil
	case task.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case task.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case task.EdgeGroup:
		m.ResetGroup()
		return nil
	case task.EdgePolicy:
		m.ResetPolicy()
		return nil
	case task.EdgeProcedure:
		m.ResetProcedure()
		return nil
	case task.EdgeControl:
		m.ResetControl()
		return nil
	case task.EdgeControlObjective:
		m.ResetControlObjective()
		return nil
	case task.EdgeSubcontrol:
		m.ResetSubcontrol()
		return nil
	case task.EdgeProgram:
		m.ResetProgram()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TaskHistoryMutation represents an operation that mutates the TaskHistory nodes in the graph.
type TaskHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	mapping_id    *string
	deleted_at    *time.Time
	deleted_by    *string
	tags          *[]string
	appendtags    []string
	title         *string
	description   *string
	details       *map[string]interface{}
	status        *enums.TaskStatus
	due           *time.Time
	completed     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TaskHistory, error)
	predicates    []predicate.TaskHistory
}

var _ ent.Mutation = (*TaskHistoryMutation)(nil)

// taskhistoryOption allows management of the mutation configuration using functional options.
type taskhistoryOption func(*TaskHistoryMutation)

// newTaskHistoryMutation creates new mutation for the TaskHistory entity.
func newTaskHistoryMutation(c config, op Op, opts ...taskhistoryOption) *TaskHistoryMutation {
	m := &TaskHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskHistoryID sets the ID field of the mutation.
func withTaskHistoryID(id string) taskhistoryOption {
	return func(m *TaskHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskHistory
		)
		m.oldValue = func(ctx context.Context) (*TaskHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskHistory sets the old TaskHistory of the mutation.
func withTaskHistory(node *TaskHistory) taskhistoryOption {
	return func(m *TaskHistoryMutation) {
		m.oldValue = func(context.Context) (*TaskHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskHistory entities.
func (m *TaskHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TaskHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TaskHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TaskHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TaskHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TaskHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TaskHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[taskhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TaskHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TaskHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, taskhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TaskHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TaskHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TaskHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TaskHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[taskhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TaskHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, taskhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[taskhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, taskhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TaskHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[taskhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TaskHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, taskhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[taskhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, taskhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *TaskHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *TaskHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *TaskHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[taskhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, taskhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TaskHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TaskHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TaskHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[taskhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TaskHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TaskHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, taskhistory.FieldDeletedBy)
}

// SetTags sets the "tags" field.
func (m *TaskHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TaskHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TaskHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TaskHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TaskHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[taskhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TaskHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TaskHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, taskhistory.FieldTags)
}

// SetTitle sets the "title" field.
func (m *TaskHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TaskHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TaskHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TaskHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[taskhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, taskhistory.FieldDescription)
}

// SetDetails sets the "details" field.
func (m *TaskHistoryMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *TaskHistoryMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *TaskHistoryMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[taskhistory.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *TaskHistoryMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *TaskHistoryMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, taskhistory.FieldDetails)
}

// SetStatus sets the "status" field.
func (m *TaskHistoryMutation) SetStatus(es enums.TaskStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskHistoryMutation) Status() (r enums.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldStatus(ctx context.Context) (v enums.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetDue sets the "due" field.
func (m *TaskHistoryMutation) SetDue(t time.Time) {
	m.due = &t
}

// Due returns the value of the "due" field in the mutation.
func (m *TaskHistoryMutation) Due() (r time.Time, exists bool) {
	v := m.due
	if v == nil {
		return
	}
	return *v, true
}

// OldDue returns the old "due" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldDue(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDue: %w", err)
	}
	return oldValue.Due, nil
}

// ClearDue clears the value of the "due" field.
func (m *TaskHistoryMutation) ClearDue() {
	m.due = nil
	m.clearedFields[taskhistory.FieldDue] = struct{}{}
}

// DueCleared returns if the "due" field was cleared in this mutation.
func (m *TaskHistoryMutation) DueCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldDue]
	return ok
}

// ResetDue resets all changes to the "due" field.
func (m *TaskHistoryMutation) ResetDue() {
	m.due = nil
	delete(m.clearedFields, taskhistory.FieldDue)
}

// SetCompleted sets the "completed" field.
func (m *TaskHistoryMutation) SetCompleted(t time.Time) {
	m.completed = &t
}

// Completed returns the value of the "completed" field in the mutation.
func (m *TaskHistoryMutation) Completed() (r time.Time, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the TaskHistory entity.
// If the TaskHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskHistoryMutation) OldCompleted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ClearCompleted clears the value of the "completed" field.
func (m *TaskHistoryMutation) ClearCompleted() {
	m.completed = nil
	m.clearedFields[taskhistory.FieldCompleted] = struct{}{}
}

// CompletedCleared returns if the "completed" field was cleared in this mutation.
func (m *TaskHistoryMutation) CompletedCleared() bool {
	_, ok := m.clearedFields[taskhistory.FieldCompleted]
	return ok
}

// ResetCompleted resets all changes to the "completed" field.
func (m *TaskHistoryMutation) ResetCompleted() {
	m.completed = nil
	delete(m.clearedFields, taskhistory.FieldCompleted)
}

// Where appends a list predicates to the TaskHistoryMutation builder.
func (m *TaskHistoryMutation) Where(ps ...predicate.TaskHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskHistory).
func (m *TaskHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, taskhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, taskhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, taskhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, taskhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, taskhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, taskhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, taskhistory.FieldMappingID)
	}
	if m.deleted_at != nil {
		fields = append(fields, taskhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, taskhistory.FieldDeletedBy)
	}
	if m.tags != nil {
		fields = append(fields, taskhistory.FieldTags)
	}
	if m.title != nil {
		fields = append(fields, taskhistory.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, taskhistory.FieldDescription)
	}
	if m.details != nil {
		fields = append(fields, taskhistory.FieldDetails)
	}
	if m.status != nil {
		fields = append(fields, taskhistory.FieldStatus)
	}
	if m.due != nil {
		fields = append(fields, taskhistory.FieldDue)
	}
	if m.completed != nil {
		fields = append(fields, taskhistory.FieldCompleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskhistory.FieldHistoryTime:
		return m.HistoryTime()
	case taskhistory.FieldRef:
		return m.Ref()
	case taskhistory.FieldOperation:
		return m.Operation()
	case taskhistory.FieldCreatedAt:
		return m.CreatedAt()
	case taskhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskhistory.FieldCreatedBy:
		return m.CreatedBy()
	case taskhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case taskhistory.FieldMappingID:
		return m.MappingID()
	case taskhistory.FieldDeletedAt:
		return m.DeletedAt()
	case taskhistory.FieldDeletedBy:
		return m.DeletedBy()
	case taskhistory.FieldTags:
		return m.Tags()
	case taskhistory.FieldTitle:
		return m.Title()
	case taskhistory.FieldDescription:
		return m.Description()
	case taskhistory.FieldDetails:
		return m.Details()
	case taskhistory.FieldStatus:
		return m.Status()
	case taskhistory.FieldDue:
		return m.Due()
	case taskhistory.FieldCompleted:
		return m.Completed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case taskhistory.FieldRef:
		return m.OldRef(ctx)
	case taskhistory.FieldOperation:
		return m.OldOperation(ctx)
	case taskhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case taskhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case taskhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case taskhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case taskhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case taskhistory.FieldTags:
		return m.OldTags(ctx)
	case taskhistory.FieldTitle:
		return m.OldTitle(ctx)
	case taskhistory.FieldDescription:
		return m.OldDescription(ctx)
	case taskhistory.FieldDetails:
		return m.OldDetails(ctx)
	case taskhistory.FieldStatus:
		return m.OldStatus(ctx)
	case taskhistory.FieldDue:
		return m.OldDue(ctx)
	case taskhistory.FieldCompleted:
		return m.OldCompleted(ctx)
	}
	return nil, fmt.Errorf("unknown TaskHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case taskhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case taskhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case taskhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case taskhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case taskhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case taskhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case taskhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case taskhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case taskhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case taskhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case taskhistory.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case taskhistory.FieldStatus:
		v, ok := value.(enums.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case taskhistory.FieldDue:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDue(v)
		return nil
	case taskhistory.FieldCompleted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	}
	return fmt.Errorf("unknown TaskHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskhistory.FieldRef) {
		fields = append(fields, taskhistory.FieldRef)
	}
	if m.FieldCleared(taskhistory.FieldCreatedAt) {
		fields = append(fields, taskhistory.FieldCreatedAt)
	}
	if m.FieldCleared(taskhistory.FieldUpdatedAt) {
		fields = append(fields, taskhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(taskhistory.FieldCreatedBy) {
		fields = append(fields, taskhistory.FieldCreatedBy)
	}
	if m.FieldCleared(taskhistory.FieldUpdatedBy) {
		fields = append(fields, taskhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(taskhistory.FieldDeletedAt) {
		fields = append(fields, taskhistory.FieldDeletedAt)
	}
	if m.FieldCleared(taskhistory.FieldDeletedBy) {
		fields = append(fields, taskhistory.FieldDeletedBy)
	}
	if m.FieldCleared(taskhistory.FieldTags) {
		fields = append(fields, taskhistory.FieldTags)
	}
	if m.FieldCleared(taskhistory.FieldDescription) {
		fields = append(fields, taskhistory.FieldDescription)
	}
	if m.FieldCleared(taskhistory.FieldDetails) {
		fields = append(fields, taskhistory.FieldDetails)
	}
	if m.FieldCleared(taskhistory.FieldDue) {
		fields = append(fields, taskhistory.FieldDue)
	}
	if m.FieldCleared(taskhistory.FieldCompleted) {
		fields = append(fields, taskhistory.FieldCompleted)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskHistoryMutation) ClearField(name string) error {
	switch name {
	case taskhistory.FieldRef:
		m.ClearRef()
		return nil
	case taskhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case taskhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case taskhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case taskhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case taskhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case taskhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case taskhistory.FieldTags:
		m.ClearTags()
		return nil
	case taskhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case taskhistory.FieldDetails:
		m.ClearDetails()
		return nil
	case taskhistory.FieldDue:
		m.ClearDue()
		return nil
	case taskhistory.FieldCompleted:
		m.ClearCompleted()
		return nil
	}
	return fmt.Errorf("unknown TaskHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskHistoryMutation) ResetField(name string) error {
	switch name {
	case taskhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case taskhistory.FieldRef:
		m.ResetRef()
		return nil
	case taskhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case taskhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case taskhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case taskhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case taskhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case taskhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case taskhistory.FieldTags:
		m.ResetTags()
		return nil
	case taskhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case taskhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case taskhistory.FieldDetails:
		m.ResetDetails()
		return nil
	case taskhistory.FieldStatus:
		m.ResetStatus()
		return nil
	case taskhistory.FieldDue:
		m.ResetDue()
		return nil
	case taskhistory.FieldCompleted:
		m.ResetCompleted()
		return nil
	}
	return fmt.Errorf("unknown TaskHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TaskHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TaskHistory edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	created_by       *string
	updated_by       *string
	deleted_at       *time.Time
	deleted_by       *string
	mapping_id       *string
	tags             *[]string
	appendtags       []string
	name             *string
	template_type    *enums.DocumentType
	description      *string
	jsonconfig       *customtypes.JSONObject
	uischema         *customtypes.JSONObject
	clearedFields    map[string]struct{}
	owner            *string
	clearedowner     bool
	documents        map[string]struct{}
	removeddocuments map[string]struct{}
	cleareddocuments bool
	files            map[string]struct{}
	removedfiles     map[string]struct{}
	clearedfiles     bool
	done             bool
	oldValue         func(context.Context) (*Template, error)
	predicates       []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id string) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Template entities.
func (m *TemplateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TemplateMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[template.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TemplateMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[template.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemplateMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, template.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TemplateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[template.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TemplateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[template.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, template.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TemplateMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TemplateMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TemplateMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[template.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TemplateMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[template.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TemplateMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, template.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TemplateMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TemplateMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TemplateMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[template.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TemplateMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[template.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TemplateMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, template.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TemplateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TemplateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TemplateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[template.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TemplateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[template.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TemplateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, template.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TemplateMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TemplateMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TemplateMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[template.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TemplateMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[template.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TemplateMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, template.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *TemplateMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *TemplateMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *TemplateMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *TemplateMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TemplateMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TemplateMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TemplateMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TemplateMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[template.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TemplateMutation) TagsCleared() bool {
	_, ok := m.clearedFields[template.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TemplateMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, template.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *TemplateMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TemplateMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *TemplateMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[template.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *TemplateMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[template.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TemplateMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, template.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetTemplateType sets the "template_type" field.
func (m *TemplateMutation) SetTemplateType(et enums.DocumentType) {
	m.template_type = &et
}

// TemplateType returns the value of the "template_type" field in the mutation.
func (m *TemplateMutation) TemplateType() (r enums.DocumentType, exists bool) {
	v := m.template_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateType returns the old "template_type" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldTemplateType(ctx context.Context) (v enums.DocumentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateType: %w", err)
	}
	return oldValue.TemplateType, nil
}

// ResetTemplateType resets all changes to the "template_type" field.
func (m *TemplateMutation) ResetTemplateType() {
	m.template_type = nil
}

// SetDescription sets the "description" field.
func (m *TemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[template.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[template.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, template.FieldDescription)
}

// SetJsonconfig sets the "jsonconfig" field.
func (m *TemplateMutation) SetJsonconfig(co customtypes.JSONObject) {
	m.jsonconfig = &co
}

// Jsonconfig returns the value of the "jsonconfig" field in the mutation.
func (m *TemplateMutation) Jsonconfig() (r customtypes.JSONObject, exists bool) {
	v := m.jsonconfig
	if v == nil {
		return
	}
	return *v, true
}

// OldJsonconfig returns the old "jsonconfig" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldJsonconfig(ctx context.Context) (v customtypes.JSONObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJsonconfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJsonconfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJsonconfig: %w", err)
	}
	return oldValue.Jsonconfig, nil
}

// ResetJsonconfig resets all changes to the "jsonconfig" field.
func (m *TemplateMutation) ResetJsonconfig() {
	m.jsonconfig = nil
}

// SetUischema sets the "uischema" field.
func (m *TemplateMutation) SetUischema(co customtypes.JSONObject) {
	m.uischema = &co
}

// Uischema returns the value of the "uischema" field in the mutation.
func (m *TemplateMutation) Uischema() (r customtypes.JSONObject, exists bool) {
	v := m.uischema
	if v == nil {
		return
	}
	return *v, true
}

// OldUischema returns the old "uischema" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldUischema(ctx context.Context) (v customtypes.JSONObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUischema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUischema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUischema: %w", err)
	}
	return oldValue.Uischema, nil
}

// ClearUischema clears the value of the "uischema" field.
func (m *TemplateMutation) ClearUischema() {
	m.uischema = nil
	m.clearedFields[template.FieldUischema] = struct{}{}
}

// UischemaCleared returns if the "uischema" field was cleared in this mutation.
func (m *TemplateMutation) UischemaCleared() bool {
	_, ok := m.clearedFields[template.FieldUischema]
	return ok
}

// ResetUischema resets all changes to the "uischema" field.
func (m *TemplateMutation) ResetUischema() {
	m.uischema = nil
	delete(m.clearedFields, template.FieldUischema)
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *TemplateMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[template.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *TemplateMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TemplateMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TemplateMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddDocumentIDs adds the "documents" edge to the DocumentData entity by ids.
func (m *TemplateMutation) AddDocumentIDs(ids ...string) {
	if m.documents == nil {
		m.documents = make(map[string]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the DocumentData entity.
func (m *TemplateMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the DocumentData entity was cleared.
func (m *TemplateMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the DocumentData entity by IDs.
func (m *TemplateMutation) RemoveDocumentIDs(ids ...string) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the DocumentData entity.
func (m *TemplateMutation) RemovedDocumentsIDs() (ids []string) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *TemplateMutation) DocumentsIDs() (ids []string) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *TemplateMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *TemplateMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *TemplateMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *TemplateMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *TemplateMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *TemplateMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *TemplateMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *TemplateMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, template.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, template.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, template.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, template.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, template.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, template.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, template.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, template.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, template.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.template_type != nil {
		fields = append(fields, template.FieldTemplateType)
	}
	if m.description != nil {
		fields = append(fields, template.FieldDescription)
	}
	if m.jsonconfig != nil {
		fields = append(fields, template.FieldJsonconfig)
	}
	if m.uischema != nil {
		fields = append(fields, template.FieldUischema)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldCreatedAt:
		return m.CreatedAt()
	case template.FieldUpdatedAt:
		return m.UpdatedAt()
	case template.FieldCreatedBy:
		return m.CreatedBy()
	case template.FieldUpdatedBy:
		return m.UpdatedBy()
	case template.FieldDeletedAt:
		return m.DeletedAt()
	case template.FieldDeletedBy:
		return m.DeletedBy()
	case template.FieldMappingID:
		return m.MappingID()
	case template.FieldTags:
		return m.Tags()
	case template.FieldOwnerID:
		return m.OwnerID()
	case template.FieldName:
		return m.Name()
	case template.FieldTemplateType:
		return m.TemplateType()
	case template.FieldDescription:
		return m.Description()
	case template.FieldJsonconfig:
		return m.Jsonconfig()
	case template.FieldUischema:
		return m.Uischema()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case template.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case template.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case template.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case template.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case template.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case template.FieldMappingID:
		return m.OldMappingID(ctx)
	case template.FieldTags:
		return m.OldTags(ctx)
	case template.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldTemplateType:
		return m.OldTemplateType(ctx)
	case template.FieldDescription:
		return m.OldDescription(ctx)
	case template.FieldJsonconfig:
		return m.OldJsonconfig(ctx)
	case template.FieldUischema:
		return m.OldUischema(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case template.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case template.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case template.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case template.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case template.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case template.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case template.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case template.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldTemplateType:
		v, ok := value.(enums.DocumentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateType(v)
		return nil
	case template.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case template.FieldJsonconfig:
		v, ok := value.(customtypes.JSONObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJsonconfig(v)
		return nil
	case template.FieldUischema:
		v, ok := value.(customtypes.JSONObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUischema(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldCreatedAt) {
		fields = append(fields, template.FieldCreatedAt)
	}
	if m.FieldCleared(template.FieldUpdatedAt) {
		fields = append(fields, template.FieldUpdatedAt)
	}
	if m.FieldCleared(template.FieldCreatedBy) {
		fields = append(fields, template.FieldCreatedBy)
	}
	if m.FieldCleared(template.FieldUpdatedBy) {
		fields = append(fields, template.FieldUpdatedBy)
	}
	if m.FieldCleared(template.FieldDeletedAt) {
		fields = append(fields, template.FieldDeletedAt)
	}
	if m.FieldCleared(template.FieldDeletedBy) {
		fields = append(fields, template.FieldDeletedBy)
	}
	if m.FieldCleared(template.FieldTags) {
		fields = append(fields, template.FieldTags)
	}
	if m.FieldCleared(template.FieldOwnerID) {
		fields = append(fields, template.FieldOwnerID)
	}
	if m.FieldCleared(template.FieldDescription) {
		fields = append(fields, template.FieldDescription)
	}
	if m.FieldCleared(template.FieldUischema) {
		fields = append(fields, template.FieldUischema)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case template.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case template.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case template.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case template.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case template.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case template.FieldTags:
		m.ClearTags()
		return nil
	case template.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case template.FieldDescription:
		m.ClearDescription()
		return nil
	case template.FieldUischema:
		m.ClearUischema()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case template.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case template.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case template.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case template.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case template.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case template.FieldMappingID:
		m.ResetMappingID()
		return nil
	case template.FieldTags:
		m.ResetTags()
		return nil
	case template.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldTemplateType:
		m.ResetTemplateType()
		return nil
	case template.FieldDescription:
		m.ResetDescription()
		return nil
	case template.FieldJsonconfig:
		m.ResetJsonconfig()
		return nil
	case template.FieldUischema:
		m.ResetUischema()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, template.EdgeOwner)
	}
	if m.documents != nil {
		edges = append(edges, template.EdgeDocuments)
	}
	if m.files != nil {
		edges = append(edges, template.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case template.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case template.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddocuments != nil {
		edges = append(edges, template.EdgeDocuments)
	}
	if m.removedfiles != nil {
		edges = append(edges, template.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case template.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case template.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, template.EdgeOwner)
	}
	if m.cleareddocuments {
		edges = append(edges, template.EdgeDocuments)
	}
	if m.clearedfiles {
		edges = append(edges, template.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case template.EdgeOwner:
		return m.clearedowner
	case template.EdgeDocuments:
		return m.cleareddocuments
	case template.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	switch name {
	case template.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	switch name {
	case template.EdgeOwner:
		m.ResetOwner()
		return nil
	case template.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case template.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Template edge %s", name)
}

// TemplateHistoryMutation represents an operation that mutates the TemplateHistory nodes in the graph.
type TemplateHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	history_time  *time.Time
	ref           *string
	operation     *history.OpType
	created_at    *time.Time
	updated_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_at    *time.Time
	deleted_by    *string
	mapping_id    *string
	tags          *[]string
	appendtags    []string
	owner_id      *string
	name          *string
	template_type *enums.DocumentType
	description   *string
	jsonconfig    *customtypes.JSONObject
	uischema      *customtypes.JSONObject
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TemplateHistory, error)
	predicates    []predicate.TemplateHistory
}

var _ ent.Mutation = (*TemplateHistoryMutation)(nil)

// templatehistoryOption allows management of the mutation configuration using functional options.
type templatehistoryOption func(*TemplateHistoryMutation)

// newTemplateHistoryMutation creates new mutation for the TemplateHistory entity.
func newTemplateHistoryMutation(c config, op Op, opts ...templatehistoryOption) *TemplateHistoryMutation {
	m := &TemplateHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplateHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateHistoryID sets the ID field of the mutation.
func withTemplateHistoryID(id string) templatehistoryOption {
	return func(m *TemplateHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TemplateHistory
		)
		m.oldValue = func(ctx context.Context) (*TemplateHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemplateHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplateHistory sets the old TemplateHistory of the mutation.
func withTemplateHistory(node *TemplateHistory) templatehistoryOption {
	return func(m *TemplateHistoryMutation) {
		m.oldValue = func(context.Context) (*TemplateHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemplateHistory entities.
func (m *TemplateHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemplateHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *TemplateHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *TemplateHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *TemplateHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *TemplateHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *TemplateHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *TemplateHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[templatehistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *TemplateHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *TemplateHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, templatehistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *TemplateHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *TemplateHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *TemplateHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TemplateHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemplateHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TemplateHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[templatehistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TemplateHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemplateHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, templatehistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TemplateHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TemplateHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TemplateHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[templatehistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TemplateHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TemplateHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, templatehistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *TemplateHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TemplateHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TemplateHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[templatehistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TemplateHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TemplateHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, templatehistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TemplateHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TemplateHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TemplateHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[templatehistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TemplateHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TemplateHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, templatehistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TemplateHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TemplateHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TemplateHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[templatehistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TemplateHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TemplateHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, templatehistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TemplateHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TemplateHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TemplateHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[templatehistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TemplateHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TemplateHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, templatehistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *TemplateHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *TemplateHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *TemplateHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *TemplateHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *TemplateHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *TemplateHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *TemplateHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *TemplateHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[templatehistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *TemplateHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *TemplateHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, templatehistory.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *TemplateHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TemplateHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *TemplateHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[templatehistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *TemplateHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TemplateHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, templatehistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *TemplateHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateHistoryMutation) ResetName() {
	m.name = nil
}

// SetTemplateType sets the "template_type" field.
func (m *TemplateHistoryMutation) SetTemplateType(et enums.DocumentType) {
	m.template_type = &et
}

// TemplateType returns the value of the "template_type" field in the mutation.
func (m *TemplateHistoryMutation) TemplateType() (r enums.DocumentType, exists bool) {
	v := m.template_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateType returns the old "template_type" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldTemplateType(ctx context.Context) (v enums.DocumentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateType: %w", err)
	}
	return oldValue.TemplateType, nil
}

// ResetTemplateType resets all changes to the "template_type" field.
func (m *TemplateHistoryMutation) ResetTemplateType() {
	m.template_type = nil
}

// SetDescription sets the "description" field.
func (m *TemplateHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemplateHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemplateHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[templatehistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemplateHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemplateHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, templatehistory.FieldDescription)
}

// SetJsonconfig sets the "jsonconfig" field.
func (m *TemplateHistoryMutation) SetJsonconfig(co customtypes.JSONObject) {
	m.jsonconfig = &co
}

// Jsonconfig returns the value of the "jsonconfig" field in the mutation.
func (m *TemplateHistoryMutation) Jsonconfig() (r customtypes.JSONObject, exists bool) {
	v := m.jsonconfig
	if v == nil {
		return
	}
	return *v, true
}

// OldJsonconfig returns the old "jsonconfig" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldJsonconfig(ctx context.Context) (v customtypes.JSONObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJsonconfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJsonconfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJsonconfig: %w", err)
	}
	return oldValue.Jsonconfig, nil
}

// ResetJsonconfig resets all changes to the "jsonconfig" field.
func (m *TemplateHistoryMutation) ResetJsonconfig() {
	m.jsonconfig = nil
}

// SetUischema sets the "uischema" field.
func (m *TemplateHistoryMutation) SetUischema(co customtypes.JSONObject) {
	m.uischema = &co
}

// Uischema returns the value of the "uischema" field in the mutation.
func (m *TemplateHistoryMutation) Uischema() (r customtypes.JSONObject, exists bool) {
	v := m.uischema
	if v == nil {
		return
	}
	return *v, true
}

// OldUischema returns the old "uischema" field's value of the TemplateHistory entity.
// If the TemplateHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateHistoryMutation) OldUischema(ctx context.Context) (v customtypes.JSONObject, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUischema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUischema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUischema: %w", err)
	}
	return oldValue.Uischema, nil
}

// ClearUischema clears the value of the "uischema" field.
func (m *TemplateHistoryMutation) ClearUischema() {
	m.uischema = nil
	m.clearedFields[templatehistory.FieldUischema] = struct{}{}
}

// UischemaCleared returns if the "uischema" field was cleared in this mutation.
func (m *TemplateHistoryMutation) UischemaCleared() bool {
	_, ok := m.clearedFields[templatehistory.FieldUischema]
	return ok
}

// ResetUischema resets all changes to the "uischema" field.
func (m *TemplateHistoryMutation) ResetUischema() {
	m.uischema = nil
	delete(m.clearedFields, templatehistory.FieldUischema)
}

// Where appends a list predicates to the TemplateHistoryMutation builder.
func (m *TemplateHistoryMutation) Where(ps ...predicate.TemplateHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemplateHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemplateHistory).
func (m *TemplateHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateHistoryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.history_time != nil {
		fields = append(fields, templatehistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, templatehistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, templatehistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, templatehistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, templatehistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, templatehistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, templatehistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, templatehistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, templatehistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, templatehistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, templatehistory.FieldTags)
	}
	if m.owner_id != nil {
		fields = append(fields, templatehistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, templatehistory.FieldName)
	}
	if m.template_type != nil {
		fields = append(fields, templatehistory.FieldTemplateType)
	}
	if m.description != nil {
		fields = append(fields, templatehistory.FieldDescription)
	}
	if m.jsonconfig != nil {
		fields = append(fields, templatehistory.FieldJsonconfig)
	}
	if m.uischema != nil {
		fields = append(fields, templatehistory.FieldUischema)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case templatehistory.FieldHistoryTime:
		return m.HistoryTime()
	case templatehistory.FieldRef:
		return m.Ref()
	case templatehistory.FieldOperation:
		return m.Operation()
	case templatehistory.FieldCreatedAt:
		return m.CreatedAt()
	case templatehistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case templatehistory.FieldCreatedBy:
		return m.CreatedBy()
	case templatehistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case templatehistory.FieldDeletedAt:
		return m.DeletedAt()
	case templatehistory.FieldDeletedBy:
		return m.DeletedBy()
	case templatehistory.FieldMappingID:
		return m.MappingID()
	case templatehistory.FieldTags:
		return m.Tags()
	case templatehistory.FieldOwnerID:
		return m.OwnerID()
	case templatehistory.FieldName:
		return m.Name()
	case templatehistory.FieldTemplateType:
		return m.TemplateType()
	case templatehistory.FieldDescription:
		return m.Description()
	case templatehistory.FieldJsonconfig:
		return m.Jsonconfig()
	case templatehistory.FieldUischema:
		return m.Uischema()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case templatehistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case templatehistory.FieldRef:
		return m.OldRef(ctx)
	case templatehistory.FieldOperation:
		return m.OldOperation(ctx)
	case templatehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case templatehistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case templatehistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case templatehistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case templatehistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case templatehistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case templatehistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case templatehistory.FieldTags:
		return m.OldTags(ctx)
	case templatehistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case templatehistory.FieldName:
		return m.OldName(ctx)
	case templatehistory.FieldTemplateType:
		return m.OldTemplateType(ctx)
	case templatehistory.FieldDescription:
		return m.OldDescription(ctx)
	case templatehistory.FieldJsonconfig:
		return m.OldJsonconfig(ctx)
	case templatehistory.FieldUischema:
		return m.OldUischema(ctx)
	}
	return nil, fmt.Errorf("unknown TemplateHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case templatehistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case templatehistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case templatehistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case templatehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case templatehistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case templatehistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case templatehistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case templatehistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case templatehistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case templatehistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case templatehistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case templatehistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case templatehistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case templatehistory.FieldTemplateType:
		v, ok := value.(enums.DocumentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateType(v)
		return nil
	case templatehistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case templatehistory.FieldJsonconfig:
		v, ok := value.(customtypes.JSONObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJsonconfig(v)
		return nil
	case templatehistory.FieldUischema:
		v, ok := value.(customtypes.JSONObject)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUischema(v)
		return nil
	}
	return fmt.Errorf("unknown TemplateHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TemplateHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(templatehistory.FieldRef) {
		fields = append(fields, templatehistory.FieldRef)
	}
	if m.FieldCleared(templatehistory.FieldCreatedAt) {
		fields = append(fields, templatehistory.FieldCreatedAt)
	}
	if m.FieldCleared(templatehistory.FieldUpdatedAt) {
		fields = append(fields, templatehistory.FieldUpdatedAt)
	}
	if m.FieldCleared(templatehistory.FieldCreatedBy) {
		fields = append(fields, templatehistory.FieldCreatedBy)
	}
	if m.FieldCleared(templatehistory.FieldUpdatedBy) {
		fields = append(fields, templatehistory.FieldUpdatedBy)
	}
	if m.FieldCleared(templatehistory.FieldDeletedAt) {
		fields = append(fields, templatehistory.FieldDeletedAt)
	}
	if m.FieldCleared(templatehistory.FieldDeletedBy) {
		fields = append(fields, templatehistory.FieldDeletedBy)
	}
	if m.FieldCleared(templatehistory.FieldTags) {
		fields = append(fields, templatehistory.FieldTags)
	}
	if m.FieldCleared(templatehistory.FieldOwnerID) {
		fields = append(fields, templatehistory.FieldOwnerID)
	}
	if m.FieldCleared(templatehistory.FieldDescription) {
		fields = append(fields, templatehistory.FieldDescription)
	}
	if m.FieldCleared(templatehistory.FieldUischema) {
		fields = append(fields, templatehistory.FieldUischema)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateHistoryMutation) ClearField(name string) error {
	switch name {
	case templatehistory.FieldRef:
		m.ClearRef()
		return nil
	case templatehistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case templatehistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case templatehistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case templatehistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case templatehistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case templatehistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case templatehistory.FieldTags:
		m.ClearTags()
		return nil
	case templatehistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case templatehistory.FieldDescription:
		m.ClearDescription()
		return nil
	case templatehistory.FieldUischema:
		m.ClearUischema()
		return nil
	}
	return fmt.Errorf("unknown TemplateHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateHistoryMutation) ResetField(name string) error {
	switch name {
	case templatehistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case templatehistory.FieldRef:
		m.ResetRef()
		return nil
	case templatehistory.FieldOperation:
		m.ResetOperation()
		return nil
	case templatehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case templatehistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case templatehistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case templatehistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case templatehistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case templatehistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case templatehistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case templatehistory.FieldTags:
		m.ResetTags()
		return nil
	case templatehistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case templatehistory.FieldName:
		m.ResetName()
		return nil
	case templatehistory.FieldTemplateType:
		m.ResetTemplateType()
		return nil
	case templatehistory.FieldDescription:
		m.ResetDescription()
		return nil
	case templatehistory.FieldJsonconfig:
		m.ResetJsonconfig()
		return nil
	case templatehistory.FieldUischema:
		m.ResetUischema()
		return nil
	}
	return fmt.Errorf("unknown TemplateHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TemplateHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TemplateHistory edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	created_at                       *time.Time
	updated_at                       *time.Time
	created_by                       *string
	updated_by                       *string
	deleted_at                       *time.Time
	deleted_by                       *string
	mapping_id                       *string
	tags                             *[]string
	appendtags                       []string
	email                            *string
	first_name                       *string
	last_name                        *string
	display_name                     *string
	avatar_remote_url                *string
	avatar_local_file                *string
	avatar_updated_at                *time.Time
	last_seen                        *time.Time
	password                         *string
	sub                              *string
	auth_provider                    *enums.AuthProvider
	role                             *enums.Role
	clearedFields                    map[string]struct{}
	personal_access_tokens           map[string]struct{}
	removedpersonal_access_tokens    map[string]struct{}
	clearedpersonal_access_tokens    bool
	tfa_settings                     map[string]struct{}
	removedtfa_settings              map[string]struct{}
	clearedtfa_settings              bool
	setting                          *string
	clearedsetting                   bool
	email_verification_tokens        map[string]struct{}
	removedemail_verification_tokens map[string]struct{}
	clearedemail_verification_tokens bool
	password_reset_tokens            map[string]struct{}
	removedpassword_reset_tokens     map[string]struct{}
	clearedpassword_reset_tokens     bool
	groups                           map[string]struct{}
	removedgroups                    map[string]struct{}
	clearedgroups                    bool
	organizations                    map[string]struct{}
	removedorganizations             map[string]struct{}
	clearedorganizations             bool
	webauthn                         map[string]struct{}
	removedwebauthn                  map[string]struct{}
	clearedwebauthn                  bool
	files                            map[string]struct{}
	removedfiles                     map[string]struct{}
	clearedfiles                     bool
	file                             *string
	clearedfile                      bool
	events                           map[string]struct{}
	removedevents                    map[string]struct{}
	clearedevents                    bool
	actionplans                      map[string]struct{}
	removedactionplans               map[string]struct{}
	clearedactionplans               bool
	subcontrols                      map[string]struct{}
	removedsubcontrols               map[string]struct{}
	clearedsubcontrols               bool
	assigner_tasks                   map[string]struct{}
	removedassigner_tasks            map[string]struct{}
	clearedassigner_tasks            bool
	assignee_tasks                   map[string]struct{}
	removedassignee_tasks            map[string]struct{}
	clearedassignee_tasks            bool
	programs                         map[string]struct{}
	removedprograms                  map[string]struct{}
	clearedprograms                  bool
	group_memberships                map[string]struct{}
	removedgroup_memberships         map[string]struct{}
	clearedgroup_memberships         bool
	org_memberships                  map[string]struct{}
	removedorg_memberships           map[string]struct{}
	clearedorg_memberships           bool
	done                             bool
	oldValue                         func(context.Context) (*User, error)
	predicates                       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[user.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, user.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[user.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, user.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *UserMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *UserMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *UserMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *UserMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *UserMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *UserMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *UserMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *UserMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[user.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *UserMutation) TagsCleared() bool {
	_, ok := m.clearedFields[user.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *UserMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, user.FieldTags)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetAvatarRemoteURL sets the "avatar_remote_url" field.
func (m *UserMutation) SetAvatarRemoteURL(s string) {
	m.avatar_remote_url = &s
}

// AvatarRemoteURL returns the value of the "avatar_remote_url" field in the mutation.
func (m *UserMutation) AvatarRemoteURL() (r string, exists bool) {
	v := m.avatar_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarRemoteURL returns the old "avatar_remote_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarRemoteURL: %w", err)
	}
	return oldValue.AvatarRemoteURL, nil
}

// ClearAvatarRemoteURL clears the value of the "avatar_remote_url" field.
func (m *UserMutation) ClearAvatarRemoteURL() {
	m.avatar_remote_url = nil
	m.clearedFields[user.FieldAvatarRemoteURL] = struct{}{}
}

// AvatarRemoteURLCleared returns if the "avatar_remote_url" field was cleared in this mutation.
func (m *UserMutation) AvatarRemoteURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarRemoteURL]
	return ok
}

// ResetAvatarRemoteURL resets all changes to the "avatar_remote_url" field.
func (m *UserMutation) ResetAvatarRemoteURL() {
	m.avatar_remote_url = nil
	delete(m.clearedFields, user.FieldAvatarRemoteURL)
}

// SetAvatarLocalFile sets the "avatar_local_file" field.
func (m *UserMutation) SetAvatarLocalFile(s string) {
	m.avatar_local_file = &s
}

// AvatarLocalFile returns the value of the "avatar_local_file" field in the mutation.
func (m *UserMutation) AvatarLocalFile() (r string, exists bool) {
	v := m.avatar_local_file
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarLocalFile returns the old "avatar_local_file" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarLocalFile(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarLocalFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarLocalFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarLocalFile: %w", err)
	}
	return oldValue.AvatarLocalFile, nil
}

// ClearAvatarLocalFile clears the value of the "avatar_local_file" field.
func (m *UserMutation) ClearAvatarLocalFile() {
	m.avatar_local_file = nil
	m.clearedFields[user.FieldAvatarLocalFile] = struct{}{}
}

// AvatarLocalFileCleared returns if the "avatar_local_file" field was cleared in this mutation.
func (m *UserMutation) AvatarLocalFileCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarLocalFile]
	return ok
}

// ResetAvatarLocalFile resets all changes to the "avatar_local_file" field.
func (m *UserMutation) ResetAvatarLocalFile() {
	m.avatar_local_file = nil
	delete(m.clearedFields, user.FieldAvatarLocalFile)
}

// SetAvatarLocalFileID sets the "avatar_local_file_id" field.
func (m *UserMutation) SetAvatarLocalFileID(s string) {
	m.file = &s
}

// AvatarLocalFileID returns the value of the "avatar_local_file_id" field in the mutation.
func (m *UserMutation) AvatarLocalFileID() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarLocalFileID returns the old "avatar_local_file_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarLocalFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarLocalFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarLocalFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarLocalFileID: %w", err)
	}
	return oldValue.AvatarLocalFileID, nil
}

// ClearAvatarLocalFileID clears the value of the "avatar_local_file_id" field.
func (m *UserMutation) ClearAvatarLocalFileID() {
	m.file = nil
	m.clearedFields[user.FieldAvatarLocalFileID] = struct{}{}
}

// AvatarLocalFileIDCleared returns if the "avatar_local_file_id" field was cleared in this mutation.
func (m *UserMutation) AvatarLocalFileIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarLocalFileID]
	return ok
}

// ResetAvatarLocalFileID resets all changes to the "avatar_local_file_id" field.
func (m *UserMutation) ResetAvatarLocalFileID() {
	m.file = nil
	delete(m.clearedFields, user.FieldAvatarLocalFileID)
}

// SetAvatarUpdatedAt sets the "avatar_updated_at" field.
func (m *UserMutation) SetAvatarUpdatedAt(t time.Time) {
	m.avatar_updated_at = &t
}

// AvatarUpdatedAt returns the value of the "avatar_updated_at" field in the mutation.
func (m *UserMutation) AvatarUpdatedAt() (r time.Time, exists bool) {
	v := m.avatar_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarUpdatedAt returns the old "avatar_updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarUpdatedAt: %w", err)
	}
	return oldValue.AvatarUpdatedAt, nil
}

// ClearAvatarUpdatedAt clears the value of the "avatar_updated_at" field.
func (m *UserMutation) ClearAvatarUpdatedAt() {
	m.avatar_updated_at = nil
	m.clearedFields[user.FieldAvatarUpdatedAt] = struct{}{}
}

// AvatarUpdatedAtCleared returns if the "avatar_updated_at" field was cleared in this mutation.
func (m *UserMutation) AvatarUpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarUpdatedAt]
	return ok
}

// ResetAvatarUpdatedAt resets all changes to the "avatar_updated_at" field.
func (m *UserMutation) ResetAvatarUpdatedAt() {
	m.avatar_updated_at = nil
	delete(m.clearedFields, user.FieldAvatarUpdatedAt)
}

// SetLastSeen sets the "last_seen" field.
func (m *UserMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *UserMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *UserMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[user.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *UserMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[user.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *UserMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, user.FieldLastSeen)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetSub sets the "sub" field.
func (m *UserMutation) SetSub(s string) {
	m.sub = &s
}

// Sub returns the value of the "sub" field in the mutation.
func (m *UserMutation) Sub() (r string, exists bool) {
	v := m.sub
	if v == nil {
		return
	}
	return *v, true
}

// OldSub returns the old "sub" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSub: %w", err)
	}
	return oldValue.Sub, nil
}

// ClearSub clears the value of the "sub" field.
func (m *UserMutation) ClearSub() {
	m.sub = nil
	m.clearedFields[user.FieldSub] = struct{}{}
}

// SubCleared returns if the "sub" field was cleared in this mutation.
func (m *UserMutation) SubCleared() bool {
	_, ok := m.clearedFields[user.FieldSub]
	return ok
}

// ResetSub resets all changes to the "sub" field.
func (m *UserMutation) ResetSub() {
	m.sub = nil
	delete(m.clearedFields, user.FieldSub)
}

// SetAuthProvider sets the "auth_provider" field.
func (m *UserMutation) SetAuthProvider(ep enums.AuthProvider) {
	m.auth_provider = &ep
}

// AuthProvider returns the value of the "auth_provider" field in the mutation.
func (m *UserMutation) AuthProvider() (r enums.AuthProvider, exists bool) {
	v := m.auth_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthProvider returns the old "auth_provider" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAuthProvider(ctx context.Context) (v enums.AuthProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthProvider: %w", err)
	}
	return oldValue.AuthProvider, nil
}

// ResetAuthProvider resets all changes to the "auth_provider" field.
func (m *UserMutation) ResetAuthProvider() {
	m.auth_provider = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *UserMutation) ClearRole() {
	m.role = nil
	m.clearedFields[user.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *UserMutation) RoleCleared() bool {
	_, ok := m.clearedFields[user.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, user.FieldRole)
}

// AddPersonalAccessTokenIDs adds the "personal_access_tokens" edge to the PersonalAccessToken entity by ids.
func (m *UserMutation) AddPersonalAccessTokenIDs(ids ...string) {
	if m.personal_access_tokens == nil {
		m.personal_access_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.personal_access_tokens[ids[i]] = struct{}{}
	}
}

// ClearPersonalAccessTokens clears the "personal_access_tokens" edge to the PersonalAccessToken entity.
func (m *UserMutation) ClearPersonalAccessTokens() {
	m.clearedpersonal_access_tokens = true
}

// PersonalAccessTokensCleared reports if the "personal_access_tokens" edge to the PersonalAccessToken entity was cleared.
func (m *UserMutation) PersonalAccessTokensCleared() bool {
	return m.clearedpersonal_access_tokens
}

// RemovePersonalAccessTokenIDs removes the "personal_access_tokens" edge to the PersonalAccessToken entity by IDs.
func (m *UserMutation) RemovePersonalAccessTokenIDs(ids ...string) {
	if m.removedpersonal_access_tokens == nil {
		m.removedpersonal_access_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.personal_access_tokens, ids[i])
		m.removedpersonal_access_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPersonalAccessTokens returns the removed IDs of the "personal_access_tokens" edge to the PersonalAccessToken entity.
func (m *UserMutation) RemovedPersonalAccessTokensIDs() (ids []string) {
	for id := range m.removedpersonal_access_tokens {
		ids = append(ids, id)
	}
	return
}

// PersonalAccessTokensIDs returns the "personal_access_tokens" edge IDs in the mutation.
func (m *UserMutation) PersonalAccessTokensIDs() (ids []string) {
	for id := range m.personal_access_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPersonalAccessTokens resets all changes to the "personal_access_tokens" edge.
func (m *UserMutation) ResetPersonalAccessTokens() {
	m.personal_access_tokens = nil
	m.clearedpersonal_access_tokens = false
	m.removedpersonal_access_tokens = nil
}

// AddTfaSettingIDs adds the "tfa_settings" edge to the TFASetting entity by ids.
func (m *UserMutation) AddTfaSettingIDs(ids ...string) {
	if m.tfa_settings == nil {
		m.tfa_settings = make(map[string]struct{})
	}
	for i := range ids {
		m.tfa_settings[ids[i]] = struct{}{}
	}
}

// ClearTfaSettings clears the "tfa_settings" edge to the TFASetting entity.
func (m *UserMutation) ClearTfaSettings() {
	m.clearedtfa_settings = true
}

// TfaSettingsCleared reports if the "tfa_settings" edge to the TFASetting entity was cleared.
func (m *UserMutation) TfaSettingsCleared() bool {
	return m.clearedtfa_settings
}

// RemoveTfaSettingIDs removes the "tfa_settings" edge to the TFASetting entity by IDs.
func (m *UserMutation) RemoveTfaSettingIDs(ids ...string) {
	if m.removedtfa_settings == nil {
		m.removedtfa_settings = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tfa_settings, ids[i])
		m.removedtfa_settings[ids[i]] = struct{}{}
	}
}

// RemovedTfaSettings returns the removed IDs of the "tfa_settings" edge to the TFASetting entity.
func (m *UserMutation) RemovedTfaSettingsIDs() (ids []string) {
	for id := range m.removedtfa_settings {
		ids = append(ids, id)
	}
	return
}

// TfaSettingsIDs returns the "tfa_settings" edge IDs in the mutation.
func (m *UserMutation) TfaSettingsIDs() (ids []string) {
	for id := range m.tfa_settings {
		ids = append(ids, id)
	}
	return
}

// ResetTfaSettings resets all changes to the "tfa_settings" edge.
func (m *UserMutation) ResetTfaSettings() {
	m.tfa_settings = nil
	m.clearedtfa_settings = false
	m.removedtfa_settings = nil
}

// SetSettingID sets the "setting" edge to the UserSetting entity by id.
func (m *UserMutation) SetSettingID(id string) {
	m.setting = &id
}

// ClearSetting clears the "setting" edge to the UserSetting entity.
func (m *UserMutation) ClearSetting() {
	m.clearedsetting = true
}

// SettingCleared reports if the "setting" edge to the UserSetting entity was cleared.
func (m *UserMutation) SettingCleared() bool {
	return m.clearedsetting
}

// SettingID returns the "setting" edge ID in the mutation.
func (m *UserMutation) SettingID() (id string, exists bool) {
	if m.setting != nil {
		return *m.setting, true
	}
	return
}

// SettingIDs returns the "setting" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SettingIDs() (ids []string) {
	if id := m.setting; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSetting resets all changes to the "setting" edge.
func (m *UserMutation) ResetSetting() {
	m.setting = nil
	m.clearedsetting = false
}

// AddEmailVerificationTokenIDs adds the "email_verification_tokens" edge to the EmailVerificationToken entity by ids.
func (m *UserMutation) AddEmailVerificationTokenIDs(ids ...string) {
	if m.email_verification_tokens == nil {
		m.email_verification_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.email_verification_tokens[ids[i]] = struct{}{}
	}
}

// ClearEmailVerificationTokens clears the "email_verification_tokens" edge to the EmailVerificationToken entity.
func (m *UserMutation) ClearEmailVerificationTokens() {
	m.clearedemail_verification_tokens = true
}

// EmailVerificationTokensCleared reports if the "email_verification_tokens" edge to the EmailVerificationToken entity was cleared.
func (m *UserMutation) EmailVerificationTokensCleared() bool {
	return m.clearedemail_verification_tokens
}

// RemoveEmailVerificationTokenIDs removes the "email_verification_tokens" edge to the EmailVerificationToken entity by IDs.
func (m *UserMutation) RemoveEmailVerificationTokenIDs(ids ...string) {
	if m.removedemail_verification_tokens == nil {
		m.removedemail_verification_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.email_verification_tokens, ids[i])
		m.removedemail_verification_tokens[ids[i]] = struct{}{}
	}
}

// RemovedEmailVerificationTokens returns the removed IDs of the "email_verification_tokens" edge to the EmailVerificationToken entity.
func (m *UserMutation) RemovedEmailVerificationTokensIDs() (ids []string) {
	for id := range m.removedemail_verification_tokens {
		ids = append(ids, id)
	}
	return
}

// EmailVerificationTokensIDs returns the "email_verification_tokens" edge IDs in the mutation.
func (m *UserMutation) EmailVerificationTokensIDs() (ids []string) {
	for id := range m.email_verification_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetEmailVerificationTokens resets all changes to the "email_verification_tokens" edge.
func (m *UserMutation) ResetEmailVerificationTokens() {
	m.email_verification_tokens = nil
	m.clearedemail_verification_tokens = false
	m.removedemail_verification_tokens = nil
}

// AddPasswordResetTokenIDs adds the "password_reset_tokens" edge to the PasswordResetToken entity by ids.
func (m *UserMutation) AddPasswordResetTokenIDs(ids ...string) {
	if m.password_reset_tokens == nil {
		m.password_reset_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.password_reset_tokens[ids[i]] = struct{}{}
	}
}

// ClearPasswordResetTokens clears the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) ClearPasswordResetTokens() {
	m.clearedpassword_reset_tokens = true
}

// PasswordResetTokensCleared reports if the "password_reset_tokens" edge to the PasswordResetToken entity was cleared.
func (m *UserMutation) PasswordResetTokensCleared() bool {
	return m.clearedpassword_reset_tokens
}

// RemovePasswordResetTokenIDs removes the "password_reset_tokens" edge to the PasswordResetToken entity by IDs.
func (m *UserMutation) RemovePasswordResetTokenIDs(ids ...string) {
	if m.removedpassword_reset_tokens == nil {
		m.removedpassword_reset_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.password_reset_tokens, ids[i])
		m.removedpassword_reset_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPasswordResetTokens returns the removed IDs of the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) RemovedPasswordResetTokensIDs() (ids []string) {
	for id := range m.removedpassword_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// PasswordResetTokensIDs returns the "password_reset_tokens" edge IDs in the mutation.
func (m *UserMutation) PasswordResetTokensIDs() (ids []string) {
	for id := range m.password_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPasswordResetTokens resets all changes to the "password_reset_tokens" edge.
func (m *UserMutation) ResetPasswordResetTokens() {
	m.password_reset_tokens = nil
	m.clearedpassword_reset_tokens = false
	m.removedpassword_reset_tokens = nil
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *UserMutation) AddGroupIDs(ids ...string) {
	if m.groups == nil {
		m.groups = make(map[string]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *UserMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *UserMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *UserMutation) RemoveGroupIDs(ids ...string) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *UserMutation) RemovedGroupsIDs() (ids []string) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *UserMutation) GroupsIDs() (ids []string) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *UserMutation) AddOrganizationIDs(ids ...string) {
	if m.organizations == nil {
		m.organizations = make(map[string]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *UserMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *UserMutation) RemovedOrganizationsIDs() (ids []string) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *UserMutation) OrganizationsIDs() (ids []string) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *UserMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddWebauthnIDs adds the "webauthn" edge to the Webauthn entity by ids.
func (m *UserMutation) AddWebauthnIDs(ids ...string) {
	if m.webauthn == nil {
		m.webauthn = make(map[string]struct{})
	}
	for i := range ids {
		m.webauthn[ids[i]] = struct{}{}
	}
}

// ClearWebauthn clears the "webauthn" edge to the Webauthn entity.
func (m *UserMutation) ClearWebauthn() {
	m.clearedwebauthn = true
}

// WebauthnCleared reports if the "webauthn" edge to the Webauthn entity was cleared.
func (m *UserMutation) WebauthnCleared() bool {
	return m.clearedwebauthn
}

// RemoveWebauthnIDs removes the "webauthn" edge to the Webauthn entity by IDs.
func (m *UserMutation) RemoveWebauthnIDs(ids ...string) {
	if m.removedwebauthn == nil {
		m.removedwebauthn = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.webauthn, ids[i])
		m.removedwebauthn[ids[i]] = struct{}{}
	}
}

// RemovedWebauthn returns the removed IDs of the "webauthn" edge to the Webauthn entity.
func (m *UserMutation) RemovedWebauthnIDs() (ids []string) {
	for id := range m.removedwebauthn {
		ids = append(ids, id)
	}
	return
}

// WebauthnIDs returns the "webauthn" edge IDs in the mutation.
func (m *UserMutation) WebauthnIDs() (ids []string) {
	for id := range m.webauthn {
		ids = append(ids, id)
	}
	return
}

// ResetWebauthn resets all changes to the "webauthn" edge.
func (m *UserMutation) ResetWebauthn() {
	m.webauthn = nil
	m.clearedwebauthn = false
	m.removedwebauthn = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *UserMutation) SetFileID(id string) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *UserMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[user.FieldAvatarLocalFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *UserMutation) FileCleared() bool {
	return m.AvatarLocalFileIDCleared() || m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *UserMutation) FileID() (id string, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) FileIDs() (ids []string) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *UserMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *UserMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *UserMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *UserMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *UserMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *UserMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *UserMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *UserMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddActionplanIDs adds the "actionplans" edge to the ActionPlan entity by ids.
func (m *UserMutation) AddActionplanIDs(ids ...string) {
	if m.actionplans == nil {
		m.actionplans = make(map[string]struct{})
	}
	for i := range ids {
		m.actionplans[ids[i]] = struct{}{}
	}
}

// ClearActionplans clears the "actionplans" edge to the ActionPlan entity.
func (m *UserMutation) ClearActionplans() {
	m.clearedactionplans = true
}

// ActionplansCleared reports if the "actionplans" edge to the ActionPlan entity was cleared.
func (m *UserMutation) ActionplansCleared() bool {
	return m.clearedactionplans
}

// RemoveActionplanIDs removes the "actionplans" edge to the ActionPlan entity by IDs.
func (m *UserMutation) RemoveActionplanIDs(ids ...string) {
	if m.removedactionplans == nil {
		m.removedactionplans = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.actionplans, ids[i])
		m.removedactionplans[ids[i]] = struct{}{}
	}
}

// RemovedActionplans returns the removed IDs of the "actionplans" edge to the ActionPlan entity.
func (m *UserMutation) RemovedActionplansIDs() (ids []string) {
	for id := range m.removedactionplans {
		ids = append(ids, id)
	}
	return
}

// ActionplansIDs returns the "actionplans" edge IDs in the mutation.
func (m *UserMutation) ActionplansIDs() (ids []string) {
	for id := range m.actionplans {
		ids = append(ids, id)
	}
	return
}

// ResetActionplans resets all changes to the "actionplans" edge.
func (m *UserMutation) ResetActionplans() {
	m.actionplans = nil
	m.clearedactionplans = false
	m.removedactionplans = nil
}

// AddSubcontrolIDs adds the "subcontrols" edge to the Subcontrol entity by ids.
func (m *UserMutation) AddSubcontrolIDs(ids ...string) {
	if m.subcontrols == nil {
		m.subcontrols = make(map[string]struct{})
	}
	for i := range ids {
		m.subcontrols[ids[i]] = struct{}{}
	}
}

// ClearSubcontrols clears the "subcontrols" edge to the Subcontrol entity.
func (m *UserMutation) ClearSubcontrols() {
	m.clearedsubcontrols = true
}

// SubcontrolsCleared reports if the "subcontrols" edge to the Subcontrol entity was cleared.
func (m *UserMutation) SubcontrolsCleared() bool {
	return m.clearedsubcontrols
}

// RemoveSubcontrolIDs removes the "subcontrols" edge to the Subcontrol entity by IDs.
func (m *UserMutation) RemoveSubcontrolIDs(ids ...string) {
	if m.removedsubcontrols == nil {
		m.removedsubcontrols = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subcontrols, ids[i])
		m.removedsubcontrols[ids[i]] = struct{}{}
	}
}

// RemovedSubcontrols returns the removed IDs of the "subcontrols" edge to the Subcontrol entity.
func (m *UserMutation) RemovedSubcontrolsIDs() (ids []string) {
	for id := range m.removedsubcontrols {
		ids = append(ids, id)
	}
	return
}

// SubcontrolsIDs returns the "subcontrols" edge IDs in the mutation.
func (m *UserMutation) SubcontrolsIDs() (ids []string) {
	for id := range m.subcontrols {
		ids = append(ids, id)
	}
	return
}

// ResetSubcontrols resets all changes to the "subcontrols" edge.
func (m *UserMutation) ResetSubcontrols() {
	m.subcontrols = nil
	m.clearedsubcontrols = false
	m.removedsubcontrols = nil
}

// AddAssignerTaskIDs adds the "assigner_tasks" edge to the Task entity by ids.
func (m *UserMutation) AddAssignerTaskIDs(ids ...string) {
	if m.assigner_tasks == nil {
		m.assigner_tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.assigner_tasks[ids[i]] = struct{}{}
	}
}

// ClearAssignerTasks clears the "assigner_tasks" edge to the Task entity.
func (m *UserMutation) ClearAssignerTasks() {
	m.clearedassigner_tasks = true
}

// AssignerTasksCleared reports if the "assigner_tasks" edge to the Task entity was cleared.
func (m *UserMutation) AssignerTasksCleared() bool {
	return m.clearedassigner_tasks
}

// RemoveAssignerTaskIDs removes the "assigner_tasks" edge to the Task entity by IDs.
func (m *UserMutation) RemoveAssignerTaskIDs(ids ...string) {
	if m.removedassigner_tasks == nil {
		m.removedassigner_tasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.assigner_tasks, ids[i])
		m.removedassigner_tasks[ids[i]] = struct{}{}
	}
}

// RemovedAssignerTasks returns the removed IDs of the "assigner_tasks" edge to the Task entity.
func (m *UserMutation) RemovedAssignerTasksIDs() (ids []string) {
	for id := range m.removedassigner_tasks {
		ids = append(ids, id)
	}
	return
}

// AssignerTasksIDs returns the "assigner_tasks" edge IDs in the mutation.
func (m *UserMutation) AssignerTasksIDs() (ids []string) {
	for id := range m.assigner_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetAssignerTasks resets all changes to the "assigner_tasks" edge.
func (m *UserMutation) ResetAssignerTasks() {
	m.assigner_tasks = nil
	m.clearedassigner_tasks = false
	m.removedassigner_tasks = nil
}

// AddAssigneeTaskIDs adds the "assignee_tasks" edge to the Task entity by ids.
func (m *UserMutation) AddAssigneeTaskIDs(ids ...string) {
	if m.assignee_tasks == nil {
		m.assignee_tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.assignee_tasks[ids[i]] = struct{}{}
	}
}

// ClearAssigneeTasks clears the "assignee_tasks" edge to the Task entity.
func (m *UserMutation) ClearAssigneeTasks() {
	m.clearedassignee_tasks = true
}

// AssigneeTasksCleared reports if the "assignee_tasks" edge to the Task entity was cleared.
func (m *UserMutation) AssigneeTasksCleared() bool {
	return m.clearedassignee_tasks
}

// RemoveAssigneeTaskIDs removes the "assignee_tasks" edge to the Task entity by IDs.
func (m *UserMutation) RemoveAssigneeTaskIDs(ids ...string) {
	if m.removedassignee_tasks == nil {
		m.removedassignee_tasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.assignee_tasks, ids[i])
		m.removedassignee_tasks[ids[i]] = struct{}{}
	}
}

// RemovedAssigneeTasks returns the removed IDs of the "assignee_tasks" edge to the Task entity.
func (m *UserMutation) RemovedAssigneeTasksIDs() (ids []string) {
	for id := range m.removedassignee_tasks {
		ids = append(ids, id)
	}
	return
}

// AssigneeTasksIDs returns the "assignee_tasks" edge IDs in the mutation.
func (m *UserMutation) AssigneeTasksIDs() (ids []string) {
	for id := range m.assignee_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetAssigneeTasks resets all changes to the "assignee_tasks" edge.
func (m *UserMutation) ResetAssigneeTasks() {
	m.assignee_tasks = nil
	m.clearedassignee_tasks = false
	m.removedassignee_tasks = nil
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *UserMutation) AddProgramIDs(ids ...string) {
	if m.programs == nil {
		m.programs = make(map[string]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *UserMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *UserMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *UserMutation) RemoveProgramIDs(ids ...string) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *UserMutation) RemovedProgramsIDs() (ids []string) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *UserMutation) ProgramsIDs() (ids []string) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *UserMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// AddGroupMembershipIDs adds the "group_memberships" edge to the GroupMembership entity by ids.
func (m *UserMutation) AddGroupMembershipIDs(ids ...string) {
	if m.group_memberships == nil {
		m.group_memberships = make(map[string]struct{})
	}
	for i := range ids {
		m.group_memberships[ids[i]] = struct{}{}
	}
}

// ClearGroupMemberships clears the "group_memberships" edge to the GroupMembership entity.
func (m *UserMutation) ClearGroupMemberships() {
	m.clearedgroup_memberships = true
}

// GroupMembershipsCleared reports if the "group_memberships" edge to the GroupMembership entity was cleared.
func (m *UserMutation) GroupMembershipsCleared() bool {
	return m.clearedgroup_memberships
}

// RemoveGroupMembershipIDs removes the "group_memberships" edge to the GroupMembership entity by IDs.
func (m *UserMutation) RemoveGroupMembershipIDs(ids ...string) {
	if m.removedgroup_memberships == nil {
		m.removedgroup_memberships = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.group_memberships, ids[i])
		m.removedgroup_memberships[ids[i]] = struct{}{}
	}
}

// RemovedGroupMemberships returns the removed IDs of the "group_memberships" edge to the GroupMembership entity.
func (m *UserMutation) RemovedGroupMembershipsIDs() (ids []string) {
	for id := range m.removedgroup_memberships {
		ids = append(ids, id)
	}
	return
}

// GroupMembershipsIDs returns the "group_memberships" edge IDs in the mutation.
func (m *UserMutation) GroupMembershipsIDs() (ids []string) {
	for id := range m.group_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetGroupMemberships resets all changes to the "group_memberships" edge.
func (m *UserMutation) ResetGroupMemberships() {
	m.group_memberships = nil
	m.clearedgroup_memberships = false
	m.removedgroup_memberships = nil
}

// AddOrgMembershipIDs adds the "org_memberships" edge to the OrgMembership entity by ids.
func (m *UserMutation) AddOrgMembershipIDs(ids ...string) {
	if m.org_memberships == nil {
		m.org_memberships = make(map[string]struct{})
	}
	for i := range ids {
		m.org_memberships[ids[i]] = struct{}{}
	}
}

// ClearOrgMemberships clears the "org_memberships" edge to the OrgMembership entity.
func (m *UserMutation) ClearOrgMemberships() {
	m.clearedorg_memberships = true
}

// OrgMembershipsCleared reports if the "org_memberships" edge to the OrgMembership entity was cleared.
func (m *UserMutation) OrgMembershipsCleared() bool {
	return m.clearedorg_memberships
}

// RemoveOrgMembershipIDs removes the "org_memberships" edge to the OrgMembership entity by IDs.
func (m *UserMutation) RemoveOrgMembershipIDs(ids ...string) {
	if m.removedorg_memberships == nil {
		m.removedorg_memberships = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.org_memberships, ids[i])
		m.removedorg_memberships[ids[i]] = struct{}{}
	}
}

// RemovedOrgMemberships returns the removed IDs of the "org_memberships" edge to the OrgMembership entity.
func (m *UserMutation) RemovedOrgMembershipsIDs() (ids []string) {
	for id := range m.removedorg_memberships {
		ids = append(ids, id)
	}
	return
}

// OrgMembershipsIDs returns the "org_memberships" edge IDs in the mutation.
func (m *UserMutation) OrgMembershipsIDs() (ids []string) {
	for id := range m.org_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetOrgMemberships resets all changes to the "org_memberships" edge.
func (m *UserMutation) ResetOrgMemberships() {
	m.org_memberships = nil
	m.clearedorg_memberships = false
	m.removedorg_memberships = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, user.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, user.FieldTags)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.avatar_remote_url != nil {
		fields = append(fields, user.FieldAvatarRemoteURL)
	}
	if m.avatar_local_file != nil {
		fields = append(fields, user.FieldAvatarLocalFile)
	}
	if m.file != nil {
		fields = append(fields, user.FieldAvatarLocalFileID)
	}
	if m.avatar_updated_at != nil {
		fields = append(fields, user.FieldAvatarUpdatedAt)
	}
	if m.last_seen != nil {
		fields = append(fields, user.FieldLastSeen)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.sub != nil {
		fields = append(fields, user.FieldSub)
	}
	if m.auth_provider != nil {
		fields = append(fields, user.FieldAuthProvider)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	case user.FieldMappingID:
		return m.MappingID()
	case user.FieldTags:
		return m.Tags()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldAvatarRemoteURL:
		return m.AvatarRemoteURL()
	case user.FieldAvatarLocalFile:
		return m.AvatarLocalFile()
	case user.FieldAvatarLocalFileID:
		return m.AvatarLocalFileID()
	case user.FieldAvatarUpdatedAt:
		return m.AvatarUpdatedAt()
	case user.FieldLastSeen:
		return m.LastSeen()
	case user.FieldPassword:
		return m.Password()
	case user.FieldSub:
		return m.Sub()
	case user.FieldAuthProvider:
		return m.AuthProvider()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case user.FieldMappingID:
		return m.OldMappingID(ctx)
	case user.FieldTags:
		return m.OldTags(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldAvatarRemoteURL:
		return m.OldAvatarRemoteURL(ctx)
	case user.FieldAvatarLocalFile:
		return m.OldAvatarLocalFile(ctx)
	case user.FieldAvatarLocalFileID:
		return m.OldAvatarLocalFileID(ctx)
	case user.FieldAvatarUpdatedAt:
		return m.OldAvatarUpdatedAt(ctx)
	case user.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldSub:
		return m.OldSub(ctx)
	case user.FieldAuthProvider:
		return m.OldAuthProvider(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case user.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case user.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldAvatarRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarRemoteURL(v)
		return nil
	case user.FieldAvatarLocalFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarLocalFile(v)
		return nil
	case user.FieldAvatarLocalFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarLocalFileID(v)
		return nil
	case user.FieldAvatarUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarUpdatedAt(v)
		return nil
	case user.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldSub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSub(v)
		return nil
	case user.FieldAuthProvider:
		v, ok := value.(enums.AuthProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthProvider(v)
		return nil
	case user.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldCreatedBy) {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldDeletedBy) {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.FieldCleared(user.FieldTags) {
		fields = append(fields, user.FieldTags)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldAvatarRemoteURL) {
		fields = append(fields, user.FieldAvatarRemoteURL)
	}
	if m.FieldCleared(user.FieldAvatarLocalFile) {
		fields = append(fields, user.FieldAvatarLocalFile)
	}
	if m.FieldCleared(user.FieldAvatarLocalFileID) {
		fields = append(fields, user.FieldAvatarLocalFileID)
	}
	if m.FieldCleared(user.FieldAvatarUpdatedAt) {
		fields = append(fields, user.FieldAvatarUpdatedAt)
	}
	if m.FieldCleared(user.FieldLastSeen) {
		fields = append(fields, user.FieldLastSeen)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldSub) {
		fields = append(fields, user.FieldSub)
	}
	if m.FieldCleared(user.FieldRole) {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case user.FieldTags:
		m.ClearTags()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldAvatarRemoteURL:
		m.ClearAvatarRemoteURL()
		return nil
	case user.FieldAvatarLocalFile:
		m.ClearAvatarLocalFile()
		return nil
	case user.FieldAvatarLocalFileID:
		m.ClearAvatarLocalFileID()
		return nil
	case user.FieldAvatarUpdatedAt:
		m.ClearAvatarUpdatedAt()
		return nil
	case user.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldSub:
		m.ClearSub()
		return nil
	case user.FieldRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case user.FieldMappingID:
		m.ResetMappingID()
		return nil
	case user.FieldTags:
		m.ResetTags()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldAvatarRemoteURL:
		m.ResetAvatarRemoteURL()
		return nil
	case user.FieldAvatarLocalFile:
		m.ResetAvatarLocalFile()
		return nil
	case user.FieldAvatarLocalFileID:
		m.ResetAvatarLocalFileID()
		return nil
	case user.FieldAvatarUpdatedAt:
		m.ResetAvatarUpdatedAt()
		return nil
	case user.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldSub:
		m.ResetSub()
		return nil
	case user.FieldAuthProvider:
		m.ResetAuthProvider()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 18)
	if m.personal_access_tokens != nil {
		edges = append(edges, user.EdgePersonalAccessTokens)
	}
	if m.tfa_settings != nil {
		edges = append(edges, user.EdgeTfaSettings)
	}
	if m.setting != nil {
		edges = append(edges, user.EdgeSetting)
	}
	if m.email_verification_tokens != nil {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.password_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.groups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.organizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.webauthn != nil {
		edges = append(edges, user.EdgeWebauthn)
	}
	if m.files != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.file != nil {
		edges = append(edges, user.EdgeFile)
	}
	if m.events != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.actionplans != nil {
		edges = append(edges, user.EdgeActionplans)
	}
	if m.subcontrols != nil {
		edges = append(edges, user.EdgeSubcontrols)
	}
	if m.assigner_tasks != nil {
		edges = append(edges, user.EdgeAssignerTasks)
	}
	if m.assignee_tasks != nil {
		edges = append(edges, user.EdgeAssigneeTasks)
	}
	if m.programs != nil {
		edges = append(edges, user.EdgePrograms)
	}
	if m.group_memberships != nil {
		edges = append(edges, user.EdgeGroupMemberships)
	}
	if m.org_memberships != nil {
		edges = append(edges, user.EdgeOrgMemberships)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePersonalAccessTokens:
		ids := make([]ent.Value, 0, len(m.personal_access_tokens))
		for id := range m.personal_access_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTfaSettings:
		ids := make([]ent.Value, 0, len(m.tfa_settings))
		for id := range m.tfa_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSetting:
		if id := m.setting; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEmailVerificationTokens:
		ids := make([]ent.Value, 0, len(m.email_verification_tokens))
		for id := range m.email_verification_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.password_reset_tokens))
		for id := range m.password_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebauthn:
		ids := make([]ent.Value, 0, len(m.webauthn))
		for id := range m.webauthn {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.actionplans))
		for id := range m.actionplans {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.subcontrols))
		for id := range m.subcontrols {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignerTasks:
		ids := make([]ent.Value, 0, len(m.assigner_tasks))
		for id := range m.assigner_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssigneeTasks:
		ids := make([]ent.Value, 0, len(m.assignee_tasks))
		for id := range m.assignee_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroupMemberships:
		ids := make([]ent.Value, 0, len(m.group_memberships))
		for id := range m.group_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrgMemberships:
		ids := make([]ent.Value, 0, len(m.org_memberships))
		for id := range m.org_memberships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 18)
	if m.removedpersonal_access_tokens != nil {
		edges = append(edges, user.EdgePersonalAccessTokens)
	}
	if m.removedtfa_settings != nil {
		edges = append(edges, user.EdgeTfaSettings)
	}
	if m.removedemail_verification_tokens != nil {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.removedpassword_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.removedgroups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	if m.removedorganizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.removedwebauthn != nil {
		edges = append(edges, user.EdgeWebauthn)
	}
	if m.removedfiles != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.removedevents != nil {
		edges = append(edges, user.EdgeEvents)
	}
	if m.removedactionplans != nil {
		edges = append(edges, user.EdgeActionplans)
	}
	if m.removedsubcontrols != nil {
		edges = append(edges, user.EdgeSubcontrols)
	}
	if m.removedassigner_tasks != nil {
		edges = append(edges, user.EdgeAssignerTasks)
	}
	if m.removedassignee_tasks != nil {
		edges = append(edges, user.EdgeAssigneeTasks)
	}
	if m.removedprograms != nil {
		edges = append(edges, user.EdgePrograms)
	}
	if m.removedgroup_memberships != nil {
		edges = append(edges, user.EdgeGroupMemberships)
	}
	if m.removedorg_memberships != nil {
		edges = append(edges, user.EdgeOrgMemberships)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePersonalAccessTokens:
		ids := make([]ent.Value, 0, len(m.removedpersonal_access_tokens))
		for id := range m.removedpersonal_access_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTfaSettings:
		ids := make([]ent.Value, 0, len(m.removedtfa_settings))
		for id := range m.removedtfa_settings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailVerificationTokens:
		ids := make([]ent.Value, 0, len(m.removedemail_verification_tokens))
		for id := range m.removedemail_verification_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.removedpassword_reset_tokens))
		for id := range m.removedpassword_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebauthn:
		ids := make([]ent.Value, 0, len(m.removedwebauthn))
		for id := range m.removedwebauthn {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActionplans:
		ids := make([]ent.Value, 0, len(m.removedactionplans))
		for id := range m.removedactionplans {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubcontrols:
		ids := make([]ent.Value, 0, len(m.removedsubcontrols))
		for id := range m.removedsubcontrols {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignerTasks:
		ids := make([]ent.Value, 0, len(m.removedassigner_tasks))
		for id := range m.removedassigner_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssigneeTasks:
		ids := make([]ent.Value, 0, len(m.removedassignee_tasks))
		for id := range m.removedassignee_tasks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroupMemberships:
		ids := make([]ent.Value, 0, len(m.removedgroup_memberships))
		for id := range m.removedgroup_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrgMemberships:
		ids := make([]ent.Value, 0, len(m.removedorg_memberships))
		for id := range m.removedorg_memberships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 18)
	if m.clearedpersonal_access_tokens {
		edges = append(edges, user.EdgePersonalAccessTokens)
	}
	if m.clearedtfa_settings {
		edges = append(edges, user.EdgeTfaSettings)
	}
	if m.clearedsetting {
		edges = append(edges, user.EdgeSetting)
	}
	if m.clearedemail_verification_tokens {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.clearedpassword_reset_tokens {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.clearedgroups {
		edges = append(edges, user.EdgeGroups)
	}
	if m.clearedorganizations {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.clearedwebauthn {
		edges = append(edges, user.EdgeWebauthn)
	}
	if m.clearedfiles {
		edges = append(edges, user.EdgeFiles)
	}
	if m.clearedfile {
		edges = append(edges, user.EdgeFile)
	}
	if m.clearedevents {
		edges = append(edges, user.EdgeEvents)
	}
	if m.clearedactionplans {
		edges = append(edges, user.EdgeActionplans)
	}
	if m.clearedsubcontrols {
		edges = append(edges, user.EdgeSubcontrols)
	}
	if m.clearedassigner_tasks {
		edges = append(edges, user.EdgeAssignerTasks)
	}
	if m.clearedassignee_tasks {
		edges = append(edges, user.EdgeAssigneeTasks)
	}
	if m.clearedprograms {
		edges = append(edges, user.EdgePrograms)
	}
	if m.clearedgroup_memberships {
		edges = append(edges, user.EdgeGroupMemberships)
	}
	if m.clearedorg_memberships {
		edges = append(edges, user.EdgeOrgMemberships)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePersonalAccessTokens:
		return m.clearedpersonal_access_tokens
	case user.EdgeTfaSettings:
		return m.clearedtfa_settings
	case user.EdgeSetting:
		return m.clearedsetting
	case user.EdgeEmailVerificationTokens:
		return m.clearedemail_verification_tokens
	case user.EdgePasswordResetTokens:
		return m.clearedpassword_reset_tokens
	case user.EdgeGroups:
		return m.clearedgroups
	case user.EdgeOrganizations:
		return m.clearedorganizations
	case user.EdgeWebauthn:
		return m.clearedwebauthn
	case user.EdgeFiles:
		return m.clearedfiles
	case user.EdgeFile:
		return m.clearedfile
	case user.EdgeEvents:
		return m.clearedevents
	case user.EdgeActionplans:
		return m.clearedactionplans
	case user.EdgeSubcontrols:
		return m.clearedsubcontrols
	case user.EdgeAssignerTasks:
		return m.clearedassigner_tasks
	case user.EdgeAssigneeTasks:
		return m.clearedassignee_tasks
	case user.EdgePrograms:
		return m.clearedprograms
	case user.EdgeGroupMemberships:
		return m.clearedgroup_memberships
	case user.EdgeOrgMemberships:
		return m.clearedorg_memberships
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeSetting:
		m.ClearSetting()
		return nil
	case user.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePersonalAccessTokens:
		m.ResetPersonalAccessTokens()
		return nil
	case user.EdgeTfaSettings:
		m.ResetTfaSettings()
		return nil
	case user.EdgeSetting:
		m.ResetSetting()
		return nil
	case user.EdgeEmailVerificationTokens:
		m.ResetEmailVerificationTokens()
		return nil
	case user.EdgePasswordResetTokens:
		m.ResetPasswordResetTokens()
		return nil
	case user.EdgeGroups:
		m.ResetGroups()
		return nil
	case user.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case user.EdgeWebauthn:
		m.ResetWebauthn()
		return nil
	case user.EdgeFiles:
		m.ResetFiles()
		return nil
	case user.EdgeFile:
		m.ResetFile()
		return nil
	case user.EdgeEvents:
		m.ResetEvents()
		return nil
	case user.EdgeActionplans:
		m.ResetActionplans()
		return nil
	case user.EdgeSubcontrols:
		m.ResetSubcontrols()
		return nil
	case user.EdgeAssignerTasks:
		m.ResetAssignerTasks()
		return nil
	case user.EdgeAssigneeTasks:
		m.ResetAssigneeTasks()
		return nil
	case user.EdgePrograms:
		m.ResetPrograms()
		return nil
	case user.EdgeGroupMemberships:
		m.ResetGroupMemberships()
		return nil
	case user.EdgeOrgMemberships:
		m.ResetOrgMemberships()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserHistoryMutation represents an operation that mutates the UserHistory nodes in the graph.
type UserHistoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	history_time         *time.Time
	ref                  *string
	operation            *history.OpType
	created_at           *time.Time
	updated_at           *time.Time
	created_by           *string
	updated_by           *string
	deleted_at           *time.Time
	deleted_by           *string
	mapping_id           *string
	tags                 *[]string
	appendtags           []string
	email                *string
	first_name           *string
	last_name            *string
	display_name         *string
	avatar_remote_url    *string
	avatar_local_file    *string
	avatar_local_file_id *string
	avatar_updated_at    *time.Time
	last_seen            *time.Time
	password             *string
	sub                  *string
	auth_provider        *enums.AuthProvider
	role                 *enums.Role
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*UserHistory, error)
	predicates           []predicate.UserHistory
}

var _ ent.Mutation = (*UserHistoryMutation)(nil)

// userhistoryOption allows management of the mutation configuration using functional options.
type userhistoryOption func(*UserHistoryMutation)

// newUserHistoryMutation creates new mutation for the UserHistory entity.
func newUserHistoryMutation(c config, op Op, opts ...userhistoryOption) *UserHistoryMutation {
	m := &UserHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUserHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserHistoryID sets the ID field of the mutation.
func withUserHistoryID(id string) userhistoryOption {
	return func(m *UserHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *UserHistory
		)
		m.oldValue = func(ctx context.Context) (*UserHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserHistory sets the old UserHistory of the mutation.
func withUserHistory(node *UserHistory) userhistoryOption {
	return func(m *UserHistoryMutation) {
		m.oldValue = func(context.Context) (*UserHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserHistory entities.
func (m *UserHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *UserHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *UserHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *UserHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *UserHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *UserHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *UserHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[userhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *UserHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *UserHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, userhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *UserHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *UserHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *UserHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[userhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, userhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[userhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, userhistory.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[userhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, userhistory.FieldDeletedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *UserHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *UserHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *UserHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *UserHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *UserHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *UserHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *UserHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *UserHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[userhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *UserHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *UserHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, userhistory.FieldTags)
}

// SetEmail sets the "email" field.
func (m *UserHistoryMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserHistoryMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserHistoryMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserHistoryMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserHistoryMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserHistoryMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[userhistory.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserHistoryMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserHistoryMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, userhistory.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserHistoryMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserHistoryMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserHistoryMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[userhistory.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserHistoryMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserHistoryMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, userhistory.FieldLastName)
}

// SetDisplayName sets the "display_name" field.
func (m *UserHistoryMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserHistoryMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserHistoryMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetAvatarRemoteURL sets the "avatar_remote_url" field.
func (m *UserHistoryMutation) SetAvatarRemoteURL(s string) {
	m.avatar_remote_url = &s
}

// AvatarRemoteURL returns the value of the "avatar_remote_url" field in the mutation.
func (m *UserHistoryMutation) AvatarRemoteURL() (r string, exists bool) {
	v := m.avatar_remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarRemoteURL returns the old "avatar_remote_url" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAvatarRemoteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarRemoteURL: %w", err)
	}
	return oldValue.AvatarRemoteURL, nil
}

// ClearAvatarRemoteURL clears the value of the "avatar_remote_url" field.
func (m *UserHistoryMutation) ClearAvatarRemoteURL() {
	m.avatar_remote_url = nil
	m.clearedFields[userhistory.FieldAvatarRemoteURL] = struct{}{}
}

// AvatarRemoteURLCleared returns if the "avatar_remote_url" field was cleared in this mutation.
func (m *UserHistoryMutation) AvatarRemoteURLCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldAvatarRemoteURL]
	return ok
}

// ResetAvatarRemoteURL resets all changes to the "avatar_remote_url" field.
func (m *UserHistoryMutation) ResetAvatarRemoteURL() {
	m.avatar_remote_url = nil
	delete(m.clearedFields, userhistory.FieldAvatarRemoteURL)
}

// SetAvatarLocalFile sets the "avatar_local_file" field.
func (m *UserHistoryMutation) SetAvatarLocalFile(s string) {
	m.avatar_local_file = &s
}

// AvatarLocalFile returns the value of the "avatar_local_file" field in the mutation.
func (m *UserHistoryMutation) AvatarLocalFile() (r string, exists bool) {
	v := m.avatar_local_file
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarLocalFile returns the old "avatar_local_file" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAvatarLocalFile(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarLocalFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarLocalFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarLocalFile: %w", err)
	}
	return oldValue.AvatarLocalFile, nil
}

// ClearAvatarLocalFile clears the value of the "avatar_local_file" field.
func (m *UserHistoryMutation) ClearAvatarLocalFile() {
	m.avatar_local_file = nil
	m.clearedFields[userhistory.FieldAvatarLocalFile] = struct{}{}
}

// AvatarLocalFileCleared returns if the "avatar_local_file" field was cleared in this mutation.
func (m *UserHistoryMutation) AvatarLocalFileCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldAvatarLocalFile]
	return ok
}

// ResetAvatarLocalFile resets all changes to the "avatar_local_file" field.
func (m *UserHistoryMutation) ResetAvatarLocalFile() {
	m.avatar_local_file = nil
	delete(m.clearedFields, userhistory.FieldAvatarLocalFile)
}

// SetAvatarLocalFileID sets the "avatar_local_file_id" field.
func (m *UserHistoryMutation) SetAvatarLocalFileID(s string) {
	m.avatar_local_file_id = &s
}

// AvatarLocalFileID returns the value of the "avatar_local_file_id" field in the mutation.
func (m *UserHistoryMutation) AvatarLocalFileID() (r string, exists bool) {
	v := m.avatar_local_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarLocalFileID returns the old "avatar_local_file_id" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAvatarLocalFileID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarLocalFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarLocalFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarLocalFileID: %w", err)
	}
	return oldValue.AvatarLocalFileID, nil
}

// ClearAvatarLocalFileID clears the value of the "avatar_local_file_id" field.
func (m *UserHistoryMutation) ClearAvatarLocalFileID() {
	m.avatar_local_file_id = nil
	m.clearedFields[userhistory.FieldAvatarLocalFileID] = struct{}{}
}

// AvatarLocalFileIDCleared returns if the "avatar_local_file_id" field was cleared in this mutation.
func (m *UserHistoryMutation) AvatarLocalFileIDCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldAvatarLocalFileID]
	return ok
}

// ResetAvatarLocalFileID resets all changes to the "avatar_local_file_id" field.
func (m *UserHistoryMutation) ResetAvatarLocalFileID() {
	m.avatar_local_file_id = nil
	delete(m.clearedFields, userhistory.FieldAvatarLocalFileID)
}

// SetAvatarUpdatedAt sets the "avatar_updated_at" field.
func (m *UserHistoryMutation) SetAvatarUpdatedAt(t time.Time) {
	m.avatar_updated_at = &t
}

// AvatarUpdatedAt returns the value of the "avatar_updated_at" field in the mutation.
func (m *UserHistoryMutation) AvatarUpdatedAt() (r time.Time, exists bool) {
	v := m.avatar_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarUpdatedAt returns the old "avatar_updated_at" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAvatarUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarUpdatedAt: %w", err)
	}
	return oldValue.AvatarUpdatedAt, nil
}

// ClearAvatarUpdatedAt clears the value of the "avatar_updated_at" field.
func (m *UserHistoryMutation) ClearAvatarUpdatedAt() {
	m.avatar_updated_at = nil
	m.clearedFields[userhistory.FieldAvatarUpdatedAt] = struct{}{}
}

// AvatarUpdatedAtCleared returns if the "avatar_updated_at" field was cleared in this mutation.
func (m *UserHistoryMutation) AvatarUpdatedAtCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldAvatarUpdatedAt]
	return ok
}

// ResetAvatarUpdatedAt resets all changes to the "avatar_updated_at" field.
func (m *UserHistoryMutation) ResetAvatarUpdatedAt() {
	m.avatar_updated_at = nil
	delete(m.clearedFields, userhistory.FieldAvatarUpdatedAt)
}

// SetLastSeen sets the "last_seen" field.
func (m *UserHistoryMutation) SetLastSeen(t time.Time) {
	m.last_seen = &t
}

// LastSeen returns the value of the "last_seen" field in the mutation.
func (m *UserHistoryMutation) LastSeen() (r time.Time, exists bool) {
	v := m.last_seen
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeen returns the old "last_seen" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldLastSeen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeen: %w", err)
	}
	return oldValue.LastSeen, nil
}

// ClearLastSeen clears the value of the "last_seen" field.
func (m *UserHistoryMutation) ClearLastSeen() {
	m.last_seen = nil
	m.clearedFields[userhistory.FieldLastSeen] = struct{}{}
}

// LastSeenCleared returns if the "last_seen" field was cleared in this mutation.
func (m *UserHistoryMutation) LastSeenCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldLastSeen]
	return ok
}

// ResetLastSeen resets all changes to the "last_seen" field.
func (m *UserHistoryMutation) ResetLastSeen() {
	m.last_seen = nil
	delete(m.clearedFields, userhistory.FieldLastSeen)
}

// SetPassword sets the "password" field.
func (m *UserHistoryMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserHistoryMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserHistoryMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[userhistory.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserHistoryMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserHistoryMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, userhistory.FieldPassword)
}

// SetSub sets the "sub" field.
func (m *UserHistoryMutation) SetSub(s string) {
	m.sub = &s
}

// Sub returns the value of the "sub" field in the mutation.
func (m *UserHistoryMutation) Sub() (r string, exists bool) {
	v := m.sub
	if v == nil {
		return
	}
	return *v, true
}

// OldSub returns the old "sub" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldSub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSub: %w", err)
	}
	return oldValue.Sub, nil
}

// ClearSub clears the value of the "sub" field.
func (m *UserHistoryMutation) ClearSub() {
	m.sub = nil
	m.clearedFields[userhistory.FieldSub] = struct{}{}
}

// SubCleared returns if the "sub" field was cleared in this mutation.
func (m *UserHistoryMutation) SubCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldSub]
	return ok
}

// ResetSub resets all changes to the "sub" field.
func (m *UserHistoryMutation) ResetSub() {
	m.sub = nil
	delete(m.clearedFields, userhistory.FieldSub)
}

// SetAuthProvider sets the "auth_provider" field.
func (m *UserHistoryMutation) SetAuthProvider(ep enums.AuthProvider) {
	m.auth_provider = &ep
}

// AuthProvider returns the value of the "auth_provider" field in the mutation.
func (m *UserHistoryMutation) AuthProvider() (r enums.AuthProvider, exists bool) {
	v := m.auth_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthProvider returns the old "auth_provider" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldAuthProvider(ctx context.Context) (v enums.AuthProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthProvider: %w", err)
	}
	return oldValue.AuthProvider, nil
}

// ResetAuthProvider resets all changes to the "auth_provider" field.
func (m *UserHistoryMutation) ResetAuthProvider() {
	m.auth_provider = nil
}

// SetRole sets the "role" field.
func (m *UserHistoryMutation) SetRole(e enums.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *UserHistoryMutation) Role() (r enums.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the UserHistory entity.
// If the UserHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldRole(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *UserHistoryMutation) ClearRole() {
	m.role = nil
	m.clearedFields[userhistory.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *UserHistoryMutation) RoleCleared() bool {
	_, ok := m.clearedFields[userhistory.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *UserHistoryMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, userhistory.FieldRole)
}

// Where appends a list predicates to the UserHistoryMutation builder.
func (m *UserHistoryMutation) Where(ps ...predicate.UserHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserHistory).
func (m *UserHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserHistoryMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.history_time != nil {
		fields = append(fields, userhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, userhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, userhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, userhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, userhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, userhistory.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, userhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, userhistory.FieldDeletedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, userhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, userhistory.FieldTags)
	}
	if m.email != nil {
		fields = append(fields, userhistory.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, userhistory.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, userhistory.FieldLastName)
	}
	if m.display_name != nil {
		fields = append(fields, userhistory.FieldDisplayName)
	}
	if m.avatar_remote_url != nil {
		fields = append(fields, userhistory.FieldAvatarRemoteURL)
	}
	if m.avatar_local_file != nil {
		fields = append(fields, userhistory.FieldAvatarLocalFile)
	}
	if m.avatar_local_file_id != nil {
		fields = append(fields, userhistory.FieldAvatarLocalFileID)
	}
	if m.avatar_updated_at != nil {
		fields = append(fields, userhistory.FieldAvatarUpdatedAt)
	}
	if m.last_seen != nil {
		fields = append(fields, userhistory.FieldLastSeen)
	}
	if m.password != nil {
		fields = append(fields, userhistory.FieldPassword)
	}
	if m.sub != nil {
		fields = append(fields, userhistory.FieldSub)
	}
	if m.auth_provider != nil {
		fields = append(fields, userhistory.FieldAuthProvider)
	}
	if m.role != nil {
		fields = append(fields, userhistory.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userhistory.FieldHistoryTime:
		return m.HistoryTime()
	case userhistory.FieldRef:
		return m.Ref()
	case userhistory.FieldOperation:
		return m.Operation()
	case userhistory.FieldCreatedAt:
		return m.CreatedAt()
	case userhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case userhistory.FieldCreatedBy:
		return m.CreatedBy()
	case userhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case userhistory.FieldDeletedAt:
		return m.DeletedAt()
	case userhistory.FieldDeletedBy:
		return m.DeletedBy()
	case userhistory.FieldMappingID:
		return m.MappingID()
	case userhistory.FieldTags:
		return m.Tags()
	case userhistory.FieldEmail:
		return m.Email()
	case userhistory.FieldFirstName:
		return m.FirstName()
	case userhistory.FieldLastName:
		return m.LastName()
	case userhistory.FieldDisplayName:
		return m.DisplayName()
	case userhistory.FieldAvatarRemoteURL:
		return m.AvatarRemoteURL()
	case userhistory.FieldAvatarLocalFile:
		return m.AvatarLocalFile()
	case userhistory.FieldAvatarLocalFileID:
		return m.AvatarLocalFileID()
	case userhistory.FieldAvatarUpdatedAt:
		return m.AvatarUpdatedAt()
	case userhistory.FieldLastSeen:
		return m.LastSeen()
	case userhistory.FieldPassword:
		return m.Password()
	case userhistory.FieldSub:
		return m.Sub()
	case userhistory.FieldAuthProvider:
		return m.AuthProvider()
	case userhistory.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case userhistory.FieldRef:
		return m.OldRef(ctx)
	case userhistory.FieldOperation:
		return m.OldOperation(ctx)
	case userhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case userhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case userhistory.FieldTags:
		return m.OldTags(ctx)
	case userhistory.FieldEmail:
		return m.OldEmail(ctx)
	case userhistory.FieldFirstName:
		return m.OldFirstName(ctx)
	case userhistory.FieldLastName:
		return m.OldLastName(ctx)
	case userhistory.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case userhistory.FieldAvatarRemoteURL:
		return m.OldAvatarRemoteURL(ctx)
	case userhistory.FieldAvatarLocalFile:
		return m.OldAvatarLocalFile(ctx)
	case userhistory.FieldAvatarLocalFileID:
		return m.OldAvatarLocalFileID(ctx)
	case userhistory.FieldAvatarUpdatedAt:
		return m.OldAvatarUpdatedAt(ctx)
	case userhistory.FieldLastSeen:
		return m.OldLastSeen(ctx)
	case userhistory.FieldPassword:
		return m.OldPassword(ctx)
	case userhistory.FieldSub:
		return m.OldSub(ctx)
	case userhistory.FieldAuthProvider:
		return m.OldAuthProvider(ctx)
	case userhistory.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown UserHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case userhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case userhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case userhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case userhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case userhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case userhistory.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case userhistory.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case userhistory.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case userhistory.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case userhistory.FieldAvatarRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarRemoteURL(v)
		return nil
	case userhistory.FieldAvatarLocalFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarLocalFile(v)
		return nil
	case userhistory.FieldAvatarLocalFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarLocalFileID(v)
		return nil
	case userhistory.FieldAvatarUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarUpdatedAt(v)
		return nil
	case userhistory.FieldLastSeen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeen(v)
		return nil
	case userhistory.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case userhistory.FieldSub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSub(v)
		return nil
	case userhistory.FieldAuthProvider:
		v, ok := value.(enums.AuthProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthProvider(v)
		return nil
	case userhistory.FieldRole:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown UserHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userhistory.FieldRef) {
		fields = append(fields, userhistory.FieldRef)
	}
	if m.FieldCleared(userhistory.FieldCreatedAt) {
		fields = append(fields, userhistory.FieldCreatedAt)
	}
	if m.FieldCleared(userhistory.FieldUpdatedAt) {
		fields = append(fields, userhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(userhistory.FieldCreatedBy) {
		fields = append(fields, userhistory.FieldCreatedBy)
	}
	if m.FieldCleared(userhistory.FieldUpdatedBy) {
		fields = append(fields, userhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(userhistory.FieldDeletedAt) {
		fields = append(fields, userhistory.FieldDeletedAt)
	}
	if m.FieldCleared(userhistory.FieldDeletedBy) {
		fields = append(fields, userhistory.FieldDeletedBy)
	}
	if m.FieldCleared(userhistory.FieldTags) {
		fields = append(fields, userhistory.FieldTags)
	}
	if m.FieldCleared(userhistory.FieldFirstName) {
		fields = append(fields, userhistory.FieldFirstName)
	}
	if m.FieldCleared(userhistory.FieldLastName) {
		fields = append(fields, userhistory.FieldLastName)
	}
	if m.FieldCleared(userhistory.FieldAvatarRemoteURL) {
		fields = append(fields, userhistory.FieldAvatarRemoteURL)
	}
	if m.FieldCleared(userhistory.FieldAvatarLocalFile) {
		fields = append(fields, userhistory.FieldAvatarLocalFile)
	}
	if m.FieldCleared(userhistory.FieldAvatarLocalFileID) {
		fields = append(fields, userhistory.FieldAvatarLocalFileID)
	}
	if m.FieldCleared(userhistory.FieldAvatarUpdatedAt) {
		fields = append(fields, userhistory.FieldAvatarUpdatedAt)
	}
	if m.FieldCleared(userhistory.FieldLastSeen) {
		fields = append(fields, userhistory.FieldLastSeen)
	}
	if m.FieldCleared(userhistory.FieldPassword) {
		fields = append(fields, userhistory.FieldPassword)
	}
	if m.FieldCleared(userhistory.FieldSub) {
		fields = append(fields, userhistory.FieldSub)
	}
	if m.FieldCleared(userhistory.FieldRole) {
		fields = append(fields, userhistory.FieldRole)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserHistoryMutation) ClearField(name string) error {
	switch name {
	case userhistory.FieldRef:
		m.ClearRef()
		return nil
	case userhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case userhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case userhistory.FieldTags:
		m.ClearTags()
		return nil
	case userhistory.FieldFirstName:
		m.ClearFirstName()
		return nil
	case userhistory.FieldLastName:
		m.ClearLastName()
		return nil
	case userhistory.FieldAvatarRemoteURL:
		m.ClearAvatarRemoteURL()
		return nil
	case userhistory.FieldAvatarLocalFile:
		m.ClearAvatarLocalFile()
		return nil
	case userhistory.FieldAvatarLocalFileID:
		m.ClearAvatarLocalFileID()
		return nil
	case userhistory.FieldAvatarUpdatedAt:
		m.ClearAvatarUpdatedAt()
		return nil
	case userhistory.FieldLastSeen:
		m.ClearLastSeen()
		return nil
	case userhistory.FieldPassword:
		m.ClearPassword()
		return nil
	case userhistory.FieldSub:
		m.ClearSub()
		return nil
	case userhistory.FieldRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown UserHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserHistoryMutation) ResetField(name string) error {
	switch name {
	case userhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case userhistory.FieldRef:
		m.ResetRef()
		return nil
	case userhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case userhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case userhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case userhistory.FieldTags:
		m.ResetTags()
		return nil
	case userhistory.FieldEmail:
		m.ResetEmail()
		return nil
	case userhistory.FieldFirstName:
		m.ResetFirstName()
		return nil
	case userhistory.FieldLastName:
		m.ResetLastName()
		return nil
	case userhistory.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case userhistory.FieldAvatarRemoteURL:
		m.ResetAvatarRemoteURL()
		return nil
	case userhistory.FieldAvatarLocalFile:
		m.ResetAvatarLocalFile()
		return nil
	case userhistory.FieldAvatarLocalFileID:
		m.ResetAvatarLocalFileID()
		return nil
	case userhistory.FieldAvatarUpdatedAt:
		m.ResetAvatarUpdatedAt()
		return nil
	case userhistory.FieldLastSeen:
		m.ResetLastSeen()
		return nil
	case userhistory.FieldPassword:
		m.ResetPassword()
		return nil
	case userhistory.FieldSub:
		m.ResetSub()
		return nil
	case userhistory.FieldAuthProvider:
		m.ResetAuthProvider()
		return nil
	case userhistory.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown UserHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserHistory edge %s", name)
}

// UserSettingMutation represents an operation that mutates the UserSetting nodes in the graph.
type UserSettingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	mapping_id          *string
	tags                *[]string
	appendtags          []string
	deleted_at          *time.Time
	deleted_by          *string
	locked              *bool
	silenced_at         *time.Time
	suspended_at        *time.Time
	status              *enums.UserStatus
	email_confirmed     *bool
	is_webauthn_allowed *bool
	is_tfa_enabled      *bool
	phone_number        *string
	clearedFields       map[string]struct{}
	user                *string
	cleareduser         bool
	default_org         *string
	cleareddefault_org  bool
	files               map[string]struct{}
	removedfiles        map[string]struct{}
	clearedfiles        bool
	done                bool
	oldValue            func(context.Context) (*UserSetting, error)
	predicates          []predicate.UserSetting
}

var _ ent.Mutation = (*UserSettingMutation)(nil)

// usersettingOption allows management of the mutation configuration using functional options.
type usersettingOption func(*UserSettingMutation)

// newUserSettingMutation creates new mutation for the UserSetting entity.
func newUserSettingMutation(c config, op Op, opts ...usersettingOption) *UserSettingMutation {
	m := &UserSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSettingID sets the ID field of the mutation.
func withUserSettingID(id string) usersettingOption {
	return func(m *UserSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSetting
		)
		m.oldValue = func(ctx context.Context) (*UserSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSetting sets the old UserSetting of the mutation.
func withUserSetting(node *UserSetting) usersettingOption {
	return func(m *UserSettingMutation) {
		m.oldValue = func(context.Context) (*UserSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSetting entities.
func (m *UserSettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserSettingMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usersetting.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserSettingMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSettingMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usersetting.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserSettingMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usersetting.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserSettingMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usersetting.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserSettingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserSettingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserSettingMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[usersetting.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserSettingMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserSettingMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, usersetting.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserSettingMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserSettingMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserSettingMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[usersetting.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserSettingMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserSettingMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, usersetting.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *UserSettingMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *UserSettingMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *UserSettingMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *UserSettingMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *UserSettingMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *UserSettingMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *UserSettingMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *UserSettingMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[usersetting.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *UserSettingMutation) TagsCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *UserSettingMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, usersetting.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserSettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserSettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserSettingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usersetting.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserSettingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserSettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usersetting.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserSettingMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserSettingMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserSettingMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[usersetting.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserSettingMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserSettingMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, usersetting.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *UserSettingMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSettingMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserSettingMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[usersetting.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserSettingMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSettingMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, usersetting.FieldUserID)
}

// SetLocked sets the "locked" field.
func (m *UserSettingMutation) SetLocked(b bool) {
	m.locked = &b
}

// Locked returns the value of the "locked" field in the mutation.
func (m *UserSettingMutation) Locked() (r bool, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ResetLocked resets all changes to the "locked" field.
func (m *UserSettingMutation) ResetLocked() {
	m.locked = nil
}

// SetSilencedAt sets the "silenced_at" field.
func (m *UserSettingMutation) SetSilencedAt(t time.Time) {
	m.silenced_at = &t
}

// SilencedAt returns the value of the "silenced_at" field in the mutation.
func (m *UserSettingMutation) SilencedAt() (r time.Time, exists bool) {
	v := m.silenced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSilencedAt returns the old "silenced_at" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldSilencedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSilencedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSilencedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSilencedAt: %w", err)
	}
	return oldValue.SilencedAt, nil
}

// ClearSilencedAt clears the value of the "silenced_at" field.
func (m *UserSettingMutation) ClearSilencedAt() {
	m.silenced_at = nil
	m.clearedFields[usersetting.FieldSilencedAt] = struct{}{}
}

// SilencedAtCleared returns if the "silenced_at" field was cleared in this mutation.
func (m *UserSettingMutation) SilencedAtCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldSilencedAt]
	return ok
}

// ResetSilencedAt resets all changes to the "silenced_at" field.
func (m *UserSettingMutation) ResetSilencedAt() {
	m.silenced_at = nil
	delete(m.clearedFields, usersetting.FieldSilencedAt)
}

// SetSuspendedAt sets the "suspended_at" field.
func (m *UserSettingMutation) SetSuspendedAt(t time.Time) {
	m.suspended_at = &t
}

// SuspendedAt returns the value of the "suspended_at" field in the mutation.
func (m *UserSettingMutation) SuspendedAt() (r time.Time, exists bool) {
	v := m.suspended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedAt returns the old "suspended_at" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldSuspendedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedAt: %w", err)
	}
	return oldValue.SuspendedAt, nil
}

// ClearSuspendedAt clears the value of the "suspended_at" field.
func (m *UserSettingMutation) ClearSuspendedAt() {
	m.suspended_at = nil
	m.clearedFields[usersetting.FieldSuspendedAt] = struct{}{}
}

// SuspendedAtCleared returns if the "suspended_at" field was cleared in this mutation.
func (m *UserSettingMutation) SuspendedAtCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldSuspendedAt]
	return ok
}

// ResetSuspendedAt resets all changes to the "suspended_at" field.
func (m *UserSettingMutation) ResetSuspendedAt() {
	m.suspended_at = nil
	delete(m.clearedFields, usersetting.FieldSuspendedAt)
}

// SetStatus sets the "status" field.
func (m *UserSettingMutation) SetStatus(es enums.UserStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *UserSettingMutation) Status() (r enums.UserStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldStatus(ctx context.Context) (v enums.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserSettingMutation) ResetStatus() {
	m.status = nil
}

// SetEmailConfirmed sets the "email_confirmed" field.
func (m *UserSettingMutation) SetEmailConfirmed(b bool) {
	m.email_confirmed = &b
}

// EmailConfirmed returns the value of the "email_confirmed" field in the mutation.
func (m *UserSettingMutation) EmailConfirmed() (r bool, exists bool) {
	v := m.email_confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailConfirmed returns the old "email_confirmed" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldEmailConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailConfirmed: %w", err)
	}
	return oldValue.EmailConfirmed, nil
}

// ResetEmailConfirmed resets all changes to the "email_confirmed" field.
func (m *UserSettingMutation) ResetEmailConfirmed() {
	m.email_confirmed = nil
}

// SetIsWebauthnAllowed sets the "is_webauthn_allowed" field.
func (m *UserSettingMutation) SetIsWebauthnAllowed(b bool) {
	m.is_webauthn_allowed = &b
}

// IsWebauthnAllowed returns the value of the "is_webauthn_allowed" field in the mutation.
func (m *UserSettingMutation) IsWebauthnAllowed() (r bool, exists bool) {
	v := m.is_webauthn_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsWebauthnAllowed returns the old "is_webauthn_allowed" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldIsWebauthnAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsWebauthnAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsWebauthnAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsWebauthnAllowed: %w", err)
	}
	return oldValue.IsWebauthnAllowed, nil
}

// ClearIsWebauthnAllowed clears the value of the "is_webauthn_allowed" field.
func (m *UserSettingMutation) ClearIsWebauthnAllowed() {
	m.is_webauthn_allowed = nil
	m.clearedFields[usersetting.FieldIsWebauthnAllowed] = struct{}{}
}

// IsWebauthnAllowedCleared returns if the "is_webauthn_allowed" field was cleared in this mutation.
func (m *UserSettingMutation) IsWebauthnAllowedCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldIsWebauthnAllowed]
	return ok
}

// ResetIsWebauthnAllowed resets all changes to the "is_webauthn_allowed" field.
func (m *UserSettingMutation) ResetIsWebauthnAllowed() {
	m.is_webauthn_allowed = nil
	delete(m.clearedFields, usersetting.FieldIsWebauthnAllowed)
}

// SetIsTfaEnabled sets the "is_tfa_enabled" field.
func (m *UserSettingMutation) SetIsTfaEnabled(b bool) {
	m.is_tfa_enabled = &b
}

// IsTfaEnabled returns the value of the "is_tfa_enabled" field in the mutation.
func (m *UserSettingMutation) IsTfaEnabled() (r bool, exists bool) {
	v := m.is_tfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTfaEnabled returns the old "is_tfa_enabled" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldIsTfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTfaEnabled: %w", err)
	}
	return oldValue.IsTfaEnabled, nil
}

// ClearIsTfaEnabled clears the value of the "is_tfa_enabled" field.
func (m *UserSettingMutation) ClearIsTfaEnabled() {
	m.is_tfa_enabled = nil
	m.clearedFields[usersetting.FieldIsTfaEnabled] = struct{}{}
}

// IsTfaEnabledCleared returns if the "is_tfa_enabled" field was cleared in this mutation.
func (m *UserSettingMutation) IsTfaEnabledCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldIsTfaEnabled]
	return ok
}

// ResetIsTfaEnabled resets all changes to the "is_tfa_enabled" field.
func (m *UserSettingMutation) ResetIsTfaEnabled() {
	m.is_tfa_enabled = nil
	delete(m.clearedFields, usersetting.FieldIsTfaEnabled)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserSettingMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserSettingMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the UserSetting entity.
// If the UserSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingMutation) OldPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserSettingMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[usersetting.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserSettingMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[usersetting.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserSettingMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, usersetting.FieldPhoneNumber)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSettingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usersetting.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSettingMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSettingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSettingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDefaultOrgID sets the "default_org" edge to the Organization entity by id.
func (m *UserSettingMutation) SetDefaultOrgID(id string) {
	m.default_org = &id
}

// ClearDefaultOrg clears the "default_org" edge to the Organization entity.
func (m *UserSettingMutation) ClearDefaultOrg() {
	m.cleareddefault_org = true
}

// DefaultOrgCleared reports if the "default_org" edge to the Organization entity was cleared.
func (m *UserSettingMutation) DefaultOrgCleared() bool {
	return m.cleareddefault_org
}

// DefaultOrgID returns the "default_org" edge ID in the mutation.
func (m *UserSettingMutation) DefaultOrgID() (id string, exists bool) {
	if m.default_org != nil {
		return *m.default_org, true
	}
	return
}

// DefaultOrgIDs returns the "default_org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultOrgID instead. It exists only for internal usage by the builders.
func (m *UserSettingMutation) DefaultOrgIDs() (ids []string) {
	if id := m.default_org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultOrg resets all changes to the "default_org" edge.
func (m *UserSettingMutation) ResetDefaultOrg() {
	m.default_org = nil
	m.cleareddefault_org = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserSettingMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserSettingMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserSettingMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserSettingMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserSettingMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserSettingMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserSettingMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the UserSettingMutation builder.
func (m *UserSettingMutation) Where(ps ...predicate.UserSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSetting).
func (m *UserSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSettingMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, usersetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersetting.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, usersetting.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, usersetting.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, usersetting.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, usersetting.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, usersetting.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, usersetting.FieldDeletedBy)
	}
	if m.user != nil {
		fields = append(fields, usersetting.FieldUserID)
	}
	if m.locked != nil {
		fields = append(fields, usersetting.FieldLocked)
	}
	if m.silenced_at != nil {
		fields = append(fields, usersetting.FieldSilencedAt)
	}
	if m.suspended_at != nil {
		fields = append(fields, usersetting.FieldSuspendedAt)
	}
	if m.status != nil {
		fields = append(fields, usersetting.FieldStatus)
	}
	if m.email_confirmed != nil {
		fields = append(fields, usersetting.FieldEmailConfirmed)
	}
	if m.is_webauthn_allowed != nil {
		fields = append(fields, usersetting.FieldIsWebauthnAllowed)
	}
	if m.is_tfa_enabled != nil {
		fields = append(fields, usersetting.FieldIsTfaEnabled)
	}
	if m.phone_number != nil {
		fields = append(fields, usersetting.FieldPhoneNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersetting.FieldCreatedAt:
		return m.CreatedAt()
	case usersetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersetting.FieldCreatedBy:
		return m.CreatedBy()
	case usersetting.FieldUpdatedBy:
		return m.UpdatedBy()
	case usersetting.FieldMappingID:
		return m.MappingID()
	case usersetting.FieldTags:
		return m.Tags()
	case usersetting.FieldDeletedAt:
		return m.DeletedAt()
	case usersetting.FieldDeletedBy:
		return m.DeletedBy()
	case usersetting.FieldUserID:
		return m.UserID()
	case usersetting.FieldLocked:
		return m.Locked()
	case usersetting.FieldSilencedAt:
		return m.SilencedAt()
	case usersetting.FieldSuspendedAt:
		return m.SuspendedAt()
	case usersetting.FieldStatus:
		return m.Status()
	case usersetting.FieldEmailConfirmed:
		return m.EmailConfirmed()
	case usersetting.FieldIsWebauthnAllowed:
		return m.IsWebauthnAllowed()
	case usersetting.FieldIsTfaEnabled:
		return m.IsTfaEnabled()
	case usersetting.FieldPhoneNumber:
		return m.PhoneNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersetting.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case usersetting.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case usersetting.FieldMappingID:
		return m.OldMappingID(ctx)
	case usersetting.FieldTags:
		return m.OldTags(ctx)
	case usersetting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usersetting.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case usersetting.FieldUserID:
		return m.OldUserID(ctx)
	case usersetting.FieldLocked:
		return m.OldLocked(ctx)
	case usersetting.FieldSilencedAt:
		return m.OldSilencedAt(ctx)
	case usersetting.FieldSuspendedAt:
		return m.OldSuspendedAt(ctx)
	case usersetting.FieldStatus:
		return m.OldStatus(ctx)
	case usersetting.FieldEmailConfirmed:
		return m.OldEmailConfirmed(ctx)
	case usersetting.FieldIsWebauthnAllowed:
		return m.OldIsWebauthnAllowed(ctx)
	case usersetting.FieldIsTfaEnabled:
		return m.OldIsTfaEnabled(ctx)
	case usersetting.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	}
	return nil, fmt.Errorf("unknown UserSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersetting.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case usersetting.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case usersetting.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case usersetting.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case usersetting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usersetting.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case usersetting.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersetting.FieldLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case usersetting.FieldSilencedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilencedAt(v)
		return nil
	case usersetting.FieldSuspendedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedAt(v)
		return nil
	case usersetting.FieldStatus:
		v, ok := value.(enums.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usersetting.FieldEmailConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailConfirmed(v)
		return nil
	case usersetting.FieldIsWebauthnAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsWebauthnAllowed(v)
		return nil
	case usersetting.FieldIsTfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTfaEnabled(v)
		return nil
	case usersetting.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	}
	return fmt.Errorf("unknown UserSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersetting.FieldCreatedAt) {
		fields = append(fields, usersetting.FieldCreatedAt)
	}
	if m.FieldCleared(usersetting.FieldUpdatedAt) {
		fields = append(fields, usersetting.FieldUpdatedAt)
	}
	if m.FieldCleared(usersetting.FieldCreatedBy) {
		fields = append(fields, usersetting.FieldCreatedBy)
	}
	if m.FieldCleared(usersetting.FieldUpdatedBy) {
		fields = append(fields, usersetting.FieldUpdatedBy)
	}
	if m.FieldCleared(usersetting.FieldTags) {
		fields = append(fields, usersetting.FieldTags)
	}
	if m.FieldCleared(usersetting.FieldDeletedAt) {
		fields = append(fields, usersetting.FieldDeletedAt)
	}
	if m.FieldCleared(usersetting.FieldDeletedBy) {
		fields = append(fields, usersetting.FieldDeletedBy)
	}
	if m.FieldCleared(usersetting.FieldUserID) {
		fields = append(fields, usersetting.FieldUserID)
	}
	if m.FieldCleared(usersetting.FieldSilencedAt) {
		fields = append(fields, usersetting.FieldSilencedAt)
	}
	if m.FieldCleared(usersetting.FieldSuspendedAt) {
		fields = append(fields, usersetting.FieldSuspendedAt)
	}
	if m.FieldCleared(usersetting.FieldIsWebauthnAllowed) {
		fields = append(fields, usersetting.FieldIsWebauthnAllowed)
	}
	if m.FieldCleared(usersetting.FieldIsTfaEnabled) {
		fields = append(fields, usersetting.FieldIsTfaEnabled)
	}
	if m.FieldCleared(usersetting.FieldPhoneNumber) {
		fields = append(fields, usersetting.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSettingMutation) ClearField(name string) error {
	switch name {
	case usersetting.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usersetting.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case usersetting.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case usersetting.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case usersetting.FieldTags:
		m.ClearTags()
		return nil
	case usersetting.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usersetting.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case usersetting.FieldUserID:
		m.ClearUserID()
		return nil
	case usersetting.FieldSilencedAt:
		m.ClearSilencedAt()
		return nil
	case usersetting.FieldSuspendedAt:
		m.ClearSuspendedAt()
		return nil
	case usersetting.FieldIsWebauthnAllowed:
		m.ClearIsWebauthnAllowed()
		return nil
	case usersetting.FieldIsTfaEnabled:
		m.ClearIsTfaEnabled()
		return nil
	case usersetting.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown UserSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSettingMutation) ResetField(name string) error {
	switch name {
	case usersetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersetting.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case usersetting.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case usersetting.FieldMappingID:
		m.ResetMappingID()
		return nil
	case usersetting.FieldTags:
		m.ResetTags()
		return nil
	case usersetting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usersetting.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case usersetting.FieldUserID:
		m.ResetUserID()
		return nil
	case usersetting.FieldLocked:
		m.ResetLocked()
		return nil
	case usersetting.FieldSilencedAt:
		m.ResetSilencedAt()
		return nil
	case usersetting.FieldSuspendedAt:
		m.ResetSuspendedAt()
		return nil
	case usersetting.FieldStatus:
		m.ResetStatus()
		return nil
	case usersetting.FieldEmailConfirmed:
		m.ResetEmailConfirmed()
		return nil
	case usersetting.FieldIsWebauthnAllowed:
		m.ResetIsWebauthnAllowed()
		return nil
	case usersetting.FieldIsTfaEnabled:
		m.ResetIsTfaEnabled()
		return nil
	case usersetting.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown UserSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, usersetting.EdgeUser)
	}
	if m.default_org != nil {
		edges = append(edges, usersetting.EdgeDefaultOrg)
	}
	if m.files != nil {
		edges = append(edges, usersetting.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersetting.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usersetting.EdgeDefaultOrg:
		if id := m.default_org; id != nil {
			return []ent.Value{*id}
		}
	case usersetting.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfiles != nil {
		edges = append(edges, usersetting.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSettingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usersetting.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, usersetting.EdgeUser)
	}
	if m.cleareddefault_org {
		edges = append(edges, usersetting.EdgeDefaultOrg)
	}
	if m.clearedfiles {
		edges = append(edges, usersetting.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSettingMutation) EdgeCleared(name string) bool {
	switch name {
	case usersetting.EdgeUser:
		return m.cleareduser
	case usersetting.EdgeDefaultOrg:
		return m.cleareddefault_org
	case usersetting.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSettingMutation) ClearEdge(name string) error {
	switch name {
	case usersetting.EdgeUser:
		m.ClearUser()
		return nil
	case usersetting.EdgeDefaultOrg:
		m.ClearDefaultOrg()
		return nil
	}
	return fmt.Errorf("unknown UserSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSettingMutation) ResetEdge(name string) error {
	switch name {
	case usersetting.EdgeUser:
		m.ResetUser()
		return nil
	case usersetting.EdgeDefaultOrg:
		m.ResetDefaultOrg()
		return nil
	case usersetting.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown UserSetting edge %s", name)
}

// UserSettingHistoryMutation represents an operation that mutates the UserSettingHistory nodes in the graph.
type UserSettingHistoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	history_time        *time.Time
	ref                 *string
	operation           *history.OpType
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	mapping_id          *string
	tags                *[]string
	appendtags          []string
	deleted_at          *time.Time
	deleted_by          *string
	user_id             *string
	locked              *bool
	silenced_at         *time.Time
	suspended_at        *time.Time
	status              *enums.UserStatus
	email_confirmed     *bool
	is_webauthn_allowed *bool
	is_tfa_enabled      *bool
	phone_number        *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*UserSettingHistory, error)
	predicates          []predicate.UserSettingHistory
}

var _ ent.Mutation = (*UserSettingHistoryMutation)(nil)

// usersettinghistoryOption allows management of the mutation configuration using functional options.
type usersettinghistoryOption func(*UserSettingHistoryMutation)

// newUserSettingHistoryMutation creates new mutation for the UserSettingHistory entity.
func newUserSettingHistoryMutation(c config, op Op, opts ...usersettinghistoryOption) *UserSettingHistoryMutation {
	m := &UserSettingHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSettingHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSettingHistoryID sets the ID field of the mutation.
func withUserSettingHistoryID(id string) usersettinghistoryOption {
	return func(m *UserSettingHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSettingHistory
		)
		m.oldValue = func(ctx context.Context) (*UserSettingHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSettingHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSettingHistory sets the old UserSettingHistory of the mutation.
func withUserSettingHistory(node *UserSettingHistory) usersettinghistoryOption {
	return func(m *UserSettingHistoryMutation) {
		m.oldValue = func(context.Context) (*UserSettingHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSettingHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSettingHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSettingHistory entities.
func (m *UserSettingHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSettingHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSettingHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSettingHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *UserSettingHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *UserSettingHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *UserSettingHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *UserSettingHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *UserSettingHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *UserSettingHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[usersettinghistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *UserSettingHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, usersettinghistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *UserSettingHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *UserSettingHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *UserSettingHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSettingHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSettingHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserSettingHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[usersettinghistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSettingHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, usersettinghistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSettingHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSettingHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserSettingHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[usersettinghistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSettingHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, usersettinghistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *UserSettingHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserSettingHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserSettingHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[usersettinghistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserSettingHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, usersettinghistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserSettingHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserSettingHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserSettingHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[usersettinghistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserSettingHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, usersettinghistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *UserSettingHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *UserSettingHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *UserSettingHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *UserSettingHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *UserSettingHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *UserSettingHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *UserSettingHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *UserSettingHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[usersettinghistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *UserSettingHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, usersettinghistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserSettingHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserSettingHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserSettingHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usersettinghistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserSettingHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usersettinghistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserSettingHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserSettingHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserSettingHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[usersettinghistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserSettingHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, usersettinghistory.FieldDeletedBy)
}

// SetUserID sets the "user_id" field.
func (m *UserSettingHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSettingHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserSettingHistoryMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[usersettinghistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSettingHistoryMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, usersettinghistory.FieldUserID)
}

// SetLocked sets the "locked" field.
func (m *UserSettingHistoryMutation) SetLocked(b bool) {
	m.locked = &b
}

// Locked returns the value of the "locked" field in the mutation.
func (m *UserSettingHistoryMutation) Locked() (r bool, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ResetLocked resets all changes to the "locked" field.
func (m *UserSettingHistoryMutation) ResetLocked() {
	m.locked = nil
}

// SetSilencedAt sets the "silenced_at" field.
func (m *UserSettingHistoryMutation) SetSilencedAt(t time.Time) {
	m.silenced_at = &t
}

// SilencedAt returns the value of the "silenced_at" field in the mutation.
func (m *UserSettingHistoryMutation) SilencedAt() (r time.Time, exists bool) {
	v := m.silenced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSilencedAt returns the old "silenced_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldSilencedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSilencedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSilencedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSilencedAt: %w", err)
	}
	return oldValue.SilencedAt, nil
}

// ClearSilencedAt clears the value of the "silenced_at" field.
func (m *UserSettingHistoryMutation) ClearSilencedAt() {
	m.silenced_at = nil
	m.clearedFields[usersettinghistory.FieldSilencedAt] = struct{}{}
}

// SilencedAtCleared returns if the "silenced_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) SilencedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldSilencedAt]
	return ok
}

// ResetSilencedAt resets all changes to the "silenced_at" field.
func (m *UserSettingHistoryMutation) ResetSilencedAt() {
	m.silenced_at = nil
	delete(m.clearedFields, usersettinghistory.FieldSilencedAt)
}

// SetSuspendedAt sets the "suspended_at" field.
func (m *UserSettingHistoryMutation) SetSuspendedAt(t time.Time) {
	m.suspended_at = &t
}

// SuspendedAt returns the value of the "suspended_at" field in the mutation.
func (m *UserSettingHistoryMutation) SuspendedAt() (r time.Time, exists bool) {
	v := m.suspended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedAt returns the old "suspended_at" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldSuspendedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedAt: %w", err)
	}
	return oldValue.SuspendedAt, nil
}

// ClearSuspendedAt clears the value of the "suspended_at" field.
func (m *UserSettingHistoryMutation) ClearSuspendedAt() {
	m.suspended_at = nil
	m.clearedFields[usersettinghistory.FieldSuspendedAt] = struct{}{}
}

// SuspendedAtCleared returns if the "suspended_at" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) SuspendedAtCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldSuspendedAt]
	return ok
}

// ResetSuspendedAt resets all changes to the "suspended_at" field.
func (m *UserSettingHistoryMutation) ResetSuspendedAt() {
	m.suspended_at = nil
	delete(m.clearedFields, usersettinghistory.FieldSuspendedAt)
}

// SetStatus sets the "status" field.
func (m *UserSettingHistoryMutation) SetStatus(es enums.UserStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *UserSettingHistoryMutation) Status() (r enums.UserStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldStatus(ctx context.Context) (v enums.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserSettingHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetEmailConfirmed sets the "email_confirmed" field.
func (m *UserSettingHistoryMutation) SetEmailConfirmed(b bool) {
	m.email_confirmed = &b
}

// EmailConfirmed returns the value of the "email_confirmed" field in the mutation.
func (m *UserSettingHistoryMutation) EmailConfirmed() (r bool, exists bool) {
	v := m.email_confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailConfirmed returns the old "email_confirmed" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldEmailConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailConfirmed: %w", err)
	}
	return oldValue.EmailConfirmed, nil
}

// ResetEmailConfirmed resets all changes to the "email_confirmed" field.
func (m *UserSettingHistoryMutation) ResetEmailConfirmed() {
	m.email_confirmed = nil
}

// SetIsWebauthnAllowed sets the "is_webauthn_allowed" field.
func (m *UserSettingHistoryMutation) SetIsWebauthnAllowed(b bool) {
	m.is_webauthn_allowed = &b
}

// IsWebauthnAllowed returns the value of the "is_webauthn_allowed" field in the mutation.
func (m *UserSettingHistoryMutation) IsWebauthnAllowed() (r bool, exists bool) {
	v := m.is_webauthn_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsWebauthnAllowed returns the old "is_webauthn_allowed" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldIsWebauthnAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsWebauthnAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsWebauthnAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsWebauthnAllowed: %w", err)
	}
	return oldValue.IsWebauthnAllowed, nil
}

// ClearIsWebauthnAllowed clears the value of the "is_webauthn_allowed" field.
func (m *UserSettingHistoryMutation) ClearIsWebauthnAllowed() {
	m.is_webauthn_allowed = nil
	m.clearedFields[usersettinghistory.FieldIsWebauthnAllowed] = struct{}{}
}

// IsWebauthnAllowedCleared returns if the "is_webauthn_allowed" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) IsWebauthnAllowedCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldIsWebauthnAllowed]
	return ok
}

// ResetIsWebauthnAllowed resets all changes to the "is_webauthn_allowed" field.
func (m *UserSettingHistoryMutation) ResetIsWebauthnAllowed() {
	m.is_webauthn_allowed = nil
	delete(m.clearedFields, usersettinghistory.FieldIsWebauthnAllowed)
}

// SetIsTfaEnabled sets the "is_tfa_enabled" field.
func (m *UserSettingHistoryMutation) SetIsTfaEnabled(b bool) {
	m.is_tfa_enabled = &b
}

// IsTfaEnabled returns the value of the "is_tfa_enabled" field in the mutation.
func (m *UserSettingHistoryMutation) IsTfaEnabled() (r bool, exists bool) {
	v := m.is_tfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTfaEnabled returns the old "is_tfa_enabled" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldIsTfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTfaEnabled: %w", err)
	}
	return oldValue.IsTfaEnabled, nil
}

// ClearIsTfaEnabled clears the value of the "is_tfa_enabled" field.
func (m *UserSettingHistoryMutation) ClearIsTfaEnabled() {
	m.is_tfa_enabled = nil
	m.clearedFields[usersettinghistory.FieldIsTfaEnabled] = struct{}{}
}

// IsTfaEnabledCleared returns if the "is_tfa_enabled" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) IsTfaEnabledCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldIsTfaEnabled]
	return ok
}

// ResetIsTfaEnabled resets all changes to the "is_tfa_enabled" field.
func (m *UserSettingHistoryMutation) ResetIsTfaEnabled() {
	m.is_tfa_enabled = nil
	delete(m.clearedFields, usersettinghistory.FieldIsTfaEnabled)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserSettingHistoryMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserSettingHistoryMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the UserSettingHistory entity.
// If the UserSettingHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingHistoryMutation) OldPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserSettingHistoryMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[usersettinghistory.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserSettingHistoryMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[usersettinghistory.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserSettingHistoryMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, usersettinghistory.FieldPhoneNumber)
}

// Where appends a list predicates to the UserSettingHistoryMutation builder.
func (m *UserSettingHistoryMutation) Where(ps ...predicate.UserSettingHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSettingHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSettingHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSettingHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSettingHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSettingHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSettingHistory).
func (m *UserSettingHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSettingHistoryMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.history_time != nil {
		fields = append(fields, usersettinghistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, usersettinghistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, usersettinghistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, usersettinghistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersettinghistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, usersettinghistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, usersettinghistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, usersettinghistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, usersettinghistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, usersettinghistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, usersettinghistory.FieldDeletedBy)
	}
	if m.user_id != nil {
		fields = append(fields, usersettinghistory.FieldUserID)
	}
	if m.locked != nil {
		fields = append(fields, usersettinghistory.FieldLocked)
	}
	if m.silenced_at != nil {
		fields = append(fields, usersettinghistory.FieldSilencedAt)
	}
	if m.suspended_at != nil {
		fields = append(fields, usersettinghistory.FieldSuspendedAt)
	}
	if m.status != nil {
		fields = append(fields, usersettinghistory.FieldStatus)
	}
	if m.email_confirmed != nil {
		fields = append(fields, usersettinghistory.FieldEmailConfirmed)
	}
	if m.is_webauthn_allowed != nil {
		fields = append(fields, usersettinghistory.FieldIsWebauthnAllowed)
	}
	if m.is_tfa_enabled != nil {
		fields = append(fields, usersettinghistory.FieldIsTfaEnabled)
	}
	if m.phone_number != nil {
		fields = append(fields, usersettinghistory.FieldPhoneNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSettingHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersettinghistory.FieldHistoryTime:
		return m.HistoryTime()
	case usersettinghistory.FieldRef:
		return m.Ref()
	case usersettinghistory.FieldOperation:
		return m.Operation()
	case usersettinghistory.FieldCreatedAt:
		return m.CreatedAt()
	case usersettinghistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersettinghistory.FieldCreatedBy:
		return m.CreatedBy()
	case usersettinghistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case usersettinghistory.FieldMappingID:
		return m.MappingID()
	case usersettinghistory.FieldTags:
		return m.Tags()
	case usersettinghistory.FieldDeletedAt:
		return m.DeletedAt()
	case usersettinghistory.FieldDeletedBy:
		return m.DeletedBy()
	case usersettinghistory.FieldUserID:
		return m.UserID()
	case usersettinghistory.FieldLocked:
		return m.Locked()
	case usersettinghistory.FieldSilencedAt:
		return m.SilencedAt()
	case usersettinghistory.FieldSuspendedAt:
		return m.SuspendedAt()
	case usersettinghistory.FieldStatus:
		return m.Status()
	case usersettinghistory.FieldEmailConfirmed:
		return m.EmailConfirmed()
	case usersettinghistory.FieldIsWebauthnAllowed:
		return m.IsWebauthnAllowed()
	case usersettinghistory.FieldIsTfaEnabled:
		return m.IsTfaEnabled()
	case usersettinghistory.FieldPhoneNumber:
		return m.PhoneNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSettingHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersettinghistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case usersettinghistory.FieldRef:
		return m.OldRef(ctx)
	case usersettinghistory.FieldOperation:
		return m.OldOperation(ctx)
	case usersettinghistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersettinghistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersettinghistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case usersettinghistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case usersettinghistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case usersettinghistory.FieldTags:
		return m.OldTags(ctx)
	case usersettinghistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usersettinghistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case usersettinghistory.FieldUserID:
		return m.OldUserID(ctx)
	case usersettinghistory.FieldLocked:
		return m.OldLocked(ctx)
	case usersettinghistory.FieldSilencedAt:
		return m.OldSilencedAt(ctx)
	case usersettinghistory.FieldSuspendedAt:
		return m.OldSuspendedAt(ctx)
	case usersettinghistory.FieldStatus:
		return m.OldStatus(ctx)
	case usersettinghistory.FieldEmailConfirmed:
		return m.OldEmailConfirmed(ctx)
	case usersettinghistory.FieldIsWebauthnAllowed:
		return m.OldIsWebauthnAllowed(ctx)
	case usersettinghistory.FieldIsTfaEnabled:
		return m.OldIsTfaEnabled(ctx)
	case usersettinghistory.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	}
	return nil, fmt.Errorf("unknown UserSettingHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersettinghistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case usersettinghistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case usersettinghistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case usersettinghistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersettinghistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersettinghistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case usersettinghistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case usersettinghistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case usersettinghistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case usersettinghistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usersettinghistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case usersettinghistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersettinghistory.FieldLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case usersettinghistory.FieldSilencedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilencedAt(v)
		return nil
	case usersettinghistory.FieldSuspendedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedAt(v)
		return nil
	case usersettinghistory.FieldStatus:
		v, ok := value.(enums.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usersettinghistory.FieldEmailConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailConfirmed(v)
		return nil
	case usersettinghistory.FieldIsWebauthnAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsWebauthnAllowed(v)
		return nil
	case usersettinghistory.FieldIsTfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTfaEnabled(v)
		return nil
	case usersettinghistory.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	}
	return fmt.Errorf("unknown UserSettingHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSettingHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSettingHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSettingHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSettingHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersettinghistory.FieldRef) {
		fields = append(fields, usersettinghistory.FieldRef)
	}
	if m.FieldCleared(usersettinghistory.FieldCreatedAt) {
		fields = append(fields, usersettinghistory.FieldCreatedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldUpdatedAt) {
		fields = append(fields, usersettinghistory.FieldUpdatedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldCreatedBy) {
		fields = append(fields, usersettinghistory.FieldCreatedBy)
	}
	if m.FieldCleared(usersettinghistory.FieldUpdatedBy) {
		fields = append(fields, usersettinghistory.FieldUpdatedBy)
	}
	if m.FieldCleared(usersettinghistory.FieldTags) {
		fields = append(fields, usersettinghistory.FieldTags)
	}
	if m.FieldCleared(usersettinghistory.FieldDeletedAt) {
		fields = append(fields, usersettinghistory.FieldDeletedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldDeletedBy) {
		fields = append(fields, usersettinghistory.FieldDeletedBy)
	}
	if m.FieldCleared(usersettinghistory.FieldUserID) {
		fields = append(fields, usersettinghistory.FieldUserID)
	}
	if m.FieldCleared(usersettinghistory.FieldSilencedAt) {
		fields = append(fields, usersettinghistory.FieldSilencedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldSuspendedAt) {
		fields = append(fields, usersettinghistory.FieldSuspendedAt)
	}
	if m.FieldCleared(usersettinghistory.FieldIsWebauthnAllowed) {
		fields = append(fields, usersettinghistory.FieldIsWebauthnAllowed)
	}
	if m.FieldCleared(usersettinghistory.FieldIsTfaEnabled) {
		fields = append(fields, usersettinghistory.FieldIsTfaEnabled)
	}
	if m.FieldCleared(usersettinghistory.FieldPhoneNumber) {
		fields = append(fields, usersettinghistory.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSettingHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSettingHistoryMutation) ClearField(name string) error {
	switch name {
	case usersettinghistory.FieldRef:
		m.ClearRef()
		return nil
	case usersettinghistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case usersettinghistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case usersettinghistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case usersettinghistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case usersettinghistory.FieldTags:
		m.ClearTags()
		return nil
	case usersettinghistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usersettinghistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case usersettinghistory.FieldUserID:
		m.ClearUserID()
		return nil
	case usersettinghistory.FieldSilencedAt:
		m.ClearSilencedAt()
		return nil
	case usersettinghistory.FieldSuspendedAt:
		m.ClearSuspendedAt()
		return nil
	case usersettinghistory.FieldIsWebauthnAllowed:
		m.ClearIsWebauthnAllowed()
		return nil
	case usersettinghistory.FieldIsTfaEnabled:
		m.ClearIsTfaEnabled()
		return nil
	case usersettinghistory.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown UserSettingHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSettingHistoryMutation) ResetField(name string) error {
	switch name {
	case usersettinghistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case usersettinghistory.FieldRef:
		m.ResetRef()
		return nil
	case usersettinghistory.FieldOperation:
		m.ResetOperation()
		return nil
	case usersettinghistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersettinghistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersettinghistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case usersettinghistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case usersettinghistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case usersettinghistory.FieldTags:
		m.ResetTags()
		return nil
	case usersettinghistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usersettinghistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case usersettinghistory.FieldUserID:
		m.ResetUserID()
		return nil
	case usersettinghistory.FieldLocked:
		m.ResetLocked()
		return nil
	case usersettinghistory.FieldSilencedAt:
		m.ResetSilencedAt()
		return nil
	case usersettinghistory.FieldSuspendedAt:
		m.ResetSuspendedAt()
		return nil
	case usersettinghistory.FieldStatus:
		m.ResetStatus()
		return nil
	case usersettinghistory.FieldEmailConfirmed:
		m.ResetEmailConfirmed()
		return nil
	case usersettinghistory.FieldIsWebauthnAllowed:
		m.ResetIsWebauthnAllowed()
		return nil
	case usersettinghistory.FieldIsTfaEnabled:
		m.ResetIsTfaEnabled()
		return nil
	case usersettinghistory.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown UserSettingHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSettingHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSettingHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSettingHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSettingHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSettingHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSettingHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSettingHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserSettingHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSettingHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserSettingHistory edge %s", name)
}

// WebauthnMutation represents an operation that mutates the Webauthn nodes in the graph.
type WebauthnMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	created_by       *string
	updated_by       *string
	mapping_id       *string
	tags             *[]string
	appendtags       []string
	credential_id    *[]byte
	public_key       *[]byte
	attestation_type *string
	aaguid           *[]byte
	sign_count       *int32
	addsign_count    *int32
	transports       *[]string
	appendtransports []string
	backup_eligible  *bool
	backup_state     *bool
	user_present     *bool
	user_verified    *bool
	clearedFields    map[string]struct{}
	owner            *string
	clearedowner     bool
	done             bool
	oldValue         func(context.Context) (*Webauthn, error)
	predicates       []predicate.Webauthn
}

var _ ent.Mutation = (*WebauthnMutation)(nil)

// webauthnOption allows management of the mutation configuration using functional options.
type webauthnOption func(*WebauthnMutation)

// newWebauthnMutation creates new mutation for the Webauthn entity.
func newWebauthnMutation(c config, op Op, opts ...webauthnOption) *WebauthnMutation {
	m := &WebauthnMutation{
		config:        c,
		op:            op,
		typ:           TypeWebauthn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebauthnID sets the ID field of the mutation.
func withWebauthnID(id string) webauthnOption {
	return func(m *WebauthnMutation) {
		var (
			err   error
			once  sync.Once
			value *Webauthn
		)
		m.oldValue = func(ctx context.Context) (*Webauthn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Webauthn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebauthn sets the old Webauthn of the mutation.
func withWebauthn(node *Webauthn) webauthnOption {
	return func(m *WebauthnMutation) {
		m.oldValue = func(context.Context) (*Webauthn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebauthnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebauthnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Webauthn entities.
func (m *WebauthnMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebauthnMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebauthnMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Webauthn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WebauthnMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebauthnMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WebauthnMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[webauthn.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WebauthnMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[webauthn.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebauthnMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, webauthn.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebauthnMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebauthnMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WebauthnMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[webauthn.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WebauthnMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[webauthn.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebauthnMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, webauthn.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WebauthnMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WebauthnMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WebauthnMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[webauthn.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WebauthnMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[webauthn.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WebauthnMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, webauthn.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WebauthnMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WebauthnMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WebauthnMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[webauthn.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WebauthnMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[webauthn.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WebauthnMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, webauthn.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *WebauthnMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *WebauthnMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *WebauthnMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *WebauthnMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WebauthnMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WebauthnMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WebauthnMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WebauthnMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[webauthn.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WebauthnMutation) TagsCleared() bool {
	_, ok := m.clearedFields[webauthn.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WebauthnMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, webauthn.FieldTags)
}

// SetOwnerID sets the "owner_id" field.
func (m *WebauthnMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WebauthnMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WebauthnMutation) ResetOwnerID() {
	m.owner = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *WebauthnMutation) SetCredentialID(b []byte) {
	m.credential_id = &b
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *WebauthnMutation) CredentialID() (r []byte, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldCredentialID(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ClearCredentialID clears the value of the "credential_id" field.
func (m *WebauthnMutation) ClearCredentialID() {
	m.credential_id = nil
	m.clearedFields[webauthn.FieldCredentialID] = struct{}{}
}

// CredentialIDCleared returns if the "credential_id" field was cleared in this mutation.
func (m *WebauthnMutation) CredentialIDCleared() bool {
	_, ok := m.clearedFields[webauthn.FieldCredentialID]
	return ok
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *WebauthnMutation) ResetCredentialID() {
	m.credential_id = nil
	delete(m.clearedFields, webauthn.FieldCredentialID)
}

// SetPublicKey sets the "public_key" field.
func (m *WebauthnMutation) SetPublicKey(b []byte) {
	m.public_key = &b
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *WebauthnMutation) PublicKey() (r []byte, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ClearPublicKey clears the value of the "public_key" field.
func (m *WebauthnMutation) ClearPublicKey() {
	m.public_key = nil
	m.clearedFields[webauthn.FieldPublicKey] = struct{}{}
}

// PublicKeyCleared returns if the "public_key" field was cleared in this mutation.
func (m *WebauthnMutation) PublicKeyCleared() bool {
	_, ok := m.clearedFields[webauthn.FieldPublicKey]
	return ok
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *WebauthnMutation) ResetPublicKey() {
	m.public_key = nil
	delete(m.clearedFields, webauthn.FieldPublicKey)
}

// SetAttestationType sets the "attestation_type" field.
func (m *WebauthnMutation) SetAttestationType(s string) {
	m.attestation_type = &s
}

// AttestationType returns the value of the "attestation_type" field in the mutation.
func (m *WebauthnMutation) AttestationType() (r string, exists bool) {
	v := m.attestation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestationType returns the old "attestation_type" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldAttestationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestationType: %w", err)
	}
	return oldValue.AttestationType, nil
}

// ClearAttestationType clears the value of the "attestation_type" field.
func (m *WebauthnMutation) ClearAttestationType() {
	m.attestation_type = nil
	m.clearedFields[webauthn.FieldAttestationType] = struct{}{}
}

// AttestationTypeCleared returns if the "attestation_type" field was cleared in this mutation.
func (m *WebauthnMutation) AttestationTypeCleared() bool {
	_, ok := m.clearedFields[webauthn.FieldAttestationType]
	return ok
}

// ResetAttestationType resets all changes to the "attestation_type" field.
func (m *WebauthnMutation) ResetAttestationType() {
	m.attestation_type = nil
	delete(m.clearedFields, webauthn.FieldAttestationType)
}

// SetAaguid sets the "aaguid" field.
func (m *WebauthnMutation) SetAaguid(b []byte) {
	m.aaguid = &b
}

// Aaguid returns the value of the "aaguid" field in the mutation.
func (m *WebauthnMutation) Aaguid() (r []byte, exists bool) {
	v := m.aaguid
	if v == nil {
		return
	}
	return *v, true
}

// OldAaguid returns the old "aaguid" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldAaguid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAaguid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAaguid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAaguid: %w", err)
	}
	return oldValue.Aaguid, nil
}

// ResetAaguid resets all changes to the "aaguid" field.
func (m *WebauthnMutation) ResetAaguid() {
	m.aaguid = nil
}

// SetSignCount sets the "sign_count" field.
func (m *WebauthnMutation) SetSignCount(i int32) {
	m.sign_count = &i
	m.addsign_count = nil
}

// SignCount returns the value of the "sign_count" field in the mutation.
func (m *WebauthnMutation) SignCount() (r int32, exists bool) {
	v := m.sign_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSignCount returns the old "sign_count" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldSignCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignCount: %w", err)
	}
	return oldValue.SignCount, nil
}

// AddSignCount adds i to the "sign_count" field.
func (m *WebauthnMutation) AddSignCount(i int32) {
	if m.addsign_count != nil {
		*m.addsign_count += i
	} else {
		m.addsign_count = &i
	}
}

// AddedSignCount returns the value that was added to the "sign_count" field in this mutation.
func (m *WebauthnMutation) AddedSignCount() (r int32, exists bool) {
	v := m.addsign_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignCount resets all changes to the "sign_count" field.
func (m *WebauthnMutation) ResetSignCount() {
	m.sign_count = nil
	m.addsign_count = nil
}

// SetTransports sets the "transports" field.
func (m *WebauthnMutation) SetTransports(s []string) {
	m.transports = &s
	m.appendtransports = nil
}

// Transports returns the value of the "transports" field in the mutation.
func (m *WebauthnMutation) Transports() (r []string, exists bool) {
	v := m.transports
	if v == nil {
		return
	}
	return *v, true
}

// OldTransports returns the old "transports" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldTransports(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransports is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransports requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransports: %w", err)
	}
	return oldValue.Transports, nil
}

// AppendTransports adds s to the "transports" field.
func (m *WebauthnMutation) AppendTransports(s []string) {
	m.appendtransports = append(m.appendtransports, s...)
}

// AppendedTransports returns the list of values that were appended to the "transports" field in this mutation.
func (m *WebauthnMutation) AppendedTransports() ([]string, bool) {
	if len(m.appendtransports) == 0 {
		return nil, false
	}
	return m.appendtransports, true
}

// ResetTransports resets all changes to the "transports" field.
func (m *WebauthnMutation) ResetTransports() {
	m.transports = nil
	m.appendtransports = nil
}

// SetBackupEligible sets the "backup_eligible" field.
func (m *WebauthnMutation) SetBackupEligible(b bool) {
	m.backup_eligible = &b
}

// BackupEligible returns the value of the "backup_eligible" field in the mutation.
func (m *WebauthnMutation) BackupEligible() (r bool, exists bool) {
	v := m.backup_eligible
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupEligible returns the old "backup_eligible" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldBackupEligible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupEligible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupEligible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupEligible: %w", err)
	}
	return oldValue.BackupEligible, nil
}

// ResetBackupEligible resets all changes to the "backup_eligible" field.
func (m *WebauthnMutation) ResetBackupEligible() {
	m.backup_eligible = nil
}

// SetBackupState sets the "backup_state" field.
func (m *WebauthnMutation) SetBackupState(b bool) {
	m.backup_state = &b
}

// BackupState returns the value of the "backup_state" field in the mutation.
func (m *WebauthnMutation) BackupState() (r bool, exists bool) {
	v := m.backup_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupState returns the old "backup_state" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldBackupState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupState: %w", err)
	}
	return oldValue.BackupState, nil
}

// ResetBackupState resets all changes to the "backup_state" field.
func (m *WebauthnMutation) ResetBackupState() {
	m.backup_state = nil
}

// SetUserPresent sets the "user_present" field.
func (m *WebauthnMutation) SetUserPresent(b bool) {
	m.user_present = &b
}

// UserPresent returns the value of the "user_present" field in the mutation.
func (m *WebauthnMutation) UserPresent() (r bool, exists bool) {
	v := m.user_present
	if v == nil {
		return
	}
	return *v, true
}

// OldUserPresent returns the old "user_present" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldUserPresent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserPresent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserPresent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserPresent: %w", err)
	}
	return oldValue.UserPresent, nil
}

// ResetUserPresent resets all changes to the "user_present" field.
func (m *WebauthnMutation) ResetUserPresent() {
	m.user_present = nil
}

// SetUserVerified sets the "user_verified" field.
func (m *WebauthnMutation) SetUserVerified(b bool) {
	m.user_verified = &b
}

// UserVerified returns the value of the "user_verified" field in the mutation.
func (m *WebauthnMutation) UserVerified() (r bool, exists bool) {
	v := m.user_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldUserVerified returns the old "user_verified" field's value of the Webauthn entity.
// If the Webauthn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebauthnMutation) OldUserVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserVerified: %w", err)
	}
	return oldValue.UserVerified, nil
}

// ResetUserVerified resets all changes to the "user_verified" field.
func (m *WebauthnMutation) ResetUserVerified() {
	m.user_verified = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *WebauthnMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[webauthn.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *WebauthnMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *WebauthnMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *WebauthnMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the WebauthnMutation builder.
func (m *WebauthnMutation) Where(ps ...predicate.Webauthn) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebauthnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebauthnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Webauthn, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebauthnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebauthnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Webauthn).
func (m *WebauthnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebauthnMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, webauthn.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webauthn.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, webauthn.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, webauthn.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, webauthn.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, webauthn.FieldTags)
	}
	if m.owner != nil {
		fields = append(fields, webauthn.FieldOwnerID)
	}
	if m.credential_id != nil {
		fields = append(fields, webauthn.FieldCredentialID)
	}
	if m.public_key != nil {
		fields = append(fields, webauthn.FieldPublicKey)
	}
	if m.attestation_type != nil {
		fields = append(fields, webauthn.FieldAttestationType)
	}
	if m.aaguid != nil {
		fields = append(fields, webauthn.FieldAaguid)
	}
	if m.sign_count != nil {
		fields = append(fields, webauthn.FieldSignCount)
	}
	if m.transports != nil {
		fields = append(fields, webauthn.FieldTransports)
	}
	if m.backup_eligible != nil {
		fields = append(fields, webauthn.FieldBackupEligible)
	}
	if m.backup_state != nil {
		fields = append(fields, webauthn.FieldBackupState)
	}
	if m.user_present != nil {
		fields = append(fields, webauthn.FieldUserPresent)
	}
	if m.user_verified != nil {
		fields = append(fields, webauthn.FieldUserVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebauthnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webauthn.FieldCreatedAt:
		return m.CreatedAt()
	case webauthn.FieldUpdatedAt:
		return m.UpdatedAt()
	case webauthn.FieldCreatedBy:
		return m.CreatedBy()
	case webauthn.FieldUpdatedBy:
		return m.UpdatedBy()
	case webauthn.FieldMappingID:
		return m.MappingID()
	case webauthn.FieldTags:
		return m.Tags()
	case webauthn.FieldOwnerID:
		return m.OwnerID()
	case webauthn.FieldCredentialID:
		return m.CredentialID()
	case webauthn.FieldPublicKey:
		return m.PublicKey()
	case webauthn.FieldAttestationType:
		return m.AttestationType()
	case webauthn.FieldAaguid:
		return m.Aaguid()
	case webauthn.FieldSignCount:
		return m.SignCount()
	case webauthn.FieldTransports:
		return m.Transports()
	case webauthn.FieldBackupEligible:
		return m.BackupEligible()
	case webauthn.FieldBackupState:
		return m.BackupState()
	case webauthn.FieldUserPresent:
		return m.UserPresent()
	case webauthn.FieldUserVerified:
		return m.UserVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebauthnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webauthn.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webauthn.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case webauthn.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case webauthn.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case webauthn.FieldMappingID:
		return m.OldMappingID(ctx)
	case webauthn.FieldTags:
		return m.OldTags(ctx)
	case webauthn.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case webauthn.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case webauthn.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case webauthn.FieldAttestationType:
		return m.OldAttestationType(ctx)
	case webauthn.FieldAaguid:
		return m.OldAaguid(ctx)
	case webauthn.FieldSignCount:
		return m.OldSignCount(ctx)
	case webauthn.FieldTransports:
		return m.OldTransports(ctx)
	case webauthn.FieldBackupEligible:
		return m.OldBackupEligible(ctx)
	case webauthn.FieldBackupState:
		return m.OldBackupState(ctx)
	case webauthn.FieldUserPresent:
		return m.OldUserPresent(ctx)
	case webauthn.FieldUserVerified:
		return m.OldUserVerified(ctx)
	}
	return nil, fmt.Errorf("unknown Webauthn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebauthnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webauthn.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webauthn.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case webauthn.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case webauthn.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case webauthn.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case webauthn.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case webauthn.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case webauthn.FieldCredentialID:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case webauthn.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case webauthn.FieldAttestationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestationType(v)
		return nil
	case webauthn.FieldAaguid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAaguid(v)
		return nil
	case webauthn.FieldSignCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignCount(v)
		return nil
	case webauthn.FieldTransports:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransports(v)
		return nil
	case webauthn.FieldBackupEligible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupEligible(v)
		return nil
	case webauthn.FieldBackupState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupState(v)
		return nil
	case webauthn.FieldUserPresent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserPresent(v)
		return nil
	case webauthn.FieldUserVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserVerified(v)
		return nil
	}
	return fmt.Errorf("unknown Webauthn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebauthnMutation) AddedFields() []string {
	var fields []string
	if m.addsign_count != nil {
		fields = append(fields, webauthn.FieldSignCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebauthnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webauthn.FieldSignCount:
		return m.AddedSignCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebauthnMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webauthn.FieldSignCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignCount(v)
		return nil
	}
	return fmt.Errorf("unknown Webauthn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebauthnMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webauthn.FieldCreatedAt) {
		fields = append(fields, webauthn.FieldCreatedAt)
	}
	if m.FieldCleared(webauthn.FieldUpdatedAt) {
		fields = append(fields, webauthn.FieldUpdatedAt)
	}
	if m.FieldCleared(webauthn.FieldCreatedBy) {
		fields = append(fields, webauthn.FieldCreatedBy)
	}
	if m.FieldCleared(webauthn.FieldUpdatedBy) {
		fields = append(fields, webauthn.FieldUpdatedBy)
	}
	if m.FieldCleared(webauthn.FieldTags) {
		fields = append(fields, webauthn.FieldTags)
	}
	if m.FieldCleared(webauthn.FieldCredentialID) {
		fields = append(fields, webauthn.FieldCredentialID)
	}
	if m.FieldCleared(webauthn.FieldPublicKey) {
		fields = append(fields, webauthn.FieldPublicKey)
	}
	if m.FieldCleared(webauthn.FieldAttestationType) {
		fields = append(fields, webauthn.FieldAttestationType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebauthnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebauthnMutation) ClearField(name string) error {
	switch name {
	case webauthn.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case webauthn.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case webauthn.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case webauthn.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case webauthn.FieldTags:
		m.ClearTags()
		return nil
	case webauthn.FieldCredentialID:
		m.ClearCredentialID()
		return nil
	case webauthn.FieldPublicKey:
		m.ClearPublicKey()
		return nil
	case webauthn.FieldAttestationType:
		m.ClearAttestationType()
		return nil
	}
	return fmt.Errorf("unknown Webauthn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebauthnMutation) ResetField(name string) error {
	switch name {
	case webauthn.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webauthn.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case webauthn.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case webauthn.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case webauthn.FieldMappingID:
		m.ResetMappingID()
		return nil
	case webauthn.FieldTags:
		m.ResetTags()
		return nil
	case webauthn.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case webauthn.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case webauthn.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case webauthn.FieldAttestationType:
		m.ResetAttestationType()
		return nil
	case webauthn.FieldAaguid:
		m.ResetAaguid()
		return nil
	case webauthn.FieldSignCount:
		m.ResetSignCount()
		return nil
	case webauthn.FieldTransports:
		m.ResetTransports()
		return nil
	case webauthn.FieldBackupEligible:
		m.ResetBackupEligible()
		return nil
	case webauthn.FieldBackupState:
		m.ResetBackupState()
		return nil
	case webauthn.FieldUserPresent:
		m.ResetUserPresent()
		return nil
	case webauthn.FieldUserVerified:
		m.ResetUserVerified()
		return nil
	}
	return fmt.Errorf("unknown Webauthn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebauthnMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, webauthn.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebauthnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webauthn.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebauthnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebauthnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebauthnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, webauthn.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebauthnMutation) EdgeCleared(name string) bool {
	switch name {
	case webauthn.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebauthnMutation) ClearEdge(name string) error {
	switch name {
	case webauthn.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Webauthn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebauthnMutation) ResetEdge(name string) error {
	switch name {
	case webauthn.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Webauthn edge %s", name)
}

// WebhookMutation represents an operation that mutates the Webhook nodes in the graph.
type WebhookMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	created_by          *string
	updated_by          *string
	mapping_id          *string
	tags                *[]string
	appendtags          []string
	deleted_at          *time.Time
	deleted_by          *string
	name                *string
	description         *string
	destination_url     *string
	enabled             *bool
	callback            *string
	expires_at          *time.Time
	secret              *[]byte
	failures            *int
	addfailures         *int
	last_error          *string
	last_response       *string
	clearedFields       map[string]struct{}
	owner               *string
	clearedowner        bool
	events              map[string]struct{}
	removedevents       map[string]struct{}
	clearedevents       bool
	integrations        map[string]struct{}
	removedintegrations map[string]struct{}
	clearedintegrations bool
	done                bool
	oldValue            func(context.Context) (*Webhook, error)
	predicates          []predicate.Webhook
}

var _ ent.Mutation = (*WebhookMutation)(nil)

// webhookOption allows management of the mutation configuration using functional options.
type webhookOption func(*WebhookMutation)

// newWebhookMutation creates new mutation for the Webhook entity.
func newWebhookMutation(c config, op Op, opts ...webhookOption) *WebhookMutation {
	m := &WebhookMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookID sets the ID field of the mutation.
func withWebhookID(id string) webhookOption {
	return func(m *WebhookMutation) {
		var (
			err   error
			once  sync.Once
			value *Webhook
		)
		m.oldValue = func(ctx context.Context) (*Webhook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Webhook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhook sets the old Webhook of the mutation.
func withWebhook(node *Webhook) webhookOption {
	return func(m *WebhookMutation) {
		m.oldValue = func(context.Context) (*Webhook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Webhook entities.
func (m *WebhookMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Webhook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WebhookMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[webhook.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WebhookMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, webhook.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WebhookMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[webhook.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WebhookMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, webhook.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WebhookMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WebhookMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WebhookMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[webhook.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WebhookMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[webhook.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WebhookMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, webhook.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WebhookMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WebhookMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WebhookMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[webhook.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WebhookMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[webhook.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WebhookMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, webhook.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *WebhookMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *WebhookMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *WebhookMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *WebhookMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WebhookMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WebhookMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WebhookMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WebhookMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[webhook.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WebhookMutation) TagsCleared() bool {
	_, ok := m.clearedFields[webhook.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WebhookMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, webhook.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WebhookMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WebhookMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WebhookMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[webhook.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WebhookMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WebhookMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, webhook.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *WebhookMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *WebhookMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *WebhookMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[webhook.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *WebhookMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[webhook.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *WebhookMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, webhook.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *WebhookMutation) SetOwnerID(s string) {
	m.owner = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WebhookMutation) OwnerID() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *WebhookMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[webhook.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *WebhookMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[webhook.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WebhookMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, webhook.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *WebhookMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebhookMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebhookMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WebhookMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WebhookMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WebhookMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[webhook.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WebhookMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[webhook.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WebhookMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, webhook.FieldDescription)
}

// SetDestinationURL sets the "destination_url" field.
func (m *WebhookMutation) SetDestinationURL(s string) {
	m.destination_url = &s
}

// DestinationURL returns the value of the "destination_url" field in the mutation.
func (m *WebhookMutation) DestinationURL() (r string, exists bool) {
	v := m.destination_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationURL returns the old "destination_url" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldDestinationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationURL: %w", err)
	}
	return oldValue.DestinationURL, nil
}

// ResetDestinationURL resets all changes to the "destination_url" field.
func (m *WebhookMutation) ResetDestinationURL() {
	m.destination_url = nil
}

// SetEnabled sets the "enabled" field.
func (m *WebhookMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *WebhookMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *WebhookMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCallback sets the "callback" field.
func (m *WebhookMutation) SetCallback(s string) {
	m.callback = &s
}

// Callback returns the value of the "callback" field in the mutation.
func (m *WebhookMutation) Callback() (r string, exists bool) {
	v := m.callback
	if v == nil {
		return
	}
	return *v, true
}

// OldCallback returns the old "callback" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCallback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallback: %w", err)
	}
	return oldValue.Callback, nil
}

// ClearCallback clears the value of the "callback" field.
func (m *WebhookMutation) ClearCallback() {
	m.callback = nil
	m.clearedFields[webhook.FieldCallback] = struct{}{}
}

// CallbackCleared returns if the "callback" field was cleared in this mutation.
func (m *WebhookMutation) CallbackCleared() bool {
	_, ok := m.clearedFields[webhook.FieldCallback]
	return ok
}

// ResetCallback resets all changes to the "callback" field.
func (m *WebhookMutation) ResetCallback() {
	m.callback = nil
	delete(m.clearedFields, webhook.FieldCallback)
}

// SetExpiresAt sets the "expires_at" field.
func (m *WebhookMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *WebhookMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *WebhookMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[webhook.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *WebhookMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *WebhookMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, webhook.FieldExpiresAt)
}

// SetSecret sets the "secret" field.
func (m *WebhookMutation) SetSecret(b []byte) {
	m.secret = &b
}

// Secret returns the value of the "secret" field in the mutation.
func (m *WebhookMutation) Secret() (r []byte, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSecret(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ClearSecret clears the value of the "secret" field.
func (m *WebhookMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[webhook.FieldSecret] = struct{}{}
}

// SecretCleared returns if the "secret" field was cleared in this mutation.
func (m *WebhookMutation) SecretCleared() bool {
	_, ok := m.clearedFields[webhook.FieldSecret]
	return ok
}

// ResetSecret resets all changes to the "secret" field.
func (m *WebhookMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, webhook.FieldSecret)
}

// SetFailures sets the "failures" field.
func (m *WebhookMutation) SetFailures(i int) {
	m.failures = &i
	m.addfailures = nil
}

// Failures returns the value of the "failures" field in the mutation.
func (m *WebhookMutation) Failures() (r int, exists bool) {
	v := m.failures
	if v == nil {
		return
	}
	return *v, true
}

// OldFailures returns the old "failures" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldFailures(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailures: %w", err)
	}
	return oldValue.Failures, nil
}

// AddFailures adds i to the "failures" field.
func (m *WebhookMutation) AddFailures(i int) {
	if m.addfailures != nil {
		*m.addfailures += i
	} else {
		m.addfailures = &i
	}
}

// AddedFailures returns the value that was added to the "failures" field in this mutation.
func (m *WebhookMutation) AddedFailures() (r int, exists bool) {
	v := m.addfailures
	if v == nil {
		return
	}
	return *v, true
}

// ClearFailures clears the value of the "failures" field.
func (m *WebhookMutation) ClearFailures() {
	m.failures = nil
	m.addfailures = nil
	m.clearedFields[webhook.FieldFailures] = struct{}{}
}

// FailuresCleared returns if the "failures" field was cleared in this mutation.
func (m *WebhookMutation) FailuresCleared() bool {
	_, ok := m.clearedFields[webhook.FieldFailures]
	return ok
}

// ResetFailures resets all changes to the "failures" field.
func (m *WebhookMutation) ResetFailures() {
	m.failures = nil
	m.addfailures = nil
	delete(m.clearedFields, webhook.FieldFailures)
}

// SetLastError sets the "last_error" field.
func (m *WebhookMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *WebhookMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ClearLastError clears the value of the "last_error" field.
func (m *WebhookMutation) ClearLastError() {
	m.last_error = nil
	m.clearedFields[webhook.FieldLastError] = struct{}{}
}

// LastErrorCleared returns if the "last_error" field was cleared in this mutation.
func (m *WebhookMutation) LastErrorCleared() bool {
	_, ok := m.clearedFields[webhook.FieldLastError]
	return ok
}

// ResetLastError resets all changes to the "last_error" field.
func (m *WebhookMutation) ResetLastError() {
	m.last_error = nil
	delete(m.clearedFields, webhook.FieldLastError)
}

// SetLastResponse sets the "last_response" field.
func (m *WebhookMutation) SetLastResponse(s string) {
	m.last_response = &s
}

// LastResponse returns the value of the "last_response" field in the mutation.
func (m *WebhookMutation) LastResponse() (r string, exists bool) {
	v := m.last_response
	if v == nil {
		return
	}
	return *v, true
}

// OldLastResponse returns the old "last_response" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldLastResponse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastResponse: %w", err)
	}
	return oldValue.LastResponse, nil
}

// ClearLastResponse clears the value of the "last_response" field.
func (m *WebhookMutation) ClearLastResponse() {
	m.last_response = nil
	m.clearedFields[webhook.FieldLastResponse] = struct{}{}
}

// LastResponseCleared returns if the "last_response" field was cleared in this mutation.
func (m *WebhookMutation) LastResponseCleared() bool {
	_, ok := m.clearedFields[webhook.FieldLastResponse]
	return ok
}

// ResetLastResponse resets all changes to the "last_response" field.
func (m *WebhookMutation) ResetLastResponse() {
	m.last_response = nil
	delete(m.clearedFields, webhook.FieldLastResponse)
}

// ClearOwner clears the "owner" edge to the Organization entity.
func (m *WebhookMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[webhook.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Organization entity was cleared.
func (m *WebhookMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *WebhookMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *WebhookMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *WebhookMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *WebhookMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *WebhookMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *WebhookMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *WebhookMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *WebhookMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *WebhookMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddIntegrationIDs adds the "integrations" edge to the Integration entity by ids.
func (m *WebhookMutation) AddIntegrationIDs(ids ...string) {
	if m.integrations == nil {
		m.integrations = make(map[string]struct{})
	}
	for i := range ids {
		m.integrations[ids[i]] = struct{}{}
	}
}

// ClearIntegrations clears the "integrations" edge to the Integration entity.
func (m *WebhookMutation) ClearIntegrations() {
	m.clearedintegrations = true
}

// IntegrationsCleared reports if the "integrations" edge to the Integration entity was cleared.
func (m *WebhookMutation) IntegrationsCleared() bool {
	return m.clearedintegrations
}

// RemoveIntegrationIDs removes the "integrations" edge to the Integration entity by IDs.
func (m *WebhookMutation) RemoveIntegrationIDs(ids ...string) {
	if m.removedintegrations == nil {
		m.removedintegrations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.integrations, ids[i])
		m.removedintegrations[ids[i]] = struct{}{}
	}
}

// RemovedIntegrations returns the removed IDs of the "integrations" edge to the Integration entity.
func (m *WebhookMutation) RemovedIntegrationsIDs() (ids []string) {
	for id := range m.removedintegrations {
		ids = append(ids, id)
	}
	return
}

// IntegrationsIDs returns the "integrations" edge IDs in the mutation.
func (m *WebhookMutation) IntegrationsIDs() (ids []string) {
	for id := range m.integrations {
		ids = append(ids, id)
	}
	return
}

// ResetIntegrations resets all changes to the "integrations" edge.
func (m *WebhookMutation) ResetIntegrations() {
	m.integrations = nil
	m.clearedintegrations = false
	m.removedintegrations = nil
}

// Where appends a list predicates to the WebhookMutation builder.
func (m *WebhookMutation) Where(ps ...predicate.Webhook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Webhook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Webhook).
func (m *WebhookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, webhook.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, webhook.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, webhook.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, webhook.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, webhook.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, webhook.FieldDeletedBy)
	}
	if m.owner != nil {
		fields = append(fields, webhook.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, webhook.FieldName)
	}
	if m.description != nil {
		fields = append(fields, webhook.FieldDescription)
	}
	if m.destination_url != nil {
		fields = append(fields, webhook.FieldDestinationURL)
	}
	if m.enabled != nil {
		fields = append(fields, webhook.FieldEnabled)
	}
	if m.callback != nil {
		fields = append(fields, webhook.FieldCallback)
	}
	if m.expires_at != nil {
		fields = append(fields, webhook.FieldExpiresAt)
	}
	if m.secret != nil {
		fields = append(fields, webhook.FieldSecret)
	}
	if m.failures != nil {
		fields = append(fields, webhook.FieldFailures)
	}
	if m.last_error != nil {
		fields = append(fields, webhook.FieldLastError)
	}
	if m.last_response != nil {
		fields = append(fields, webhook.FieldLastResponse)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldCreatedAt:
		return m.CreatedAt()
	case webhook.FieldUpdatedAt:
		return m.UpdatedAt()
	case webhook.FieldCreatedBy:
		return m.CreatedBy()
	case webhook.FieldUpdatedBy:
		return m.UpdatedBy()
	case webhook.FieldMappingID:
		return m.MappingID()
	case webhook.FieldTags:
		return m.Tags()
	case webhook.FieldDeletedAt:
		return m.DeletedAt()
	case webhook.FieldDeletedBy:
		return m.DeletedBy()
	case webhook.FieldOwnerID:
		return m.OwnerID()
	case webhook.FieldName:
		return m.Name()
	case webhook.FieldDescription:
		return m.Description()
	case webhook.FieldDestinationURL:
		return m.DestinationURL()
	case webhook.FieldEnabled:
		return m.Enabled()
	case webhook.FieldCallback:
		return m.Callback()
	case webhook.FieldExpiresAt:
		return m.ExpiresAt()
	case webhook.FieldSecret:
		return m.Secret()
	case webhook.FieldFailures:
		return m.Failures()
	case webhook.FieldLastError:
		return m.LastError()
	case webhook.FieldLastResponse:
		return m.LastResponse()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case webhook.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case webhook.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case webhook.FieldMappingID:
		return m.OldMappingID(ctx)
	case webhook.FieldTags:
		return m.OldTags(ctx)
	case webhook.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case webhook.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case webhook.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case webhook.FieldName:
		return m.OldName(ctx)
	case webhook.FieldDescription:
		return m.OldDescription(ctx)
	case webhook.FieldDestinationURL:
		return m.OldDestinationURL(ctx)
	case webhook.FieldEnabled:
		return m.OldEnabled(ctx)
	case webhook.FieldCallback:
		return m.OldCallback(ctx)
	case webhook.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case webhook.FieldSecret:
		return m.OldSecret(ctx)
	case webhook.FieldFailures:
		return m.OldFailures(ctx)
	case webhook.FieldLastError:
		return m.OldLastError(ctx)
	case webhook.FieldLastResponse:
		return m.OldLastResponse(ctx)
	}
	return nil, fmt.Errorf("unknown Webhook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case webhook.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case webhook.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case webhook.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case webhook.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case webhook.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case webhook.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case webhook.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case webhook.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webhook.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case webhook.FieldDestinationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationURL(v)
		return nil
	case webhook.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case webhook.FieldCallback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallback(v)
		return nil
	case webhook.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case webhook.FieldSecret:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case webhook.FieldFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailures(v)
		return nil
	case webhook.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	case webhook.FieldLastResponse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastResponse(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookMutation) AddedFields() []string {
	var fields []string
	if m.addfailures != nil {
		fields = append(fields, webhook.FieldFailures)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldFailures:
		return m.AddedFailures()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailures(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhook.FieldCreatedAt) {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.FieldCleared(webhook.FieldUpdatedAt) {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	if m.FieldCleared(webhook.FieldCreatedBy) {
		fields = append(fields, webhook.FieldCreatedBy)
	}
	if m.FieldCleared(webhook.FieldUpdatedBy) {
		fields = append(fields, webhook.FieldUpdatedBy)
	}
	if m.FieldCleared(webhook.FieldTags) {
		fields = append(fields, webhook.FieldTags)
	}
	if m.FieldCleared(webhook.FieldDeletedAt) {
		fields = append(fields, webhook.FieldDeletedAt)
	}
	if m.FieldCleared(webhook.FieldDeletedBy) {
		fields = append(fields, webhook.FieldDeletedBy)
	}
	if m.FieldCleared(webhook.FieldOwnerID) {
		fields = append(fields, webhook.FieldOwnerID)
	}
	if m.FieldCleared(webhook.FieldDescription) {
		fields = append(fields, webhook.FieldDescription)
	}
	if m.FieldCleared(webhook.FieldCallback) {
		fields = append(fields, webhook.FieldCallback)
	}
	if m.FieldCleared(webhook.FieldExpiresAt) {
		fields = append(fields, webhook.FieldExpiresAt)
	}
	if m.FieldCleared(webhook.FieldSecret) {
		fields = append(fields, webhook.FieldSecret)
	}
	if m.FieldCleared(webhook.FieldFailures) {
		fields = append(fields, webhook.FieldFailures)
	}
	if m.FieldCleared(webhook.FieldLastError) {
		fields = append(fields, webhook.FieldLastError)
	}
	if m.FieldCleared(webhook.FieldLastResponse) {
		fields = append(fields, webhook.FieldLastResponse)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookMutation) ClearField(name string) error {
	switch name {
	case webhook.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case webhook.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case webhook.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case webhook.FieldTags:
		m.ClearTags()
		return nil
	case webhook.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case webhook.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case webhook.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case webhook.FieldDescription:
		m.ClearDescription()
		return nil
	case webhook.FieldCallback:
		m.ClearCallback()
		return nil
	case webhook.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case webhook.FieldSecret:
		m.ClearSecret()
		return nil
	case webhook.FieldFailures:
		m.ClearFailures()
		return nil
	case webhook.FieldLastError:
		m.ClearLastError()
		return nil
	case webhook.FieldLastResponse:
		m.ClearLastResponse()
		return nil
	}
	return fmt.Errorf("unknown Webhook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookMutation) ResetField(name string) error {
	switch name {
	case webhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case webhook.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case webhook.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case webhook.FieldMappingID:
		m.ResetMappingID()
		return nil
	case webhook.FieldTags:
		m.ResetTags()
		return nil
	case webhook.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case webhook.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case webhook.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case webhook.FieldName:
		m.ResetName()
		return nil
	case webhook.FieldDescription:
		m.ResetDescription()
		return nil
	case webhook.FieldDestinationURL:
		m.ResetDestinationURL()
		return nil
	case webhook.FieldEnabled:
		m.ResetEnabled()
		return nil
	case webhook.FieldCallback:
		m.ResetCallback()
		return nil
	case webhook.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case webhook.FieldSecret:
		m.ResetSecret()
		return nil
	case webhook.FieldFailures:
		m.ResetFailures()
		return nil
	case webhook.FieldLastError:
		m.ResetLastError()
		return nil
	case webhook.FieldLastResponse:
		m.ResetLastResponse()
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, webhook.EdgeOwner)
	}
	if m.events != nil {
		edges = append(edges, webhook.EdgeEvents)
	}
	if m.integrations != nil {
		edges = append(edges, webhook.EdgeIntegrations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case webhook.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case webhook.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.integrations))
		for id := range m.integrations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedevents != nil {
		edges = append(edges, webhook.EdgeEvents)
	}
	if m.removedintegrations != nil {
		edges = append(edges, webhook.EdgeIntegrations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case webhook.EdgeIntegrations:
		ids := make([]ent.Value, 0, len(m.removedintegrations))
		for id := range m.removedintegrations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, webhook.EdgeOwner)
	}
	if m.clearedevents {
		edges = append(edges, webhook.EdgeEvents)
	}
	if m.clearedintegrations {
		edges = append(edges, webhook.EdgeIntegrations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookMutation) EdgeCleared(name string) bool {
	switch name {
	case webhook.EdgeOwner:
		return m.clearedowner
	case webhook.EdgeEvents:
		return m.clearedevents
	case webhook.EdgeIntegrations:
		return m.clearedintegrations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookMutation) ClearEdge(name string) error {
	switch name {
	case webhook.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Webhook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookMutation) ResetEdge(name string) error {
	switch name {
	case webhook.EdgeOwner:
		m.ResetOwner()
		return nil
	case webhook.EdgeEvents:
		m.ResetEvents()
		return nil
	case webhook.EdgeIntegrations:
		m.ResetIntegrations()
		return nil
	}
	return fmt.Errorf("unknown Webhook edge %s", name)
}

// WebhookHistoryMutation represents an operation that mutates the WebhookHistory nodes in the graph.
type WebhookHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	history_time    *time.Time
	ref             *string
	operation       *history.OpType
	created_at      *time.Time
	updated_at      *time.Time
	created_by      *string
	updated_by      *string
	mapping_id      *string
	tags            *[]string
	appendtags      []string
	deleted_at      *time.Time
	deleted_by      *string
	owner_id        *string
	name            *string
	description     *string
	destination_url *string
	enabled         *bool
	callback        *string
	expires_at      *time.Time
	secret          *[]byte
	failures        *int
	addfailures     *int
	last_error      *string
	last_response   *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*WebhookHistory, error)
	predicates      []predicate.WebhookHistory
}

var _ ent.Mutation = (*WebhookHistoryMutation)(nil)

// webhookhistoryOption allows management of the mutation configuration using functional options.
type webhookhistoryOption func(*WebhookHistoryMutation)

// newWebhookHistoryMutation creates new mutation for the WebhookHistory entity.
func newWebhookHistoryMutation(c config, op Op, opts ...webhookhistoryOption) *WebhookHistoryMutation {
	m := &WebhookHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhookHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookHistoryID sets the ID field of the mutation.
func withWebhookHistoryID(id string) webhookhistoryOption {
	return func(m *WebhookHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WebhookHistory
		)
		m.oldValue = func(ctx context.Context) (*WebhookHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebhookHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhookHistory sets the old WebhookHistory of the mutation.
func withWebhookHistory(node *WebhookHistory) webhookhistoryOption {
	return func(m *WebhookHistoryMutation) {
		m.oldValue = func(context.Context) (*WebhookHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebhookHistory entities.
func (m *WebhookHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebhookHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHistoryTime sets the "history_time" field.
func (m *WebhookHistoryMutation) SetHistoryTime(t time.Time) {
	m.history_time = &t
}

// HistoryTime returns the value of the "history_time" field in the mutation.
func (m *WebhookHistoryMutation) HistoryTime() (r time.Time, exists bool) {
	v := m.history_time
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryTime returns the old "history_time" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldHistoryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryTime: %w", err)
	}
	return oldValue.HistoryTime, nil
}

// ResetHistoryTime resets all changes to the "history_time" field.
func (m *WebhookHistoryMutation) ResetHistoryTime() {
	m.history_time = nil
}

// SetRef sets the "ref" field.
func (m *WebhookHistoryMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *WebhookHistoryMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ClearRef clears the value of the "ref" field.
func (m *WebhookHistoryMutation) ClearRef() {
	m.ref = nil
	m.clearedFields[webhookhistory.FieldRef] = struct{}{}
}

// RefCleared returns if the "ref" field was cleared in this mutation.
func (m *WebhookHistoryMutation) RefCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldRef]
	return ok
}

// ResetRef resets all changes to the "ref" field.
func (m *WebhookHistoryMutation) ResetRef() {
	m.ref = nil
	delete(m.clearedFields, webhookhistory.FieldRef)
}

// SetOperation sets the "operation" field.
func (m *WebhookHistoryMutation) SetOperation(ht history.OpType) {
	m.operation = &ht
}

// Operation returns the value of the "operation" field in the mutation.
func (m *WebhookHistoryMutation) Operation() (r history.OpType, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldOperation(ctx context.Context) (v history.OpType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *WebhookHistoryMutation) ResetOperation() {
	m.operation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WebhookHistoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[webhookhistory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WebhookHistoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, webhookhistory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WebhookHistoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[webhookhistory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WebhookHistoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, webhookhistory.FieldUpdatedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *WebhookHistoryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WebhookHistoryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *WebhookHistoryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[webhookhistory.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *WebhookHistoryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WebhookHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, webhookhistory.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *WebhookHistoryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *WebhookHistoryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *WebhookHistoryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[webhookhistory.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *WebhookHistoryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *WebhookHistoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, webhookhistory.FieldUpdatedBy)
}

// SetMappingID sets the "mapping_id" field.
func (m *WebhookHistoryMutation) SetMappingID(s string) {
	m.mapping_id = &s
}

// MappingID returns the value of the "mapping_id" field in the mutation.
func (m *WebhookHistoryMutation) MappingID() (r string, exists bool) {
	v := m.mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMappingID returns the old "mapping_id" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldMappingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMappingID: %w", err)
	}
	return oldValue.MappingID, nil
}

// ResetMappingID resets all changes to the "mapping_id" field.
func (m *WebhookHistoryMutation) ResetMappingID() {
	m.mapping_id = nil
}

// SetTags sets the "tags" field.
func (m *WebhookHistoryMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WebhookHistoryMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WebhookHistoryMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WebhookHistoryMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *WebhookHistoryMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[webhookhistory.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *WebhookHistoryMutation) TagsCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *WebhookHistoryMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, webhookhistory.FieldTags)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WebhookHistoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WebhookHistoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WebhookHistoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[webhookhistory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WebhookHistoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WebhookHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, webhookhistory.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *WebhookHistoryMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *WebhookHistoryMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldDeletedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *WebhookHistoryMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[webhookhistory.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *WebhookHistoryMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *WebhookHistoryMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, webhookhistory.FieldDeletedBy)
}

// SetOwnerID sets the "owner_id" field.
func (m *WebhookHistoryMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *WebhookHistoryMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *WebhookHistoryMutation) ClearOwnerID() {
	m.owner_id = nil
	m.clearedFields[webhookhistory.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *WebhookHistoryMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *WebhookHistoryMutation) ResetOwnerID() {
	m.owner_id = nil
	delete(m.clearedFields, webhookhistory.FieldOwnerID)
}

// SetName sets the "name" field.
func (m *WebhookHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebhookHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebhookHistoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *WebhookHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WebhookHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WebhookHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[webhookhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WebhookHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WebhookHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, webhookhistory.FieldDescription)
}

// SetDestinationURL sets the "destination_url" field.
func (m *WebhookHistoryMutation) SetDestinationURL(s string) {
	m.destination_url = &s
}

// DestinationURL returns the value of the "destination_url" field in the mutation.
func (m *WebhookHistoryMutation) DestinationURL() (r string, exists bool) {
	v := m.destination_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationURL returns the old "destination_url" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldDestinationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationURL: %w", err)
	}
	return oldValue.DestinationURL, nil
}

// ResetDestinationURL resets all changes to the "destination_url" field.
func (m *WebhookHistoryMutation) ResetDestinationURL() {
	m.destination_url = nil
}

// SetEnabled sets the "enabled" field.
func (m *WebhookHistoryMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *WebhookHistoryMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *WebhookHistoryMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCallback sets the "callback" field.
func (m *WebhookHistoryMutation) SetCallback(s string) {
	m.callback = &s
}

// Callback returns the value of the "callback" field in the mutation.
func (m *WebhookHistoryMutation) Callback() (r string, exists bool) {
	v := m.callback
	if v == nil {
		return
	}
	return *v, true
}

// OldCallback returns the old "callback" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldCallback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallback: %w", err)
	}
	return oldValue.Callback, nil
}

// ClearCallback clears the value of the "callback" field.
func (m *WebhookHistoryMutation) ClearCallback() {
	m.callback = nil
	m.clearedFields[webhookhistory.FieldCallback] = struct{}{}
}

// CallbackCleared returns if the "callback" field was cleared in this mutation.
func (m *WebhookHistoryMutation) CallbackCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldCallback]
	return ok
}

// ResetCallback resets all changes to the "callback" field.
func (m *WebhookHistoryMutation) ResetCallback() {
	m.callback = nil
	delete(m.clearedFields, webhookhistory.FieldCallback)
}

// SetExpiresAt sets the "expires_at" field.
func (m *WebhookHistoryMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *WebhookHistoryMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *WebhookHistoryMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[webhookhistory.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *WebhookHistoryMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *WebhookHistoryMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, webhookhistory.FieldExpiresAt)
}

// SetSecret sets the "secret" field.
func (m *WebhookHistoryMutation) SetSecret(b []byte) {
	m.secret = &b
}

// Secret returns the value of the "secret" field in the mutation.
func (m *WebhookHistoryMutation) Secret() (r []byte, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldSecret(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ClearSecret clears the value of the "secret" field.
func (m *WebhookHistoryMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[webhookhistory.FieldSecret] = struct{}{}
}

// SecretCleared returns if the "secret" field was cleared in this mutation.
func (m *WebhookHistoryMutation) SecretCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldSecret]
	return ok
}

// ResetSecret resets all changes to the "secret" field.
func (m *WebhookHistoryMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, webhookhistory.FieldSecret)
}

// SetFailures sets the "failures" field.
func (m *WebhookHistoryMutation) SetFailures(i int) {
	m.failures = &i
	m.addfailures = nil
}

// Failures returns the value of the "failures" field in the mutation.
func (m *WebhookHistoryMutation) Failures() (r int, exists bool) {
	v := m.failures
	if v == nil {
		return
	}
	return *v, true
}

// OldFailures returns the old "failures" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldFailures(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailures: %w", err)
	}
	return oldValue.Failures, nil
}

// AddFailures adds i to the "failures" field.
func (m *WebhookHistoryMutation) AddFailures(i int) {
	if m.addfailures != nil {
		*m.addfailures += i
	} else {
		m.addfailures = &i
	}
}

// AddedFailures returns the value that was added to the "failures" field in this mutation.
func (m *WebhookHistoryMutation) AddedFailures() (r int, exists bool) {
	v := m.addfailures
	if v == nil {
		return
	}
	return *v, true
}

// ClearFailures clears the value of the "failures" field.
func (m *WebhookHistoryMutation) ClearFailures() {
	m.failures = nil
	m.addfailures = nil
	m.clearedFields[webhookhistory.FieldFailures] = struct{}{}
}

// FailuresCleared returns if the "failures" field was cleared in this mutation.
func (m *WebhookHistoryMutation) FailuresCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldFailures]
	return ok
}

// ResetFailures resets all changes to the "failures" field.
func (m *WebhookHistoryMutation) ResetFailures() {
	m.failures = nil
	m.addfailures = nil
	delete(m.clearedFields, webhookhistory.FieldFailures)
}

// SetLastError sets the "last_error" field.
func (m *WebhookHistoryMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *WebhookHistoryMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ClearLastError clears the value of the "last_error" field.
func (m *WebhookHistoryMutation) ClearLastError() {
	m.last_error = nil
	m.clearedFields[webhookhistory.FieldLastError] = struct{}{}
}

// LastErrorCleared returns if the "last_error" field was cleared in this mutation.
func (m *WebhookHistoryMutation) LastErrorCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldLastError]
	return ok
}

// ResetLastError resets all changes to the "last_error" field.
func (m *WebhookHistoryMutation) ResetLastError() {
	m.last_error = nil
	delete(m.clearedFields, webhookhistory.FieldLastError)
}

// SetLastResponse sets the "last_response" field.
func (m *WebhookHistoryMutation) SetLastResponse(s string) {
	m.last_response = &s
}

// LastResponse returns the value of the "last_response" field in the mutation.
func (m *WebhookHistoryMutation) LastResponse() (r string, exists bool) {
	v := m.last_response
	if v == nil {
		return
	}
	return *v, true
}

// OldLastResponse returns the old "last_response" field's value of the WebhookHistory entity.
// If the WebhookHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookHistoryMutation) OldLastResponse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastResponse: %w", err)
	}
	return oldValue.LastResponse, nil
}

// ClearLastResponse clears the value of the "last_response" field.
func (m *WebhookHistoryMutation) ClearLastResponse() {
	m.last_response = nil
	m.clearedFields[webhookhistory.FieldLastResponse] = struct{}{}
}

// LastResponseCleared returns if the "last_response" field was cleared in this mutation.
func (m *WebhookHistoryMutation) LastResponseCleared() bool {
	_, ok := m.clearedFields[webhookhistory.FieldLastResponse]
	return ok
}

// ResetLastResponse resets all changes to the "last_response" field.
func (m *WebhookHistoryMutation) ResetLastResponse() {
	m.last_response = nil
	delete(m.clearedFields, webhookhistory.FieldLastResponse)
}

// Where appends a list predicates to the WebhookHistoryMutation builder.
func (m *WebhookHistoryMutation) Where(ps ...predicate.WebhookHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebhookHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebhookHistory).
func (m *WebhookHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookHistoryMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.history_time != nil {
		fields = append(fields, webhookhistory.FieldHistoryTime)
	}
	if m.ref != nil {
		fields = append(fields, webhookhistory.FieldRef)
	}
	if m.operation != nil {
		fields = append(fields, webhookhistory.FieldOperation)
	}
	if m.created_at != nil {
		fields = append(fields, webhookhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhookhistory.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, webhookhistory.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, webhookhistory.FieldUpdatedBy)
	}
	if m.mapping_id != nil {
		fields = append(fields, webhookhistory.FieldMappingID)
	}
	if m.tags != nil {
		fields = append(fields, webhookhistory.FieldTags)
	}
	if m.deleted_at != nil {
		fields = append(fields, webhookhistory.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, webhookhistory.FieldDeletedBy)
	}
	if m.owner_id != nil {
		fields = append(fields, webhookhistory.FieldOwnerID)
	}
	if m.name != nil {
		fields = append(fields, webhookhistory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, webhookhistory.FieldDescription)
	}
	if m.destination_url != nil {
		fields = append(fields, webhookhistory.FieldDestinationURL)
	}
	if m.enabled != nil {
		fields = append(fields, webhookhistory.FieldEnabled)
	}
	if m.callback != nil {
		fields = append(fields, webhookhistory.FieldCallback)
	}
	if m.expires_at != nil {
		fields = append(fields, webhookhistory.FieldExpiresAt)
	}
	if m.secret != nil {
		fields = append(fields, webhookhistory.FieldSecret)
	}
	if m.failures != nil {
		fields = append(fields, webhookhistory.FieldFailures)
	}
	if m.last_error != nil {
		fields = append(fields, webhookhistory.FieldLastError)
	}
	if m.last_response != nil {
		fields = append(fields, webhookhistory.FieldLastResponse)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhookhistory.FieldHistoryTime:
		return m.HistoryTime()
	case webhookhistory.FieldRef:
		return m.Ref()
	case webhookhistory.FieldOperation:
		return m.Operation()
	case webhookhistory.FieldCreatedAt:
		return m.CreatedAt()
	case webhookhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case webhookhistory.FieldCreatedBy:
		return m.CreatedBy()
	case webhookhistory.FieldUpdatedBy:
		return m.UpdatedBy()
	case webhookhistory.FieldMappingID:
		return m.MappingID()
	case webhookhistory.FieldTags:
		return m.Tags()
	case webhookhistory.FieldDeletedAt:
		return m.DeletedAt()
	case webhookhistory.FieldDeletedBy:
		return m.DeletedBy()
	case webhookhistory.FieldOwnerID:
		return m.OwnerID()
	case webhookhistory.FieldName:
		return m.Name()
	case webhookhistory.FieldDescription:
		return m.Description()
	case webhookhistory.FieldDestinationURL:
		return m.DestinationURL()
	case webhookhistory.FieldEnabled:
		return m.Enabled()
	case webhookhistory.FieldCallback:
		return m.Callback()
	case webhookhistory.FieldExpiresAt:
		return m.ExpiresAt()
	case webhookhistory.FieldSecret:
		return m.Secret()
	case webhookhistory.FieldFailures:
		return m.Failures()
	case webhookhistory.FieldLastError:
		return m.LastError()
	case webhookhistory.FieldLastResponse:
		return m.LastResponse()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhookhistory.FieldHistoryTime:
		return m.OldHistoryTime(ctx)
	case webhookhistory.FieldRef:
		return m.OldRef(ctx)
	case webhookhistory.FieldOperation:
		return m.OldOperation(ctx)
	case webhookhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhookhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case webhookhistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case webhookhistory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case webhookhistory.FieldMappingID:
		return m.OldMappingID(ctx)
	case webhookhistory.FieldTags:
		return m.OldTags(ctx)
	case webhookhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case webhookhistory.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case webhookhistory.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case webhookhistory.FieldName:
		return m.OldName(ctx)
	case webhookhistory.FieldDescription:
		return m.OldDescription(ctx)
	case webhookhistory.FieldDestinationURL:
		return m.OldDestinationURL(ctx)
	case webhookhistory.FieldEnabled:
		return m.OldEnabled(ctx)
	case webhookhistory.FieldCallback:
		return m.OldCallback(ctx)
	case webhookhistory.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case webhookhistory.FieldSecret:
		return m.OldSecret(ctx)
	case webhookhistory.FieldFailures:
		return m.OldFailures(ctx)
	case webhookhistory.FieldLastError:
		return m.OldLastError(ctx)
	case webhookhistory.FieldLastResponse:
		return m.OldLastResponse(ctx)
	}
	return nil, fmt.Errorf("unknown WebhookHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhookhistory.FieldHistoryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryTime(v)
		return nil
	case webhookhistory.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case webhookhistory.FieldOperation:
		v, ok := value.(history.OpType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case webhookhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhookhistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case webhookhistory.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case webhookhistory.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case webhookhistory.FieldMappingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMappingID(v)
		return nil
	case webhookhistory.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case webhookhistory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case webhookhistory.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case webhookhistory.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case webhookhistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webhookhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case webhookhistory.FieldDestinationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationURL(v)
		return nil
	case webhookhistory.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case webhookhistory.FieldCallback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallback(v)
		return nil
	case webhookhistory.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case webhookhistory.FieldSecret:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case webhookhistory.FieldFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailures(v)
		return nil
	case webhookhistory.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	case webhookhistory.FieldLastResponse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastResponse(v)
		return nil
	}
	return fmt.Errorf("unknown WebhookHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addfailures != nil {
		fields = append(fields, webhookhistory.FieldFailures)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhookhistory.FieldFailures:
		return m.AddedFailures()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhookhistory.FieldFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailures(v)
		return nil
	}
	return fmt.Errorf("unknown WebhookHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhookhistory.FieldRef) {
		fields = append(fields, webhookhistory.FieldRef)
	}
	if m.FieldCleared(webhookhistory.FieldCreatedAt) {
		fields = append(fields, webhookhistory.FieldCreatedAt)
	}
	if m.FieldCleared(webhookhistory.FieldUpdatedAt) {
		fields = append(fields, webhookhistory.FieldUpdatedAt)
	}
	if m.FieldCleared(webhookhistory.FieldCreatedBy) {
		fields = append(fields, webhookhistory.FieldCreatedBy)
	}
	if m.FieldCleared(webhookhistory.FieldUpdatedBy) {
		fields = append(fields, webhookhistory.FieldUpdatedBy)
	}
	if m.FieldCleared(webhookhistory.FieldTags) {
		fields = append(fields, webhookhistory.FieldTags)
	}
	if m.FieldCleared(webhookhistory.FieldDeletedAt) {
		fields = append(fields, webhookhistory.FieldDeletedAt)
	}
	if m.FieldCleared(webhookhistory.FieldDeletedBy) {
		fields = append(fields, webhookhistory.FieldDeletedBy)
	}
	if m.FieldCleared(webhookhistory.FieldOwnerID) {
		fields = append(fields, webhookhistory.FieldOwnerID)
	}
	if m.FieldCleared(webhookhistory.FieldDescription) {
		fields = append(fields, webhookhistory.FieldDescription)
	}
	if m.FieldCleared(webhookhistory.FieldCallback) {
		fields = append(fields, webhookhistory.FieldCallback)
	}
	if m.FieldCleared(webhookhistory.FieldExpiresAt) {
		fields = append(fields, webhookhistory.FieldExpiresAt)
	}
	if m.FieldCleared(webhookhistory.FieldSecret) {
		fields = append(fields, webhookhistory.FieldSecret)
	}
	if m.FieldCleared(webhookhistory.FieldFailures) {
		fields = append(fields, webhookhistory.FieldFailures)
	}
	if m.FieldCleared(webhookhistory.FieldLastError) {
		fields = append(fields, webhookhistory.FieldLastError)
	}
	if m.FieldCleared(webhookhistory.FieldLastResponse) {
		fields = append(fields, webhookhistory.FieldLastResponse)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookHistoryMutation) ClearField(name string) error {
	switch name {
	case webhookhistory.FieldRef:
		m.ClearRef()
		return nil
	case webhookhistory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case webhookhistory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case webhookhistory.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case webhookhistory.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case webhookhistory.FieldTags:
		m.ClearTags()
		return nil
	case webhookhistory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case webhookhistory.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case webhookhistory.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case webhookhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case webhookhistory.FieldCallback:
		m.ClearCallback()
		return nil
	case webhookhistory.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case webhookhistory.FieldSecret:
		m.ClearSecret()
		return nil
	case webhookhistory.FieldFailures:
		m.ClearFailures()
		return nil
	case webhookhistory.FieldLastError:
		m.ClearLastError()
		return nil
	case webhookhistory.FieldLastResponse:
		m.ClearLastResponse()
		return nil
	}
	return fmt.Errorf("unknown WebhookHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookHistoryMutation) ResetField(name string) error {
	switch name {
	case webhookhistory.FieldHistoryTime:
		m.ResetHistoryTime()
		return nil
	case webhookhistory.FieldRef:
		m.ResetRef()
		return nil
	case webhookhistory.FieldOperation:
		m.ResetOperation()
		return nil
	case webhookhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhookhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case webhookhistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case webhookhistory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case webhookhistory.FieldMappingID:
		m.ResetMappingID()
		return nil
	case webhookhistory.FieldTags:
		m.ResetTags()
		return nil
	case webhookhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case webhookhistory.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case webhookhistory.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case webhookhistory.FieldName:
		m.ResetName()
		return nil
	case webhookhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case webhookhistory.FieldDestinationURL:
		m.ResetDestinationURL()
		return nil
	case webhookhistory.FieldEnabled:
		m.ResetEnabled()
		return nil
	case webhookhistory.FieldCallback:
		m.ResetCallback()
		return nil
	case webhookhistory.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case webhookhistory.FieldSecret:
		m.ResetSecret()
		return nil
	case webhookhistory.FieldFailures:
		m.ResetFailures()
		return nil
	case webhookhistory.FieldLastError:
		m.ResetLastError()
		return nil
	case webhookhistory.FieldLastResponse:
		m.ResetLastResponse()
		return nil
	}
	return fmt.Errorf("unknown WebhookHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WebhookHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WebhookHistory edge %s", name)
}
