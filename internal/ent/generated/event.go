// Code generated by ent, DO NOT EDIT.

package generated

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/theopenlane/core/internal/ent/generated/event"
)

// Event is the model entity for the Event schema.
type Event struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy string `json:"created_by,omitempty"`
	// UpdatedBy holds the value of the "updated_by" field.
	UpdatedBy string `json:"updated_by,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// EventID holds the value of the "event_id" field.
	EventID string `json:"event_id,omitempty"`
	// CorrelationID holds the value of the "correlation_id" field.
	CorrelationID string `json:"correlation_id,omitempty"`
	// EventType holds the value of the "event_type" field.
	EventType string `json:"event_type,omitempty"`
	// Metadata holds the value of the "metadata" field.
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the EventQuery when eager-loading is set.
	Edges        EventEdges `json:"edges"`
	selectValues sql.SelectValues
}

// EventEdges holds the relations/edges for other nodes in the graph.
type EventEdges struct {
	// Users holds the value of the users edge.
	Users []*User `json:"users,omitempty"`
	// Groups holds the value of the groups edge.
	Groups []*Group `json:"groups,omitempty"`
	// Integrations holds the value of the integrations edge.
	Integrations []*Integration `json:"integrations,omitempty"`
	// Organizations holds the value of the organizations edge.
	Organizations []*Organization `json:"organizations,omitempty"`
	// Invites holds the value of the invites edge.
	Invites []*Invite `json:"invites,omitempty"`
	// PersonalAccessTokens holds the value of the personal_access_tokens edge.
	PersonalAccessTokens []*PersonalAccessToken `json:"personal_access_tokens,omitempty"`
	// Secrets holds the value of the secrets edge.
	Secrets []*Hush `json:"secrets,omitempty"`
	// Orgmemberships holds the value of the orgmemberships edge.
	Orgmemberships []*OrgMembership `json:"orgmemberships,omitempty"`
	// Groupmemberships holds the value of the groupmemberships edge.
	Groupmemberships []*GroupMembership `json:"groupmemberships,omitempty"`
	// Subscribers holds the value of the subscribers edge.
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
	// Files holds the value of the files edge.
	Files []*File `json:"files,omitempty"`
	// OrgSubscriptions holds the value of the org_subscriptions edge.
	OrgSubscriptions []*OrgSubscription `json:"org_subscriptions,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [12]bool
	// totalCount holds the count of the edges above.
	totalCount [12]map[string]int

	namedUsers                map[string][]*User
	namedGroups               map[string][]*Group
	namedIntegrations         map[string][]*Integration
	namedOrganizations        map[string][]*Organization
	namedInvites              map[string][]*Invite
	namedPersonalAccessTokens map[string][]*PersonalAccessToken
	namedSecrets              map[string][]*Hush
	namedOrgmemberships       map[string][]*OrgMembership
	namedGroupmemberships     map[string][]*GroupMembership
	namedSubscribers          map[string][]*Subscriber
	namedFiles                map[string][]*File
	namedOrgSubscriptions     map[string][]*OrgSubscription
}

// UsersOrErr returns the Users value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) UsersOrErr() ([]*User, error) {
	if e.loadedTypes[0] {
		return e.Users, nil
	}
	return nil, &NotLoadedError{edge: "users"}
}

// GroupsOrErr returns the Groups value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) GroupsOrErr() ([]*Group, error) {
	if e.loadedTypes[1] {
		return e.Groups, nil
	}
	return nil, &NotLoadedError{edge: "groups"}
}

// IntegrationsOrErr returns the Integrations value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) IntegrationsOrErr() ([]*Integration, error) {
	if e.loadedTypes[2] {
		return e.Integrations, nil
	}
	return nil, &NotLoadedError{edge: "integrations"}
}

// OrganizationsOrErr returns the Organizations value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) OrganizationsOrErr() ([]*Organization, error) {
	if e.loadedTypes[3] {
		return e.Organizations, nil
	}
	return nil, &NotLoadedError{edge: "organizations"}
}

// InvitesOrErr returns the Invites value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) InvitesOrErr() ([]*Invite, error) {
	if e.loadedTypes[4] {
		return e.Invites, nil
	}
	return nil, &NotLoadedError{edge: "invites"}
}

// PersonalAccessTokensOrErr returns the PersonalAccessTokens value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) PersonalAccessTokensOrErr() ([]*PersonalAccessToken, error) {
	if e.loadedTypes[5] {
		return e.PersonalAccessTokens, nil
	}
	return nil, &NotLoadedError{edge: "personal_access_tokens"}
}

// SecretsOrErr returns the Secrets value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) SecretsOrErr() ([]*Hush, error) {
	if e.loadedTypes[6] {
		return e.Secrets, nil
	}
	return nil, &NotLoadedError{edge: "secrets"}
}

// OrgmembershipsOrErr returns the Orgmemberships value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) OrgmembershipsOrErr() ([]*OrgMembership, error) {
	if e.loadedTypes[7] {
		return e.Orgmemberships, nil
	}
	return nil, &NotLoadedError{edge: "orgmemberships"}
}

// GroupmembershipsOrErr returns the Groupmemberships value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) GroupmembershipsOrErr() ([]*GroupMembership, error) {
	if e.loadedTypes[8] {
		return e.Groupmemberships, nil
	}
	return nil, &NotLoadedError{edge: "groupmemberships"}
}

// SubscribersOrErr returns the Subscribers value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) SubscribersOrErr() ([]*Subscriber, error) {
	if e.loadedTypes[9] {
		return e.Subscribers, nil
	}
	return nil, &NotLoadedError{edge: "subscribers"}
}

// FilesOrErr returns the Files value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) FilesOrErr() ([]*File, error) {
	if e.loadedTypes[10] {
		return e.Files, nil
	}
	return nil, &NotLoadedError{edge: "files"}
}

// OrgSubscriptionsOrErr returns the OrgSubscriptions value or an error if the edge
// was not loaded in eager-loading.
func (e EventEdges) OrgSubscriptionsOrErr() ([]*OrgSubscription, error) {
	if e.loadedTypes[11] {
		return e.OrgSubscriptions, nil
	}
	return nil, &NotLoadedError{edge: "org_subscriptions"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Event) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case event.FieldTags, event.FieldMetadata:
			values[i] = new([]byte)
		case event.FieldID, event.FieldCreatedBy, event.FieldUpdatedBy, event.FieldEventID, event.FieldCorrelationID, event.FieldEventType:
			values[i] = new(sql.NullString)
		case event.FieldCreatedAt, event.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Event fields.
func (e *Event) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case event.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				e.ID = value.String
			}
		case event.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				e.CreatedAt = value.Time
			}
		case event.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				e.UpdatedAt = value.Time
			}
		case event.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				e.CreatedBy = value.String
			}
		case event.FieldUpdatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[i])
			} else if value.Valid {
				e.UpdatedBy = value.String
			}
		case event.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &e.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case event.FieldEventID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field event_id", values[i])
			} else if value.Valid {
				e.EventID = value.String
			}
		case event.FieldCorrelationID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field correlation_id", values[i])
			} else if value.Valid {
				e.CorrelationID = value.String
			}
		case event.FieldEventType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field event_type", values[i])
			} else if value.Valid {
				e.EventType = value.String
			}
		case event.FieldMetadata:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field metadata", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &e.Metadata); err != nil {
					return fmt.Errorf("unmarshal field metadata: %w", err)
				}
			}
		default:
			e.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Event.
// This includes values selected through modifiers, order, etc.
func (e *Event) Value(name string) (ent.Value, error) {
	return e.selectValues.Get(name)
}

// QueryUsers queries the "users" edge of the Event entity.
func (e *Event) QueryUsers() *UserQuery {
	return NewEventClient(e.config).QueryUsers(e)
}

// QueryGroups queries the "groups" edge of the Event entity.
func (e *Event) QueryGroups() *GroupQuery {
	return NewEventClient(e.config).QueryGroups(e)
}

// QueryIntegrations queries the "integrations" edge of the Event entity.
func (e *Event) QueryIntegrations() *IntegrationQuery {
	return NewEventClient(e.config).QueryIntegrations(e)
}

// QueryOrganizations queries the "organizations" edge of the Event entity.
func (e *Event) QueryOrganizations() *OrganizationQuery {
	return NewEventClient(e.config).QueryOrganizations(e)
}

// QueryInvites queries the "invites" edge of the Event entity.
func (e *Event) QueryInvites() *InviteQuery {
	return NewEventClient(e.config).QueryInvites(e)
}

// QueryPersonalAccessTokens queries the "personal_access_tokens" edge of the Event entity.
func (e *Event) QueryPersonalAccessTokens() *PersonalAccessTokenQuery {
	return NewEventClient(e.config).QueryPersonalAccessTokens(e)
}

// QuerySecrets queries the "secrets" edge of the Event entity.
func (e *Event) QuerySecrets() *HushQuery {
	return NewEventClient(e.config).QuerySecrets(e)
}

// QueryOrgmemberships queries the "orgmemberships" edge of the Event entity.
func (e *Event) QueryOrgmemberships() *OrgMembershipQuery {
	return NewEventClient(e.config).QueryOrgmemberships(e)
}

// QueryGroupmemberships queries the "groupmemberships" edge of the Event entity.
func (e *Event) QueryGroupmemberships() *GroupMembershipQuery {
	return NewEventClient(e.config).QueryGroupmemberships(e)
}

// QuerySubscribers queries the "subscribers" edge of the Event entity.
func (e *Event) QuerySubscribers() *SubscriberQuery {
	return NewEventClient(e.config).QuerySubscribers(e)
}

// QueryFiles queries the "files" edge of the Event entity.
func (e *Event) QueryFiles() *FileQuery {
	return NewEventClient(e.config).QueryFiles(e)
}

// QueryOrgSubscriptions queries the "org_subscriptions" edge of the Event entity.
func (e *Event) QueryOrgSubscriptions() *OrgSubscriptionQuery {
	return NewEventClient(e.config).QueryOrgSubscriptions(e)
}

// Update returns a builder for updating this Event.
// Note that you need to call Event.Unwrap() before calling this method if this Event
// was returned from a transaction, and the transaction was committed or rolled back.
func (e *Event) Update() *EventUpdateOne {
	return NewEventClient(e.config).UpdateOne(e)
}

// Unwrap unwraps the Event entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (e *Event) Unwrap() *Event {
	_tx, ok := e.config.driver.(*txDriver)
	if !ok {
		panic("generated: Event is not a transactional entity")
	}
	e.config.driver = _tx.drv
	return e
}

// String implements the fmt.Stringer.
func (e *Event) String() string {
	var builder strings.Builder
	builder.WriteString("Event(")
	builder.WriteString(fmt.Sprintf("id=%v, ", e.ID))
	builder.WriteString("created_at=")
	builder.WriteString(e.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(e.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(e.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(e.UpdatedBy)
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", e.Tags))
	builder.WriteString(", ")
	builder.WriteString("event_id=")
	builder.WriteString(e.EventID)
	builder.WriteString(", ")
	builder.WriteString("correlation_id=")
	builder.WriteString(e.CorrelationID)
	builder.WriteString(", ")
	builder.WriteString("event_type=")
	builder.WriteString(e.EventType)
	builder.WriteString(", ")
	builder.WriteString("metadata=")
	builder.WriteString(fmt.Sprintf("%v", e.Metadata))
	builder.WriteByte(')')
	return builder.String()
}

// NamedUsers returns the Users named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedUsers(name string) ([]*User, error) {
	if e.Edges.namedUsers == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedUsers[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedUsers(name string, edges ...*User) {
	if e.Edges.namedUsers == nil {
		e.Edges.namedUsers = make(map[string][]*User)
	}
	if len(edges) == 0 {
		e.Edges.namedUsers[name] = []*User{}
	} else {
		e.Edges.namedUsers[name] = append(e.Edges.namedUsers[name], edges...)
	}
}

// NamedGroups returns the Groups named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedGroups(name string) ([]*Group, error) {
	if e.Edges.namedGroups == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedGroups[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedGroups(name string, edges ...*Group) {
	if e.Edges.namedGroups == nil {
		e.Edges.namedGroups = make(map[string][]*Group)
	}
	if len(edges) == 0 {
		e.Edges.namedGroups[name] = []*Group{}
	} else {
		e.Edges.namedGroups[name] = append(e.Edges.namedGroups[name], edges...)
	}
}

// NamedIntegrations returns the Integrations named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedIntegrations(name string) ([]*Integration, error) {
	if e.Edges.namedIntegrations == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedIntegrations[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedIntegrations(name string, edges ...*Integration) {
	if e.Edges.namedIntegrations == nil {
		e.Edges.namedIntegrations = make(map[string][]*Integration)
	}
	if len(edges) == 0 {
		e.Edges.namedIntegrations[name] = []*Integration{}
	} else {
		e.Edges.namedIntegrations[name] = append(e.Edges.namedIntegrations[name], edges...)
	}
}

// NamedOrganizations returns the Organizations named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedOrganizations(name string) ([]*Organization, error) {
	if e.Edges.namedOrganizations == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedOrganizations[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedOrganizations(name string, edges ...*Organization) {
	if e.Edges.namedOrganizations == nil {
		e.Edges.namedOrganizations = make(map[string][]*Organization)
	}
	if len(edges) == 0 {
		e.Edges.namedOrganizations[name] = []*Organization{}
	} else {
		e.Edges.namedOrganizations[name] = append(e.Edges.namedOrganizations[name], edges...)
	}
}

// NamedInvites returns the Invites named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedInvites(name string) ([]*Invite, error) {
	if e.Edges.namedInvites == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedInvites[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedInvites(name string, edges ...*Invite) {
	if e.Edges.namedInvites == nil {
		e.Edges.namedInvites = make(map[string][]*Invite)
	}
	if len(edges) == 0 {
		e.Edges.namedInvites[name] = []*Invite{}
	} else {
		e.Edges.namedInvites[name] = append(e.Edges.namedInvites[name], edges...)
	}
}

// NamedPersonalAccessTokens returns the PersonalAccessTokens named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedPersonalAccessTokens(name string) ([]*PersonalAccessToken, error) {
	if e.Edges.namedPersonalAccessTokens == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedPersonalAccessTokens[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedPersonalAccessTokens(name string, edges ...*PersonalAccessToken) {
	if e.Edges.namedPersonalAccessTokens == nil {
		e.Edges.namedPersonalAccessTokens = make(map[string][]*PersonalAccessToken)
	}
	if len(edges) == 0 {
		e.Edges.namedPersonalAccessTokens[name] = []*PersonalAccessToken{}
	} else {
		e.Edges.namedPersonalAccessTokens[name] = append(e.Edges.namedPersonalAccessTokens[name], edges...)
	}
}

// NamedSecrets returns the Secrets named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedSecrets(name string) ([]*Hush, error) {
	if e.Edges.namedSecrets == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedSecrets[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedSecrets(name string, edges ...*Hush) {
	if e.Edges.namedSecrets == nil {
		e.Edges.namedSecrets = make(map[string][]*Hush)
	}
	if len(edges) == 0 {
		e.Edges.namedSecrets[name] = []*Hush{}
	} else {
		e.Edges.namedSecrets[name] = append(e.Edges.namedSecrets[name], edges...)
	}
}

// NamedOrgmemberships returns the Orgmemberships named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedOrgmemberships(name string) ([]*OrgMembership, error) {
	if e.Edges.namedOrgmemberships == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedOrgmemberships[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedOrgmemberships(name string, edges ...*OrgMembership) {
	if e.Edges.namedOrgmemberships == nil {
		e.Edges.namedOrgmemberships = make(map[string][]*OrgMembership)
	}
	if len(edges) == 0 {
		e.Edges.namedOrgmemberships[name] = []*OrgMembership{}
	} else {
		e.Edges.namedOrgmemberships[name] = append(e.Edges.namedOrgmemberships[name], edges...)
	}
}

// NamedGroupmemberships returns the Groupmemberships named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedGroupmemberships(name string) ([]*GroupMembership, error) {
	if e.Edges.namedGroupmemberships == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedGroupmemberships[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedGroupmemberships(name string, edges ...*GroupMembership) {
	if e.Edges.namedGroupmemberships == nil {
		e.Edges.namedGroupmemberships = make(map[string][]*GroupMembership)
	}
	if len(edges) == 0 {
		e.Edges.namedGroupmemberships[name] = []*GroupMembership{}
	} else {
		e.Edges.namedGroupmemberships[name] = append(e.Edges.namedGroupmemberships[name], edges...)
	}
}

// NamedSubscribers returns the Subscribers named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedSubscribers(name string) ([]*Subscriber, error) {
	if e.Edges.namedSubscribers == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedSubscribers[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedSubscribers(name string, edges ...*Subscriber) {
	if e.Edges.namedSubscribers == nil {
		e.Edges.namedSubscribers = make(map[string][]*Subscriber)
	}
	if len(edges) == 0 {
		e.Edges.namedSubscribers[name] = []*Subscriber{}
	} else {
		e.Edges.namedSubscribers[name] = append(e.Edges.namedSubscribers[name], edges...)
	}
}

// NamedFiles returns the Files named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedFiles(name string) ([]*File, error) {
	if e.Edges.namedFiles == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedFiles[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedFiles(name string, edges ...*File) {
	if e.Edges.namedFiles == nil {
		e.Edges.namedFiles = make(map[string][]*File)
	}
	if len(edges) == 0 {
		e.Edges.namedFiles[name] = []*File{}
	} else {
		e.Edges.namedFiles[name] = append(e.Edges.namedFiles[name], edges...)
	}
}

// NamedOrgSubscriptions returns the OrgSubscriptions named value or an error if the edge was not
// loaded in eager-loading with this name.
func (e *Event) NamedOrgSubscriptions(name string) ([]*OrgSubscription, error) {
	if e.Edges.namedOrgSubscriptions == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := e.Edges.namedOrgSubscriptions[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (e *Event) appendNamedOrgSubscriptions(name string, edges ...*OrgSubscription) {
	if e.Edges.namedOrgSubscriptions == nil {
		e.Edges.namedOrgSubscriptions = make(map[string][]*OrgSubscription)
	}
	if len(edges) == 0 {
		e.Edges.namedOrgSubscriptions[name] = []*OrgSubscription{}
	} else {
		e.Edges.namedOrgSubscriptions[name] = append(e.Edges.namedOrgSubscriptions[name], edges...)
	}
}

// Events is a parsable slice of Event.
type Events []*Event
