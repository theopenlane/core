// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/theopenlane/core/internal/ent/generated/actionplan"
	"github.com/theopenlane/core/internal/ent/generated/documentrevision"
	"github.com/theopenlane/core/internal/ent/generated/internalpolicy"
	"github.com/theopenlane/core/internal/ent/generated/predicate"
	"github.com/theopenlane/core/internal/ent/generated/procedure"
	"github.com/theopenlane/core/internal/ent/generated/user"
	"github.com/theopenlane/core/pkg/enums"

	"github.com/theopenlane/core/internal/ent/generated/internal"
)

// DocumentRevisionUpdate is the builder for updating DocumentRevision entities.
type DocumentRevisionUpdate struct {
	config
	hooks     []Hook
	mutation  *DocumentRevisionMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the DocumentRevisionUpdate builder.
func (dru *DocumentRevisionUpdate) Where(ps ...predicate.DocumentRevision) *DocumentRevisionUpdate {
	dru.mutation.Where(ps...)
	return dru
}

// SetUpdatedAt sets the "updated_at" field.
func (dru *DocumentRevisionUpdate) SetUpdatedAt(t time.Time) *DocumentRevisionUpdate {
	dru.mutation.SetUpdatedAt(t)
	return dru
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (dru *DocumentRevisionUpdate) ClearUpdatedAt() *DocumentRevisionUpdate {
	dru.mutation.ClearUpdatedAt()
	return dru
}

// SetUpdatedBy sets the "updated_by" field.
func (dru *DocumentRevisionUpdate) SetUpdatedBy(s string) *DocumentRevisionUpdate {
	dru.mutation.SetUpdatedBy(s)
	return dru
}

// SetNillableUpdatedBy sets the "updated_by" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableUpdatedBy(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetUpdatedBy(*s)
	}
	return dru
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (dru *DocumentRevisionUpdate) ClearUpdatedBy() *DocumentRevisionUpdate {
	dru.mutation.ClearUpdatedBy()
	return dru
}

// SetDeletedAt sets the "deleted_at" field.
func (dru *DocumentRevisionUpdate) SetDeletedAt(t time.Time) *DocumentRevisionUpdate {
	dru.mutation.SetDeletedAt(t)
	return dru
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableDeletedAt(t *time.Time) *DocumentRevisionUpdate {
	if t != nil {
		dru.SetDeletedAt(*t)
	}
	return dru
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (dru *DocumentRevisionUpdate) ClearDeletedAt() *DocumentRevisionUpdate {
	dru.mutation.ClearDeletedAt()
	return dru
}

// SetDeletedBy sets the "deleted_by" field.
func (dru *DocumentRevisionUpdate) SetDeletedBy(s string) *DocumentRevisionUpdate {
	dru.mutation.SetDeletedBy(s)
	return dru
}

// SetNillableDeletedBy sets the "deleted_by" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableDeletedBy(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetDeletedBy(*s)
	}
	return dru
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (dru *DocumentRevisionUpdate) ClearDeletedBy() *DocumentRevisionUpdate {
	dru.mutation.ClearDeletedBy()
	return dru
}

// SetTags sets the "tags" field.
func (dru *DocumentRevisionUpdate) SetTags(s []string) *DocumentRevisionUpdate {
	dru.mutation.SetTags(s)
	return dru
}

// AppendTags appends s to the "tags" field.
func (dru *DocumentRevisionUpdate) AppendTags(s []string) *DocumentRevisionUpdate {
	dru.mutation.AppendTags(s)
	return dru
}

// ClearTags clears the value of the "tags" field.
func (dru *DocumentRevisionUpdate) ClearTags() *DocumentRevisionUpdate {
	dru.mutation.ClearTags()
	return dru
}

// SetRevision sets the "revision" field.
func (dru *DocumentRevisionUpdate) SetRevision(s string) *DocumentRevisionUpdate {
	dru.mutation.SetRevision(s)
	return dru
}

// SetNillableRevision sets the "revision" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableRevision(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetRevision(*s)
	}
	return dru
}

// ClearRevision clears the value of the "revision" field.
func (dru *DocumentRevisionUpdate) ClearRevision() *DocumentRevisionUpdate {
	dru.mutation.ClearRevision()
	return dru
}

// SetDetails sets the "details" field.
func (dru *DocumentRevisionUpdate) SetDetails(s string) *DocumentRevisionUpdate {
	dru.mutation.SetDetails(s)
	return dru
}

// SetNillableDetails sets the "details" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableDetails(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetDetails(*s)
	}
	return dru
}

// ClearDetails clears the value of the "details" field.
func (dru *DocumentRevisionUpdate) ClearDetails() *DocumentRevisionUpdate {
	dru.mutation.ClearDetails()
	return dru
}

// SetStatus sets the "status" field.
func (dru *DocumentRevisionUpdate) SetStatus(es enums.ApprovalStatus) *DocumentRevisionUpdate {
	dru.mutation.SetStatus(es)
	return dru
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableStatus(es *enums.ApprovalStatus) *DocumentRevisionUpdate {
	if es != nil {
		dru.SetStatus(*es)
	}
	return dru
}

// ClearStatus clears the value of the "status" field.
func (dru *DocumentRevisionUpdate) ClearStatus() *DocumentRevisionUpdate {
	dru.mutation.ClearStatus()
	return dru
}

// SetApprovalDate sets the "approval_date" field.
func (dru *DocumentRevisionUpdate) SetApprovalDate(t time.Time) *DocumentRevisionUpdate {
	dru.mutation.SetApprovalDate(t)
	return dru
}

// SetNillableApprovalDate sets the "approval_date" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableApprovalDate(t *time.Time) *DocumentRevisionUpdate {
	if t != nil {
		dru.SetApprovalDate(*t)
	}
	return dru
}

// ClearApprovalDate clears the value of the "approval_date" field.
func (dru *DocumentRevisionUpdate) ClearApprovalDate() *DocumentRevisionUpdate {
	dru.mutation.ClearApprovalDate()
	return dru
}

// SetSubmittedByID sets the "submitted_by_id" field.
func (dru *DocumentRevisionUpdate) SetSubmittedByID(s string) *DocumentRevisionUpdate {
	dru.mutation.SetSubmittedByID(s)
	return dru
}

// SetNillableSubmittedByID sets the "submitted_by_id" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableSubmittedByID(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetSubmittedByID(*s)
	}
	return dru
}

// ClearSubmittedByID clears the value of the "submitted_by_id" field.
func (dru *DocumentRevisionUpdate) ClearSubmittedByID() *DocumentRevisionUpdate {
	dru.mutation.ClearSubmittedByID()
	return dru
}

// SetApprovedByID sets the "approved_by_id" field.
func (dru *DocumentRevisionUpdate) SetApprovedByID(s string) *DocumentRevisionUpdate {
	dru.mutation.SetApprovedByID(s)
	return dru
}

// SetNillableApprovedByID sets the "approved_by_id" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableApprovedByID(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetApprovedByID(*s)
	}
	return dru
}

// ClearApprovedByID clears the value of the "approved_by_id" field.
func (dru *DocumentRevisionUpdate) ClearApprovedByID() *DocumentRevisionUpdate {
	dru.mutation.ClearApprovedByID()
	return dru
}

// SetInternalPolicyID sets the "internal_policy_id" field.
func (dru *DocumentRevisionUpdate) SetInternalPolicyID(s string) *DocumentRevisionUpdate {
	dru.mutation.SetInternalPolicyID(s)
	return dru
}

// SetNillableInternalPolicyID sets the "internal_policy_id" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableInternalPolicyID(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetInternalPolicyID(*s)
	}
	return dru
}

// ClearInternalPolicyID clears the value of the "internal_policy_id" field.
func (dru *DocumentRevisionUpdate) ClearInternalPolicyID() *DocumentRevisionUpdate {
	dru.mutation.ClearInternalPolicyID()
	return dru
}

// SetProcedureID sets the "procedure_id" field.
func (dru *DocumentRevisionUpdate) SetProcedureID(s string) *DocumentRevisionUpdate {
	dru.mutation.SetProcedureID(s)
	return dru
}

// SetNillableProcedureID sets the "procedure_id" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableProcedureID(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetProcedureID(*s)
	}
	return dru
}

// ClearProcedureID clears the value of the "procedure_id" field.
func (dru *DocumentRevisionUpdate) ClearProcedureID() *DocumentRevisionUpdate {
	dru.mutation.ClearProcedureID()
	return dru
}

// SetActionPlanID sets the "action_plan_id" field.
func (dru *DocumentRevisionUpdate) SetActionPlanID(s string) *DocumentRevisionUpdate {
	dru.mutation.SetActionPlanID(s)
	return dru
}

// SetNillableActionPlanID sets the "action_plan_id" field if the given value is not nil.
func (dru *DocumentRevisionUpdate) SetNillableActionPlanID(s *string) *DocumentRevisionUpdate {
	if s != nil {
		dru.SetActionPlanID(*s)
	}
	return dru
}

// ClearActionPlanID clears the value of the "action_plan_id" field.
func (dru *DocumentRevisionUpdate) ClearActionPlanID() *DocumentRevisionUpdate {
	dru.mutation.ClearActionPlanID()
	return dru
}

// SetSubmittedBy sets the "submitted_by" edge to the User entity.
func (dru *DocumentRevisionUpdate) SetSubmittedBy(u *User) *DocumentRevisionUpdate {
	return dru.SetSubmittedByID(u.ID)
}

// SetApprovedBy sets the "approved_by" edge to the User entity.
func (dru *DocumentRevisionUpdate) SetApprovedBy(u *User) *DocumentRevisionUpdate {
	return dru.SetApprovedByID(u.ID)
}

// SetInternalPolicy sets the "internal_policy" edge to the InternalPolicy entity.
func (dru *DocumentRevisionUpdate) SetInternalPolicy(i *InternalPolicy) *DocumentRevisionUpdate {
	return dru.SetInternalPolicyID(i.ID)
}

// SetProcedure sets the "procedure" edge to the Procedure entity.
func (dru *DocumentRevisionUpdate) SetProcedure(p *Procedure) *DocumentRevisionUpdate {
	return dru.SetProcedureID(p.ID)
}

// SetActionPlan sets the "action_plan" edge to the ActionPlan entity.
func (dru *DocumentRevisionUpdate) SetActionPlan(a *ActionPlan) *DocumentRevisionUpdate {
	return dru.SetActionPlanID(a.ID)
}

// Mutation returns the DocumentRevisionMutation object of the builder.
func (dru *DocumentRevisionUpdate) Mutation() *DocumentRevisionMutation {
	return dru.mutation
}

// ClearSubmittedBy clears the "submitted_by" edge to the User entity.
func (dru *DocumentRevisionUpdate) ClearSubmittedBy() *DocumentRevisionUpdate {
	dru.mutation.ClearSubmittedBy()
	return dru
}

// ClearApprovedBy clears the "approved_by" edge to the User entity.
func (dru *DocumentRevisionUpdate) ClearApprovedBy() *DocumentRevisionUpdate {
	dru.mutation.ClearApprovedBy()
	return dru
}

// ClearInternalPolicy clears the "internal_policy" edge to the InternalPolicy entity.
func (dru *DocumentRevisionUpdate) ClearInternalPolicy() *DocumentRevisionUpdate {
	dru.mutation.ClearInternalPolicy()
	return dru
}

// ClearProcedure clears the "procedure" edge to the Procedure entity.
func (dru *DocumentRevisionUpdate) ClearProcedure() *DocumentRevisionUpdate {
	dru.mutation.ClearProcedure()
	return dru
}

// ClearActionPlan clears the "action_plan" edge to the ActionPlan entity.
func (dru *DocumentRevisionUpdate) ClearActionPlan() *DocumentRevisionUpdate {
	dru.mutation.ClearActionPlan()
	return dru
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (dru *DocumentRevisionUpdate) Save(ctx context.Context) (int, error) {
	if err := dru.defaults(); err != nil {
		return 0, err
	}
	return withHooks(ctx, dru.sqlSave, dru.mutation, dru.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (dru *DocumentRevisionUpdate) SaveX(ctx context.Context) int {
	affected, err := dru.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (dru *DocumentRevisionUpdate) Exec(ctx context.Context) error {
	_, err := dru.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (dru *DocumentRevisionUpdate) ExecX(ctx context.Context) {
	if err := dru.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (dru *DocumentRevisionUpdate) defaults() error {
	if _, ok := dru.mutation.UpdatedAt(); !ok && !dru.mutation.UpdatedAtCleared() {
		if documentrevision.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("generated: uninitialized documentrevision.UpdateDefaultUpdatedAt (forgotten import generated/runtime?)")
		}
		v := documentrevision.UpdateDefaultUpdatedAt()
		dru.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (dru *DocumentRevisionUpdate) check() error {
	if v, ok := dru.mutation.Revision(); ok {
		if err := documentrevision.RevisionValidator(v); err != nil {
			return &ValidationError{Name: "revision", err: fmt.Errorf(`generated: validator failed for field "DocumentRevision.revision": %w`, err)}
		}
	}
	if v, ok := dru.mutation.Status(); ok {
		if err := documentrevision.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`generated: validator failed for field "DocumentRevision.status": %w`, err)}
		}
	}
	if v, ok := dru.mutation.SubmittedByID(); ok {
		if err := documentrevision.SubmittedByIDValidator(v); err != nil {
			return &ValidationError{Name: "submitted_by_id", err: fmt.Errorf(`generated: validator failed for field "DocumentRevision.submitted_by_id": %w`, err)}
		}
	}
	if v, ok := dru.mutation.ApprovedByID(); ok {
		if err := documentrevision.ApprovedByIDValidator(v); err != nil {
			return &ValidationError{Name: "approved_by_id", err: fmt.Errorf(`generated: validator failed for field "DocumentRevision.approved_by_id": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (dru *DocumentRevisionUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *DocumentRevisionUpdate {
	dru.modifiers = append(dru.modifiers, modifiers...)
	return dru
}

func (dru *DocumentRevisionUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := dru.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(documentrevision.Table, documentrevision.Columns, sqlgraph.NewFieldSpec(documentrevision.FieldID, field.TypeString))
	if ps := dru.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if dru.mutation.CreatedAtCleared() {
		_spec.ClearField(documentrevision.FieldCreatedAt, field.TypeTime)
	}
	if value, ok := dru.mutation.UpdatedAt(); ok {
		_spec.SetField(documentrevision.FieldUpdatedAt, field.TypeTime, value)
	}
	if dru.mutation.UpdatedAtCleared() {
		_spec.ClearField(documentrevision.FieldUpdatedAt, field.TypeTime)
	}
	if dru.mutation.CreatedByCleared() {
		_spec.ClearField(documentrevision.FieldCreatedBy, field.TypeString)
	}
	if value, ok := dru.mutation.UpdatedBy(); ok {
		_spec.SetField(documentrevision.FieldUpdatedBy, field.TypeString, value)
	}
	if dru.mutation.UpdatedByCleared() {
		_spec.ClearField(documentrevision.FieldUpdatedBy, field.TypeString)
	}
	if value, ok := dru.mutation.DeletedAt(); ok {
		_spec.SetField(documentrevision.FieldDeletedAt, field.TypeTime, value)
	}
	if dru.mutation.DeletedAtCleared() {
		_spec.ClearField(documentrevision.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := dru.mutation.DeletedBy(); ok {
		_spec.SetField(documentrevision.FieldDeletedBy, field.TypeString, value)
	}
	if dru.mutation.DeletedByCleared() {
		_spec.ClearField(documentrevision.FieldDeletedBy, field.TypeString)
	}
	if value, ok := dru.mutation.Tags(); ok {
		_spec.SetField(documentrevision.FieldTags, field.TypeJSON, value)
	}
	if value, ok := dru.mutation.AppendedTags(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, documentrevision.FieldTags, value)
		})
	}
	if dru.mutation.TagsCleared() {
		_spec.ClearField(documentrevision.FieldTags, field.TypeJSON)
	}
	if value, ok := dru.mutation.Revision(); ok {
		_spec.SetField(documentrevision.FieldRevision, field.TypeString, value)
	}
	if dru.mutation.RevisionCleared() {
		_spec.ClearField(documentrevision.FieldRevision, field.TypeString)
	}
	if value, ok := dru.mutation.Details(); ok {
		_spec.SetField(documentrevision.FieldDetails, field.TypeString, value)
	}
	if dru.mutation.DetailsCleared() {
		_spec.ClearField(documentrevision.FieldDetails, field.TypeString)
	}
	if value, ok := dru.mutation.Status(); ok {
		_spec.SetField(documentrevision.FieldStatus, field.TypeEnum, value)
	}
	if dru.mutation.StatusCleared() {
		_spec.ClearField(documentrevision.FieldStatus, field.TypeEnum)
	}
	if value, ok := dru.mutation.ApprovalDate(); ok {
		_spec.SetField(documentrevision.FieldApprovalDate, field.TypeTime, value)
	}
	if dru.mutation.ApprovalDateCleared() {
		_spec.ClearField(documentrevision.FieldApprovalDate, field.TypeTime)
	}
	if dru.mutation.SubmittedByCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.SubmittedByTable,
			Columns: []string{documentrevision.SubmittedByColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := dru.mutation.SubmittedByIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.SubmittedByTable,
			Columns: []string{documentrevision.SubmittedByColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if dru.mutation.ApprovedByCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ApprovedByTable,
			Columns: []string{documentrevision.ApprovedByColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := dru.mutation.ApprovedByIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ApprovedByTable,
			Columns: []string{documentrevision.ApprovedByColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if dru.mutation.InternalPolicyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.InternalPolicyTable,
			Columns: []string{documentrevision.InternalPolicyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(internalpolicy.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := dru.mutation.InternalPolicyIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.InternalPolicyTable,
			Columns: []string{documentrevision.InternalPolicyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(internalpolicy.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if dru.mutation.ProcedureCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ProcedureTable,
			Columns: []string{documentrevision.ProcedureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(procedure.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := dru.mutation.ProcedureIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ProcedureTable,
			Columns: []string{documentrevision.ProcedureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(procedure.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if dru.mutation.ActionPlanCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ActionPlanTable,
			Columns: []string{documentrevision.ActionPlanColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(actionplan.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := dru.mutation.ActionPlanIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ActionPlanTable,
			Columns: []string{documentrevision.ActionPlanColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(actionplan.FieldID, field.TypeString),
			},
		}
		edge.Schema = dru.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = dru.schemaConfig.DocumentRevision
	ctx = internal.NewSchemaConfigContext(ctx, dru.schemaConfig)
	_spec.AddModifiers(dru.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, dru.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{documentrevision.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	dru.mutation.done = true
	return n, nil
}

// DocumentRevisionUpdateOne is the builder for updating a single DocumentRevision entity.
type DocumentRevisionUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *DocumentRevisionMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetUpdatedAt sets the "updated_at" field.
func (druo *DocumentRevisionUpdateOne) SetUpdatedAt(t time.Time) *DocumentRevisionUpdateOne {
	druo.mutation.SetUpdatedAt(t)
	return druo
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (druo *DocumentRevisionUpdateOne) ClearUpdatedAt() *DocumentRevisionUpdateOne {
	druo.mutation.ClearUpdatedAt()
	return druo
}

// SetUpdatedBy sets the "updated_by" field.
func (druo *DocumentRevisionUpdateOne) SetUpdatedBy(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetUpdatedBy(s)
	return druo
}

// SetNillableUpdatedBy sets the "updated_by" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableUpdatedBy(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetUpdatedBy(*s)
	}
	return druo
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (druo *DocumentRevisionUpdateOne) ClearUpdatedBy() *DocumentRevisionUpdateOne {
	druo.mutation.ClearUpdatedBy()
	return druo
}

// SetDeletedAt sets the "deleted_at" field.
func (druo *DocumentRevisionUpdateOne) SetDeletedAt(t time.Time) *DocumentRevisionUpdateOne {
	druo.mutation.SetDeletedAt(t)
	return druo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableDeletedAt(t *time.Time) *DocumentRevisionUpdateOne {
	if t != nil {
		druo.SetDeletedAt(*t)
	}
	return druo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (druo *DocumentRevisionUpdateOne) ClearDeletedAt() *DocumentRevisionUpdateOne {
	druo.mutation.ClearDeletedAt()
	return druo
}

// SetDeletedBy sets the "deleted_by" field.
func (druo *DocumentRevisionUpdateOne) SetDeletedBy(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetDeletedBy(s)
	return druo
}

// SetNillableDeletedBy sets the "deleted_by" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableDeletedBy(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetDeletedBy(*s)
	}
	return druo
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (druo *DocumentRevisionUpdateOne) ClearDeletedBy() *DocumentRevisionUpdateOne {
	druo.mutation.ClearDeletedBy()
	return druo
}

// SetTags sets the "tags" field.
func (druo *DocumentRevisionUpdateOne) SetTags(s []string) *DocumentRevisionUpdateOne {
	druo.mutation.SetTags(s)
	return druo
}

// AppendTags appends s to the "tags" field.
func (druo *DocumentRevisionUpdateOne) AppendTags(s []string) *DocumentRevisionUpdateOne {
	druo.mutation.AppendTags(s)
	return druo
}

// ClearTags clears the value of the "tags" field.
func (druo *DocumentRevisionUpdateOne) ClearTags() *DocumentRevisionUpdateOne {
	druo.mutation.ClearTags()
	return druo
}

// SetRevision sets the "revision" field.
func (druo *DocumentRevisionUpdateOne) SetRevision(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetRevision(s)
	return druo
}

// SetNillableRevision sets the "revision" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableRevision(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetRevision(*s)
	}
	return druo
}

// ClearRevision clears the value of the "revision" field.
func (druo *DocumentRevisionUpdateOne) ClearRevision() *DocumentRevisionUpdateOne {
	druo.mutation.ClearRevision()
	return druo
}

// SetDetails sets the "details" field.
func (druo *DocumentRevisionUpdateOne) SetDetails(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetDetails(s)
	return druo
}

// SetNillableDetails sets the "details" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableDetails(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetDetails(*s)
	}
	return druo
}

// ClearDetails clears the value of the "details" field.
func (druo *DocumentRevisionUpdateOne) ClearDetails() *DocumentRevisionUpdateOne {
	druo.mutation.ClearDetails()
	return druo
}

// SetStatus sets the "status" field.
func (druo *DocumentRevisionUpdateOne) SetStatus(es enums.ApprovalStatus) *DocumentRevisionUpdateOne {
	druo.mutation.SetStatus(es)
	return druo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableStatus(es *enums.ApprovalStatus) *DocumentRevisionUpdateOne {
	if es != nil {
		druo.SetStatus(*es)
	}
	return druo
}

// ClearStatus clears the value of the "status" field.
func (druo *DocumentRevisionUpdateOne) ClearStatus() *DocumentRevisionUpdateOne {
	druo.mutation.ClearStatus()
	return druo
}

// SetApprovalDate sets the "approval_date" field.
func (druo *DocumentRevisionUpdateOne) SetApprovalDate(t time.Time) *DocumentRevisionUpdateOne {
	druo.mutation.SetApprovalDate(t)
	return druo
}

// SetNillableApprovalDate sets the "approval_date" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableApprovalDate(t *time.Time) *DocumentRevisionUpdateOne {
	if t != nil {
		druo.SetApprovalDate(*t)
	}
	return druo
}

// ClearApprovalDate clears the value of the "approval_date" field.
func (druo *DocumentRevisionUpdateOne) ClearApprovalDate() *DocumentRevisionUpdateOne {
	druo.mutation.ClearApprovalDate()
	return druo
}

// SetSubmittedByID sets the "submitted_by_id" field.
func (druo *DocumentRevisionUpdateOne) SetSubmittedByID(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetSubmittedByID(s)
	return druo
}

// SetNillableSubmittedByID sets the "submitted_by_id" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableSubmittedByID(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetSubmittedByID(*s)
	}
	return druo
}

// ClearSubmittedByID clears the value of the "submitted_by_id" field.
func (druo *DocumentRevisionUpdateOne) ClearSubmittedByID() *DocumentRevisionUpdateOne {
	druo.mutation.ClearSubmittedByID()
	return druo
}

// SetApprovedByID sets the "approved_by_id" field.
func (druo *DocumentRevisionUpdateOne) SetApprovedByID(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetApprovedByID(s)
	return druo
}

// SetNillableApprovedByID sets the "approved_by_id" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableApprovedByID(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetApprovedByID(*s)
	}
	return druo
}

// ClearApprovedByID clears the value of the "approved_by_id" field.
func (druo *DocumentRevisionUpdateOne) ClearApprovedByID() *DocumentRevisionUpdateOne {
	druo.mutation.ClearApprovedByID()
	return druo
}

// SetInternalPolicyID sets the "internal_policy_id" field.
func (druo *DocumentRevisionUpdateOne) SetInternalPolicyID(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetInternalPolicyID(s)
	return druo
}

// SetNillableInternalPolicyID sets the "internal_policy_id" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableInternalPolicyID(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetInternalPolicyID(*s)
	}
	return druo
}

// ClearInternalPolicyID clears the value of the "internal_policy_id" field.
func (druo *DocumentRevisionUpdateOne) ClearInternalPolicyID() *DocumentRevisionUpdateOne {
	druo.mutation.ClearInternalPolicyID()
	return druo
}

// SetProcedureID sets the "procedure_id" field.
func (druo *DocumentRevisionUpdateOne) SetProcedureID(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetProcedureID(s)
	return druo
}

// SetNillableProcedureID sets the "procedure_id" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableProcedureID(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetProcedureID(*s)
	}
	return druo
}

// ClearProcedureID clears the value of the "procedure_id" field.
func (druo *DocumentRevisionUpdateOne) ClearProcedureID() *DocumentRevisionUpdateOne {
	druo.mutation.ClearProcedureID()
	return druo
}

// SetActionPlanID sets the "action_plan_id" field.
func (druo *DocumentRevisionUpdateOne) SetActionPlanID(s string) *DocumentRevisionUpdateOne {
	druo.mutation.SetActionPlanID(s)
	return druo
}

// SetNillableActionPlanID sets the "action_plan_id" field if the given value is not nil.
func (druo *DocumentRevisionUpdateOne) SetNillableActionPlanID(s *string) *DocumentRevisionUpdateOne {
	if s != nil {
		druo.SetActionPlanID(*s)
	}
	return druo
}

// ClearActionPlanID clears the value of the "action_plan_id" field.
func (druo *DocumentRevisionUpdateOne) ClearActionPlanID() *DocumentRevisionUpdateOne {
	druo.mutation.ClearActionPlanID()
	return druo
}

// SetSubmittedBy sets the "submitted_by" edge to the User entity.
func (druo *DocumentRevisionUpdateOne) SetSubmittedBy(u *User) *DocumentRevisionUpdateOne {
	return druo.SetSubmittedByID(u.ID)
}

// SetApprovedBy sets the "approved_by" edge to the User entity.
func (druo *DocumentRevisionUpdateOne) SetApprovedBy(u *User) *DocumentRevisionUpdateOne {
	return druo.SetApprovedByID(u.ID)
}

// SetInternalPolicy sets the "internal_policy" edge to the InternalPolicy entity.
func (druo *DocumentRevisionUpdateOne) SetInternalPolicy(i *InternalPolicy) *DocumentRevisionUpdateOne {
	return druo.SetInternalPolicyID(i.ID)
}

// SetProcedure sets the "procedure" edge to the Procedure entity.
func (druo *DocumentRevisionUpdateOne) SetProcedure(p *Procedure) *DocumentRevisionUpdateOne {
	return druo.SetProcedureID(p.ID)
}

// SetActionPlan sets the "action_plan" edge to the ActionPlan entity.
func (druo *DocumentRevisionUpdateOne) SetActionPlan(a *ActionPlan) *DocumentRevisionUpdateOne {
	return druo.SetActionPlanID(a.ID)
}

// Mutation returns the DocumentRevisionMutation object of the builder.
func (druo *DocumentRevisionUpdateOne) Mutation() *DocumentRevisionMutation {
	return druo.mutation
}

// ClearSubmittedBy clears the "submitted_by" edge to the User entity.
func (druo *DocumentRevisionUpdateOne) ClearSubmittedBy() *DocumentRevisionUpdateOne {
	druo.mutation.ClearSubmittedBy()
	return druo
}

// ClearApprovedBy clears the "approved_by" edge to the User entity.
func (druo *DocumentRevisionUpdateOne) ClearApprovedBy() *DocumentRevisionUpdateOne {
	druo.mutation.ClearApprovedBy()
	return druo
}

// ClearInternalPolicy clears the "internal_policy" edge to the InternalPolicy entity.
func (druo *DocumentRevisionUpdateOne) ClearInternalPolicy() *DocumentRevisionUpdateOne {
	druo.mutation.ClearInternalPolicy()
	return druo
}

// ClearProcedure clears the "procedure" edge to the Procedure entity.
func (druo *DocumentRevisionUpdateOne) ClearProcedure() *DocumentRevisionUpdateOne {
	druo.mutation.ClearProcedure()
	return druo
}

// ClearActionPlan clears the "action_plan" edge to the ActionPlan entity.
func (druo *DocumentRevisionUpdateOne) ClearActionPlan() *DocumentRevisionUpdateOne {
	druo.mutation.ClearActionPlan()
	return druo
}

// Where appends a list predicates to the DocumentRevisionUpdate builder.
func (druo *DocumentRevisionUpdateOne) Where(ps ...predicate.DocumentRevision) *DocumentRevisionUpdateOne {
	druo.mutation.Where(ps...)
	return druo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (druo *DocumentRevisionUpdateOne) Select(field string, fields ...string) *DocumentRevisionUpdateOne {
	druo.fields = append([]string{field}, fields...)
	return druo
}

// Save executes the query and returns the updated DocumentRevision entity.
func (druo *DocumentRevisionUpdateOne) Save(ctx context.Context) (*DocumentRevision, error) {
	if err := druo.defaults(); err != nil {
		return nil, err
	}
	return withHooks(ctx, druo.sqlSave, druo.mutation, druo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (druo *DocumentRevisionUpdateOne) SaveX(ctx context.Context) *DocumentRevision {
	node, err := druo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (druo *DocumentRevisionUpdateOne) Exec(ctx context.Context) error {
	_, err := druo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (druo *DocumentRevisionUpdateOne) ExecX(ctx context.Context) {
	if err := druo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (druo *DocumentRevisionUpdateOne) defaults() error {
	if _, ok := druo.mutation.UpdatedAt(); !ok && !druo.mutation.UpdatedAtCleared() {
		if documentrevision.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("generated: uninitialized documentrevision.UpdateDefaultUpdatedAt (forgotten import generated/runtime?)")
		}
		v := documentrevision.UpdateDefaultUpdatedAt()
		druo.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (druo *DocumentRevisionUpdateOne) check() error {
	if v, ok := druo.mutation.Revision(); ok {
		if err := documentrevision.RevisionValidator(v); err != nil {
			return &ValidationError{Name: "revision", err: fmt.Errorf(`generated: validator failed for field "DocumentRevision.revision": %w`, err)}
		}
	}
	if v, ok := druo.mutation.Status(); ok {
		if err := documentrevision.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`generated: validator failed for field "DocumentRevision.status": %w`, err)}
		}
	}
	if v, ok := druo.mutation.SubmittedByID(); ok {
		if err := documentrevision.SubmittedByIDValidator(v); err != nil {
			return &ValidationError{Name: "submitted_by_id", err: fmt.Errorf(`generated: validator failed for field "DocumentRevision.submitted_by_id": %w`, err)}
		}
	}
	if v, ok := druo.mutation.ApprovedByID(); ok {
		if err := documentrevision.ApprovedByIDValidator(v); err != nil {
			return &ValidationError{Name: "approved_by_id", err: fmt.Errorf(`generated: validator failed for field "DocumentRevision.approved_by_id": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (druo *DocumentRevisionUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *DocumentRevisionUpdateOne {
	druo.modifiers = append(druo.modifiers, modifiers...)
	return druo
}

func (druo *DocumentRevisionUpdateOne) sqlSave(ctx context.Context) (_node *DocumentRevision, err error) {
	if err := druo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(documentrevision.Table, documentrevision.Columns, sqlgraph.NewFieldSpec(documentrevision.FieldID, field.TypeString))
	id, ok := druo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`generated: missing "DocumentRevision.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := druo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, documentrevision.FieldID)
		for _, f := range fields {
			if !documentrevision.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("generated: invalid field %q for query", f)}
			}
			if f != documentrevision.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := druo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if druo.mutation.CreatedAtCleared() {
		_spec.ClearField(documentrevision.FieldCreatedAt, field.TypeTime)
	}
	if value, ok := druo.mutation.UpdatedAt(); ok {
		_spec.SetField(documentrevision.FieldUpdatedAt, field.TypeTime, value)
	}
	if druo.mutation.UpdatedAtCleared() {
		_spec.ClearField(documentrevision.FieldUpdatedAt, field.TypeTime)
	}
	if druo.mutation.CreatedByCleared() {
		_spec.ClearField(documentrevision.FieldCreatedBy, field.TypeString)
	}
	if value, ok := druo.mutation.UpdatedBy(); ok {
		_spec.SetField(documentrevision.FieldUpdatedBy, field.TypeString, value)
	}
	if druo.mutation.UpdatedByCleared() {
		_spec.ClearField(documentrevision.FieldUpdatedBy, field.TypeString)
	}
	if value, ok := druo.mutation.DeletedAt(); ok {
		_spec.SetField(documentrevision.FieldDeletedAt, field.TypeTime, value)
	}
	if druo.mutation.DeletedAtCleared() {
		_spec.ClearField(documentrevision.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := druo.mutation.DeletedBy(); ok {
		_spec.SetField(documentrevision.FieldDeletedBy, field.TypeString, value)
	}
	if druo.mutation.DeletedByCleared() {
		_spec.ClearField(documentrevision.FieldDeletedBy, field.TypeString)
	}
	if value, ok := druo.mutation.Tags(); ok {
		_spec.SetField(documentrevision.FieldTags, field.TypeJSON, value)
	}
	if value, ok := druo.mutation.AppendedTags(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, documentrevision.FieldTags, value)
		})
	}
	if druo.mutation.TagsCleared() {
		_spec.ClearField(documentrevision.FieldTags, field.TypeJSON)
	}
	if value, ok := druo.mutation.Revision(); ok {
		_spec.SetField(documentrevision.FieldRevision, field.TypeString, value)
	}
	if druo.mutation.RevisionCleared() {
		_spec.ClearField(documentrevision.FieldRevision, field.TypeString)
	}
	if value, ok := druo.mutation.Details(); ok {
		_spec.SetField(documentrevision.FieldDetails, field.TypeString, value)
	}
	if druo.mutation.DetailsCleared() {
		_spec.ClearField(documentrevision.FieldDetails, field.TypeString)
	}
	if value, ok := druo.mutation.Status(); ok {
		_spec.SetField(documentrevision.FieldStatus, field.TypeEnum, value)
	}
	if druo.mutation.StatusCleared() {
		_spec.ClearField(documentrevision.FieldStatus, field.TypeEnum)
	}
	if value, ok := druo.mutation.ApprovalDate(); ok {
		_spec.SetField(documentrevision.FieldApprovalDate, field.TypeTime, value)
	}
	if druo.mutation.ApprovalDateCleared() {
		_spec.ClearField(documentrevision.FieldApprovalDate, field.TypeTime)
	}
	if druo.mutation.SubmittedByCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.SubmittedByTable,
			Columns: []string{documentrevision.SubmittedByColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := druo.mutation.SubmittedByIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.SubmittedByTable,
			Columns: []string{documentrevision.SubmittedByColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if druo.mutation.ApprovedByCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ApprovedByTable,
			Columns: []string{documentrevision.ApprovedByColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := druo.mutation.ApprovedByIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ApprovedByTable,
			Columns: []string{documentrevision.ApprovedByColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if druo.mutation.InternalPolicyCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.InternalPolicyTable,
			Columns: []string{documentrevision.InternalPolicyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(internalpolicy.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := druo.mutation.InternalPolicyIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.InternalPolicyTable,
			Columns: []string{documentrevision.InternalPolicyColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(internalpolicy.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if druo.mutation.ProcedureCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ProcedureTable,
			Columns: []string{documentrevision.ProcedureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(procedure.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := druo.mutation.ProcedureIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ProcedureTable,
			Columns: []string{documentrevision.ProcedureColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(procedure.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if druo.mutation.ActionPlanCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ActionPlanTable,
			Columns: []string{documentrevision.ActionPlanColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(actionplan.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := druo.mutation.ActionPlanIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   documentrevision.ActionPlanTable,
			Columns: []string{documentrevision.ActionPlanColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(actionplan.FieldID, field.TypeString),
			},
		}
		edge.Schema = druo.schemaConfig.DocumentRevision
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = druo.schemaConfig.DocumentRevision
	ctx = internal.NewSchemaConfigContext(ctx, druo.schemaConfig)
	_spec.AddModifiers(druo.modifiers...)
	_node = &DocumentRevision{config: druo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, druo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{documentrevision.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	druo.mutation.done = true
	return _node, nil
}
