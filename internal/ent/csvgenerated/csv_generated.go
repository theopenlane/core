// Code generated by entx CSV generator. DO NOT EDIT.
package csvgenerated

import (
	"context"
	"strings"

	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/predicate"
	"github.com/theopenlane/core/internal/ent/generated/entity"
	"github.com/theopenlane/core/internal/ent/generated/group"
	"github.com/theopenlane/core/internal/ent/generated/identityholder"
	"github.com/theopenlane/core/internal/ent/generated/platform"
	"github.com/theopenlane/core/internal/ent/generated/template"
	"github.com/theopenlane/core/internal/ent/generated/user"
)

// CSVLookupFn is the function signature for CSV reference lookups.
type CSVLookupFn func(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error)

// CSVCreateFn is the function signature for CSV reference auto-creation.
type CSVCreateFn func(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error)

// CSVLookupEntry contains the lookup and optional create function for a target entity/match field pair.
type CSVLookupEntry struct {
	Lookup CSVLookupFn
	Create CSVCreateFn
}

// CSVLookupRegistry maps (TargetEntity:MatchField) to lookup/create functions.
var CSVLookupRegistry = map[string]CSVLookupEntry{
	"Entity:name": {
		Lookup: LookupEntityByName,
	},
	"Group:name": {
		Lookup: LookupGroupByName,
	},
	"IdentityHolder:email": {
		Lookup: LookupIdentityHolderByEmail,
	},
	"Platform:name": {
		Lookup: LookupPlatformByName,
		Create: CreatePlatformByName,
	},
	"Template:name": {
		Lookup: LookupTemplateByName,
	},
	"User:email": {
		Lookup: LookupUserByEmail,
	},
}

// GetCSVLookupEntry returns the lookup entry for a target entity and match field.
func GetCSVLookupEntry(targetEntity, matchField string) (CSVLookupEntry, bool) {
	key := targetEntity + ":" + matchField
	entry, ok := CSVLookupRegistry[key]
	return entry, ok
}

// normalizeCSVKey normalizes input values for lookup comparisons.
func normalizeCSVKey(value string) string {
	return strings.ToLower(strings.TrimSpace(value))
}

// LookupEntityByName resolves Entity name values to IDs.
func LookupEntityByName(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	predicates := make([]predicate.Entity, 0, len(unique))
	for _, v := range unique {
		predicates = append(predicates, entity.NameEqualFold(v))
	}
	records, err := client.Entity.Query().
		Where(entity.OwnerID(orgID), entity.Or(predicates...)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(records))
	for _, r := range records {
		key := normalizeCSVKey(r.Name)
		resolved[key] = r.ID
	}

	return resolved, nil
}

// LookupGroupByName resolves Group name values to IDs.
func LookupGroupByName(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	predicates := make([]predicate.Group, 0, len(unique))
	for _, v := range unique {
		predicates = append(predicates, group.NameEqualFold(v))
	}
	records, err := client.Group.Query().
		Where(group.OwnerID(orgID), group.Or(predicates...)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(records))
	for _, r := range records {
		key := normalizeCSVKey(r.Name)
		resolved[key] = r.ID
	}

	return resolved, nil
}

// LookupIdentityHolderByEmail resolves IdentityHolder email values to IDs.
func LookupIdentityHolderByEmail(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	predicates := make([]predicate.IdentityHolder, 0, len(unique))
	for _, v := range unique {
		predicates = append(predicates, identityholder.EmailEqualFold(v))
	}
	records, err := client.IdentityHolder.Query().
		Where(identityholder.OwnerID(orgID), identityholder.Or(predicates...)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(records))
	for _, r := range records {
		key := normalizeCSVKey(r.Email)
		resolved[key] = r.ID
	}

	return resolved, nil
}

// LookupPlatformByName resolves Platform name values to IDs.
func LookupPlatformByName(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	predicates := make([]predicate.Platform, 0, len(unique))
	for _, v := range unique {
		predicates = append(predicates, platform.NameEqualFold(v))
	}
	records, err := client.Platform.Query().
		Where(platform.OwnerID(orgID), platform.Or(predicates...)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(records))
	for _, r := range records {
		key := normalizeCSVKey(r.Name)
		resolved[key] = r.ID
	}

	return resolved, nil
}

// CreatePlatformByName creates missing Platform records and returns their IDs.
func CreatePlatformByName(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	builders := make([]*generated.PlatformCreate, 0, len(unique))
	for _, v := range unique {
		builders = append(builders, client.Platform.Create().
			SetName(v).
			SetOwnerID(orgID))
	}

	created, err := client.Platform.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(created))
	for _, r := range created {
		key := normalizeCSVKey(r.Name)
		resolved[key] = r.ID
	}

	return resolved, nil
}

// LookupTemplateByName resolves Template name values to IDs.
func LookupTemplateByName(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	predicates := make([]predicate.Template, 0, len(unique))
	for _, v := range unique {
		predicates = append(predicates, template.NameEqualFold(v))
	}
	records, err := client.Template.Query().
		Where(template.OwnerID(orgID), template.Or(predicates...)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(records))
	for _, r := range records {
		key := normalizeCSVKey(r.Name)
		resolved[key] = r.ID
	}

	return resolved, nil
}

// LookupUserByEmail resolves User email values to IDs.
func LookupUserByEmail(ctx context.Context, client *generated.Client, orgID string, values []string) (map[string]string, error) {
	if len(values) == 0 {
		return nil, nil
	}

	unique := make(map[string]string)
	for _, v := range values {
		v = strings.TrimSpace(v)
		if v == "" {
			continue
		}
		key := normalizeCSVKey(v)
		if _, exists := unique[key]; !exists {
			unique[key] = v
		}
	}

	if len(unique) == 0 {
		return nil, nil
	}

	predicates := make([]predicate.User, 0, len(unique))
	for _, v := range unique {
		predicates = append(predicates, user.EmailEqualFold(v))
	}
	records, err := client.User.Query().
		Where(user.Or(predicates...)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	resolved := make(map[string]string, len(records))
	for _, r := range records {
		key := normalizeCSVKey(r.Email)
		resolved[key] = r.ID
	}

	return resolved, nil
}

// CSVReferenceRule describes how a CSV column maps to a target ID field.
type CSVReferenceRule struct {
	// SourceColumn is the CSV column name containing friendly values
	SourceColumn string
	// TargetField is the Go field name on the input struct to populate
	TargetField string
	// TargetEntity is the entity type to query (e.g., User, Group)
	TargetEntity string
	// MatchField is the field on the target entity to match (e.g., email, name)
	MatchField string
	// IsSlice indicates if the target field is []string
	IsSlice bool
	// CreateIfMissing allows auto-creation during import
	CreateIfMissing bool
}

// CSVSchemaInfo contains CSV reference metadata for a schema.
type CSVSchemaInfo struct {
	// SchemaName is the ent schema name
	SchemaName string
	// Rules contains the CSV reference rules for this schema
	Rules []CSVReferenceRule
}

// CSVReferenceRegistry maps schema names to their CSV reference info.
var CSVReferenceRegistry = map[string]CSVSchemaInfo{
	"ActionPlan": {
		SchemaName: "ActionPlan",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "ApproverGroupName",
				TargetField:     "ApproverID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "DocumentDelegateGroupName",
				TargetField:     "DelegateID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Assessment": {
		SchemaName: "Assessment",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "AssessmentTemplateRef",
				TargetField:     "TemplateID",
				TargetEntity:    "Template",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"AssessmentResponse": {
		SchemaName: "AssessmentResponse",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "AssessmentIdentityHolderEmail",
				TargetField:     "IdentityHolderID",
				TargetEntity:    "IdentityHolder",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "AssessmentResponseEntityName",
				TargetField:     "EntityID",
				TargetEntity:    "Entity",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Asset": {
		SchemaName: "Asset",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "InternalOwnerGroupName",
				TargetField:     "InternalOwnerGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "InternalOwnerUserEmail",
				TargetField:     "InternalOwnerUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "SourcePlatformName",
				TargetField:     "SourcePlatformID",
				TargetEntity:    "Platform",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: true,
			},
		},
	},
	"Campaign": {
		SchemaName: "Campaign",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "CampaignEntityName",
				TargetField:     "EntityID",
				TargetEntity:    "Entity",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "CampaignTemplateRef",
				TargetField:     "TemplateID",
				TargetEntity:    "Template",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "InternalOwnerGroupName",
				TargetField:     "InternalOwnerGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "InternalOwnerUserEmail",
				TargetField:     "InternalOwnerUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"CampaignTarget": {
		SchemaName: "CampaignTarget",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "CampaignTargetGroupName",
				TargetField:     "GroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "CampaignTargetUserEmail",
				TargetField:     "UserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Control": {
		SchemaName: "Control",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "ControlDelegateGroupName",
				TargetField:     "DelegateID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "ControlOwnerGroupName",
				TargetField:     "ControlOwnerID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "ResponsiblePartyEntityName",
				TargetField:     "ResponsiblePartyID",
				TargetEntity:    "Entity",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Entity": {
		SchemaName: "Entity",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "InternalOwnerGroupName",
				TargetField:     "InternalOwnerGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "InternalOwnerUserEmail",
				TargetField:     "InternalOwnerUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "ReviewedByGroupName",
				TargetField:     "ReviewedByGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "ReviewedByUserEmail",
				TargetField:     "ReviewedByUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"IdentityHolder": {
		SchemaName: "IdentityHolder",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "EmployerEntityName",
				TargetField:     "EmployerEntityID",
				TargetEntity:    "Entity",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "IdentityHolderUserEmail",
				TargetField:     "UserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "InternalOwnerGroupName",
				TargetField:     "InternalOwnerGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "InternalOwnerUserEmail",
				TargetField:     "InternalOwnerUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"InternalPolicy": {
		SchemaName: "InternalPolicy",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "ApproverGroupName",
				TargetField:     "ApproverID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "DocumentDelegateGroupName",
				TargetField:     "DelegateID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Platform": {
		SchemaName: "Platform",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "BusinessOwnerGroupName",
				TargetField:     "BusinessOwnerGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "BusinessOwnerUserEmail",
				TargetField:     "BusinessOwnerUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "InternalOwnerGroupName",
				TargetField:     "InternalOwnerGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "InternalOwnerUserEmail",
				TargetField:     "InternalOwnerUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "PlatformOwnerEmail",
				TargetField:     "PlatformOwnerID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "SecurityOwnerGroupName",
				TargetField:     "SecurityOwnerGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "SecurityOwnerUserEmail",
				TargetField:     "SecurityOwnerUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "TechnicalOwnerGroupName",
				TargetField:     "TechnicalOwnerGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "TechnicalOwnerUserEmail",
				TargetField:     "TechnicalOwnerUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Procedure": {
		SchemaName: "Procedure",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "ApproverGroupName",
				TargetField:     "ApproverID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "DocumentDelegateGroupName",
				TargetField:     "DelegateID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Program": {
		SchemaName: "Program",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "ProgramOwnerEmail",
				TargetField:     "ProgramOwnerID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Risk": {
		SchemaName: "Risk",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "RiskDelegateGroupName",
				TargetField:     "DelegateID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "StakeholderGroupName",
				TargetField:     "StakeholderID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Scan": {
		SchemaName: "Scan",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "AssignedToGroupName",
				TargetField:     "AssignedToGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "AssignedToUserEmail",
				TargetField:     "AssignedToUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "GeneratedByPlatformName",
				TargetField:     "GeneratedByPlatformID",
				TargetEntity:    "Platform",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: true,
			},
			{
				SourceColumn:    "PerformedByGroupName",
				TargetField:     "PerformedByGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "PerformedByUserEmail",
				TargetField:     "PerformedByUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "ReviewedByGroupName",
				TargetField:     "ReviewedByGroupID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "ReviewedByUserEmail",
				TargetField:     "ReviewedByUserID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Subcontrol": {
		SchemaName: "Subcontrol",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "ControlDelegateGroupName",
				TargetField:     "DelegateID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "ControlOwnerGroupName",
				TargetField:     "ControlOwnerID",
				TargetEntity:    "Group",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "ResponsiblePartyEntityName",
				TargetField:     "ResponsiblePartyID",
				TargetEntity:    "Entity",
				MatchField:      "name",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
	"Task": {
		SchemaName: "Task",
		Rules: []CSVReferenceRule{
			{
				SourceColumn:    "AssigneeEmail",
				TargetField:     "AssigneeID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
			{
				SourceColumn:    "AssignerEmail",
				TargetField:     "AssignerID",
				TargetEntity:    "User",
				MatchField:      "email",
				IsSlice:         false,
				CreateIfMissing: false,
			},
		},
	},
}

// GetCSVReferenceRules returns the CSV reference rules for a schema.
func GetCSVReferenceRules(schemaName string) []CSVReferenceRule {
	info, ok := CSVReferenceRegistry[schemaName]
	if !ok {
		return nil
	}

	return info.Rules
}

// HasCSVReferences returns true if a schema has CSV reference fields.
func HasCSVReferences(schemaName string) bool {
	info, ok := CSVReferenceRegistry[schemaName]
	return ok && len(info.Rules) > 0
}

// ActionPlanCSVInput wraps CreateActionPlanInput with CSV reference columns.
type ActionPlanCSVInput struct {
	Input generated.CreateActionPlanInput
	ApproverGroupName string `csv:"ApproverGroupName"`
	DocumentDelegateGroupName string `csv:"DocumentDelegateGroupName"`
}

// CSVInputWrapper marks ActionPlanCSVInput for CSV header preprocessing.
func (ActionPlanCSVInput) CSVInputWrapper() {}

// AssessmentCSVInput wraps CreateAssessmentInput with CSV reference columns.
type AssessmentCSVInput struct {
	Input generated.CreateAssessmentInput
	AssessmentTemplateRef string `csv:"AssessmentTemplateRef"`
}

// CSVInputWrapper marks AssessmentCSVInput for CSV header preprocessing.
func (AssessmentCSVInput) CSVInputWrapper() {}

// AssessmentResponseCSVInput wraps CreateAssessmentResponseInput with CSV reference columns.
type AssessmentResponseCSVInput struct {
	Input generated.CreateAssessmentResponseInput
	AssessmentIdentityHolderEmail string `csv:"AssessmentIdentityHolderEmail"`
	AssessmentResponseEntityName string `csv:"AssessmentResponseEntityName"`
}

// CSVInputWrapper marks AssessmentResponseCSVInput for CSV header preprocessing.
func (AssessmentResponseCSVInput) CSVInputWrapper() {}

// AssetCSVInput wraps CreateAssetInput with CSV reference columns.
type AssetCSVInput struct {
	Input generated.CreateAssetInput
	InternalOwnerGroupName string `csv:"InternalOwnerGroupName"`
	InternalOwnerUserEmail string `csv:"InternalOwnerUserEmail"`
	SourcePlatformName string `csv:"SourcePlatformName"`
}

// CSVInputWrapper marks AssetCSVInput for CSV header preprocessing.
func (AssetCSVInput) CSVInputWrapper() {}

// CampaignCSVInput wraps CreateCampaignInput with CSV reference columns.
type CampaignCSVInput struct {
	Input generated.CreateCampaignInput
	CampaignEntityName string `csv:"CampaignEntityName"`
	CampaignTemplateRef string `csv:"CampaignTemplateRef"`
	InternalOwnerGroupName string `csv:"InternalOwnerGroupName"`
	InternalOwnerUserEmail string `csv:"InternalOwnerUserEmail"`
}

// CSVInputWrapper marks CampaignCSVInput for CSV header preprocessing.
func (CampaignCSVInput) CSVInputWrapper() {}

// CampaignTargetCSVInput wraps CreateCampaignTargetInput with CSV reference columns.
type CampaignTargetCSVInput struct {
	Input generated.CreateCampaignTargetInput
	CampaignTargetGroupName string `csv:"CampaignTargetGroupName"`
	CampaignTargetUserEmail string `csv:"CampaignTargetUserEmail"`
}

// CSVInputWrapper marks CampaignTargetCSVInput for CSV header preprocessing.
func (CampaignTargetCSVInput) CSVInputWrapper() {}

// ControlCSVInput wraps CreateControlInput with CSV reference columns.
type ControlCSVInput struct {
	Input generated.CreateControlInput
	ControlDelegateGroupName string `csv:"ControlDelegateGroupName"`
	ControlOwnerGroupName string `csv:"ControlOwnerGroupName"`
	ResponsiblePartyEntityName string `csv:"ResponsiblePartyEntityName"`
}

// CSVInputWrapper marks ControlCSVInput for CSV header preprocessing.
func (ControlCSVInput) CSVInputWrapper() {}

// EntityCSVInput wraps CreateEntityInput with CSV reference columns.
type EntityCSVInput struct {
	Input generated.CreateEntityInput
	InternalOwnerGroupName string `csv:"InternalOwnerGroupName"`
	InternalOwnerUserEmail string `csv:"InternalOwnerUserEmail"`
	ReviewedByGroupName string `csv:"ReviewedByGroupName"`
	ReviewedByUserEmail string `csv:"ReviewedByUserEmail"`
}

// CSVInputWrapper marks EntityCSVInput for CSV header preprocessing.
func (EntityCSVInput) CSVInputWrapper() {}

// IdentityHolderCSVInput wraps CreateIdentityHolderInput with CSV reference columns.
type IdentityHolderCSVInput struct {
	Input generated.CreateIdentityHolderInput
	EmployerEntityName string `csv:"EmployerEntityName"`
	IdentityHolderUserEmail string `csv:"IdentityHolderUserEmail"`
	InternalOwnerGroupName string `csv:"InternalOwnerGroupName"`
	InternalOwnerUserEmail string `csv:"InternalOwnerUserEmail"`
}

// CSVInputWrapper marks IdentityHolderCSVInput for CSV header preprocessing.
func (IdentityHolderCSVInput) CSVInputWrapper() {}

// InternalPolicyCSVInput wraps CreateInternalPolicyInput with CSV reference columns.
type InternalPolicyCSVInput struct {
	Input generated.CreateInternalPolicyInput
	ApproverGroupName string `csv:"ApproverGroupName"`
	DocumentDelegateGroupName string `csv:"DocumentDelegateGroupName"`
}

// CSVInputWrapper marks InternalPolicyCSVInput for CSV header preprocessing.
func (InternalPolicyCSVInput) CSVInputWrapper() {}

// PlatformCSVInput wraps CreatePlatformInput with CSV reference columns.
type PlatformCSVInput struct {
	Input generated.CreatePlatformInput
	BusinessOwnerGroupName string `csv:"BusinessOwnerGroupName"`
	BusinessOwnerUserEmail string `csv:"BusinessOwnerUserEmail"`
	InternalOwnerGroupName string `csv:"InternalOwnerGroupName"`
	InternalOwnerUserEmail string `csv:"InternalOwnerUserEmail"`
	PlatformOwnerEmail string `csv:"PlatformOwnerEmail"`
	SecurityOwnerGroupName string `csv:"SecurityOwnerGroupName"`
	SecurityOwnerUserEmail string `csv:"SecurityOwnerUserEmail"`
	TechnicalOwnerGroupName string `csv:"TechnicalOwnerGroupName"`
	TechnicalOwnerUserEmail string `csv:"TechnicalOwnerUserEmail"`
}

// CSVInputWrapper marks PlatformCSVInput for CSV header preprocessing.
func (PlatformCSVInput) CSVInputWrapper() {}

// ProcedureCSVInput wraps CreateProcedureInput with CSV reference columns.
type ProcedureCSVInput struct {
	Input generated.CreateProcedureInput
	ApproverGroupName string `csv:"ApproverGroupName"`
	DocumentDelegateGroupName string `csv:"DocumentDelegateGroupName"`
}

// CSVInputWrapper marks ProcedureCSVInput for CSV header preprocessing.
func (ProcedureCSVInput) CSVInputWrapper() {}

// ProgramCSVInput wraps CreateProgramInput with CSV reference columns.
type ProgramCSVInput struct {
	Input generated.CreateProgramInput
	ProgramOwnerEmail string `csv:"ProgramOwnerEmail"`
}

// CSVInputWrapper marks ProgramCSVInput for CSV header preprocessing.
func (ProgramCSVInput) CSVInputWrapper() {}

// RiskCSVInput wraps CreateRiskInput with CSV reference columns.
type RiskCSVInput struct {
	Input generated.CreateRiskInput
	RiskDelegateGroupName string `csv:"RiskDelegateGroupName"`
	StakeholderGroupName string `csv:"StakeholderGroupName"`
}

// CSVInputWrapper marks RiskCSVInput for CSV header preprocessing.
func (RiskCSVInput) CSVInputWrapper() {}

// ScanCSVInput wraps CreateScanInput with CSV reference columns.
type ScanCSVInput struct {
	Input generated.CreateScanInput
	AssignedToGroupName string `csv:"AssignedToGroupName"`
	AssignedToUserEmail string `csv:"AssignedToUserEmail"`
	GeneratedByPlatformName string `csv:"GeneratedByPlatformName"`
	PerformedByGroupName string `csv:"PerformedByGroupName"`
	PerformedByUserEmail string `csv:"PerformedByUserEmail"`
	ReviewedByGroupName string `csv:"ReviewedByGroupName"`
	ReviewedByUserEmail string `csv:"ReviewedByUserEmail"`
}

// CSVInputWrapper marks ScanCSVInput for CSV header preprocessing.
func (ScanCSVInput) CSVInputWrapper() {}

// SubcontrolCSVInput wraps CreateSubcontrolInput with CSV reference columns.
type SubcontrolCSVInput struct {
	Input generated.CreateSubcontrolInput
	ControlDelegateGroupName string `csv:"ControlDelegateGroupName"`
	ControlOwnerGroupName string `csv:"ControlOwnerGroupName"`
	ResponsiblePartyEntityName string `csv:"ResponsiblePartyEntityName"`
}

// CSVInputWrapper marks SubcontrolCSVInput for CSV header preprocessing.
func (SubcontrolCSVInput) CSVInputWrapper() {}

// TaskCSVInput wraps CreateTaskInput with CSV reference columns.
type TaskCSVInput struct {
	Input generated.CreateTaskInput
	AssigneeEmail string `csv:"AssigneeEmail"`
	AssignerEmail string `csv:"AssignerEmail"`
}

// CSVInputWrapper marks TaskCSVInput for CSV header preprocessing.
func (TaskCSVInput) CSVInputWrapper() {}
