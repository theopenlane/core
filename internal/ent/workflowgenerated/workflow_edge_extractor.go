// Code generated by ent. DO NOT EDIT.
// This should be above the package name declaration for go tooling to treat this as generated.
// This file is generated to detect edge mutations for workflow triggers.
package workflowgenerated

import (
	"entgo.io/ent"
	"github.com/theopenlane/core/internal/ent/generated"
)

var workflowEligibleEdges = map[string][]string{
	generated.TypeActionPlan: edgeList(
		"approver",
		"delegate",
		"workflow_object_refs",
	),
	generated.TypeControl: edgeList(
		"evidence",
		"control_objectives",
		"tasks",
		"narratives",
		"risks",
		"action_plans",
		"procedures",
		"internal_policies",
		"comments",
		"discussions",
		"control_owner",
		"delegate",
		"responsible_party",
		"workflow_object_refs",
	),
	generated.TypeEvidence: edgeList(
		"workflow_object_refs",
	),
	generated.TypeInternalPolicy: edgeList(
		"approver",
		"delegate",
		"file",
		"comments",
		"discussions",
		"workflow_object_refs",
	),
	generated.TypeProcedure: edgeList(
		"approver",
		"delegate",
		"controls",
		"subcontrols",
		"internal_policies",
		"programs",
		"narratives",
		"risks",
		"tasks",
		"comments",
		"discussions",
		"file",
		"workflow_object_refs",
	),
	generated.TypeSubcontrol: edgeList(
		"evidence",
		"control_objectives",
		"tasks",
		"narratives",
		"risks",
		"action_plans",
		"procedures",
		"internal_policies",
		"comments",
		"discussions",
		"control_owner",
		"delegate",
		"responsible_party",
		"control",
		"control_implementations",
		"mapped_to_subcontrols",
		"mapped_from_subcontrols",
		"workflow_object_refs",
	),
}

// extractChangedEdges inspects the mutation to determine which edge relationships were modified.
// It returns: edge names, added IDs per edge, removed IDs per edge.
func extractChangedEdges(m ent.Mutation) ([]string, map[string][]string, map[string][]string) {
	var edgeNames []string
	addedIDs := make(map[string][]string)
	removedIDs := make(map[string][]string)

	eligibleEdges := workflowEligibleEdges[m.Type()]
	if len(eligibleEdges) == 0 {
		return edgeNames, addedIDs, removedIDs
	}

	changedEdges := make(map[string]struct{})
	for _, edge := range m.AddedEdges() {
		changedEdges[edge] = struct{}{}
	}
	for _, edge := range m.RemovedEdges() {
		changedEdges[edge] = struct{}{}
	}
	for _, edge := range m.ClearedEdges() {
		changedEdges[edge] = struct{}{}
	}

	for _, edge := range eligibleEdges {
		if _, ok := changedEdges[edge]; !ok {
			continue
		}

		edgeNames = append(edgeNames, edge)

		if ids := toStringIDs(m.AddedIDs(edge)); len(ids) > 0 {
			addedIDs[edge] = ids
		}
		if ids := toStringIDs(m.RemovedIDs(edge)); len(ids) > 0 {
			removedIDs[edge] = ids
		}
		if m.EdgeCleared(edge) {
			removedIDs[edge] = []string{}
		}
	}

	return edgeNames, addedIDs, removedIDs
}

func edgeList(edges ...string) []string {
	return edges
}

func toStringIDs(values []ent.Value) []string {
	if len(values) == 0 {
		return nil
	}
	ids := make([]string, 0, len(values))
	for _, value := range values {
		id, ok := value.(string)
		if !ok {
			continue
		}
		ids = append(ids, id)
	}
	return ids
}
