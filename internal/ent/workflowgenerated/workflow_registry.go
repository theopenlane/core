// Code generated by ent. DO NOT EDIT.
// This file is generated to keep workflow registries in sync with ent schemas.
package workflowgenerated

import (
	"context"
	"encoding/json"

	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/workflowobjectref"
	wf "github.com/theopenlane/core/internal/workflows"
)

func init() {
	// Register WorkflowObjectRef resolvers for workflow-addressable schemas.
	wf.RegisterObjectRefResolver(func(ref *generated.WorkflowObjectRef) (*wf.Object, bool) {
		if ref.ControlID != "" {
			return &wf.Object{ID: ref.ControlID, Type: enums.WorkflowObjectTypeControl}, true
		}
		if ref.InternalPolicyID != "" {
			return &wf.Object{ID: ref.InternalPolicyID, Type: enums.WorkflowObjectTypeInternalPolicy}, true
		}
		if ref.EvidenceID != "" {
			return &wf.Object{ID: ref.EvidenceID, Type: enums.WorkflowObjectTypeEvidence}, true
		}
		if ref.SubcontrolID != "" {
			return &wf.Object{ID: ref.SubcontrolID, Type: enums.WorkflowObjectTypeSubcontrol}, true
		}
		if ref.ActionPlanID != "" {
			return &wf.Object{ID: ref.ActionPlanID, Type: enums.WorkflowObjectTypeActionPlan}, true
		}
		if ref.ProcedureID != "" {
			return &wf.Object{ID: ref.ProcedureID, Type: enums.WorkflowObjectTypeProcedure}, true
		}
		if ref.CampaignID != "" {
			return &wf.Object{ID: ref.CampaignID, Type: enums.WorkflowObjectTypeCampaign}, true
		}
		if ref.CampaignTargetID != "" {
			return &wf.Object{ID: ref.CampaignTargetID, Type: enums.WorkflowObjectTypeCampaignTarget}, true
		}
		if ref.IdentityHolderID != "" {
			return &wf.Object{ID: ref.IdentityHolderID, Type: enums.WorkflowObjectTypeIdentityHolder}, true
		}
		if ref.PlatformID != "" {
			return &wf.Object{ID: ref.PlatformID, Type: enums.WorkflowObjectTypePlatform}, true
		}
		return nil, false
	})

	// Register WorkflowObjectRef query builders so object-based lookups avoid table scans.
	wf.RegisterObjectRefQueryBuilder(func(query *generated.WorkflowObjectRefQuery, obj *wf.Object) (*generated.WorkflowObjectRefQuery, bool) {
		if obj == nil {
			return nil, false
		}

		switch obj.Type {
		case enums.WorkflowObjectTypeActionPlan:
			return query.Where(workflowobjectref.ActionPlanIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeCampaign:
			return query.Where(workflowobjectref.CampaignIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeCampaignTarget:
			return query.Where(workflowobjectref.CampaignTargetIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeControl:
			return query.Where(workflowobjectref.ControlIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeEvidence:
			return query.Where(workflowobjectref.EvidenceIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeIdentityHolder:
			return query.Where(workflowobjectref.IdentityHolderIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeInternalPolicy:
			return query.Where(workflowobjectref.InternalPolicyIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypePlatform:
			return query.Where(workflowobjectref.PlatformIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeProcedure:
			return query.Where(workflowobjectref.ProcedureIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeSubcontrol:
			return query.Where(workflowobjectref.SubcontrolIDEQ(obj.ID)), true
		default:
			return nil, false
		}
	})

	// Register CEL context builders so CEL expressions can work with typed objects.
	// Objects are converted to map[string]any via JSON to ensure:
	// - Field names match JSON tags (lowercase)
	// - Enum types are converted to strings
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.ActionPlan)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Campaign)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.CampaignTarget)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Control)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Evidence)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.IdentityHolder)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.InternalPolicy)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Platform)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Procedure)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Subcontrol)
		if !ok {
			return nil
		}
		objectMap, err := entObjectToMap(entObj)
		if err != nil {
			return nil
		}
		return map[string]any{
			"object":         objectMap,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})

	// Register assignment context builder for workflow runtime state in CEL expressions.
	wf.RegisterAssignmentContextBuilder(buildAssignmentContext)
}

// entObjectToMap converts an ent entity to a map[string]any via JSON marshaling.
// This ensures field names match JSON tags (lowercase) and enums are converted to strings.
func entObjectToMap(obj any) (map[string]any, error) {
	data, err := json.Marshal(obj)
	if err != nil {
		return nil, err
	}
	var result map[string]any
	if err := json.Unmarshal(data, &result); err != nil {
		return nil, err
	}
	return result, nil
}

// buildAssignmentContext builds the workflow runtime context (assignments, instance, initiator) for CEL evaluation.
// This is called when evaluating NOTIFY action When expressions that depend on assignment state.
func buildAssignmentContext(ctx context.Context, client *generated.Client, instanceID string) (map[string]any, error) {
	if client == nil || instanceID == "" {
		return nil, nil
	}

	// Build assignment summary
	summary, err := client.BuildAssignmentSummary(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	// Convert summary to map for CEL dynamic access
	// CEL cannot traverse Go structs directly - it needs map[string]any
	summaryMap, err := entObjectToMap(summary)
	if err != nil {
		return nil, err
	}

	// Get instance for context
	instance, err := client.WorkflowInstance.Get(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	// Build instance context map
	instanceContext := map[string]any{
		"id":                   instance.ID,
		"state":                instance.State.String(),
		"current_action_index": instance.CurrentActionIndex,
	}

	// Extract initiator from instance context
	initiator := ""
	if instance.Context.TriggerUserID != "" {
		initiator = instance.Context.TriggerUserID
	}

	return map[string]any{
		"assignments": summaryMap,
		"instance":    instanceContext,
		"initiator":   initiator,
	}, nil
}
