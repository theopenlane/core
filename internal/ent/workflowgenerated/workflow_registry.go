// Code generated by ent. DO NOT EDIT.
// This file is generated to keep workflow registries in sync with ent schemas.
package workflowgenerated

import (
	"context"

	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/workflowobjectref"
	wf "github.com/theopenlane/core/internal/workflows"
)

func init() {
	// Register WorkflowObjectRef resolvers for workflow-addressable schemas.
	wf.RegisterObjectRefResolver(func(ref *generated.WorkflowObjectRef) (*wf.Object, bool) {
		if ref.ControlID != "" {
			return &wf.Object{ID: ref.ControlID, Type: enums.WorkflowObjectTypeControl}, true
		}
		if ref.InternalPolicyID != "" {
			return &wf.Object{ID: ref.InternalPolicyID, Type: enums.WorkflowObjectTypeInternalPolicy}, true
		}
		if ref.EvidenceID != "" {
			return &wf.Object{ID: ref.EvidenceID, Type: enums.WorkflowObjectTypeEvidence}, true
		}
		if ref.SubcontrolID != "" {
			return &wf.Object{ID: ref.SubcontrolID, Type: enums.WorkflowObjectTypeSubcontrol}, true
		}
		if ref.ActionPlanID != "" {
			return &wf.Object{ID: ref.ActionPlanID, Type: enums.WorkflowObjectTypeActionPlan}, true
		}
		if ref.ProcedureID != "" {
			return &wf.Object{ID: ref.ProcedureID, Type: enums.WorkflowObjectTypeProcedure}, true
		}
		return nil, false
	})

	// Register WorkflowObjectRef query builders so object-based lookups avoid table scans.
	wf.RegisterObjectRefQueryBuilder(func(query *generated.WorkflowObjectRefQuery, obj *wf.Object) (*generated.WorkflowObjectRefQuery, bool) {
		if obj == nil {
			return nil, false
		}

		switch obj.Type {
		case enums.WorkflowObjectTypeActionPlan:
			return query.Where(workflowobjectref.ActionPlanIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeControl:
			return query.Where(workflowobjectref.ControlIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeEvidence:
			return query.Where(workflowobjectref.EvidenceIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeInternalPolicy:
			return query.Where(workflowobjectref.InternalPolicyIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeProcedure:
			return query.Where(workflowobjectref.ProcedureIDEQ(obj.ID)), true
		case enums.WorkflowObjectTypeSubcontrol:
			return query.Where(workflowobjectref.SubcontrolIDEQ(obj.ID)), true
		default:
			return nil, false
		}
	})

	// Register CEL context builders so CEL expressions can work with typed objects.
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.ActionPlan)
		if !ok {
			return nil
		}
		return map[string]any{
			"object":         entObj,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Control)
		if !ok {
			return nil
		}
		return map[string]any{
			"object":         entObj,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Evidence)
		if !ok {
			return nil
		}
		return map[string]any{
			"object":         entObj,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.InternalPolicy)
		if !ok {
			return nil
		}
		return map[string]any{
			"object":         entObj,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Procedure)
		if !ok {
			return nil
		}
		return map[string]any{
			"object":         entObj,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.Subcontrol)
		if !ok {
			return nil
		}
		return map[string]any{
			"object":         entObj,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})

	// Register assignment context builder for workflow runtime state in CEL expressions.
	wf.RegisterAssignmentContextBuilder(buildAssignmentContext)
}

// buildAssignmentContext builds the workflow runtime context (assignments, instance, initiator) for CEL evaluation.
// This is called when evaluating NOTIFY action When expressions that depend on assignment state.
func buildAssignmentContext(ctx context.Context, client *generated.Client, instanceID string) (map[string]any, error) {
	if client == nil || instanceID == "" {
		return nil, nil
	}

	// Build assignment summary
	summary, err := client.BuildAssignmentSummary(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	// Get instance for context
	instance, err := client.WorkflowInstance.Get(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	// Build instance context map
	instanceContext := map[string]any{
		"id":                   instance.ID,
		"state":                instance.State.String(),
		"current_action_index": instance.CurrentActionIndex,
	}

	// Extract initiator from instance context
	initiator := ""
	if instance.Context.TriggerUserID != "" {
		initiator = instance.Context.TriggerUserID
	}

	return map[string]any{
		"assignments": summary,
		"instance":    instanceContext,
		"initiator":   initiator,
	}, nil
}
