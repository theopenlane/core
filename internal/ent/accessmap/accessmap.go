package accessmap

import (
	"bytes"
	"fmt"
	"html/template"
	"os"
	"strings"

	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
	"github.com/gertd/go-pluralize"
	"github.com/rs/zerolog/log"
	"github.com/stoewer/go-strcase"
	"golang.org/x/tools/imports"
)

// ExtensionOption is a function that modifies the Extension configuration.
type ExtensionOption = func(*Extension)

// Config is the configuration for the accessmap extension.
type Config struct {
	SchemaPath string
	OutputDir  string
}

// New creates a new accessmap extension
func New(opts ...ExtensionOption) *Extension {
	extension := &Extension{
		// Set configuration defaults that can get overridden with ExtensionOption
		config: &Config{
			SchemaPath: "./schema",
			OutputDir:  "./internal/ent/generated",
		},
	}

	for _, opt := range opts {
		opt(extension)
	}

	return extension
}

// Extension implements entc.Extension
type Extension struct {
	entc.DefaultExtension
	config *Config
}

// EdgeAuthCheckName is a name for the edge auth check
var EdgeAuthCheckName = "EdgeAuthCheck"

// Name returns the name of the SchemaGenAnnotation
func (a Annotations) Name() string {
	return EdgeAuthCheckName
}

// Annotations defines the configuration settings for the edge access map annotation
type Annotations struct {
	// ObjectType is the type of the object that the edge is associated with and referenced in authz checks
	ObjectType string `yaml:"ObjectType,omitempty"`
	// SkipEditCheck indicates whether the edge requires an edit access check at all
	// If SkipEditCheck is true and CheckViewAccess is false, the edge will not be checked for access at all
	SkipEditCheck bool `yaml:"SkipEditCheck,omitempty"`
	// CheckViewAccess indicates whether the edge requires a view access check instead of an edit access check
	// this is useful for edges that you can allow users to set with only view access to the edge, for example
	// system owned edges that are not editable by the user
	// If CheckViewAccess is true, but SkipEditCheck is false, the edge will still be checked for edit access and
	// this setting is ignored
	CheckViewAccess bool `yaml:"CheckViewAccess,omitempty"`
}

// EdgeAuthCheck creates an annotation for edge access checks with the specified object type
// and requires the edit check
// this should be used for edges that have a mismatch between the edge name and the object type
// that holds the edge access check
func EdgeAuthCheck(objectType string) Annotations {
	return Annotations{
		ObjectType:    objectType,
		SkipEditCheck: false,
	}
}

// EdgeViewCheck creates an annotation for edge access checks with the specified object type
// and requires only view access to the object
// this should be used to for edges that only require view access to the object
// such as system owned edges
func EdgeViewCheck(objectType string) Annotations {
	return Annotations{
		ObjectType:      objectType,
		SkipEditCheck:   true,
		CheckViewAccess: true,
	}
}

// EdgeNoAuthCheck creates an annotation for edges that do not require an auth check
// this should be used for edges that do not require the user having edit access to the edge object
// or it is handled by other means, such as the parent schema
func EdgeNoAuthCheck() Annotations {
	return Annotations{
		SkipEditCheck: true,
	}
}

// WithSchemaPath allows you to set an alternative schemaPath
// Defaults to "./schema"
func WithSchemaPath(schemaPath string) ExtensionOption {
	return func(h *Extension) {
		h.config.SchemaPath = schemaPath
	}
}

// WithOutputDir allows you to set an alternative output directory
// Defaults to "./internal/ent/generated"
func WithOutputDir(outputDir string) ExtensionOption {
	return func(h *Extension) {
		h.config.OutputDir = outputDir
	}
}

// Hooks satisfies the entc.Extension interface
func (e Extension) Hooks() []gen.Hook {
	return []gen.Hook{
		e.Hook(),
	}
}

// Hook is the function that generates the access map code
// this is called after all schemas have been generated
// to ensure the generated edges are available
func (e Extension) Hook() gen.Hook {
	return func(next gen.Generator) gen.Generator {
		return gen.GenerateFunc(func(g *gen.Graph) error {
			if err := next.Generate(g); err != nil {
				return err
			}

			name := "accessmap"
			t, err := template.New(name).Funcs(template.FuncMap{
				"contains": strings.Contains,
				"toLower":  strings.ToLower,
				"toSnake":  strcase.SnakeCase,
				"singular": pluralize.NewClient().Singular,
			}).
				Parse(`// Code generated by ent (accessmap). DO NOT EDIT.

package generated

type EdgeAccess struct {
	ObjectType    string
	SkipEditCheck bool
	CheckViewAccess bool
}

// EdgeAccessMap maps <SchemaName> -> <edgeName> -> metadata.
// If an edge defines the accessmap.EdgeAccess annotation, its values are used.
// Otherwise, defaults are used: ObjectType = edge name, RequiresCheck = false.
var EdgeAccessMap = map[string]map[string]EdgeAccess{
{{- range $n := $.Nodes }}
	{{- if not (contains $n.Name "History") -}}
	"{{ toSnake $n.Name}}": {
	{{- range $e := $n.Edges }}
		{{- $ann := $e.Annotations.EdgeAuthCheck -}}
		"{{ toSnake $e.Name }}": {
			ObjectType: "{{- if and $ann (ne $ann.ObjectType "") -}}{{ $ann.ObjectType }}{{- else -}}{{ singular $e.Name }}{{- end -}}",
			SkipEditCheck: {{- if $ann -}}{{ $ann.SkipEditCheck }}{{- else -}}false{{- end -}},
			CheckViewAccess: {{- if $ann -}}{{ $ann.CheckViewAccess }}{{- else -}}false{{- end -}},
		},
	{{- end }}
	},
	{{- end -}}
{{- end }}
}
`)
			if err != nil {
				log.Error().Err(err).Msg("failed to parse accessmap template")

				return err
			}

			// execute the template into a buffer
			var buf bytes.Buffer
			if err := t.ExecuteTemplate(&buf, name, g); err != nil {
				return err
			}

			// create the output file
			outputPath := fmt.Sprintf("%s/%s.go", e.config.OutputDir, name)

			file, err := os.Create(outputPath)
			if err != nil {
				log.Fatal().Err(err).Msgf("failed to create file %s", outputPath)
			}

			defer file.Close()

			// run gofmt and goimports on the file contents
			formatted, err := imports.Process(outputPath, buf.Bytes(), nil)
			if err != nil {
				return fmt.Errorf("%w: failed to format file", err)
			}

			if _, err := file.Write(formatted); err != nil {
				log.Fatal().Err(err).Msgf("failed to write to file %s", outputPath)
			}

			return nil
		})
	}
}

// Annotations satisfies the entc.Extension interface
func (Extension) Annotations() []entc.Annotation {
	return []entc.Annotation{}
}

// Options satisfies the entc.Extension interface
func (Extension) Options() []entc.Option { return nil }

// Templates satisfies the entc.Extension interface
func (Extension) Templates() []*gen.Template {
	return []*gen.Template{}
}
