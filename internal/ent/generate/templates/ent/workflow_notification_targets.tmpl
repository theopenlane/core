{{/* Generate notification target resolvers for workflow-eligible schemas */}}
{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "workflow_notification_targets" }}

{{ $pkg := base $.Config.Package }}
{{ template "header" $ }}

import (
	"github.com/samber/lo"
	"github.com/theopenlane/core/common/enums"
)

// Code generated by ent. DO NOT EDIT.
// This file provides notification target resolvers for workflow-eligible schemas.

{{- $workflowTypes := dict }}
{{- range $n := $.Nodes }}
	{{- $hasWorkflowFields := false }}
	{{- $isHistory := false }}
	{{- if hasSuffix $n.Name "History" }}{{ $isHistory = true }}{{ end }}
	{{- range $f := $n.Fields }}
		{{- if $f.Annotations.OPENLANE_WORKFLOW_ELIGIBLE }}{{ $hasWorkflowFields = true }}{{ end }}
	{{- end }}
	{{- if and $hasWorkflowFields (not $isHistory) }}
		{{- $_ := set $workflowTypes $n.Name true }}
	{{- end }}
{{- end }}

// NotificationTargetType represents the type of notification target
type NotificationTargetType string

const (
	NotificationTargetOwner           NotificationTargetType = "OWNER"
	NotificationTargetApprover        NotificationTargetType = "APPROVER"
	NotificationTargetDelegate        NotificationTargetType = "DELEGATE"
	NotificationTargetEditors         NotificationTargetType = "EDITORS"
	NotificationTargetControlOwner    NotificationTargetType = "CONTROL_OWNER"
	NotificationTargetResponsibleParty NotificationTargetType = "RESPONSIBLE_PARTY"
	NotificationTargetInitiator       NotificationTargetType = "INITIATOR"
)

// ResolveNotificationTargets returns user IDs for a given target type and workflow object
func (c *Client) ResolveNotificationTargets(ctx context.Context, objectType enums.WorkflowObjectType, objectID string, targetType NotificationTargetType) ([]string, error) {
	switch objectType {
{{- range $n := $.Nodes }}
	{{- if hasKey $workflowTypes $n.Name }}
	case enums.WorkflowObjectType{{ $n.Name }}:
		return c.resolve{{ $n.Name }}NotificationTargets(ctx, objectID, targetType)
	{{- end }}
{{- end }}
	default:
		return nil, nil
	}
}

// resolveGroupMemberIDs resolves a group ID to its member user IDs
func (c *Client) resolveGroupMemberIDs(ctx context.Context, groupID string) ([]string, error) {
	if groupID == "" {
		return nil, nil
	}

	group, err := c.Group.Get(ctx, groupID)
	if err != nil {
		return nil, err
	}

	members, err := group.QueryMembers().All(ctx)
	if err != nil {
		return nil, err
	}

	userIDs := make([]string, 0, len(members))
	for _, member := range members {
		if member.UserID != "" {
			userIDs = append(userIDs, member.UserID)
		}
	}

	return userIDs, nil
}

// resolveGroupsMemberIDs resolves multiple group IDs to their member user IDs
func (c *Client) resolveGroupsMemberIDs(ctx context.Context, groupIDs []string) ([]string, error) {
	if len(groupIDs) == 0 {
		return nil, nil
	}

	var allUserIDs []string
	for _, groupID := range groupIDs {
		userIDs, err := c.resolveGroupMemberIDs(ctx, groupID)
		if err != nil {
			continue
		}
		allUserIDs = append(allUserIDs, userIDs...)
	}

	return lo.Uniq(allUserIDs), nil
}

{{- range $n := $.Nodes }}
{{- if hasKey $workflowTypes $n.Name }}

{{/* Build map of nillable FK fields for this node */}}
{{- $nillableFKs := dict }}
{{- range $f := $n.Fields }}
	{{- if and (hasSuffix $f.Name "_id") $f.Nillable }}
		{{- $_ := set $nillableFKs $f.Name true }}
	{{- end }}
{{- end }}

// resolve{{ $n.Name }}NotificationTargets resolves notification targets for {{ $n.Name }}
func (c *Client) resolve{{ $n.Name }}NotificationTargets(ctx context.Context, objectID string, targetType NotificationTargetType) ([]string, error) {
	obj, err := c.{{ $n.Name }}.Get(ctx, objectID)
	if err != nil {
		return nil, err
	}

	switch targetType {
	case NotificationTargetOwner:
		if obj.OwnerID != "" {
			return []string{obj.OwnerID}, nil
		}
		return nil, nil
	case NotificationTargetInitiator:
		// Initiator is resolved from workflow instance context, not from the object
		return nil, nil
	{{- range $e := $n.Edges }}
		{{- if and $e.Unique (eq $e.Type.Name "User") }}
			{{- $targetName := upper (snake $e.Name) }}
			{{- $fkFieldName := printf "%s_id" (snake $e.Name) }}
			{{- $isNillable := hasKey $nillableFKs $fkFieldName }}
	case NotificationTargetType("{{ $targetName }}"):
		{{- if $isNillable }}
		if obj.{{ $e.StructField }}ID != nil && *obj.{{ $e.StructField }}ID != "" {
			return []string{*obj.{{ $e.StructField }}ID}, nil
		}
		return nil, nil
		{{- else if $e.Optional }}
		if obj.{{ $e.StructField }}ID != "" {
			return []string{obj.{{ $e.StructField }}ID}, nil
		}
		return nil, nil
		{{- else }}
		return []string{obj.{{ $e.StructField }}ID}, nil
		{{- end }}
		{{- end }}
		{{- if and $e.Unique (eq $e.Type.Name "Group") }}
			{{- $targetName := upper (snake $e.Name) }}
			{{- $fkFieldName := printf "%s_id" (snake $e.Name) }}
			{{- $isNillable := hasKey $nillableFKs $fkFieldName }}
	case NotificationTargetType("{{ $targetName }}"):
		{{- if $isNillable }}
		if obj.{{ $e.StructField }}ID != nil && *obj.{{ $e.StructField }}ID != "" {
			return c.resolveGroupMemberIDs(ctx, *obj.{{ $e.StructField }}ID)
		}
		return nil, nil
		{{- else if $e.Optional }}
		if obj.{{ $e.StructField }}ID != "" {
			return c.resolveGroupMemberIDs(ctx, obj.{{ $e.StructField }}ID)
		}
		return nil, nil
		{{- else }}
		return c.resolveGroupMemberIDs(ctx, obj.{{ $e.StructField }}ID)
		{{- end }}
		{{- end }}
		{{- if and (not $e.Unique) (eq $e.Type.Name "Group") }}
			{{- $targetName := upper (snake $e.Name) }}
	case NotificationTargetType("{{ $targetName }}"):
		groups, err := obj.Query{{ $e.StructField }}().IDs(ctx)
		if err != nil {
			return nil, err
		}
		return c.resolveGroupsMemberIDs(ctx, groups)
		{{- end }}
	{{- end }}
	default:
		return nil, nil
	}
}
{{- end }}
{{- end }}

{{ end }}
