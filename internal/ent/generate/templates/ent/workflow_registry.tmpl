{{/* Generate workflow object + CEL registry hooks for workflows */}}
{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "workflow_registry" }}

{{ $pkg := base $.Config.Package }}
package hooks

import (
	"context"

	wf "github.com/theopenlane/core/internal/workflows"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/workflowobjectref"
	"github.com/theopenlane/core/common/enums"
)

// Code generated by ent. DO NOT EDIT.
// This file is generated to keep workflow registries in sync with ent schemas.

{{- $workflowTypes := dict }}
{{- range $n := $.Nodes }}
	{{- $hasWorkflowFields := false }}
	{{- $isHistory := false }}
	{{- if hasSuffix $n.Name "History" }}{{ $isHistory = true }}{{ end }}
	{{- range $f := $n.Fields }}
		{{- if $f.Annotations.OPENLANE_WORKFLOW_ELIGIBLE }}{{ $hasWorkflowFields = true }}{{ end }}
	{{- end }}
	{{- if and $hasWorkflowFields (not $isHistory) }}
		{{- $_ := set $workflowTypes $n.Name true }}
	{{- end }}
{{- end }}

func init() {
	// Register WorkflowObjectRef resolvers for workflow-addressable schemas.
	// Only entities with WorkflowApprovalMixin are registered: {{ join (keys $workflowTypes) ", " }}
	{{- range $n := $.Nodes }}
	{{- if eq $n.Name "WorkflowObjectRef" }}
	wf.RegisterObjectRefResolver(func(ref *generated.WorkflowObjectRef) (*wf.Object, bool) {
		{{- range $e := $n.Edges }}
			{{- if $e.Unique }}
				{{- $targetType := $e.Type.Name }}
				{{- if hasKey $workflowTypes $targetType }}
		if ref.{{ $e.StructField }}ID != "" {
			return &wf.Object{ID: ref.{{ $e.StructField }}ID, Type: enums.WorkflowObjectType{{ $targetType }}}, true
		}
				{{- end }}
			{{- end }}
		{{- end }}
		return nil, false
	})
	{{- end }}
	{{- end }}

	// Register WorkflowObjectRef query builders so object-based lookups avoid table scans.
	wf.RegisterObjectRefQueryBuilder(func(query *generated.WorkflowObjectRefQuery, obj *wf.Object) (*generated.WorkflowObjectRefQuery, bool) {
		if obj == nil {
			return nil, false
		}

		switch obj.Type {
		{{- range $n := $.Nodes }}
			{{- if hasKey $workflowTypes $n.Name }}
		case enums.WorkflowObjectType{{ $n.Name }}:
			return query.Where(workflowobjectref.{{ $n.Name }}IDEQ(obj.ID)), true
			{{- end }}
		{{- end }}
		default:
			return nil, false
		}
	})

	// Register CEL context builders so CEL expressions can work with typed objects.
	{{- range $n := $.Nodes }}
		{{- $hasWorkflowFields := false }}
		{{- range $f := $n.Fields }}
			{{- if $f.Annotations.OPENLANE_WORKFLOW_ELIGIBLE }}{{ $hasWorkflowFields = true }}{{ end }}
		{{- end }}
		{{- if $hasWorkflowFields }}
	wf.RegisterCELContextBuilder(func(obj *wf.Object, changedFields []string, changedEdges []string, addedIDs, removedIDs map[string][]string, eventType, userID string) map[string]any {
		if obj == nil || obj.Node == nil {
			return nil
		}
		entObj, ok := obj.Node.(*generated.{{ $n.Name }})
		if !ok {
			return nil
		}
		return map[string]any{
			"object":         entObj,
			"changed_fields": changedFields,
			"changed_edges":  changedEdges,
			"added_ids":      addedIDs,
			"removed_ids":    removedIDs,
			"event_type":     eventType,
			"user_id":        userID,
		}
	})
		{{- end }}
	{{- end }}

	// Register assignment context builder for workflow runtime state in CEL expressions.
	wf.RegisterAssignmentContextBuilder(buildAssignmentContext)
}

// buildAssignmentContext builds the workflow runtime context (assignments, instance, initiator) for CEL evaluation.
// This is called when evaluating NOTIFY action When expressions that depend on assignment state.
func buildAssignmentContext(ctx context.Context, client *generated.Client, instanceID string) (map[string]any, error) {
	if client == nil || instanceID == "" {
		return nil, nil
	}

	// Build assignment summary
	summary, err := client.BuildAssignmentSummary(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	// Get instance for context
	instance, err := client.WorkflowInstance.Get(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	// Build instance context map
	instanceContext := map[string]any{
		"id":                   instance.ID,
		"state":                instance.State.String(),
		"current_action_index": instance.CurrentActionIndex,
	}

	// Extract initiator from instance context
	initiator := ""
	if instance.Context.TriggerUserID != "" {
		initiator = instance.Context.TriggerUserID
	}

	return map[string]any{
		"assignments": summary,
		"instance":    instanceContext,
		"initiator":   initiator,
	}, nil
}

{{ end }}
