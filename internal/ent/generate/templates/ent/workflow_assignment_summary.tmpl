{{/* Generate workflow assignment summary types and builder for CEL evaluation */}}
{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "workflow_assignment_summary" }}

{{ $pkg := base $.Config.Package }}
{{ template "header" $ }}

import (
	"strings"

	"github.com/theopenlane/core/internal/ent/generated/workflowassignment"
	"github.com/theopenlane/core/common/enums"
)

// Code generated by ent. DO NOT EDIT.
// This file provides assignment summary types and builder for workflow CEL evaluation.

// WorkflowCELAssignments provides assignment state for CEL evaluation
type WorkflowCELAssignments struct {
	Total    int                                `json:"total"`
	Pending  int                                `json:"pending"`
	Approved int                                `json:"approved"`
	Rejected int                                `json:"rejected"`
	ByAction map[string]WorkflowActionSummary   `json:"by_action"`
}

// WorkflowActionSummary provides per-action assignment summary
type WorkflowActionSummary struct {
	Key         string   `json:"key"`
	Status      string   `json:"status"`
	Total       int      `json:"total"`
	Pending     int      `json:"pending"`
	Approved    int      `json:"approved"`
	Rejected    int      `json:"rejected"`
	ApproverIDs []string `json:"approver_ids"`
}

// BuildAssignmentSummary queries assignments for an instance and builds a CEL-compatible summary
func (c *Client) BuildAssignmentSummary(ctx context.Context, instanceID string) (*WorkflowCELAssignments, error) {
	assignments, err := c.WorkflowAssignment.Query().
		Where(workflowassignment.WorkflowInstanceIDEQ(instanceID)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	summary := &WorkflowCELAssignments{
		ByAction: make(map[string]WorkflowActionSummary),
	}

	for _, a := range assignments {
		summary.Total++
		actionKey := extractActionKeyFromAssignmentKey(a.AssignmentKey)

		actionSummary := summary.ByAction[actionKey]
		actionSummary.Key = actionKey
		actionSummary.Total++

		switch a.Status {
		case enums.WorkflowAssignmentStatusPending:
			summary.Pending++
			actionSummary.Pending++
		case enums.WorkflowAssignmentStatusApproved:
			summary.Approved++
			actionSummary.Approved++
			if a.ActorUserID != "" {
				actionSummary.ApproverIDs = append(actionSummary.ApproverIDs, a.ActorUserID)
			}
		case enums.WorkflowAssignmentStatusRejected:
			summary.Rejected++
			actionSummary.Rejected++
		}

		actionSummary.Status = deriveWorkflowActionStatus(actionSummary)
		summary.ByAction[actionKey] = actionSummary
	}

	return summary, nil
}

// deriveWorkflowActionStatus determines the overall status of an action based on assignment counts
func deriveWorkflowActionStatus(s WorkflowActionSummary) string {
	if s.Rejected > 0 {
		return "REJECTED"
	}

	if s.Pending == 0 && s.Approved > 0 {
		return "APPROVED"
	}

	return "PENDING"
}

// extractActionKeyFromAssignmentKey extracts the action key from an assignment key
// Assignment keys are formatted as "approval_{action_key}_{index}"
func extractActionKeyFromAssignmentKey(assignmentKey string) string {
	if !strings.HasPrefix(assignmentKey, "approval_") {
		return assignmentKey
	}

	withoutPrefix := strings.TrimPrefix(assignmentKey, "approval_")
	lastUnderscore := strings.LastIndex(withoutPrefix, "_")
	if lastUnderscore == -1 {
		return withoutPrefix
	}

	return withoutPrefix[:lastUnderscore]
}

{{ end }}
