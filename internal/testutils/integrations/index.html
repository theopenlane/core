<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Integration Test Console</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@json-editor/json-editor@2.12.3/dist/css/bootstrap5.min.css"
    />
    <style>
      .providers-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 1.5rem;
        width: 100%;
      }
      body {
        background: #f4f5f7;
      }
      .integration-card {
        border: 1px solid #dee2e6;
        border-radius: 10px;
        background: #fff;
        padding: 24px;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        height: 100%;
      }
      .provider-header {
        display: flex;
        gap: 1rem;
        align-items: center;
      }
      .provider-info {
        flex: 1;
        min-width: 0;
      }
      .provider-meta {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        align-items: flex-end;
        justify-content: center;
      }
      .provider-logo {
        width: 52px;
        height: 52px;
        border-radius: 12px;
        background: #f1f5f9;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 6px;
        flex-shrink: 0;
      }
      .provider-logo img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
      }
      .provider-info h3 {
        margin-bottom: 0.15rem;
      }
      .provider-actions {
        margin-top: auto;
      }
      .provider-actions .btn {
        width: 100%;
      }
      .provider-body {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .provider-operations {
        border-top: 1px solid #e2e8f0;
        padding-top: 0.75rem;
        margin-top: 0.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .operation-heading {
        font-size: 0.9rem;
        font-weight: 600;
        color: #334155;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .operation-row {
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 0.75rem;
        background: #f8fafc;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .operation-title-line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }
      .operation-title {
        font-weight: 600;
      }
      .operation-kind {
        font-size: 0.75rem;
        background: #e2e8f0;
        border-radius: 12px;
        padding: 2px 8px;
        font-weight: 600;
        text-transform: uppercase;
        color: #475569;
      }
      .operation-controls {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .operation-controls textarea {
        font-size: 0.85rem;
      }
      .operation-hint {
        font-size: 0.8rem;
        color: #64748b;
      }
      .operation-force {
        font-size: 0.85rem;
        color: #475569;
      }
      .operation-run-btn {
        align-self: flex-start;
      }
      .status-badge {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 600;
      }
      .docs-link {
        white-space: nowrap;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 4px 10px;
      }
      .config-modal {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.4);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1050;
        padding: 1rem;
      }
      .config-modal.show {
        display: flex;
      }
      .config-modal__dialog {
        background: #fff;
        border-radius: 12px;
        max-width: 640px;
        width: 100%;
        display: flex;
        flex-direction: column;
        max-height: 90vh;
        box-shadow: 0 20px 40px rgba(15, 23, 42, 0.2);
      }
      .config-modal__header,
      .config-modal__footer {
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #e2e8f0;
      }
      .config-modal__footer {
        border-top: 1px solid #e2e8f0;
        border-bottom: none;
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
      }
      .config-modal__body {
        padding: 1.5rem;
        overflow-y: auto;
      }
      .config-form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .config-form__field {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
      .config-form .form-text {
        font-size: 0.85rem;
      }
      .config-form__empty {
        text-align: center;
        color: #64748b;
        font-style: italic;
      }
      .config-modal__close {
        border: none;
        background: none;
        font-size: 1.25rem;
      }
      .status-connected {
        background: #d1f1e0;
        color: #0f5132;
      }
      .status-configured {
        background: #cdeed8;
        color: #0f5132;
      }
      .status-expired {
        background: #fff3cd;
        color: #664d03;
      }
      .status-invalid {
        background: #f8d7da;
        color: #842029;
      }
      .status-disconnected {
        background: #e2e3e5;
        color: #495057;
      }
      .log-entry {
        padding: 8px 12px;
        margin: 4px 0;
        border-radius: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
        font-size: 0.85rem;
      }
      .log-success {
        background: #d1f1e0;
        color: #0f5132;
      }
      .log-error {
        background: #f8d7da;
        color: #842029;
      }
      .log-info {
        background: #d7e8ff;
        color: #0b3d91;
      }
    </style>
  </head>
  <body>
    <div class="container my-4">
      <div class="row">
        <div class="col-12">
          <h1 class="text-center mb-3">Integration Test Console</h1>
          <p class="text-center text-muted mb-4">
            Drive the declarative integration pipeline end-to-end against a running Openlane instance.
          </p>
          <div class="alert alert-info d-flex justify-content-between align-items-center" id="authStatus">
            <div>
              <strong>Authentication Status:</strong>
              <span id="authStatusText">Checking...</span>
            </div>
            <button class="btn btn-sm btn-outline-light d-none" id="loginButton">Login with Seeded User</button>
          </div>

          <div id="callbackNotice"></div>

          <section class="mt-4">
            <div class="d-flex justify-content-between align-items-center">
              <h2 class="mb-3">Configured Integrations</h2>
              <button class="btn btn-outline-secondary btn-sm" id="refreshIntegrations">Refresh List</button>
            </div>
            <div id="integrationsList" class="mb-4">
              <div class="text-center text-muted">No data loaded yet</div>
            </div>
          </section>

          <section class="mt-5">
            <div class="d-flex justify-content-between align-items-center">
              <h2 class="mb-3">Available Providers</h2>
              <button class="btn btn-outline-primary btn-sm" id="refreshProviders">Refresh Providers</button>
            </div>
            <div id="providersContainer" class="providers-grid">
              <div class="text-center text-muted" id="providersPlaceholder">Loading provider metadata...</div>
            </div>
          </section>

          <section class="mt-4">
            <div class="d-flex justify-content-between align-items-center">
              <h2 class="mb-3">Activity Log</h2>
              <button class="btn btn-outline-secondary btn-sm" id="clearLog">Clear Log</button>
            </div>
            <div
              id="activityLog"
              style="max-height: 320px; overflow-y: auto; background: #fff; border-radius: 8px; border: 1px solid #e2e8f0; padding: 12px;"
            ></div>
          </section>
        </div>
      </div>
    </div>

    <div class="config-modal" id="configModal" aria-hidden="true">
      <div class="config-modal__dialog">
        <div class="config-modal__header d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0" id="configModalTitle">Configure Provider</h5>
            <small class="text-muted" id="configModalSubtitle"></small>
          </div>
          <button class="config-modal__close" id="configModalClose" aria-label="Close">&times;</button>
        </div>
        <div class="config-modal__body">
          <div id="configEditorContainer"></div>
        </div>
        <div class="config-modal__footer">
          <button class="btn btn-outline-secondary" id="configModalCancel">Cancel</button>
          <button class="btn btn-primary" id="configModalSubmit">Submit Configuration</button>
        </div>
      </div>
    </div>

    <script>
      const apiBase = "http://localhost:17608";
      let authToken = null;
      let userInfo = null;
      const providerMetadata = new Map();
      let activeConfigProvider = null;
      let activeCredentialSchema = null;
      let configModalForm = null;
      const integrationSecretsQuery = `
        query ($kind: String!) {
          integrations(where: { kind: $kind }) {
            edges {
              node {
                id
                secrets {
                  edges {
                    node {
                      id
                      secretName
                      description
                      kind
                      expiresAt
                      lastUsedAt
                      credentialSet
                      metadata
                    }
                  }
                }
              }
            }
          }
        }
      `;

      const providerDomId = (name) => name.toLowerCase().replace(/[^a-z0-9_-]/g, "_");
      const toTitleCase = (value = "") =>
        value
          .toString()
          .replace(/[_-]+/g, " ")
          .replace(/\s+/g, " ")
          .trim()
          .replace(/\b\w/g, (char) => char.toUpperCase());

      function inferInputType(prop = {}) {
        if (prop.type === "integer" || prop.type === "number") return "number";
        if (prop.format === "password" || prop.secret === true) return "password";
        if (prop.format === "email") return "email";
        if (prop.format === "uri" || prop.format === "url") return "url";
        return "text";
      }

      function buildCredentialField(key, prop = {}, isRequired = false) {
        const fieldId = `config-${key}`.replace(/[^a-z0-9_-]/gi, "-");
        const labelText = prop.title || toTitleCase(key);
        if (prop.type === "boolean") {
          const wrapper = document.createElement("div");
          wrapper.className = "form-check form-switch";
          const input = document.createElement("input");
          input.type = "checkbox";
          input.className = "form-check-input";
          input.id = fieldId;
          input.name = key;
          input.dataset.field = key;
          if (prop.default !== undefined) {
            input.checked = Boolean(prop.default);
          }
          wrapper.appendChild(input);

          const label = document.createElement("label");
          label.className = "form-check-label";
          label.setAttribute("for", fieldId);
          label.textContent = labelText;
          if (isRequired) {
            const star = document.createElement("span");
            star.className = "text-danger ms-1";
            star.textContent = "*";
            label.appendChild(star);
          }
          wrapper.appendChild(label);

          if (prop.description) {
            const hint = document.createElement("small");
            hint.className = "form-text";
            hint.textContent = prop.description;
            wrapper.appendChild(hint);
          }
          return wrapper;
        }

        const wrapper = document.createElement("div");
        wrapper.className = "config-form__field";
        const label = document.createElement("label");
        label.className = "form-label fw-semibold";
        label.setAttribute("for", fieldId);
        label.textContent = labelText;
        if (isRequired) {
          const star = document.createElement("span");
          star.className = "text-danger ms-1";
          star.textContent = "*";
          label.appendChild(star);
        }
        wrapper.appendChild(label);

        let control;
        if (Array.isArray(prop.enum) && prop.enum.length) {
          control = document.createElement("select");
          control.className = "form-select";
          const placeholderOption = document.createElement("option");
          placeholderOption.value = "";
          placeholderOption.textContent = "Select value";
          if (isRequired && prop.default === undefined) {
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
          }
          control.appendChild(placeholderOption);
          prop.enum.forEach((value) => {
            const option = document.createElement("option");
            option.value = value;
            option.textContent = value;
            if (prop.default === value) {
              option.selected = true;
              placeholderOption.selected = false;
            }
            control.appendChild(option);
          });
        } else if (prop.type === "array") {
          control = document.createElement("textarea");
          control.className = "form-control";
          const defaultRowCount = Array.isArray(prop.default) ? prop.default.length : 0;
          control.rows = Math.min(8, Math.max(3, defaultRowCount || 3));
          control.placeholder = "Enter one value per line";
          control.dataset.arrayField = "true";
          if (Array.isArray(prop.default)) {
            control.value = prop.default.join("\n");
          }
        } else {
          control = document.createElement("input");
          control.className = "form-control";
          control.type = inferInputType(prop);
          if (prop.default !== undefined && prop.default !== null) {
            control.value = prop.default;
          }
        }

        control.id = fieldId;
        control.name = key;
        control.dataset.field = key;
        if (control.tagName === "INPUT" && control.type === "password") {
          control.autocomplete = "new-password";
        }
        if (isRequired) {
          control.required = true;
        }
        if (!control.placeholder) {
          if (prop.example) {
            control.placeholder = prop.example;
          } else if (Array.isArray(prop.examples) && prop.examples.length) {
            control.placeholder = prop.examples[0];
          }
        }
        if (prop.minLength) control.minLength = prop.minLength;
        if (prop.maxLength) control.maxLength = prop.maxLength;
        if (prop.pattern) control.pattern = prop.pattern;
        if (prop.minimum !== undefined) control.min = prop.minimum;
        if (prop.maximum !== undefined) control.max = prop.maximum;
        if (prop.readonly || prop.readOnly) control.readOnly = true;

        wrapper.appendChild(control);

        const descriptionBits = [];
        if (prop.description) descriptionBits.push(prop.description);
        if (prop.type === "array") descriptionBits.push("Separate values with new lines.");
        if (descriptionBits.length) {
          const hint = document.createElement("small");
          hint.className = "form-text text-muted";
          hint.textContent = descriptionBits.join(" ");
          wrapper.appendChild(hint);
        }
        return wrapper;
      }

      function renderCredentialForm(schema) {
        const form = document.createElement("form");
        form.className = "config-form";
        form.id = "configModalForm";
        form.setAttribute("novalidate", "novalidate");
        const properties = schema?.properties || {};
        const keys = Object.keys(properties);
        if (keys.length === 0) {
          const empty = document.createElement("p");
          empty.className = "config-form__empty mb-0";
          empty.textContent = "This provider does not require credential inputs.";
          form.appendChild(empty);
          return form;
        }
        const requiredFields = new Set(schema.required || []);
        keys.forEach((key) => {
          form.appendChild(buildCredentialField(key, properties[key], requiredFields.has(key)));
        });
        return form;
      }

      function collectCredentialValues(form, schema) {
        const values = {};
        const properties = schema?.properties || {};
        Object.entries(properties).forEach(([key, prop]) => {
          const field = form.querySelector(`[data-field="${key}"]`);
          if (!field) return;
          if (prop.type === "boolean") {
            values[key] = field.checked;
            return;
          }
          if (prop.type === "array") {
            const raw = field.value.trim();
            if (raw) {
              const items = raw
                .split(/[\r\n,]+/)
                .map((item) => item.trim())
                .filter(Boolean);
              if (items.length > 0) {
                values[key] = items;
              }
            } else if (field.required) {
              values[key] = [];
            }
            return;
          }
          const rawValue = field.value;
          if (rawValue === "" || rawValue === undefined || rawValue === null) {
            return;
          }
          if (prop.type === "integer") {
            const parsed = parseInt(rawValue, 10);
            if (!Number.isNaN(parsed)) {
              values[key] = parsed;
            }
            return;
          }
          if (prop.type === "number") {
            const parsed = parseFloat(rawValue);
            if (!Number.isNaN(parsed)) {
              values[key] = parsed;
            }
            return;
          }
          values[key] = rawValue.trim();
        });
        return values;
      }

      function openConfigModal(providerName) {
        const provider = providerMetadata.get(providerName);
        if (!provider?.credentialsSchema) {
          log(`Provider ${providerName} does not expose a credential schema`, "error");
          return;
        }
        activeConfigProvider = providerName;
        activeCredentialSchema = provider.credentialsSchema;
        const modal = document.getElementById("configModal");
        document.getElementById("configModalTitle").textContent = `Configure ${provider.displayName || provider.name}`;
        document.getElementById("configModalSubtitle").textContent =
          provider.labels?.vendor ? `Vendor: ${provider.labels.vendor}` : "";
        const container = document.getElementById("configEditorContainer");
        container.innerHTML = "";
        configModalForm = renderCredentialForm(activeCredentialSchema);
        container.appendChild(configModalForm);
        modal.classList.add("show");
      }

      function closeConfigModal() {
        const modal = document.getElementById("configModal");
        modal.classList.remove("show");
        if (configModalForm) {
          configModalForm.remove();
          configModalForm = null;
        }
        activeConfigProvider = null;
        activeCredentialSchema = null;
      }

      async function submitConfiguration() {
        if (!activeConfigProvider || !configModalForm || !activeCredentialSchema) {
          log("No provider selected for configuration", "error");
          return;
        }
        if (!configModalForm.reportValidity()) {
          log("Resolve validation errors before submitting configuration", "error");
          return;
        }
        const submitButton = document.getElementById("configModalSubmit");
        try {
          const providerName = activeConfigProvider;
          if (!providerName) {
            throw new Error("No provider selected");
          }
          const payload = { payload: collectCredentialValues(configModalForm, activeCredentialSchema) };
          if (submitButton) {
            submitButton.disabled = true;
            submitButton.textContent = "Submitting...";
          }
          log(`Submitting configuration for ${providerName}`, "info");
          const response = await makeRequest(`/v1/integrations/${providerName}/config`, {
            method: "POST",
            body: JSON.stringify(payload),
          });
          if (!response.ok) throw new Error(await response.text());
          const result = await response.json();
          if (!result?.success) {
            throw new Error("Configuration response did not indicate success");
          }
          log(`Configuration saved for ${providerName}`, "success");
          closeConfigModal();
          await handleStatus(providerName);
          await loadIntegrations();
        } catch (err) {
          log(`Failed to save configuration: ${err.message}`, "error");
        } finally {
          if (submitButton) {
            submitButton.disabled = false;
            submitButton.textContent = "Submit Configuration";
          }
        }
      }

      function log(message, type = "info") {
        const container = document.getElementById("activityLog");
        const entry = document.createElement("div");
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        container.appendChild(entry);
        container.scrollTop = container.scrollHeight;
      }

      function getCSRFToken() {
        const cookieName = "ol.csrf-token";
        return document.cookie
          .split(";")
          .map((c) => c.trim().split("="))
          .find(([name]) => name === cookieName)?.[1] || null;
      }

      async function makeRequest(path, options = {}) {
        const headers = { "Content-Type": "application/json", ...(options.headers || {}) };
        const method = (options.method || "GET").toUpperCase();
        if (authToken) {
          headers["Authorization"] = `Bearer ${authToken}`;
        }
        if (method !== "GET" && !path.includes("/login")) {
          const csrf = getCSRFToken();
          if (csrf) {
            headers["X-CSRF-Token"] = csrf;
          }
        }
        return fetch(`${apiBase}${path}`, {
          ...options,
          method,
          headers,
          credentials: "include",
        });
      }

      async function loginWithSeedUser() {
        try {
          log("Attempting login with seeded user", "info");
          const response = await fetch(`${apiBase}/v1/login`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({
              username: "mitb@theopenlane.io",
              password: "mattisthebest1234",
            }),
          });
          if (!response.ok) {
            log(`Login failed: ${await response.text()}`, "error");
            return false;
          }
          const data = await response.json();
          if (data.success && data.access_token) {
            authToken = data.access_token;
            log("Login successful", "success");
            return true;
          }
          log("Unexpected login response format", "error");
          return false;
        } catch (err) {
          log(`Login error: ${err.message}`, "error");
          return false;
        }
      }

      async function ensureAuthenticated() {
        try {
          const params = new URLSearchParams(window.location.search);
          const sessionToken = params.get("session");
          if (sessionToken) {
            authToken = sessionToken;
            log("Adopted session token from query param", "info");
          }

          if (!authToken) {
            const loggedIn = await loginWithSeedUser();
            if (!loggedIn) {
              document.getElementById("authStatus").className =
                "alert alert-warning d-flex justify-content-between align-items-center";
              document.getElementById("authStatusText").innerHTML =
                'Authentication required. <button class="btn btn-sm btn-primary ms-2" onclick="loginWithSeedUser().then(ok => ok && initialize())">Login</button>';
              document.getElementById("loginButton").classList.remove("d-none");
              return false;
            }
          }

          const response = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({ query: "{ self { id displayName email } }" }),
          });
          if (!response.ok) {
            log(`Auth check failed: HTTP ${response.status}`, "error");
            return false;
          }
          const data = await response.json();
          if (!data?.data?.self) {
            log("Auth check failed: no self payload", "error");
            return false;
          }
          userInfo = data.data.self;
          document.getElementById("authStatus").className =
            "alert alert-success d-flex justify-content-between align-items-center";
          document.getElementById("authStatusText").innerHTML =
            `Authenticated as <strong>${userInfo.displayName}</strong> (${userInfo.email})`;
          document.getElementById("loginButton").classList.add("d-none");
          log(`Authenticated as ${userInfo.displayName}`, "success");
          return true;
        } catch (err) {
          log(`Auth check error: ${err.message}`, "error");
          return false;
        }
      }

      function updateProviderStatus(provider, status, tokenValid = false, tokenExpired = false) {
        const badge = document.getElementById(`${providerDomId(provider)}-status`);
        if (!badge) return;
        badge.className = "status-badge";
        switch (status) {
          case "connected":
            badge.classList.add(tokenExpired ? "status-expired" : "status-connected");
            badge.textContent = tokenExpired ? "Token Expired" : "Connected";
            break;
          case "configured":
            badge.classList.add("status-configured");
            badge.textContent = "Configured";
            break;
          case "invalid":
            badge.classList.add("status-invalid");
            badge.textContent = "Invalid";
            break;
          default:
            badge.classList.add("status-disconnected");
            badge.textContent = "Disconnected";
        }
      }

      async function fetchProviders() {
        try {
          log("Fetching provider library", "info");
          const response = await makeRequest("/v1/integrations/providers");
          if (!response.ok) throw new Error(await response.text());
          const data = await response.json();
          log(`Loaded ${data.providers?.length || 0} providers`, "success");
          return data.providers || [];
        } catch (err) {
          log(`Failed to load providers: ${err.message}`, "error");
          return [];
        }
      }

      function renderProviders(providers) {
        const container = document.getElementById("providersContainer");
        container.innerHTML = "";
        if (providers.length === 0) {
          container.innerHTML = '<div class="text-center text-muted">No providers registered</div>';
          return;
        }

        providerMetadata.clear();
        providerMetadata.clear();
        providers
          .slice()
          .sort((a, b) => (a.displayName || a.name).localeCompare(b.displayName || b.name))
          .forEach((provider) => {
            if (provider?.active === false) {
              return;
            }
            providerMetadata.set(provider.name, provider);
            const name = provider.name || provider.displayName;
            const id = providerDomId(name);
            const card = document.createElement("div");
            card.className = "integration-card";
            const initials = (provider.displayName || provider.name || "??").slice(0, 2).toUpperCase();
            const logo = provider.logoUrl
              ? `<div class="provider-logo"><img src="${provider.logoUrl}" alt="${provider.displayName || provider.name} logo" loading="lazy" onerror="this.onerror=null;this.remove();this.parentElement.textContent='${initials}';" /></div>`
              : `<div class="provider-logo text-uppercase fw-bold">${initials}</div>`;
            const vendorLabel = provider.labels?.vendor || provider.category || "Integration";
            const docsLink = provider.docsUrl
              ? `<a class="btn btn-sm btn-outline-secondary docs-link" href="${provider.docsUrl}" target="_blank" rel="noopener noreferrer">Docs â†—</a>`
              : "";
            card.innerHTML = `
              <div class="provider-header">
                ${logo}
                <div class="provider-info">
                  <h3 class="mb-1">${provider.displayName || provider.name}</h3>
                  <small class="text-muted text-uppercase">${vendorLabel}</small>
                </div>
                <div class="provider-meta text-end">
                  ${docsLink || ""}
                  <span class="status-badge status-disconnected" id="${id}-status">Disconnected</span>
                </div>
              </div>
              <div class="provider-body">
                <small class="text-muted mb-0">Authentication: ${(provider.authType || "unknown").toUpperCase()}</small>
              </div>
              <div class="provider-operations d-none" id="${id}-operations"></div>
              <div class="provider-actions d-grid gap-2" id="${id}-actions"></div>
            `;

            container.appendChild(card);

            const actions = card.querySelector(`#${id}-actions`);
            const operationsPanel = card.querySelector(`#${id}-operations`);
            const addButton = (label, style, handler) => {
              const btn = document.createElement("button");
              btn.type = "button";
              btn.className = `btn btn-${style}`;
              btn.textContent = label;
              btn.addEventListener("click", handler);
              actions.appendChild(btn);
              return btn;
            };

            if (Array.isArray(provider.operations) && provider.operations.length) {
              operationsPanel.classList.remove("d-none");
              const heading = document.createElement("div");
              heading.className = "operation-heading";
              heading.textContent = "Operations";
              operationsPanel.appendChild(heading);

              provider.operations.forEach((operation) => {
                const opRow = document.createElement("div");
                opRow.className = "operation-row";

                const titleLine = document.createElement("div");
                titleLine.className = "operation-title-line";
                const title = document.createElement("div");
                title.className = "operation-title";
                title.textContent = operation.name;
                titleLine.appendChild(title);
                const kind = document.createElement("span");
                kind.className = "operation-kind";
                kind.textContent = operation.kind || "operation";
                titleLine.appendChild(kind);
                opRow.appendChild(titleLine);

                if (operation.description) {
                  const desc = document.createElement("div");
                  desc.className = "operation-hint";
                  desc.textContent = operation.description;
                  opRow.appendChild(desc);
                }

                const controls = document.createElement("div");
                controls.className = "operation-controls";

                let configInput = null;
                if (operation.configSchema && Object.keys(operation.configSchema).length > 0) {
                  configInput = document.createElement("textarea");
                  configInput.className = "form-control form-control-sm";
                  configInput.rows = 3;
                  configInput.placeholder = "Optional config JSON (match schema)";
                  controls.appendChild(configInput);
                } else {
                  const hint = document.createElement("div");
                  hint.className = "operation-hint";
                  hint.textContent = "No config required";
                  controls.appendChild(hint);
                }

                const forceWrapper = document.createElement("label");
                forceWrapper.className = "form-check form-switch operation-force";
                const forceInput = document.createElement("input");
                forceInput.type = "checkbox";
                forceInput.className = "form-check-input";
                forceInput.checked = false;
                forceWrapper.appendChild(forceInput);
                const forceText = document.createElement("span");
                forceText.className = "ms-2";
                forceText.textContent = "Force fresh credentials";
                forceWrapper.appendChild(forceText);
                controls.appendChild(forceWrapper);

                const runBtn = document.createElement("button");
                runBtn.type = "button";
                runBtn.className = "btn btn-sm btn-success operation-run-btn";
                runBtn.textContent = "Run Operation";
                runBtn.addEventListener("click", () =>
                  handleOperation(
                    provider.name,
                    operation.name,
                    configInput ? configInput.value : "",
                    forceInput.checked,
                  ),
                );
                controls.appendChild(runBtn);

                opRow.appendChild(controls);
                operationsPanel.appendChild(opRow);
              });
            }

            if (provider.credentialsSchema) {
              addButton("Submit Configuration", "primary", () => openConfigModal(provider.name));
            }

            if (provider.authType === "oauth2" || provider.authType === "oidc") {
              addButton("Start OAuth Flow", "dark", () => handleOAuth(provider.name));
              addButton("Refresh Token", "outline-warning", () => handleRefresh(provider.name));
            }

            addButton("Check Status", "outline-secondary", () => handleStatus(provider.name));
            addButton("Disconnect Integration", "outline-danger", () => handleDisconnect(provider.name));
          });
      }

      async function handleOAuth(provider) {
        const meta = providerMetadata.get(provider);
        if (meta?.oauth?.authUrl && meta?.oauth?.clientId && meta?.oauth?.redirectUri) {
          const params = new URLSearchParams({
            client_id: meta.oauth.clientId,
            response_type: "code",
            redirect_uri: meta.oauth.redirectUri,
            scope: (meta.oauth.scopes || []).join(" "),
            state: btoa(JSON.stringify({ provider, ts: Date.now() })),
          });
          if (meta.oauth.authParams) {
            Object.entries(meta.oauth.authParams).forEach(([key, value]) => params.set(key, value));
          }
          const authorizeUrl = `${meta.oauth.authUrl}?${params.toString()}`;
          log(`Redirecting to ${meta.displayName || provider} OAuth flow`, "info");
          window.location.href = authorizeUrl;
          return;
        }
        try {
          const payload = { provider };
          log(`Starting OAuth flow for ${provider}`, "info");
          const response = await makeRequest("/v1/integrations/oauth/start", {
            method: "POST",
            body: JSON.stringify(payload),
          });
          if (!response.ok) throw new Error(await response.text());
          const data = await response.json();
          if (!data.authUrl) throw new Error("Provider did not return an authUrl");
          window.location.href = data.authUrl;
        } catch (err) {
          log(`OAuth start failed: ${err.message}`, "error");
        }
      }

      async function handleStatus(provider) {
        try {
          log(`Checking status for ${provider}`, "info");
          const response = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({ query: integrationSecretsQuery, variables: { kind: provider } }),
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const payload = await response.json();
          const integration = payload?.data?.integrations?.edges?.[0]?.node;
          if (!integration) {
            updateProviderStatus(provider, "disconnected");
            return;
          }
          const secrets = integration.secrets?.edges?.map((edge) => edge.node) || [];
          const tokenMatchers = [/access_token/i, /api_token/i, /token/i];
          const primarySecret =
            tokenMatchers
              .map((regex) => secrets.find((secret) => regex.test(secret?.secretName || "")))
              .find(Boolean) || null;
          const expirationSource =
            primarySecret?.expiresAt ||
            primarySecret?.metadata?.expiresAt ||
            secrets.find((secret) => (secret?.secretName || "").includes("_expires_at"))?.metadata?.expiresAt ||
            null;
          const expired = expirationSource ? new Date(expirationSource) < new Date() : false;
          const status = primarySecret ? (expired ? "expired" : "connected") : secrets.length ? "configured" : "disconnected";
          updateProviderStatus(provider, status, Boolean(primarySecret), expired);
        } catch (err) {
          log(`Status check failed: ${err.message}`, "error");
          updateProviderStatus(provider, "disconnected");
        }
      }

      async function handleOperation(provider, operation, rawConfig, force) {
        let config = {};
        if (rawConfig && rawConfig.trim()) {
          try {
            config = JSON.parse(rawConfig);
          } catch (err) {
            log(`Invalid config JSON for ${operation}: ${err.message}`, "error");
            return;
          }
        }
        try {
          log(`Running ${operation} for ${provider}`, "info");
          const response = await makeRequest(`/v1/integrations/${provider}/operations/run`, {
            method: "POST",
            body: JSON.stringify({
              payload: {
                operation,
                config,
                force: Boolean(force),
              },
            }),
          });
          const raw = await response.text();
          if (!response.ok) {
            throw new Error(raw || `HTTP ${response.status}`);
          }
          const data = raw ? JSON.parse(raw) : {};
          const status = (data.status || "unknown").toUpperCase();
          const summary = data.summary || data.message || "No summary returned";
          const logType = data.success === false || status !== "OK" ? "warning" : "success";
          log(`Operation ${operation} (${status}): ${summary}`, logType);
          if (data.details) {
            log(`Details: ${JSON.stringify(data.details)}`, "info");
          }
        } catch (err) {
          log(`Operation ${operation} failed: ${err.message}`, "error");
        }
      }

      async function handleRefresh(provider) {
        try {
          const response = await makeRequest(`/v1/integrations/${provider}/refresh`, {
            method: "POST",
          });
          if (!response.ok) throw new Error(await response.text());
          log(`Trigger refresh succeeded for ${provider}`, "success");
          await handleStatus(provider);
        } catch (err) {
          log(`Refresh failed: ${err.message}`, "error");
        }
      }

      async function handleDisconnect(provider) {
        try {
          const lookup = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({
              query: "query ($kind: String!) { integrations(where: { kind: $kind }) { edges { node { id } } } }",
              variables: { kind: provider },
            }),
          });
          if (!lookup.ok) throw new Error(`lookup failed: HTTP ${lookup.status}`);
          const data = await lookup.json();
          const id = data?.data?.integrations?.edges?.[0]?.node?.id;
          if (!id) {
            log(`No integration to delete for ${provider}`, "info");
            updateProviderStatus(provider, "disconnected");
            return;
          }
          const response = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({
              query: "mutation ($id: ID!) { deleteIntegration(id: $id) { deletedID } }",
              variables: { id },
            }),
          });
          if (!response.ok) throw new Error(`delete failed: HTTP ${response.status}`);
          log(`Integration deleted for ${provider}`, "success");
          updateProviderStatus(provider, "disconnected");
          await loadIntegrations();
        } catch (err) {
          log(`Disconnect failed: ${err.message}`, "error");
        }
      }

      async function loadIntegrations() {
        log("Loading configured integrations", "info");
        try {
          const container = document.getElementById("integrationsList");
          const response = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({ query: "{ integrations { edges { node { id name kind description updatedAt } } } }" }),
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const data = await response.json();
          const items = data?.data?.integrations?.edges || [];
          if (items.length === 0) {
            container.innerHTML = '<div class="text-center text-muted">No integrations configured</div>';
            return;
          }
          container.innerHTML = items
            .map(({ node }) => `
              <div class="card mb-2">
                <div class="card-body">
                  <div class="d-flex justify-content-between align-items-center">
                    <div>
                      <h6 class="card-title mb-1">${node.name}</h6>
                      <small class="text-muted">Provider: ${node.kind}</small>
                    </div>
                    <small class="text-muted">ID: ${node.id}</small>
                  </div>
                  <p class="card-text mt-2 mb-1">${node.description || "No description"}</p>
                  <small class="text-muted">Updated ${new Date(node.updatedAt).toLocaleString()}</small>
                </div>
              </div>
            `)
            .join("");
        } catch (err) {
          log(`Failed to load integrations: ${err.message}`, "error");
        }
      }

      function handleOAuthCallback() {
        const params = new URLSearchParams(window.location.search);
        const provider = params.get("provider");
        const status = params.get("status");
        const message = params.get("message");
        if (!provider || !status) return;
        const container = document.getElementById("callbackNotice");
        container.innerHTML = `
          <div class="alert ${status === "success" ? "alert-success" : "alert-danger"} alert-dismissible fade show">
            <strong>${status === "success" ? "Integration Connected" : "Integration Error"}:</strong>
            ${decodeURIComponent(message || provider)}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
          </div>
        `;
      }

      async function loadProvidersAndStatus() {
        const providers = await fetchProviders();
        renderProviders(providers);
        for (const provider of providers) {
          await handleStatus(provider.name);
        }
      }

      async function initialize() {
        log("Initializing integration console", "info");
        handleOAuthCallback();
        const authed = await ensureAuthenticated();
        if (!authed) {
          log("Authentication required before continuing", "error");
          return;
        }
        await loadProvidersAndStatus();
        await loadIntegrations();
        log("Initialization complete", "success");
      }

      document.addEventListener("DOMContentLoaded", () => {
        initialize();
        document.getElementById("loginButton").addEventListener("click", () => {
          loginWithSeedUser().then((ok) => ok && initialize());
        });
        document.getElementById("refreshProviders").addEventListener("click", loadProvidersAndStatus);
        document.getElementById("refreshIntegrations").addEventListener("click", loadIntegrations);
        document.getElementById("clearLog").addEventListener("click", () => {
          document.getElementById("activityLog").innerHTML = "";
        });
        document.getElementById("configModalClose").addEventListener("click", closeConfigModal);
        document.getElementById("configModalCancel").addEventListener("click", closeConfigModal);
        document.getElementById("configModalSubmit").addEventListener("click", submitConfiguration);
        document.getElementById("configModal").addEventListener("click", (event) => {
          if (event.target.id === "configModal") {
            closeConfigModal();
          }
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            closeConfigModal();
          }
        });
      });

      window.loginWithSeedUser = loginWithSeedUser;
    </script>
  </body>
</html>
