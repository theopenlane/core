package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/pkg/logx"
	"github.com/theopenlane/ent/generated"
	"github.com/theopenlane/ent/generated/control"
	"github.com/theopenlane/ent/generated/program"
	"github.com/theopenlane/ent/generated/programmembership"
	"github.com/theopenlane/gqlgen-plugins/graphutils"
	"github.com/theopenlane/utils/rout"
)

// CreateProgramWithMembers is the resolver for the createProgramWithMembers field.
func (r *mutationResolver) CreateProgramWithMembers(ctx context.Context, input model.CreateProgramWithMembersInput) (*model.ProgramCreatePayload, error) {
	// set the organization in the auth context if its not done for us
	if err := setOrganizationInAuthContext(ctx, input.Program.OwnerID); err != nil {
		logx.FromContext(ctx).Error().Err(err).Msg("failed to set organization in auth context")
		return nil, rout.NewMissingRequiredFieldError("owner_id")
	}

	createdProgram := withTransactionalMutation(ctx).Program.Create()

	if hasStandardFilter(input) {
		cf := cloneFilterOptions{
			categories: input.Categories,
		}

		if input.StandardID != nil {
			cf.standardID = input.StandardID
		} else {
			cf.standardShortName = input.StandardShortName
			cf.standardVersion = input.StandardVersion
		}

		bulkControls, err := r.cloneControlsFromStandard(ctx, cf, nil)
		if err != nil {
			return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
		}

		for _, control := range bulkControls {
			createdProgram.AddControlIDs(control.ID)
		}
	}

	res, err := createdProgram.SetInput(*input.Program).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
	}

	// add the members to the program
	if len(input.Members) > 0 {
		c := withTransactionalMutation(ctx)

		builders := make([]*generated.ProgramMembershipCreate, len(input.Members))
		for i := range input.Members {
			input := generated.CreateProgramMembershipInput{
				ProgramID: res.ID,
				UserID:    input.Members[i].UserID,
				Role:      input.Members[i].Role,
			}

			builders[i] = c.ProgramMembership.Create().SetInput(input)
		}

		if err := c.ProgramMembership.CreateBulk(builders...).Exec(ctx); err != nil {
			return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
		}
	}

	query, err := withTransactionalMutation(ctx).Program.
		Query().
		Where(program.ID(res.ID)).
		CollectFields(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
	}

	finalResult, err := query.Only(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
	}

	return &model.ProgramCreatePayload{
		Program: finalResult,
	}, nil
}

// CreateFullProgram is the resolver for the createFullProgram field.
func (r *mutationResolver) CreateFullProgram(ctx context.Context, input model.CreateFullProgramInput) (*model.ProgramCreatePayload, error) {
	// set the organization in the auth context if its not done for us
	if err := setOrganizationInAuthContext(ctx, input.Program.OwnerID); err != nil {
		logx.FromContext(ctx).Error().Err(err).Msg("failed to set organization in auth context")
		return nil, rout.NewMissingRequiredFieldError("owner_id")
	}

	createdProgram := withTransactionalMutation(ctx).Program.Create()

	if hasStandardFilter(input) {
		bulkControls, err := r.cloneControlsFromStandard(ctx, cloneFilterOptions{standardID: input.StandardID}, nil)
		if err != nil {
			return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
		}

		for _, control := range bulkControls {
			createdProgram.AddControlIDs(control.ID)
		}
	}

	// create the program
	res, err := createdProgram.SetInput(*input.Program).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
	}

	if len(input.Members) > 0 {
		// create the program memberships
		c := withTransactionalMutation(ctx)
		builders := make([]*generated.ProgramMembershipCreate, len(input.Members))
		for i := range input.Members {
			input := generated.CreateProgramMembershipInput{
				ProgramID: res.ID,
				UserID:    input.Members[i].UserID,
				Role:      input.Members[i].Role,
			}

			builders[i] = c.ProgramMembership.Create().SetInput(input)
		}

		if err := c.ProgramMembership.CreateBulk(builders...).Exec(ctx); err != nil {
			return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
		}
	}

	// create the risks
	if input.Risks != nil {
		c := withTransactionalMutation(ctx)
		builders := make([]*generated.RiskCreate, len(input.Risks))
		for i := range input.Risks {
			input.Risks[i].ProgramIDs = []string{res.ID}

			builders[i] = c.Risk.Create().SetInput(*input.Risks[i])
		}

		if err := c.Risk.CreateBulk(builders...).Exec(ctx); err != nil {
			return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
		}
	}

	// create the procedures
	if input.Procedures != nil {
		c := withTransactionalMutation(ctx)
		builders := make([]*generated.ProcedureCreate, len(input.Procedures))
		for i := range input.Procedures {
			input.Procedures[i].ProgramIDs = []string{res.ID}

			builders[i] = c.Procedure.Create().SetInput(*input.Procedures[i])
		}

		if err := c.Procedure.CreateBulk(builders...).Exec(ctx); err != nil {
			return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
		}
	}

	// create the policies
	if input.InternalPolicies != nil {
		c := withTransactionalMutation(ctx)
		builders := make([]*generated.InternalPolicyCreate, len(input.InternalPolicies))
		for i := range input.InternalPolicies {
			input.InternalPolicies[i].ProgramIDs = []string{res.ID}

			builders[i] = c.InternalPolicy.Create().SetInput(*input.InternalPolicies[i])
		}

		if err := c.InternalPolicy.CreateBulk(builders...).Exec(ctx); err != nil {
			return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
		}
	}

	// create the controls
	if input.Controls != nil {
		for _, control := range input.Controls {
			control.Control.ProgramIDs = []string{res.ID}
			_, err := r.CreateControlWithSubcontrols(ctx, *control)
			if err != nil {
				return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
			}
		}
	}

	query, err := withTransactionalMutation(ctx).Program.
		Query().
		Where(program.ID(res.ID)).
		CollectFields(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
	}

	finalResult, err := query.Only(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "program"})
	}

	return &model.ProgramCreatePayload{
		Program: finalResult,
	}, nil
}

// CreateControlWithSubcontrols is the resolver for the createControlWithSubcontrols field.
func (r *mutationResolver) CreateControlWithSubcontrols(ctx context.Context, input model.CreateControlWithSubcontrolsInput) (*model.ControlCreatePayload, error) {
	res, err := withTransactionalMutation(ctx).Control.Create().SetInput(*input.Control).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "control"})
	}

	// create the subcontrols
	if input.Subcontrols != nil {
		c := withTransactionalMutation(ctx)
		builders := make([]*generated.SubcontrolCreate, len(input.Subcontrols))
		for i := range input.Subcontrols {
			input.Subcontrols[i].ControlID = res.ID

			builders[i] = c.Subcontrol.Create().SetInput(*input.Subcontrols[i])
		}

		if err := c.Subcontrol.CreateBulk(builders...).Exec(ctx); err != nil {
			return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "control"})
		}
	}

	query, err := withTransactionalMutation(ctx).Control.
		Query().
		Where(control.ID(res.ID)).
		CollectFields(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "control"})

	}

	finalResult, err := query.Only(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, action{action: ActionCreate, object: "control"})
	}

	return &model.ControlCreatePayload{
		Control: finalResult,
	}, nil
}

// AddProgramMembers is the resolver for the addProgramMembers field.
func (r *updateProgramInputResolver) AddProgramMembers(ctx context.Context, obj *generated.UpdateProgramInput, data []*model.AddProgramMembershipInput) error {
	programID := graphutils.GetStringInputVariableByName(ctx, "id")
	if programID == nil {
		logx.FromContext(ctx).Error().Msg("unable to get program from context")

		return ErrInternalServerError
	}

	// return early if no members to add
	if len(data) == 0 {
		return nil
	}

	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ProgramMembershipCreate, len(data))
	for i := range data {
		input := generated.CreateProgramMembershipInput{
			ProgramID: *programID,
			UserID:    data[i].UserID,
			Role:      data[i].Role,
		}

		builders[i] = c.ProgramMembership.Create().SetInput(input)
	}

	if err := c.ProgramMembership.CreateBulk(builders...).Exec(ctx); err != nil {
		return parseRequestError(ctx, err, action{action: ActionUpdate, object: "program"})
	}

	return nil
}

// RemoveProgramMembers is the resolver for the removeProgramMembers field.
func (r *updateProgramInputResolver) RemoveProgramMembers(ctx context.Context, obj *generated.UpdateProgramInput, data []string) error {
	if len(data) == 0 {
		return nil
	}

	programID := graphutils.GetStringInputVariableByName(ctx, "id")
	if programID == nil {
		logx.FromContext(ctx).Error().Msg("unable to get program from context")

		return ErrInternalServerError
	}

	c := withTransactionalMutation(ctx)

	for _, id := range data {
		if err := c.ProgramMembership.DeleteOneID(id).
			Where(programmembership.ProgramID(*programID)).
			Exec(ctx); err != nil {

			return parseRequestError(ctx, err, action{action: ActionUpdate, object: "program"})
		}
	}

	return nil
}
