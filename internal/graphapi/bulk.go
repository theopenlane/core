package graphapi

// THIS CODE IS REGENERATED BY github.com/theopenlane/core/pkg/gqlplugin. DO NOT EDIT.

import (
	"context"
	"sync"

	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/graphapi/common"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/pkg/logx"
	"github.com/theopenlane/utils/rout"
)

// bulkCreateActionPlan uses the CreateBulk function to create multiple ActionPlan entities
func (r *mutationResolver) bulkCreateActionPlan(ctx context.Context, input []*generated.CreateActionPlanInput) (*model.ActionPlanBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ActionPlanCreate, len(input))
	for i, data := range input {
		builders[i] = c.ActionPlan.Create().SetInput(*data)
	}

	res, err := c.ActionPlan.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "actionplan"})
	}

	// return response
	return &model.ActionPlanBulkCreatePayload{
		ActionPlans: res,
	}, nil
}

// bulkUpdateActionPlan updates multiple ActionPlan entities
func (r *mutationResolver) bulkUpdateActionPlan(ctx context.Context, ids []string, input generated.UpdateActionPlanInput) (*model.ActionPlanBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.ActionPlan, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each actionplan individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for actionplan")
			continue
		}

		// get the existing entity first
		existing, err := c.ActionPlan.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("actionplan_id", id).Msg("failed to get actionplan in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("actionplan_id", id).Msg("failed to update actionplan in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ActionPlanBulkUpdatePayload{
		ActionPlans: results,
		UpdatedIDs:  updatedIDs,
	}, nil
}

// bulkDeleteActionPlan deletes multiple ActionPlan entities by their IDs
func (r *mutationResolver) bulkDeleteActionPlan(ctx context.Context, ids []string) (*model.ActionPlanBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each actionplan individually to ensure proper cleanup
			if err := r.db.ActionPlan.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("actionplan_id", id).Msg("failed to delete actionplan in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ActionPlanEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("actionplan_id", id).Msg("failed to cleanup actionplan edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some actionplan deletions failed")
	}

	return &model.ActionPlanBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateAPIToken uses the CreateBulk function to create multiple APIToken entities
func (r *mutationResolver) bulkCreateAPIToken(ctx context.Context, input []*generated.CreateAPITokenInput) (*model.APITokenBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.APITokenCreate, len(input))
	for i, data := range input {
		builders[i] = c.APIToken.Create().SetInput(*data)
	}

	res, err := c.APIToken.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "apitoken"})
	}

	// return response
	return &model.APITokenBulkCreatePayload{
		APITokens: res,
	}, nil
}

// bulkDeleteAPIToken deletes multiple APIToken entities by their IDs
func (r *mutationResolver) bulkDeleteAPIToken(ctx context.Context, ids []string) (*model.APITokenBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each apitoken individually to ensure proper cleanup
			if err := r.db.APIToken.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("apitoken_id", id).Msg("failed to delete apitoken in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.APITokenEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("apitoken_id", id).Msg("failed to cleanup apitoken edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some apitoken deletions failed")
	}

	return &model.APITokenBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkDeleteAssessment deletes multiple Assessment entities by their IDs
func (r *mutationResolver) bulkDeleteAssessment(ctx context.Context, ids []string) (*model.AssessmentBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each assessment individually to ensure proper cleanup
			if err := r.db.Assessment.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("assessment_id", id).Msg("failed to delete assessment in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.AssessmentEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("assessment_id", id).Msg("failed to cleanup assessment edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some assessment deletions failed")
	}

	return &model.AssessmentBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateAsset uses the CreateBulk function to create multiple Asset entities
func (r *mutationResolver) bulkCreateAsset(ctx context.Context, input []*generated.CreateAssetInput) (*model.AssetBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.AssetCreate, len(input))
	for i, data := range input {
		builders[i] = c.Asset.Create().SetInput(*data)
	}

	res, err := c.Asset.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "asset"})
	}

	// return response
	return &model.AssetBulkCreatePayload{
		Assets: res,
	}, nil
}

// bulkDeleteAsset deletes multiple Asset entities by their IDs
func (r *mutationResolver) bulkDeleteAsset(ctx context.Context, ids []string) (*model.AssetBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each asset individually to ensure proper cleanup
			if err := r.db.Asset.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("asset_id", id).Msg("failed to delete asset in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.AssetEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("asset_id", id).Msg("failed to cleanup asset edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some asset deletions failed")
	}

	return &model.AssetBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateCampaign uses the CreateBulk function to create multiple Campaign entities
func (r *mutationResolver) bulkCreateCampaign(ctx context.Context, input []*generated.CreateCampaignInput) (*model.CampaignBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.CampaignCreate, len(input))
	for i, data := range input {
		builders[i] = c.Campaign.Create().SetInput(*data)
	}

	res, err := c.Campaign.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "campaign"})
	}

	// return response
	return &model.CampaignBulkCreatePayload{
		Campaigns: res,
	}, nil
}

// bulkCreateCampaignTarget uses the CreateBulk function to create multiple CampaignTarget entities
func (r *mutationResolver) bulkCreateCampaignTarget(ctx context.Context, input []*generated.CreateCampaignTargetInput) (*model.CampaignTargetBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.CampaignTargetCreate, len(input))
	for i, data := range input {
		builders[i] = c.CampaignTarget.Create().SetInput(*data)
	}

	res, err := c.CampaignTarget.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "campaigntarget"})
	}

	// return response
	return &model.CampaignTargetBulkCreatePayload{
		CampaignTargets: res,
	}, nil
}

// bulkCreateContact uses the CreateBulk function to create multiple Contact entities
func (r *mutationResolver) bulkCreateContact(ctx context.Context, input []*generated.CreateContactInput) (*model.ContactBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ContactCreate, len(input))
	for i, data := range input {
		builders[i] = c.Contact.Create().SetInput(*data)
	}

	res, err := c.Contact.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "contact"})
	}

	// return response
	return &model.ContactBulkCreatePayload{
		Contacts: res,
	}, nil
}

// bulkUpdateContact updates multiple Contact entities
func (r *mutationResolver) bulkUpdateContact(ctx context.Context, ids []string, input generated.UpdateContactInput) (*model.ContactBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Contact, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each contact individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for contact")
			continue
		}

		// get the existing entity first
		existing, err := c.Contact.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("contact_id", id).Msg("failed to get contact in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("contact_id", id).Msg("failed to update contact in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ContactBulkUpdatePayload{
		Contacts:   results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkDeleteContact deletes multiple Contact entities by their IDs
func (r *mutationResolver) bulkDeleteContact(ctx context.Context, ids []string) (*model.ContactBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each contact individually to ensure proper cleanup
			if err := r.db.Contact.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("contact_id", id).Msg("failed to delete contact in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ContactEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("contact_id", id).Msg("failed to cleanup contact edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some contact deletions failed")
	}

	return &model.ContactBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateControl uses the CreateBulk function to create multiple Control entities
func (r *mutationResolver) bulkCreateControl(ctx context.Context, input []*generated.CreateControlInput) (*model.ControlBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ControlCreate, len(input))
	for i, data := range input {
		builders[i] = c.Control.Create().SetInput(*data)
	}

	res, err := c.Control.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
	}

	// return response
	return &model.ControlBulkCreatePayload{
		Controls: res,
	}, nil
}

// bulkUpdateControl updates multiple Control entities
func (r *mutationResolver) bulkUpdateControl(ctx context.Context, ids []string, input generated.UpdateControlInput) (*model.ControlBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Control, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each control individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for control")
			continue
		}

		// get the existing entity first
		existing, err := c.Control.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("control_id", id).Msg("failed to get control in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("control_id", id).Msg("failed to update control in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ControlBulkUpdatePayload{
		Controls:   results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkDeleteControl deletes multiple Control entities by their IDs
func (r *mutationResolver) bulkDeleteControl(ctx context.Context, ids []string) (*model.ControlBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each control individually to ensure proper cleanup
			if err := r.db.Control.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("control_id", id).Msg("failed to delete control in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ControlEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("control_id", id).Msg("failed to cleanup control edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some control deletions failed")
	}

	return &model.ControlBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateControlImplementation uses the CreateBulk function to create multiple ControlImplementation entities
func (r *mutationResolver) bulkCreateControlImplementation(ctx context.Context, input []*generated.CreateControlImplementationInput) (*model.ControlImplementationBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ControlImplementationCreate, len(input))
	for i, data := range input {
		builders[i] = c.ControlImplementation.Create().SetInput(*data)
	}

	res, err := c.ControlImplementation.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "controlimplementation"})
	}

	// return response
	return &model.ControlImplementationBulkCreatePayload{
		ControlImplementations: res,
	}, nil
}

// bulkDeleteControlImplementation deletes multiple ControlImplementation entities by their IDs
func (r *mutationResolver) bulkDeleteControlImplementation(ctx context.Context, ids []string) (*model.ControlImplementationBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each controlimplementation individually to ensure proper cleanup
			if err := r.db.ControlImplementation.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("controlimplementation_id", id).Msg("failed to delete controlimplementation in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ControlImplementationEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("controlimplementation_id", id).Msg("failed to cleanup controlimplementation edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some controlimplementation deletions failed")
	}

	return &model.ControlImplementationBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateControlObjective uses the CreateBulk function to create multiple ControlObjective entities
func (r *mutationResolver) bulkCreateControlObjective(ctx context.Context, input []*generated.CreateControlObjectiveInput) (*model.ControlObjectiveBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ControlObjectiveCreate, len(input))
	for i, data := range input {
		builders[i] = c.ControlObjective.Create().SetInput(*data)
	}

	res, err := c.ControlObjective.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "controlobjective"})
	}

	// return response
	return &model.ControlObjectiveBulkCreatePayload{
		ControlObjectives: res,
	}, nil
}

// bulkDeleteControlObjective deletes multiple ControlObjective entities by their IDs
func (r *mutationResolver) bulkDeleteControlObjective(ctx context.Context, ids []string) (*model.ControlObjectiveBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each controlobjective individually to ensure proper cleanup
			if err := r.db.ControlObjective.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("controlobjective_id", id).Msg("failed to delete controlobjective in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ControlObjectiveEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("controlobjective_id", id).Msg("failed to cleanup controlobjective edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some controlobjective deletions failed")
	}

	return &model.ControlObjectiveBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateCustomDomain uses the CreateBulk function to create multiple CustomDomain entities
func (r *mutationResolver) bulkCreateCustomDomain(ctx context.Context, input []*generated.CreateCustomDomainInput) (*model.CustomDomainBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.CustomDomainCreate, len(input))
	for i, data := range input {
		builders[i] = c.CustomDomain.Create().SetInput(*data)
	}

	res, err := c.CustomDomain.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "customdomain"})
	}

	// return response
	return &model.CustomDomainBulkCreatePayload{
		CustomDomains: res,
	}, nil
}

// bulkDeleteCustomDomain deletes multiple CustomDomain entities by their IDs
func (r *mutationResolver) bulkDeleteCustomDomain(ctx context.Context, ids []string) (*model.CustomDomainBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each customdomain individually to ensure proper cleanup
			if err := r.db.CustomDomain.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("customdomain_id", id).Msg("failed to delete customdomain in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.CustomDomainEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("customdomain_id", id).Msg("failed to cleanup customdomain edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some customdomain deletions failed")
	}

	return &model.CustomDomainBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateCustomTypeEnum uses the CreateBulk function to create multiple CustomTypeEnum entities
func (r *mutationResolver) bulkCreateCustomTypeEnum(ctx context.Context, input []*generated.CreateCustomTypeEnumInput) (*model.CustomTypeEnumBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.CustomTypeEnumCreate, len(input))
	for i, data := range input {
		builders[i] = c.CustomTypeEnum.Create().SetInput(*data)
	}

	res, err := c.CustomTypeEnum.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "customtypeenum"})
	}

	// return response
	return &model.CustomTypeEnumBulkCreatePayload{
		CustomTypeEnums: res,
	}, nil
}

// bulkCreateDirectoryAccount uses the CreateBulk function to create multiple DirectoryAccount entities
func (r *mutationResolver) bulkCreateDirectoryAccount(ctx context.Context, input []*generated.CreateDirectoryAccountInput) (*model.DirectoryAccountBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DirectoryAccountCreate, len(input))
	for i, data := range input {
		builders[i] = c.DirectoryAccount.Create().SetInput(*data)
	}

	res, err := c.DirectoryAccount.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "directoryaccount"})
	}

	// return response
	return &model.DirectoryAccountBulkCreatePayload{
		DirectoryAccounts: res,
	}, nil
}

// bulkCreateDirectoryGroup uses the CreateBulk function to create multiple DirectoryGroup entities
func (r *mutationResolver) bulkCreateDirectoryGroup(ctx context.Context, input []*generated.CreateDirectoryGroupInput) (*model.DirectoryGroupBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DirectoryGroupCreate, len(input))
	for i, data := range input {
		builders[i] = c.DirectoryGroup.Create().SetInput(*data)
	}

	res, err := c.DirectoryGroup.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "directorygroup"})
	}

	// return response
	return &model.DirectoryGroupBulkCreatePayload{
		DirectoryGroups: res,
	}, nil
}

// bulkCreateDirectoryMembership uses the CreateBulk function to create multiple DirectoryMembership entities
func (r *mutationResolver) bulkCreateDirectoryMembership(ctx context.Context, input []*generated.CreateDirectoryMembershipInput) (*model.DirectoryMembershipBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DirectoryMembershipCreate, len(input))
	for i, data := range input {
		builders[i] = c.DirectoryMembership.Create().SetInput(*data)
	}

	res, err := c.DirectoryMembership.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "directorymembership"})
	}

	// return response
	return &model.DirectoryMembershipBulkCreatePayload{
		DirectoryMemberships: res,
	}, nil
}

// bulkCreateDirectorySyncRun uses the CreateBulk function to create multiple DirectorySyncRun entities
func (r *mutationResolver) bulkCreateDirectorySyncRun(ctx context.Context, input []*generated.CreateDirectorySyncRunInput) (*model.DirectorySyncRunBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DirectorySyncRunCreate, len(input))
	for i, data := range input {
		builders[i] = c.DirectorySyncRun.Create().SetInput(*data)
	}

	res, err := c.DirectorySyncRun.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "directorysyncrun"})
	}

	// return response
	return &model.DirectorySyncRunBulkCreatePayload{
		DirectorySyncRuns: res,
	}, nil
}

// bulkCreateDiscussion uses the CreateBulk function to create multiple Discussion entities
func (r *mutationResolver) bulkCreateDiscussion(ctx context.Context, input []*generated.CreateDiscussionInput) (*model.DiscussionBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DiscussionCreate, len(input))
	for i, data := range input {
		builders[i] = c.Discussion.Create().SetInput(*data)
	}

	res, err := c.Discussion.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "discussion"})
	}

	// return response
	return &model.DiscussionBulkCreatePayload{
		Discussions: res,
	}, nil
}

// bulkCreateDNSVerification uses the CreateBulk function to create multiple DNSVerification entities
func (r *mutationResolver) bulkCreateDNSVerification(ctx context.Context, input []*generated.CreateDNSVerificationInput) (*model.DNSVerificationBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DNSVerificationCreate, len(input))
	for i, data := range input {
		builders[i] = c.DNSVerification.Create().SetInput(*data)
	}

	res, err := c.DNSVerification.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "dnsverification"})
	}

	// return response
	return &model.DNSVerificationBulkCreatePayload{
		DNSVerifications: res,
	}, nil
}

// bulkDeleteDNSVerification deletes multiple DNSVerification entities by their IDs
func (r *mutationResolver) bulkDeleteDNSVerification(ctx context.Context, ids []string) (*model.DNSVerificationBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each dnsverification individually to ensure proper cleanup
			if err := r.db.DNSVerification.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("dnsverification_id", id).Msg("failed to delete dnsverification in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.DNSVerificationEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("dnsverification_id", id).Msg("failed to cleanup dnsverification edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some dnsverification deletions failed")
	}

	return &model.DNSVerificationBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateDocumentData uses the CreateBulk function to create multiple DocumentData entities
func (r *mutationResolver) bulkCreateDocumentData(ctx context.Context, input []*generated.CreateDocumentDataInput) (*model.DocumentDataBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DocumentDataCreate, len(input))
	for i, data := range input {
		builders[i] = c.DocumentData.Create().SetInput(*data)
	}

	res, err := c.DocumentData.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "documentdata"})
	}

	// return response
	return &model.DocumentDataBulkCreatePayload{
		DocumentData: res,
	}, nil
}

// bulkDeleteDocumentData deletes multiple DocumentData entities by their IDs
func (r *mutationResolver) bulkDeleteDocumentData(ctx context.Context, ids []string) (*model.DocumentDataBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each documentdata individually to ensure proper cleanup
			if err := r.db.DocumentData.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("documentdata_id", id).Msg("failed to delete documentdata in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.DocumentDataEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("documentdata_id", id).Msg("failed to cleanup documentdata edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some documentdata deletions failed")
	}

	return &model.DocumentDataBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateEntity uses the CreateBulk function to create multiple Entity entities
func (r *mutationResolver) bulkCreateEntity(ctx context.Context, input []*generated.CreateEntityInput) (*model.EntityBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.EntityCreate, len(input))
	for i, data := range input {
		builders[i] = c.Entity.Create().SetInput(*data)
	}

	res, err := c.Entity.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "entity"})
	}

	// return response
	return &model.EntityBulkCreatePayload{
		Entities: res,
	}, nil
}

// bulkDeleteEntity deletes multiple Entity entities by their IDs
func (r *mutationResolver) bulkDeleteEntity(ctx context.Context, ids []string) (*model.EntityBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each entity individually to ensure proper cleanup
			if err := r.db.Entity.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("entity_id", id).Msg("failed to delete entity in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.EntityEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("entity_id", id).Msg("failed to cleanup entity edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some entity deletions failed")
	}

	return &model.EntityBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateEntityType uses the CreateBulk function to create multiple EntityType entities
func (r *mutationResolver) bulkCreateEntityType(ctx context.Context, input []*generated.CreateEntityTypeInput) (*model.EntityTypeBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.EntityTypeCreate, len(input))
	for i, data := range input {
		builders[i] = c.EntityType.Create().SetInput(*data)
	}

	res, err := c.EntityType.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "entitytype"})
	}

	// return response
	return &model.EntityTypeBulkCreatePayload{
		EntityTypes: res,
	}, nil
}

// bulkDeleteEntityType deletes multiple EntityType entities by their IDs
func (r *mutationResolver) bulkDeleteEntityType(ctx context.Context, ids []string) (*model.EntityTypeBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each entitytype individually to ensure proper cleanup
			if err := r.db.EntityType.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("entitytype_id", id).Msg("failed to delete entitytype in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.EntityTypeEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("entitytype_id", id).Msg("failed to cleanup entitytype edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some entitytype deletions failed")
	}

	return &model.EntityTypeBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateEvent uses the CreateBulk function to create multiple Event entities
func (r *mutationResolver) bulkCreateEvent(ctx context.Context, input []*generated.CreateEventInput) (*model.EventBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.EventCreate, len(input))
	for i, data := range input {
		builders[i] = c.Event.Create().SetInput(*data)
	}

	res, err := c.Event.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "event"})
	}

	// return response
	return &model.EventBulkCreatePayload{
		Events: res,
	}, nil
}

// bulkDeleteEvent deletes multiple Event entities by their IDs
func (r *mutationResolver) bulkDeleteEvent(ctx context.Context, ids []string) (*model.EventBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each event individually to ensure proper cleanup
			if err := r.db.Event.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("event_id", id).Msg("failed to delete event in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.EventEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("event_id", id).Msg("failed to cleanup event edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some event deletions failed")
	}

	return &model.EventBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateEvidence uses the CreateBulk function to create multiple Evidence entities
func (r *mutationResolver) bulkCreateEvidence(ctx context.Context, input []*generated.CreateEvidenceInput) (*model.EvidenceBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.EvidenceCreate, len(input))
	for i, data := range input {
		builders[i] = c.Evidence.Create().SetInput(*data)
	}

	res, err := c.Evidence.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "evidence"})
	}

	// return response
	return &model.EvidenceBulkCreatePayload{
		Evidences: res,
	}, nil
}

// bulkUpdateEvidence updates multiple Evidence entities
func (r *mutationResolver) bulkUpdateEvidence(ctx context.Context, ids []string, input generated.UpdateEvidenceInput) (*model.EvidenceBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Evidence, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each evidence individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for evidence")
			continue
		}

		// get the existing entity first
		existing, err := c.Evidence.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("evidence_id", id).Msg("failed to get evidence in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("evidence_id", id).Msg("failed to update evidence in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.EvidenceBulkUpdatePayload{
		Evidences:  results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkDeleteEvidence deletes multiple Evidence entities by their IDs
func (r *mutationResolver) bulkDeleteEvidence(ctx context.Context, ids []string) (*model.EvidenceBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each evidence individually to ensure proper cleanup
			if err := r.db.Evidence.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("evidence_id", id).Msg("failed to delete evidence in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.EvidenceEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("evidence_id", id).Msg("failed to cleanup evidence edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some evidence deletions failed")
	}

	return &model.EvidenceBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkDeleteExport deletes multiple Export entities by their IDs
func (r *mutationResolver) bulkDeleteExport(ctx context.Context, ids []string) (*model.ExportBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each export individually to ensure proper cleanup
			if err := r.db.Export.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("export_id", id).Msg("failed to delete export in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ExportEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("export_id", id).Msg("failed to cleanup export edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some export deletions failed")
	}

	return &model.ExportBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateFinding uses the CreateBulk function to create multiple Finding entities
func (r *mutationResolver) bulkCreateFinding(ctx context.Context, input []*generated.CreateFindingInput) (*model.FindingBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.FindingCreate, len(input))
	for i, data := range input {
		builders[i] = c.Finding.Create().SetInput(*data)
	}

	res, err := c.Finding.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "finding"})
	}

	// return response
	return &model.FindingBulkCreatePayload{
		Findings: res,
	}, nil
}

// bulkCreateFindingControl uses the CreateBulk function to create multiple FindingControl entities
func (r *mutationResolver) bulkCreateFindingControl(ctx context.Context, input []*generated.CreateFindingControlInput) (*model.FindingControlBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.FindingControlCreate, len(input))
	for i, data := range input {
		builders[i] = c.FindingControl.Create().SetInput(*data)
	}

	res, err := c.FindingControl.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "findingcontrol"})
	}

	// return response
	return &model.FindingControlBulkCreatePayload{
		FindingControls: res,
	}, nil
}

// bulkCreateGroup uses the CreateBulk function to create multiple Group entities
func (r *mutationResolver) bulkCreateGroup(ctx context.Context, input []*generated.CreateGroupInput) (*model.GroupBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.GroupCreate, len(input))
	for i, data := range input {
		builders[i] = c.Group.Create().SetInput(*data)
	}

	res, err := c.Group.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "group"})
	}

	// return response
	return &model.GroupBulkCreatePayload{
		Groups: res,
	}, nil
}

// bulkDeleteGroup deletes multiple Group entities by their IDs
func (r *mutationResolver) bulkDeleteGroup(ctx context.Context, ids []string) (*model.GroupBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each group individually to ensure proper cleanup
			if err := r.db.Group.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("group_id", id).Msg("failed to delete group in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.GroupEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("group_id", id).Msg("failed to cleanup group edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some group deletions failed")
	}

	return &model.GroupBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateGroupMembership uses the CreateBulk function to create multiple GroupMembership entities
func (r *mutationResolver) bulkCreateGroupMembership(ctx context.Context, input []*generated.CreateGroupMembershipInput) (*model.GroupMembershipBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.GroupMembershipCreate, len(input))
	for i, data := range input {
		builders[i] = c.GroupMembership.Create().SetInput(*data)
	}

	res, err := c.GroupMembership.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "groupmembership"})
	}

	// return response
	return &model.GroupMembershipBulkCreatePayload{
		GroupMemberships: res,
	}, nil
}

// bulkDeleteGroupMembership deletes multiple GroupMembership entities by their IDs
func (r *mutationResolver) bulkDeleteGroupMembership(ctx context.Context, ids []string) (*model.GroupMembershipBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each groupmembership individually to ensure proper cleanup
			if err := r.db.GroupMembership.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("groupmembership_id", id).Msg("failed to delete groupmembership in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.GroupMembershipEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("groupmembership_id", id).Msg("failed to cleanup groupmembership edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some groupmembership deletions failed")
	}

	return &model.GroupMembershipBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateGroupSetting uses the CreateBulk function to create multiple GroupSetting entities
func (r *mutationResolver) bulkCreateGroupSetting(ctx context.Context, input []*generated.CreateGroupSettingInput) (*model.GroupSettingBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.GroupSettingCreate, len(input))
	for i, data := range input {
		builders[i] = c.GroupSetting.Create().SetInput(*data)
	}

	res, err := c.GroupSetting.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "groupsetting"})
	}

	// return response
	return &model.GroupSettingBulkCreatePayload{
		GroupSettings: res,
	}, nil
}

// bulkDeleteGroupSetting deletes multiple GroupSetting entities by their IDs
func (r *mutationResolver) bulkDeleteGroupSetting(ctx context.Context, ids []string) (*model.GroupSettingBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each groupsetting individually to ensure proper cleanup
			if err := r.db.GroupSetting.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("groupsetting_id", id).Msg("failed to delete groupsetting in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.GroupSettingEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("groupsetting_id", id).Msg("failed to cleanup groupsetting edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some groupsetting deletions failed")
	}

	return &model.GroupSettingBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateHush uses the CreateBulk function to create multiple Hush entities
func (r *mutationResolver) bulkCreateHush(ctx context.Context, input []*generated.CreateHushInput) (*model.HushBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.HushCreate, len(input))
	for i, data := range input {
		builders[i] = c.Hush.Create().SetInput(*data)
	}

	res, err := c.Hush.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "hush"})
	}

	// return response
	return &model.HushBulkCreatePayload{
		Hushes: res,
	}, nil
}

// bulkUpdateHush updates multiple Hush entities
func (r *mutationResolver) bulkUpdateHush(ctx context.Context, ids []string, input generated.UpdateHushInput) (*model.HushBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Hush, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each hush individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for hush")
			continue
		}

		// get the existing entity first
		existing, err := c.Hush.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("hush_id", id).Msg("failed to get hush in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("hush_id", id).Msg("failed to update hush in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.HushBulkUpdatePayload{
		Hushes:     results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkDeleteHush deletes multiple Hush entities by their IDs
func (r *mutationResolver) bulkDeleteHush(ctx context.Context, ids []string) (*model.HushBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each hush individually to ensure proper cleanup
			if err := r.db.Hush.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("hush_id", id).Msg("failed to delete hush in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.HushEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("hush_id", id).Msg("failed to cleanup hush edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some hush deletions failed")
	}

	return &model.HushBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateIdentityHolder uses the CreateBulk function to create multiple IdentityHolder entities
func (r *mutationResolver) bulkCreateIdentityHolder(ctx context.Context, input []*generated.CreateIdentityHolderInput) (*model.IdentityHolderBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.IdentityHolderCreate, len(input))
	for i, data := range input {
		builders[i] = c.IdentityHolder.Create().SetInput(*data)
	}

	res, err := c.IdentityHolder.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "identityholder"})
	}

	// return response
	return &model.IdentityHolderBulkCreatePayload{
		IdentityHolders: res,
	}, nil
}

// bulkCreateInternalPolicy uses the CreateBulk function to create multiple InternalPolicy entities
func (r *mutationResolver) bulkCreateInternalPolicy(ctx context.Context, input []*generated.CreateInternalPolicyInput) (*model.InternalPolicyBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.InternalPolicyCreate, len(input))
	for i, data := range input {
		builders[i] = c.InternalPolicy.Create().SetInput(*data)
	}

	res, err := c.InternalPolicy.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "internalpolicy"})
	}

	// return response
	return &model.InternalPolicyBulkCreatePayload{
		InternalPolicies: res,
	}, nil
}

// bulkUpdateInternalPolicy updates multiple InternalPolicy entities
func (r *mutationResolver) bulkUpdateInternalPolicy(ctx context.Context, ids []string, input generated.UpdateInternalPolicyInput) (*model.InternalPolicyBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.InternalPolicy, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each internalpolicy individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for internalpolicy")
			continue
		}

		// get the existing entity first
		existing, err := c.InternalPolicy.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("internalpolicy_id", id).Msg("failed to get internalpolicy in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("internalpolicy_id", id).Msg("failed to update internalpolicy in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.InternalPolicyBulkUpdatePayload{
		InternalPolicies: results,
		UpdatedIDs:       updatedIDs,
	}, nil
}

// bulkDeleteInternalPolicy deletes multiple InternalPolicy entities by their IDs
func (r *mutationResolver) bulkDeleteInternalPolicy(ctx context.Context, ids []string) (*model.InternalPolicyBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each internalpolicy individually to ensure proper cleanup
			if err := r.db.InternalPolicy.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("internalpolicy_id", id).Msg("failed to delete internalpolicy in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.InternalPolicyEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("internalpolicy_id", id).Msg("failed to cleanup internalpolicy edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some internalpolicy deletions failed")
	}

	return &model.InternalPolicyBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateInvite uses the CreateBulk function to create multiple Invite entities
func (r *mutationResolver) bulkCreateInvite(ctx context.Context, input []*generated.CreateInviteInput) (*model.InviteBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.InviteCreate, len(input))
	for i, data := range input {
		builders[i] = c.Invite.Create().SetInput(*data)
	}

	res, err := c.Invite.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "invite"})
	}

	// return response
	return &model.InviteBulkCreatePayload{
		Invites: res,
	}, nil
}

// bulkDeleteInvite deletes multiple Invite entities by their IDs
func (r *mutationResolver) bulkDeleteInvite(ctx context.Context, ids []string) (*model.InviteBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each invite individually to ensure proper cleanup
			if err := r.db.Invite.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("invite_id", id).Msg("failed to delete invite in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.InviteEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("invite_id", id).Msg("failed to cleanup invite edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some invite deletions failed")
	}

	return &model.InviteBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateJobTemplate uses the CreateBulk function to create multiple JobTemplate entities
func (r *mutationResolver) bulkCreateJobTemplate(ctx context.Context, input []*generated.CreateJobTemplateInput) (*model.JobTemplateBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.JobTemplateCreate, len(input))
	for i, data := range input {
		builders[i] = c.JobTemplate.Create().SetInput(*data)
	}

	res, err := c.JobTemplate.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "jobtemplate"})
	}

	// return response
	return &model.JobTemplateBulkCreatePayload{
		JobTemplates: res,
	}, nil
}

// bulkDeleteJobTemplate deletes multiple JobTemplate entities by their IDs
func (r *mutationResolver) bulkDeleteJobTemplate(ctx context.Context, ids []string) (*model.JobTemplateBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each jobtemplate individually to ensure proper cleanup
			if err := r.db.JobTemplate.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("jobtemplate_id", id).Msg("failed to delete jobtemplate in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.JobTemplateEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("jobtemplate_id", id).Msg("failed to cleanup jobtemplate edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some jobtemplate deletions failed")
	}

	return &model.JobTemplateBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateMappableDomain uses the CreateBulk function to create multiple MappableDomain entities
func (r *mutationResolver) bulkCreateMappableDomain(ctx context.Context, input []*generated.CreateMappableDomainInput) (*model.MappableDomainBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.MappableDomainCreate, len(input))
	for i, data := range input {
		builders[i] = c.MappableDomain.Create().SetInput(*data)
	}

	res, err := c.MappableDomain.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "mappabledomain"})
	}

	// return response
	return &model.MappableDomainBulkCreatePayload{
		MappableDomains: res,
	}, nil
}

// bulkDeleteMappableDomain deletes multiple MappableDomain entities by their IDs
func (r *mutationResolver) bulkDeleteMappableDomain(ctx context.Context, ids []string) (*model.MappableDomainBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each mappabledomain individually to ensure proper cleanup
			if err := r.db.MappableDomain.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("mappabledomain_id", id).Msg("failed to delete mappabledomain in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.MappableDomainEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("mappabledomain_id", id).Msg("failed to cleanup mappabledomain edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some mappabledomain deletions failed")
	}

	return &model.MappableDomainBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateMappedControl uses the CreateBulk function to create multiple MappedControl entities
func (r *mutationResolver) bulkCreateMappedControl(ctx context.Context, input []*generated.CreateMappedControlInput) (*model.MappedControlBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.MappedControlCreate, len(input))
	for i, data := range input {
		builders[i] = c.MappedControl.Create().SetInput(*data)
	}

	res, err := c.MappedControl.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "mappedcontrol"})
	}

	// return response
	return &model.MappedControlBulkCreatePayload{
		MappedControls: res,
	}, nil
}

// bulkDeleteMappedControl deletes multiple MappedControl entities by their IDs
func (r *mutationResolver) bulkDeleteMappedControl(ctx context.Context, ids []string) (*model.MappedControlBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each mappedcontrol individually to ensure proper cleanup
			if err := r.db.MappedControl.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("mappedcontrol_id", id).Msg("failed to delete mappedcontrol in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.MappedControlEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("mappedcontrol_id", id).Msg("failed to cleanup mappedcontrol edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some mappedcontrol deletions failed")
	}

	return &model.MappedControlBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateNarrative uses the CreateBulk function to create multiple Narrative entities
func (r *mutationResolver) bulkCreateNarrative(ctx context.Context, input []*generated.CreateNarrativeInput) (*model.NarrativeBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.NarrativeCreate, len(input))
	for i, data := range input {
		builders[i] = c.Narrative.Create().SetInput(*data)
	}

	res, err := c.Narrative.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "narrative"})
	}

	// return response
	return &model.NarrativeBulkCreatePayload{
		Narratives: res,
	}, nil
}

// bulkDeleteNarrative deletes multiple Narrative entities by their IDs
func (r *mutationResolver) bulkDeleteNarrative(ctx context.Context, ids []string) (*model.NarrativeBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each narrative individually to ensure proper cleanup
			if err := r.db.Narrative.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("narrative_id", id).Msg("failed to delete narrative in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.NarrativeEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("narrative_id", id).Msg("failed to cleanup narrative edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some narrative deletions failed")
	}

	return &model.NarrativeBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateOrganizationSetting uses the CreateBulk function to create multiple OrganizationSetting entities
func (r *mutationResolver) bulkCreateOrganizationSetting(ctx context.Context, input []*generated.CreateOrganizationSettingInput) (*model.OrganizationSettingBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.OrganizationSettingCreate, len(input))
	for i, data := range input {
		builders[i] = c.OrganizationSetting.Create().SetInput(*data)
	}

	res, err := c.OrganizationSetting.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "organizationsetting"})
	}

	// return response
	return &model.OrganizationSettingBulkCreatePayload{
		OrganizationSettings: res,
	}, nil
}

// bulkDeleteOrganizationSetting deletes multiple OrganizationSetting entities by their IDs
func (r *mutationResolver) bulkDeleteOrganizationSetting(ctx context.Context, ids []string) (*model.OrganizationSettingBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each organizationsetting individually to ensure proper cleanup
			if err := r.db.OrganizationSetting.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("organizationsetting_id", id).Msg("failed to delete organizationsetting in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.OrganizationSettingEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("organizationsetting_id", id).Msg("failed to cleanup organizationsetting edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some organizationsetting deletions failed")
	}

	return &model.OrganizationSettingBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateOrgMembership uses the CreateBulk function to create multiple OrgMembership entities
func (r *mutationResolver) bulkCreateOrgMembership(ctx context.Context, input []*generated.CreateOrgMembershipInput) (*model.OrgMembershipBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.OrgMembershipCreate, len(input))
	for i, data := range input {
		builders[i] = c.OrgMembership.Create().SetInput(*data)
	}

	res, err := c.OrgMembership.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "orgmembership"})
	}

	// return response
	return &model.OrgMembershipBulkCreatePayload{
		OrgMemberships: res,
	}, nil
}

// bulkDeleteOrgMembership deletes multiple OrgMembership entities by their IDs
func (r *mutationResolver) bulkDeleteOrgMembership(ctx context.Context, ids []string) (*model.OrgMembershipBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each orgmembership individually to ensure proper cleanup
			if err := r.db.OrgMembership.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("orgmembership_id", id).Msg("failed to delete orgmembership in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.OrgMembershipEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("orgmembership_id", id).Msg("failed to cleanup orgmembership edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some orgmembership deletions failed")
	}

	return &model.OrgMembershipBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreatePlatform uses the CreateBulk function to create multiple Platform entities
func (r *mutationResolver) bulkCreatePlatform(ctx context.Context, input []*generated.CreatePlatformInput) (*model.PlatformBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.PlatformCreate, len(input))
	for i, data := range input {
		builders[i] = c.Platform.Create().SetInput(*data)
	}

	res, err := c.Platform.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "platform"})
	}

	// return response
	return &model.PlatformBulkCreatePayload{
		Platforms: res,
	}, nil
}

// bulkCreateProcedure uses the CreateBulk function to create multiple Procedure entities
func (r *mutationResolver) bulkCreateProcedure(ctx context.Context, input []*generated.CreateProcedureInput) (*model.ProcedureBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ProcedureCreate, len(input))
	for i, data := range input {
		builders[i] = c.Procedure.Create().SetInput(*data)
	}

	res, err := c.Procedure.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "procedure"})
	}

	// return response
	return &model.ProcedureBulkCreatePayload{
		Procedures: res,
	}, nil
}

// bulkUpdateProcedure updates multiple Procedure entities
func (r *mutationResolver) bulkUpdateProcedure(ctx context.Context, ids []string, input generated.UpdateProcedureInput) (*model.ProcedureBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Procedure, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each procedure individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for procedure")
			continue
		}

		// get the existing entity first
		existing, err := c.Procedure.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("procedure_id", id).Msg("failed to get procedure in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("procedure_id", id).Msg("failed to update procedure in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ProcedureBulkUpdatePayload{
		Procedures: results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkDeleteProcedure deletes multiple Procedure entities by their IDs
func (r *mutationResolver) bulkDeleteProcedure(ctx context.Context, ids []string) (*model.ProcedureBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each procedure individually to ensure proper cleanup
			if err := r.db.Procedure.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("procedure_id", id).Msg("failed to delete procedure in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ProcedureEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("procedure_id", id).Msg("failed to cleanup procedure edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some procedure deletions failed")
	}

	return &model.ProcedureBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateProgram uses the CreateBulk function to create multiple Program entities
func (r *mutationResolver) bulkCreateProgram(ctx context.Context, input []*generated.CreateProgramInput) (*model.ProgramBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ProgramCreate, len(input))
	for i, data := range input {
		builders[i] = c.Program.Create().SetInput(*data)
	}

	res, err := c.Program.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "program"})
	}

	// return response
	return &model.ProgramBulkCreatePayload{
		Programs: res,
	}, nil
}

// bulkDeleteProgram deletes multiple Program entities by their IDs
func (r *mutationResolver) bulkDeleteProgram(ctx context.Context, ids []string) (*model.ProgramBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each program individually to ensure proper cleanup
			if err := r.db.Program.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("program_id", id).Msg("failed to delete program in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ProgramEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("program_id", id).Msg("failed to cleanup program edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some program deletions failed")
	}

	return &model.ProgramBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateProgramMembership uses the CreateBulk function to create multiple ProgramMembership entities
func (r *mutationResolver) bulkCreateProgramMembership(ctx context.Context, input []*generated.CreateProgramMembershipInput) (*model.ProgramMembershipBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ProgramMembershipCreate, len(input))
	for i, data := range input {
		builders[i] = c.ProgramMembership.Create().SetInput(*data)
	}

	res, err := c.ProgramMembership.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "programmembership"})
	}

	// return response
	return &model.ProgramMembershipBulkCreatePayload{
		ProgramMemberships: res,
	}, nil
}

// bulkDeleteProgramMembership deletes multiple ProgramMembership entities by their IDs
func (r *mutationResolver) bulkDeleteProgramMembership(ctx context.Context, ids []string) (*model.ProgramMembershipBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each programmembership individually to ensure proper cleanup
			if err := r.db.ProgramMembership.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("programmembership_id", id).Msg("failed to delete programmembership in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ProgramMembershipEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("programmembership_id", id).Msg("failed to cleanup programmembership edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some programmembership deletions failed")
	}

	return &model.ProgramMembershipBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateRemediation uses the CreateBulk function to create multiple Remediation entities
func (r *mutationResolver) bulkCreateRemediation(ctx context.Context, input []*generated.CreateRemediationInput) (*model.RemediationBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.RemediationCreate, len(input))
	for i, data := range input {
		builders[i] = c.Remediation.Create().SetInput(*data)
	}

	res, err := c.Remediation.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "remediation"})
	}

	// return response
	return &model.RemediationBulkCreatePayload{
		Remediations: res,
	}, nil
}

// bulkCreateReview uses the CreateBulk function to create multiple Review entities
func (r *mutationResolver) bulkCreateReview(ctx context.Context, input []*generated.CreateReviewInput) (*model.ReviewBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ReviewCreate, len(input))
	for i, data := range input {
		builders[i] = c.Review.Create().SetInput(*data)
	}

	res, err := c.Review.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "review"})
	}

	// return response
	return &model.ReviewBulkCreatePayload{
		Reviews: res,
	}, nil
}

// bulkCreateRisk uses the CreateBulk function to create multiple Risk entities
func (r *mutationResolver) bulkCreateRisk(ctx context.Context, input []*generated.CreateRiskInput) (*model.RiskBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.RiskCreate, len(input))
	for i, data := range input {
		builders[i] = c.Risk.Create().SetInput(*data)
	}

	res, err := c.Risk.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "risk"})
	}

	// return response
	return &model.RiskBulkCreatePayload{
		Risks: res,
	}, nil
}

// bulkUpdateRisk updates multiple Risk entities
func (r *mutationResolver) bulkUpdateRisk(ctx context.Context, ids []string, input generated.UpdateRiskInput) (*model.RiskBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Risk, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each risk individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for risk")
			continue
		}

		// get the existing entity first
		existing, err := c.Risk.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("risk_id", id).Msg("failed to get risk in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("risk_id", id).Msg("failed to update risk in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.RiskBulkUpdatePayload{
		Risks:      results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkDeleteRisk deletes multiple Risk entities by their IDs
func (r *mutationResolver) bulkDeleteRisk(ctx context.Context, ids []string) (*model.RiskBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each risk individually to ensure proper cleanup
			if err := r.db.Risk.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("risk_id", id).Msg("failed to delete risk in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.RiskEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("risk_id", id).Msg("failed to cleanup risk edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some risk deletions failed")
	}

	return &model.RiskBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateScan uses the CreateBulk function to create multiple Scan entities
func (r *mutationResolver) bulkCreateScan(ctx context.Context, input []*generated.CreateScanInput) (*model.ScanBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ScanCreate, len(input))
	for i, data := range input {
		builders[i] = c.Scan.Create().SetInput(*data)
	}

	res, err := c.Scan.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "scan"})
	}

	// return response
	return &model.ScanBulkCreatePayload{
		Scans: res,
	}, nil
}

// bulkUpdateScan updates multiple Scan entities
func (r *mutationResolver) bulkUpdateScan(ctx context.Context, ids []string, input generated.UpdateScanInput) (*model.ScanBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Scan, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each scan individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for scan")
			continue
		}

		// get the existing entity first
		existing, err := c.Scan.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("scan_id", id).Msg("failed to get scan in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("scan_id", id).Msg("failed to update scan in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ScanBulkUpdatePayload{
		Scans:      results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkDeleteScan deletes multiple Scan entities by their IDs
func (r *mutationResolver) bulkDeleteScan(ctx context.Context, ids []string) (*model.ScanBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each scan individually to ensure proper cleanup
			if err := r.db.Scan.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("scan_id", id).Msg("failed to delete scan in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ScanEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("scan_id", id).Msg("failed to cleanup scan edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some scan deletions failed")
	}

	return &model.ScanBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateScheduledJob uses the CreateBulk function to create multiple ScheduledJob entities
func (r *mutationResolver) bulkCreateScheduledJob(ctx context.Context, input []*generated.CreateScheduledJobInput) (*model.ScheduledJobBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ScheduledJobCreate, len(input))
	for i, data := range input {
		builders[i] = c.ScheduledJob.Create().SetInput(*data)
	}

	res, err := c.ScheduledJob.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "scheduledjob"})
	}

	// return response
	return &model.ScheduledJobBulkCreatePayload{
		ScheduledJobs: res,
	}, nil
}

// bulkDeleteScheduledJob deletes multiple ScheduledJob entities by their IDs
func (r *mutationResolver) bulkDeleteScheduledJob(ctx context.Context, ids []string) (*model.ScheduledJobBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each scheduledjob individually to ensure proper cleanup
			if err := r.db.ScheduledJob.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("scheduledjob_id", id).Msg("failed to delete scheduledjob in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.ScheduledJobEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("scheduledjob_id", id).Msg("failed to cleanup scheduledjob edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some scheduledjob deletions failed")
	}

	return &model.ScheduledJobBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateSubcontrol uses the CreateBulk function to create multiple Subcontrol entities
func (r *mutationResolver) bulkCreateSubcontrol(ctx context.Context, input []*generated.CreateSubcontrolInput) (*model.SubcontrolBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.SubcontrolCreate, len(input))
	for i, data := range input {
		builders[i] = c.Subcontrol.Create().SetInput(*data)
	}

	res, err := c.Subcontrol.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "subcontrol"})
	}

	// return response
	return &model.SubcontrolBulkCreatePayload{
		Subcontrols: res,
	}, nil
}

// bulkDeleteSubcontrol deletes multiple Subcontrol entities by their IDs
func (r *mutationResolver) bulkDeleteSubcontrol(ctx context.Context, ids []string) (*model.SubcontrolBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each subcontrol individually to ensure proper cleanup
			if err := r.db.Subcontrol.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("subcontrol_id", id).Msg("failed to delete subcontrol in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.SubcontrolEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("subcontrol_id", id).Msg("failed to cleanup subcontrol edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some subcontrol deletions failed")
	}

	return &model.SubcontrolBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateSubprocessor uses the CreateBulk function to create multiple Subprocessor entities
func (r *mutationResolver) bulkCreateSubprocessor(ctx context.Context, input []*generated.CreateSubprocessorInput) (*model.SubprocessorBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.SubprocessorCreate, len(input))
	for i, data := range input {
		builders[i] = c.Subprocessor.Create().SetInput(*data)
	}

	res, err := c.Subprocessor.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "subprocessor"})
	}

	// return response
	return &model.SubprocessorBulkCreatePayload{
		Subprocessors: res,
	}, nil
}

// bulkUpdateSubprocessor updates multiple Subprocessor entities
func (r *mutationResolver) bulkUpdateSubprocessor(ctx context.Context, ids []string, input generated.UpdateSubprocessorInput) (*model.SubprocessorBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Subprocessor, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each subprocessor individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for subprocessor")
			continue
		}

		// get the existing entity first
		existing, err := c.Subprocessor.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("subprocessor_id", id).Msg("failed to get subprocessor in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("subprocessor_id", id).Msg("failed to update subprocessor in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.SubprocessorBulkUpdatePayload{
		Subprocessors: results,
		UpdatedIDs:    updatedIDs,
	}, nil
}

// bulkDeleteSubprocessor deletes multiple Subprocessor entities by their IDs
func (r *mutationResolver) bulkDeleteSubprocessor(ctx context.Context, ids []string) (*model.SubprocessorBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each subprocessor individually to ensure proper cleanup
			if err := r.db.Subprocessor.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("subprocessor_id", id).Msg("failed to delete subprocessor in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.SubprocessorEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("subprocessor_id", id).Msg("failed to cleanup subprocessor edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some subprocessor deletions failed")
	}

	return &model.SubprocessorBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateSubscriber uses the CreateBulk function to create multiple Subscriber entities
func (r *mutationResolver) bulkCreateSubscriber(ctx context.Context, input []*generated.CreateSubscriberInput) (*model.SubscriberBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.SubscriberCreate, len(input))
	for i, data := range input {
		builders[i] = c.Subscriber.Create().SetInput(*data)
	}

	res, err := c.Subscriber.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "subscriber"})
	}

	// return response
	return &model.SubscriberBulkCreatePayload{
		Subscribers: res,
	}, nil
}

// bulkCreateTagDefinition uses the CreateBulk function to create multiple TagDefinition entities
func (r *mutationResolver) bulkCreateTagDefinition(ctx context.Context, input []*generated.CreateTagDefinitionInput) (*model.TagDefinitionBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TagDefinitionCreate, len(input))
	for i, data := range input {
		builders[i] = c.TagDefinition.Create().SetInput(*data)
	}

	res, err := c.TagDefinition.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "tagdefinition"})
	}

	// return response
	return &model.TagDefinitionBulkCreatePayload{
		TagDefinitions: res,
	}, nil
}

// bulkCreateTask uses the CreateBulk function to create multiple Task entities
func (r *mutationResolver) bulkCreateTask(ctx context.Context, input []*generated.CreateTaskInput) (*model.TaskBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TaskCreate, len(input))
	for i, data := range input {
		builders[i] = c.Task.Create().SetInput(*data)
	}

	res, err := c.Task.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "task"})
	}

	// return response
	return &model.TaskBulkCreatePayload{
		Tasks: res,
	}, nil
}

// bulkUpdateTask updates multiple Task entities
func (r *mutationResolver) bulkUpdateTask(ctx context.Context, ids []string, input generated.UpdateTaskInput) (*model.TaskBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Task, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each task individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for task")
			continue
		}

		// get the existing entity first
		existing, err := c.Task.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("task_id", id).Msg("failed to get task in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("task_id", id).Msg("failed to update task in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.TaskBulkUpdatePayload{
		Tasks:      results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkDeleteTask deletes multiple Task entities by their IDs
func (r *mutationResolver) bulkDeleteTask(ctx context.Context, ids []string) (*model.TaskBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each task individually to ensure proper cleanup
			if err := r.db.Task.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("task_id", id).Msg("failed to delete task in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.TaskEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("task_id", id).Msg("failed to cleanup task edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some task deletions failed")
	}

	return &model.TaskBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateTemplate uses the CreateBulk function to create multiple Template entities
func (r *mutationResolver) bulkCreateTemplate(ctx context.Context, input []*generated.CreateTemplateInput) (*model.TemplateBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TemplateCreate, len(input))
	for i, data := range input {
		builders[i] = c.Template.Create().SetInput(*data)
	}

	res, err := c.Template.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "template"})
	}

	// return response
	return &model.TemplateBulkCreatePayload{
		Templates: res,
	}, nil
}

// bulkDeleteTemplate deletes multiple Template entities by their IDs
func (r *mutationResolver) bulkDeleteTemplate(ctx context.Context, ids []string) (*model.TemplateBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each template individually to ensure proper cleanup
			if err := r.db.Template.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("template_id", id).Msg("failed to delete template in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.TemplateEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("template_id", id).Msg("failed to cleanup template edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some template deletions failed")
	}

	return &model.TemplateBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateTrustCenterCompliance uses the CreateBulk function to create multiple TrustCenterCompliance entities
func (r *mutationResolver) bulkCreateTrustCenterCompliance(ctx context.Context, input []*generated.CreateTrustCenterComplianceInput) (*model.TrustCenterComplianceBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TrustCenterComplianceCreate, len(input))
	for i, data := range input {
		builders[i] = c.TrustCenterCompliance.Create().SetInput(*data)
	}

	res, err := c.TrustCenterCompliance.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "trustcentercompliance"})
	}

	// return response
	return &model.TrustCenterComplianceBulkCreatePayload{
		TrustCenterCompliances: res,
	}, nil
}

// bulkDeleteTrustCenterCompliance deletes multiple TrustCenterCompliance entities by their IDs
func (r *mutationResolver) bulkDeleteTrustCenterCompliance(ctx context.Context, ids []string) (*model.TrustCenterComplianceBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each trustcentercompliance individually to ensure proper cleanup
			if err := r.db.TrustCenterCompliance.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("trustcentercompliance_id", id).Msg("failed to delete trustcentercompliance in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.TrustCenterComplianceEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("trustcentercompliance_id", id).Msg("failed to cleanup trustcentercompliance edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some trustcentercompliance deletions failed")
	}

	return &model.TrustCenterComplianceBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateTrustCenterDoc uses the CreateBulk function to create multiple TrustCenterDoc entities
func (r *mutationResolver) bulkCreateTrustCenterDoc(ctx context.Context, input []*generated.CreateTrustCenterDocInput) (*model.TrustCenterDocBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TrustCenterDocCreate, len(input))
	for i, data := range input {
		builders[i] = c.TrustCenterDoc.Create().SetInput(*data)
	}

	res, err := c.TrustCenterDoc.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "trustcenterdoc"})
	}

	// return response
	return &model.TrustCenterDocBulkCreatePayload{
		TrustCenterDocs: res,
	}, nil
}

// bulkUpdateTrustCenterDoc updates multiple TrustCenterDoc entities
func (r *mutationResolver) bulkUpdateTrustCenterDoc(ctx context.Context, ids []string, input generated.UpdateTrustCenterDocInput) (*model.TrustCenterDocBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.TrustCenterDoc, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each trustcenterdoc individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for trustcenterdoc")
			continue
		}

		// get the existing entity first
		existing, err := c.TrustCenterDoc.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("trustcenterdoc_id", id).Msg("failed to get trustcenterdoc in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("trustcenterdoc_id", id).Msg("failed to update trustcenterdoc in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.TrustCenterDocBulkUpdatePayload{
		TrustCenterDocs: results,
		UpdatedIDs:      updatedIDs,
	}, nil
}

// bulkDeleteTrustCenterDoc deletes multiple TrustCenterDoc entities by their IDs
func (r *mutationResolver) bulkDeleteTrustCenterDoc(ctx context.Context, ids []string) (*model.TrustCenterDocBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each trustcenterdoc individually to ensure proper cleanup
			if err := r.db.TrustCenterDoc.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("trustcenterdoc_id", id).Msg("failed to delete trustcenterdoc in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.TrustCenterDocEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("trustcenterdoc_id", id).Msg("failed to cleanup trustcenterdoc edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some trustcenterdoc deletions failed")
	}

	return &model.TrustCenterDocBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateTrustCenterEntity uses the CreateBulk function to create multiple TrustCenterEntity entities
func (r *mutationResolver) bulkCreateTrustCenterEntity(ctx context.Context, input []*generated.CreateTrustCenterEntityInput) (*model.TrustCenterEntityBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TrustCenterEntityCreate, len(input))
	for i, data := range input {
		builders[i] = c.TrustCenterEntity.Create().SetInput(*data)
	}

	res, err := c.TrustCenterEntity.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "trustcenterentity"})
	}

	// return response
	return &model.TrustCenterEntityBulkCreatePayload{
		TrustCenterEntities: res,
	}, nil
}

// bulkCreateTrustCenterNDARequest uses the CreateBulk function to create multiple TrustCenterNDARequest entities
func (r *mutationResolver) bulkCreateTrustCenterNDARequest(ctx context.Context, input []*generated.CreateTrustCenterNDARequestInput) (*model.TrustCenterNDARequestBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TrustCenterNDARequestCreate, len(input))
	for i, data := range input {
		builders[i] = c.TrustCenterNDARequest.Create().SetInput(*data)
	}

	res, err := c.TrustCenterNDARequest.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "trustcenterndarequest"})
	}

	// return response
	return &model.TrustCenterNDARequestBulkCreatePayload{
		TrustCenterNDARequests: res,
	}, nil
}

// bulkCreateTrustCenterSubprocessor uses the CreateBulk function to create multiple TrustCenterSubprocessor entities
func (r *mutationResolver) bulkCreateTrustCenterSubprocessor(ctx context.Context, input []*generated.CreateTrustCenterSubprocessorInput) (*model.TrustCenterSubprocessorBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TrustCenterSubprocessorCreate, len(input))
	for i, data := range input {
		builders[i] = c.TrustCenterSubprocessor.Create().SetInput(*data)
	}

	res, err := c.TrustCenterSubprocessor.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "trustcentersubprocessor"})
	}

	// return response
	return &model.TrustCenterSubprocessorBulkCreatePayload{
		TrustCenterSubprocessors: res,
	}, nil
}

// bulkUpdateTrustCenterSubprocessor updates multiple TrustCenterSubprocessor entities
func (r *mutationResolver) bulkUpdateTrustCenterSubprocessor(ctx context.Context, ids []string, input generated.UpdateTrustCenterSubprocessorInput) (*model.TrustCenterSubprocessorBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.TrustCenterSubprocessor, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each trustcentersubprocessor individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			logx.FromContext(ctx).Error().Msg("empty id in bulk update for trustcentersubprocessor")
			continue
		}

		// get the existing entity first
		existing, err := c.TrustCenterSubprocessor.Get(ctx, id)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("trustcentersubprocessor_id", id).Msg("failed to get trustcentersubprocessor in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			logx.FromContext(ctx).Error().Err(err).Str("trustcentersubprocessor_id", id).Msg("failed to update trustcentersubprocessor in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.TrustCenterSubprocessorBulkUpdatePayload{
		TrustCenterSubprocessors: results,
		UpdatedIDs:               updatedIDs,
	}, nil
}

// bulkDeleteTrustCenterSubprocessor deletes multiple TrustCenterSubprocessor entities by their IDs
func (r *mutationResolver) bulkDeleteTrustCenterSubprocessor(ctx context.Context, ids []string) (*model.TrustCenterSubprocessorBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each trustcentersubprocessor individually to ensure proper cleanup
			if err := r.db.TrustCenterSubprocessor.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("trustcentersubprocessor_id", id).Msg("failed to delete trustcentersubprocessor in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.TrustCenterSubprocessorEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("trustcentersubprocessor_id", id).Msg("failed to cleanup trustcentersubprocessor edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some trustcentersubprocessor deletions failed")
	}

	return &model.TrustCenterSubprocessorBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateUserSetting uses the CreateBulk function to create multiple UserSetting entities
func (r *mutationResolver) bulkCreateUserSetting(ctx context.Context, input []*generated.CreateUserSettingInput) (*model.UserSettingBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.UserSettingCreate, len(input))
	for i, data := range input {
		builders[i] = c.UserSetting.Create().SetInput(*data)
	}

	res, err := c.UserSetting.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "usersetting"})
	}

	// return response
	return &model.UserSettingBulkCreatePayload{
		UserSettings: res,
	}, nil
}

// bulkDeleteUserSetting deletes multiple UserSetting entities by their IDs
func (r *mutationResolver) bulkDeleteUserSetting(ctx context.Context, ids []string) (*model.UserSettingBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))
	errors := make([]error, 0, len(ids))

	var mu sync.Mutex

	funcs := make([]func(), 0, len(ids))
	for _, id := range ids {
		funcs = append(funcs, func() {
			// delete each usersetting individually to ensure proper cleanup
			if err := r.db.UserSetting.DeleteOneID(id).Exec(ctx); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("usersetting_id", id).Msg("failed to delete usersetting in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			if err := generated.UserSettingEdgeCleanup(ctx, id); err != nil {
				logx.FromContext(ctx).Error().Err(err).Str("usersetting_id", id).Msg("failed to cleanup usersetting edges in bulk operation")
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			deletedIDs = append(deletedIDs, id)
			mu.Unlock()
		})
	}

	if err := r.withPool().SubmitMultipleAndWait(funcs); err != nil {
		return nil, err
	}

	if len(errors) > 0 {
		logx.FromContext(ctx).Error().Int("deleted_items", len(deletedIDs)).Int("errors", len(errors)).Msg("some usersetting deletions failed")
	}

	return &model.UserSettingBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateVulnerability uses the CreateBulk function to create multiple Vulnerability entities
func (r *mutationResolver) bulkCreateVulnerability(ctx context.Context, input []*generated.CreateVulnerabilityInput) (*model.VulnerabilityBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.VulnerabilityCreate, len(input))
	for i, data := range input {
		builders[i] = c.Vulnerability.Create().SetInput(*data)
	}

	res, err := c.Vulnerability.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "vulnerability"})
	}

	// return response
	return &model.VulnerabilityBulkCreatePayload{
		Vulnerabilities: res,
	}, nil
}

// bulkCreateWorkflowDefinition uses the CreateBulk function to create multiple WorkflowDefinition entities
func (r *mutationResolver) bulkCreateWorkflowDefinition(ctx context.Context, input []*generated.CreateWorkflowDefinitionInput) (*model.WorkflowDefinitionBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.WorkflowDefinitionCreate, len(input))
	for i, data := range input {
		builders[i] = c.WorkflowDefinition.Create().SetInput(*data)
	}

	res, err := c.WorkflowDefinition.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "workflowdefinition"})
	}

	// return response
	return &model.WorkflowDefinitionBulkCreatePayload{
		WorkflowDefinitions: res,
	}, nil
}

// bulkCreateWorkflowEvent uses the CreateBulk function to create multiple WorkflowEvent entities
func (r *mutationResolver) bulkCreateWorkflowEvent(ctx context.Context, input []*generated.CreateWorkflowEventInput) (*model.WorkflowEventBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.WorkflowEventCreate, len(input))
	for i, data := range input {
		builders[i] = c.WorkflowEvent.Create().SetInput(*data)
	}

	res, err := c.WorkflowEvent.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "workflowevent"})
	}

	// return response
	return &model.WorkflowEventBulkCreatePayload{
		WorkflowEvents: res,
	}, nil
}

// bulkCreateWorkflowObjectRef uses the CreateBulk function to create multiple WorkflowObjectRef entities
func (r *mutationResolver) bulkCreateWorkflowObjectRef(ctx context.Context, input []*generated.CreateWorkflowObjectRefInput) (*model.WorkflowObjectRefBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.WorkflowObjectRefCreate, len(input))
	for i, data := range input {
		builders[i] = c.WorkflowObjectRef.Create().SetInput(*data)
	}

	res, err := c.WorkflowObjectRef.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "workflowobjectref"})
	}

	// return response
	return &model.WorkflowObjectRefBulkCreatePayload{
		WorkflowObjectRefs: res,
	}, nil
}
