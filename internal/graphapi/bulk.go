package graphapi

// THIS CODE IS REGENERATED BY github.com/theopenlane/core/pkg/gqlplugin. DO NOT EDIT.

import (
	"context"

	"github.com/rs/zerolog/log"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/utils/rout"
)

// bulkCreateActionPlan uses the CreateBulk function to create multiple ActionPlan entities
func (r *mutationResolver) bulkCreateActionPlan(ctx context.Context, input []*generated.CreateActionPlanInput) (*model.ActionPlanBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ActionPlanCreate, len(input))
	for i, data := range input {
		builders[i] = c.ActionPlan.Create().SetInput(*data)
	}

	res, err := c.ActionPlan.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "actionplan"})
	}

	// return response
	return &model.ActionPlanBulkCreatePayload{
		ActionPlans: res,
	}, nil
}

// bulkUpdateActionPlan updates multiple ActionPlan entities
func (r *mutationResolver) bulkUpdateActionPlan(ctx context.Context, ids []string, input generated.UpdateActionPlanInput) (*model.ActionPlanBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.ActionPlan, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each actionplan individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for actionplan")
			continue
		}

		// get the existing entity first
		existing, err := c.ActionPlan.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("actionplan_id", id).Msg("failed to get actionplan in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("actionplan_id", id).Msg("failed to update actionplan in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ActionPlanBulkUpdatePayload{
		ActionPlans: results,
		UpdatedIDs:  updatedIDs,
	}, nil
}

// bulkCreateAPIToken uses the CreateBulk function to create multiple APIToken entities
func (r *mutationResolver) bulkCreateAPIToken(ctx context.Context, input []*generated.CreateAPITokenInput) (*model.APITokenBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.APITokenCreate, len(input))
	for i, data := range input {
		builders[i] = c.APIToken.Create().SetInput(*data)
	}

	res, err := c.APIToken.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "apitoken"})
	}

	// return response
	return &model.APITokenBulkCreatePayload{
		APITokens: res,
	}, nil
}

// bulkCreateAsset uses the CreateBulk function to create multiple Asset entities
func (r *mutationResolver) bulkCreateAsset(ctx context.Context, input []*generated.CreateAssetInput) (*model.AssetBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.AssetCreate, len(input))
	for i, data := range input {
		builders[i] = c.Asset.Create().SetInput(*data)
	}

	res, err := c.Asset.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "asset"})
	}

	// return response
	return &model.AssetBulkCreatePayload{
		Assets: res,
	}, nil
}

// bulkCreateContact uses the CreateBulk function to create multiple Contact entities
func (r *mutationResolver) bulkCreateContact(ctx context.Context, input []*generated.CreateContactInput) (*model.ContactBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ContactCreate, len(input))
	for i, data := range input {
		builders[i] = c.Contact.Create().SetInput(*data)
	}

	res, err := c.Contact.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "contact"})
	}

	// return response
	return &model.ContactBulkCreatePayload{
		Contacts: res,
	}, nil
}

// bulkUpdateContact updates multiple Contact entities
func (r *mutationResolver) bulkUpdateContact(ctx context.Context, ids []string, input generated.UpdateContactInput) (*model.ContactBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Contact, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each contact individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for contact")
			continue
		}

		// get the existing entity first
		existing, err := c.Contact.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("contact_id", id).Msg("failed to get contact in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("contact_id", id).Msg("failed to update contact in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ContactBulkUpdatePayload{
		Contacts:   results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkCreateControl uses the CreateBulk function to create multiple Control entities
func (r *mutationResolver) bulkCreateControl(ctx context.Context, input []*generated.CreateControlInput) (*model.ControlBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ControlCreate, len(input))
	for i, data := range input {
		builders[i] = c.Control.Create().SetInput(*data)
	}

	res, err := c.Control.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "control"})
	}

	// return response
	return &model.ControlBulkCreatePayload{
		Controls: res,
	}, nil
}

// bulkUpdateControl updates multiple Control entities
func (r *mutationResolver) bulkUpdateControl(ctx context.Context, ids []string, input generated.UpdateControlInput) (*model.ControlBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Control, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each control individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for control")
			continue
		}

		// get the existing entity first
		existing, err := c.Control.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("control_id", id).Msg("failed to get control in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("control_id", id).Msg("failed to update control in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ControlBulkUpdatePayload{
		Controls:   results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkCreateControlImplementation uses the CreateBulk function to create multiple ControlImplementation entities
func (r *mutationResolver) bulkCreateControlImplementation(ctx context.Context, input []*generated.CreateControlImplementationInput) (*model.ControlImplementationBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ControlImplementationCreate, len(input))
	for i, data := range input {
		builders[i] = c.ControlImplementation.Create().SetInput(*data)
	}

	res, err := c.ControlImplementation.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "controlimplementation"})
	}

	// return response
	return &model.ControlImplementationBulkCreatePayload{
		ControlImplementations: res,
	}, nil
}

// bulkCreateControlObjective uses the CreateBulk function to create multiple ControlObjective entities
func (r *mutationResolver) bulkCreateControlObjective(ctx context.Context, input []*generated.CreateControlObjectiveInput) (*model.ControlObjectiveBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ControlObjectiveCreate, len(input))
	for i, data := range input {
		builders[i] = c.ControlObjective.Create().SetInput(*data)
	}

	res, err := c.ControlObjective.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "controlobjective"})
	}

	// return response
	return &model.ControlObjectiveBulkCreatePayload{
		ControlObjectives: res,
	}, nil
}

// bulkCreateCustomDomain uses the CreateBulk function to create multiple CustomDomain entities
func (r *mutationResolver) bulkCreateCustomDomain(ctx context.Context, input []*generated.CreateCustomDomainInput) (*model.CustomDomainBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.CustomDomainCreate, len(input))
	for i, data := range input {
		builders[i] = c.CustomDomain.Create().SetInput(*data)
	}

	res, err := c.CustomDomain.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "customdomain"})
	}

	// return response
	return &model.CustomDomainBulkCreatePayload{
		CustomDomains: res,
	}, nil
}

// bulkCreateDNSVerification uses the CreateBulk function to create multiple DNSVerification entities
func (r *mutationResolver) bulkCreateDNSVerification(ctx context.Context, input []*generated.CreateDNSVerificationInput) (*model.DNSVerificationBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DNSVerificationCreate, len(input))
	for i, data := range input {
		builders[i] = c.DNSVerification.Create().SetInput(*data)
	}

	res, err := c.DNSVerification.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "dnsverification"})
	}

	// return response
	return &model.DNSVerificationBulkCreatePayload{
		DNSVerifications: res,
	}, nil
}

// bulkCreateDocumentData uses the CreateBulk function to create multiple DocumentData entities
func (r *mutationResolver) bulkCreateDocumentData(ctx context.Context, input []*generated.CreateDocumentDataInput) (*model.DocumentDataBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.DocumentDataCreate, len(input))
	for i, data := range input {
		builders[i] = c.DocumentData.Create().SetInput(*data)
	}

	res, err := c.DocumentData.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "documentdata"})
	}

	// return response
	return &model.DocumentDataBulkCreatePayload{
		DocumentData: res,
	}, nil
}

// bulkCreateEntity uses the CreateBulk function to create multiple Entity entities
func (r *mutationResolver) bulkCreateEntity(ctx context.Context, input []*generated.CreateEntityInput) (*model.EntityBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.EntityCreate, len(input))
	for i, data := range input {
		builders[i] = c.Entity.Create().SetInput(*data)
	}

	res, err := c.Entity.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "entity"})
	}

	// return response
	return &model.EntityBulkCreatePayload{
		Entities: res,
	}, nil
}

// bulkCreateEntityType uses the CreateBulk function to create multiple EntityType entities
func (r *mutationResolver) bulkCreateEntityType(ctx context.Context, input []*generated.CreateEntityTypeInput) (*model.EntityTypeBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.EntityTypeCreate, len(input))
	for i, data := range input {
		builders[i] = c.EntityType.Create().SetInput(*data)
	}

	res, err := c.EntityType.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "entitytype"})
	}

	// return response
	return &model.EntityTypeBulkCreatePayload{
		EntityTypes: res,
	}, nil
}

// bulkCreateEvent uses the CreateBulk function to create multiple Event entities
func (r *mutationResolver) bulkCreateEvent(ctx context.Context, input []*generated.CreateEventInput) (*model.EventBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.EventCreate, len(input))
	for i, data := range input {
		builders[i] = c.Event.Create().SetInput(*data)
	}

	res, err := c.Event.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "event"})
	}

	// return response
	return &model.EventBulkCreatePayload{
		Events: res,
	}, nil
}

// bulkDeleteExport deletes multiple Export entities by their IDs
func (r *mutationResolver) bulkDeleteExport(ctx context.Context, ids []string) (*model.ExportBulkDeletePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	deletedIDs := make([]string, 0, len(ids))

	// delete each export individually to ensure proper cleanup
	for _, id := range ids {
		if err := withTransactionalMutation(ctx).Export.DeleteOneID(id).Exec(ctx); err != nil {
			log.Error().Err(err).Str("export_id", id).Msg("failed to delete export in bulk operation")
			continue
		}

		// call edge cleanup if the function exists
		if err := generated.ExportEdgeCleanup(ctx, id); err != nil {
			log.Error().Err(err).Str("export_id", id).Msg("failed to cleanup export edges in bulk operation")
			continue
		}

		deletedIDs = append(deletedIDs, id)
	}

	return &model.ExportBulkDeletePayload{
		DeletedIDs: deletedIDs,
	}, nil
}

// bulkCreateGroup uses the CreateBulk function to create multiple Group entities
func (r *mutationResolver) bulkCreateGroup(ctx context.Context, input []*generated.CreateGroupInput) (*model.GroupBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.GroupCreate, len(input))
	for i, data := range input {
		builders[i] = c.Group.Create().SetInput(*data)
	}

	res, err := c.Group.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "group"})
	}

	// return response
	return &model.GroupBulkCreatePayload{
		Groups: res,
	}, nil
}

// bulkCreateGroupMembership uses the CreateBulk function to create multiple GroupMembership entities
func (r *mutationResolver) bulkCreateGroupMembership(ctx context.Context, input []*generated.CreateGroupMembershipInput) (*model.GroupMembershipBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.GroupMembershipCreate, len(input))
	for i, data := range input {
		builders[i] = c.GroupMembership.Create().SetInput(*data)
	}

	res, err := c.GroupMembership.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "groupmembership"})
	}

	// return response
	return &model.GroupMembershipBulkCreatePayload{
		GroupMemberships: res,
	}, nil
}

// bulkCreateGroupSetting uses the CreateBulk function to create multiple GroupSetting entities
func (r *mutationResolver) bulkCreateGroupSetting(ctx context.Context, input []*generated.CreateGroupSettingInput) (*model.GroupSettingBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.GroupSettingCreate, len(input))
	for i, data := range input {
		builders[i] = c.GroupSetting.Create().SetInput(*data)
	}

	res, err := c.GroupSetting.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "groupsetting"})
	}

	// return response
	return &model.GroupSettingBulkCreatePayload{
		GroupSettings: res,
	}, nil
}

// bulkCreateHush uses the CreateBulk function to create multiple Hush entities
func (r *mutationResolver) bulkCreateHush(ctx context.Context, input []*generated.CreateHushInput) (*model.HushBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.HushCreate, len(input))
	for i, data := range input {
		builders[i] = c.Hush.Create().SetInput(*data)
	}

	res, err := c.Hush.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "hush"})
	}

	// return response
	return &model.HushBulkCreatePayload{
		Hushes: res,
	}, nil
}

// bulkUpdateHush updates multiple Hush entities
func (r *mutationResolver) bulkUpdateHush(ctx context.Context, ids []string, input generated.UpdateHushInput) (*model.HushBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Hush, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each hush individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for hush")
			continue
		}

		// get the existing entity first
		existing, err := c.Hush.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("hush_id", id).Msg("failed to get hush in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("hush_id", id).Msg("failed to update hush in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.HushBulkUpdatePayload{
		Hushes:     results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkCreateInternalPolicy uses the CreateBulk function to create multiple InternalPolicy entities
func (r *mutationResolver) bulkCreateInternalPolicy(ctx context.Context, input []*generated.CreateInternalPolicyInput) (*model.InternalPolicyBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.InternalPolicyCreate, len(input))
	for i, data := range input {
		builders[i] = c.InternalPolicy.Create().SetInput(*data)
	}

	res, err := c.InternalPolicy.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "internalpolicy"})
	}

	// return response
	return &model.InternalPolicyBulkCreatePayload{
		InternalPolicies: res,
	}, nil
}

// bulkUpdateInternalPolicy updates multiple InternalPolicy entities
func (r *mutationResolver) bulkUpdateInternalPolicy(ctx context.Context, ids []string, input generated.UpdateInternalPolicyInput) (*model.InternalPolicyBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.InternalPolicy, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each internalpolicy individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for internalpolicy")
			continue
		}

		// get the existing entity first
		existing, err := c.InternalPolicy.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("internalpolicy_id", id).Msg("failed to get internalpolicy in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("internalpolicy_id", id).Msg("failed to update internalpolicy in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.InternalPolicyBulkUpdatePayload{
		InternalPolicies: results,
		UpdatedIDs:       updatedIDs,
	}, nil
}

// bulkCreateInvite uses the CreateBulk function to create multiple Invite entities
func (r *mutationResolver) bulkCreateInvite(ctx context.Context, input []*generated.CreateInviteInput) (*model.InviteBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.InviteCreate, len(input))
	for i, data := range input {
		builders[i] = c.Invite.Create().SetInput(*data)
	}

	res, err := c.Invite.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "invite"})
	}

	// return response
	return &model.InviteBulkCreatePayload{
		Invites: res,
	}, nil
}

// bulkCreateJobTemplate uses the CreateBulk function to create multiple JobTemplate entities
func (r *mutationResolver) bulkCreateJobTemplate(ctx context.Context, input []*generated.CreateJobTemplateInput) (*model.JobTemplateBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.JobTemplateCreate, len(input))
	for i, data := range input {
		builders[i] = c.JobTemplate.Create().SetInput(*data)
	}

	res, err := c.JobTemplate.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "jobtemplate"})
	}

	// return response
	return &model.JobTemplateBulkCreatePayload{
		JobTemplates: res,
	}, nil
}

// bulkCreateMappableDomain uses the CreateBulk function to create multiple MappableDomain entities
func (r *mutationResolver) bulkCreateMappableDomain(ctx context.Context, input []*generated.CreateMappableDomainInput) (*model.MappableDomainBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.MappableDomainCreate, len(input))
	for i, data := range input {
		builders[i] = c.MappableDomain.Create().SetInput(*data)
	}

	res, err := c.MappableDomain.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "mappabledomain"})
	}

	// return response
	return &model.MappableDomainBulkCreatePayload{
		MappableDomains: res,
	}, nil
}

// bulkCreateMappedControl uses the CreateBulk function to create multiple MappedControl entities
func (r *mutationResolver) bulkCreateMappedControl(ctx context.Context, input []*generated.CreateMappedControlInput) (*model.MappedControlBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.MappedControlCreate, len(input))
	for i, data := range input {
		builders[i] = c.MappedControl.Create().SetInput(*data)
	}

	res, err := c.MappedControl.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "mappedcontrol"})
	}

	// return response
	return &model.MappedControlBulkCreatePayload{
		MappedControls: res,
	}, nil
}

// bulkCreateNarrative uses the CreateBulk function to create multiple Narrative entities
func (r *mutationResolver) bulkCreateNarrative(ctx context.Context, input []*generated.CreateNarrativeInput) (*model.NarrativeBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.NarrativeCreate, len(input))
	for i, data := range input {
		builders[i] = c.Narrative.Create().SetInput(*data)
	}

	res, err := c.Narrative.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "narrative"})
	}

	// return response
	return &model.NarrativeBulkCreatePayload{
		Narratives: res,
	}, nil
}

// bulkCreateOrganizationSetting uses the CreateBulk function to create multiple OrganizationSetting entities
func (r *mutationResolver) bulkCreateOrganizationSetting(ctx context.Context, input []*generated.CreateOrganizationSettingInput) (*model.OrganizationSettingBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.OrganizationSettingCreate, len(input))
	for i, data := range input {
		builders[i] = c.OrganizationSetting.Create().SetInput(*data)
	}

	res, err := c.OrganizationSetting.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "organizationsetting"})
	}

	// return response
	return &model.OrganizationSettingBulkCreatePayload{
		OrganizationSettings: res,
	}, nil
}

// bulkCreateOrgMembership uses the CreateBulk function to create multiple OrgMembership entities
func (r *mutationResolver) bulkCreateOrgMembership(ctx context.Context, input []*generated.CreateOrgMembershipInput) (*model.OrgMembershipBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.OrgMembershipCreate, len(input))
	for i, data := range input {
		builders[i] = c.OrgMembership.Create().SetInput(*data)
	}

	res, err := c.OrgMembership.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "orgmembership"})
	}

	// return response
	return &model.OrgMembershipBulkCreatePayload{
		OrgMemberships: res,
	}, nil
}

// bulkCreateProcedure uses the CreateBulk function to create multiple Procedure entities
func (r *mutationResolver) bulkCreateProcedure(ctx context.Context, input []*generated.CreateProcedureInput) (*model.ProcedureBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ProcedureCreate, len(input))
	for i, data := range input {
		builders[i] = c.Procedure.Create().SetInput(*data)
	}

	res, err := c.Procedure.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "procedure"})
	}

	// return response
	return &model.ProcedureBulkCreatePayload{
		Procedures: res,
	}, nil
}

// bulkUpdateProcedure updates multiple Procedure entities
func (r *mutationResolver) bulkUpdateProcedure(ctx context.Context, ids []string, input generated.UpdateProcedureInput) (*model.ProcedureBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Procedure, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each procedure individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for procedure")
			continue
		}

		// get the existing entity first
		existing, err := c.Procedure.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("procedure_id", id).Msg("failed to get procedure in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("procedure_id", id).Msg("failed to update procedure in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ProcedureBulkUpdatePayload{
		Procedures: results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkCreateProgram uses the CreateBulk function to create multiple Program entities
func (r *mutationResolver) bulkCreateProgram(ctx context.Context, input []*generated.CreateProgramInput) (*model.ProgramBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ProgramCreate, len(input))
	for i, data := range input {
		builders[i] = c.Program.Create().SetInput(*data)
	}

	res, err := c.Program.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "program"})
	}

	// return response
	return &model.ProgramBulkCreatePayload{
		Programs: res,
	}, nil
}

// bulkCreateProgramMembership uses the CreateBulk function to create multiple ProgramMembership entities
func (r *mutationResolver) bulkCreateProgramMembership(ctx context.Context, input []*generated.CreateProgramMembershipInput) (*model.ProgramMembershipBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ProgramMembershipCreate, len(input))
	for i, data := range input {
		builders[i] = c.ProgramMembership.Create().SetInput(*data)
	}

	res, err := c.ProgramMembership.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "programmembership"})
	}

	// return response
	return &model.ProgramMembershipBulkCreatePayload{
		ProgramMemberships: res,
	}, nil
}

// bulkCreateRisk uses the CreateBulk function to create multiple Risk entities
func (r *mutationResolver) bulkCreateRisk(ctx context.Context, input []*generated.CreateRiskInput) (*model.RiskBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.RiskCreate, len(input))
	for i, data := range input {
		builders[i] = c.Risk.Create().SetInput(*data)
	}

	res, err := c.Risk.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "risk"})
	}

	// return response
	return &model.RiskBulkCreatePayload{
		Risks: res,
	}, nil
}

// bulkUpdateRisk updates multiple Risk entities
func (r *mutationResolver) bulkUpdateRisk(ctx context.Context, ids []string, input generated.UpdateRiskInput) (*model.RiskBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Risk, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each risk individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for risk")
			continue
		}

		// get the existing entity first
		existing, err := c.Risk.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("risk_id", id).Msg("failed to get risk in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("risk_id", id).Msg("failed to update risk in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.RiskBulkUpdatePayload{
		Risks:      results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkCreateScan uses the CreateBulk function to create multiple Scan entities
func (r *mutationResolver) bulkCreateScan(ctx context.Context, input []*generated.CreateScanInput) (*model.ScanBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ScanCreate, len(input))
	for i, data := range input {
		builders[i] = c.Scan.Create().SetInput(*data)
	}

	res, err := c.Scan.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "scan"})
	}

	// return response
	return &model.ScanBulkCreatePayload{
		Scans: res,
	}, nil
}

// bulkUpdateScan updates multiple Scan entities
func (r *mutationResolver) bulkUpdateScan(ctx context.Context, ids []string, input generated.UpdateScanInput) (*model.ScanBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Scan, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each scan individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for scan")
			continue
		}

		// get the existing entity first
		existing, err := c.Scan.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("scan_id", id).Msg("failed to get scan in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("scan_id", id).Msg("failed to update scan in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.ScanBulkUpdatePayload{
		Scans:      results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkCreateScheduledJob uses the CreateBulk function to create multiple ScheduledJob entities
func (r *mutationResolver) bulkCreateScheduledJob(ctx context.Context, input []*generated.CreateScheduledJobInput) (*model.ScheduledJobBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.ScheduledJobCreate, len(input))
	for i, data := range input {
		builders[i] = c.ScheduledJob.Create().SetInput(*data)
	}

	res, err := c.ScheduledJob.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "scheduledjob"})
	}

	// return response
	return &model.ScheduledJobBulkCreatePayload{
		ScheduledJobs: res,
	}, nil
}

// bulkCreateSubcontrol uses the CreateBulk function to create multiple Subcontrol entities
func (r *mutationResolver) bulkCreateSubcontrol(ctx context.Context, input []*generated.CreateSubcontrolInput) (*model.SubcontrolBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.SubcontrolCreate, len(input))
	for i, data := range input {
		builders[i] = c.Subcontrol.Create().SetInput(*data)
	}

	res, err := c.Subcontrol.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "subcontrol"})
	}

	// return response
	return &model.SubcontrolBulkCreatePayload{
		Subcontrols: res,
	}, nil
}

// bulkCreateSubprocessor uses the CreateBulk function to create multiple Subprocessor entities
func (r *mutationResolver) bulkCreateSubprocessor(ctx context.Context, input []*generated.CreateSubprocessorInput) (*model.SubprocessorBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.SubprocessorCreate, len(input))
	for i, data := range input {
		builders[i] = c.Subprocessor.Create().SetInput(*data)
	}

	res, err := c.Subprocessor.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "subprocessor"})
	}

	// return response
	return &model.SubprocessorBulkCreatePayload{
		Subprocessors: res,
	}, nil
}

// bulkCreateSubscriber uses the CreateBulk function to create multiple Subscriber entities
func (r *mutationResolver) bulkCreateSubscriber(ctx context.Context, input []*generated.CreateSubscriberInput) (*model.SubscriberBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.SubscriberCreate, len(input))
	for i, data := range input {
		builders[i] = c.Subscriber.Create().SetInput(*data)
	}

	res, err := c.Subscriber.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "subscriber"})
	}

	// return response
	return &model.SubscriberBulkCreatePayload{
		Subscribers: res,
	}, nil
}

// bulkCreateTask uses the CreateBulk function to create multiple Task entities
func (r *mutationResolver) bulkCreateTask(ctx context.Context, input []*generated.CreateTaskInput) (*model.TaskBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TaskCreate, len(input))
	for i, data := range input {
		builders[i] = c.Task.Create().SetInput(*data)
	}

	res, err := c.Task.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "task"})
	}

	// return response
	return &model.TaskBulkCreatePayload{
		Tasks: res,
	}, nil
}

// bulkUpdateTask updates multiple Task entities
func (r *mutationResolver) bulkUpdateTask(ctx context.Context, ids []string, input generated.UpdateTaskInput) (*model.TaskBulkUpdatePayload, error) {
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	c := withTransactionalMutation(ctx)
	results := make([]*generated.Task, 0, len(ids))
	updatedIDs := make([]string, 0, len(ids))

	// update each task individually to ensure proper validation
	for _, id := range ids {
		if id == "" {
			log.Error().Msg("empty id in bulk update for task")
			continue
		}

		// get the existing entity first
		existing, err := c.Task.Get(ctx, id)
		if err != nil {
			log.Error().Err(err).Str("task_id", id).Msg("failed to get task in bulk update operation")
			continue
		}

		// setup update request
		updatedEntity, err := existing.Update().SetInput(input).Save(ctx)
		if err != nil {
			log.Error().Err(err).Str("task_id", id).Msg("failed to update task in bulk operation")
			continue
		}

		results = append(results, updatedEntity)
		updatedIDs = append(updatedIDs, id)
	}

	return &model.TaskBulkUpdatePayload{
		Tasks:      results,
		UpdatedIDs: updatedIDs,
	}, nil
}

// bulkCreateTemplate uses the CreateBulk function to create multiple Template entities
func (r *mutationResolver) bulkCreateTemplate(ctx context.Context, input []*generated.CreateTemplateInput) (*model.TemplateBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TemplateCreate, len(input))
	for i, data := range input {
		builders[i] = c.Template.Create().SetInput(*data)
	}

	res, err := c.Template.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "template"})
	}

	// return response
	return &model.TemplateBulkCreatePayload{
		Templates: res,
	}, nil
}

// bulkCreateTrustCenterCompliance uses the CreateBulk function to create multiple TrustCenterCompliance entities
func (r *mutationResolver) bulkCreateTrustCenterCompliance(ctx context.Context, input []*generated.CreateTrustCenterComplianceInput) (*model.TrustCenterComplianceBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TrustCenterComplianceCreate, len(input))
	for i, data := range input {
		builders[i] = c.TrustCenterCompliance.Create().SetInput(*data)
	}

	res, err := c.TrustCenterCompliance.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "trustcentercompliance"})
	}

	// return response
	return &model.TrustCenterComplianceBulkCreatePayload{
		TrustCenterCompliances: res,
	}, nil
}

// bulkCreateTrustCenterDoc uses the CreateBulk function to create multiple TrustCenterDoc entities
func (r *mutationResolver) bulkCreateTrustCenterDoc(ctx context.Context, input []*generated.CreateTrustCenterDocInput) (*model.TrustCenterDocBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TrustCenterDocCreate, len(input))
	for i, data := range input {
		builders[i] = c.TrustCenterDoc.Create().SetInput(*data)
	}

	res, err := c.TrustCenterDoc.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "trustcenterdoc"})
	}

	// return response
	return &model.TrustCenterDocBulkCreatePayload{
		TrustCenterDocs: res,
	}, nil
}

// bulkCreateTrustCenterSubprocessor uses the CreateBulk function to create multiple TrustCenterSubprocessor entities
func (r *mutationResolver) bulkCreateTrustCenterSubprocessor(ctx context.Context, input []*generated.CreateTrustCenterSubprocessorInput) (*model.TrustCenterSubprocessorBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.TrustCenterSubprocessorCreate, len(input))
	for i, data := range input {
		builders[i] = c.TrustCenterSubprocessor.Create().SetInput(*data)
	}

	res, err := c.TrustCenterSubprocessor.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "trustcentersubprocessor"})
	}

	// return response
	return &model.TrustCenterSubprocessorBulkCreatePayload{
		TrustCenterSubprocessors: res,
	}, nil
}

// bulkCreateUserSetting uses the CreateBulk function to create multiple UserSetting entities
func (r *mutationResolver) bulkCreateUserSetting(ctx context.Context, input []*generated.CreateUserSettingInput) (*model.UserSettingBulkCreatePayload, error) {
	c := withTransactionalMutation(ctx)
	builders := make([]*generated.UserSettingCreate, len(input))
	for i, data := range input {
		builders[i] = c.UserSetting.Create().SetInput(*data)
	}

	res, err := c.UserSetting.CreateBulk(builders...).Save(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "usersetting"})
	}

	// return response
	return &model.UserSettingBulkCreatePayload{
		UserSettings: res,
	}, nil
}
