package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"

	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/workflowgenerated"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/internal/workflows/resolvers"
)

// WorkflowMetadata is a resolver for the UI to allow composition of CEL statements based on eligible fields and objects
// its intentionally public and doesn't have any access restrictions as it only exposes metadata
func (r *queryResolver) WorkflowMetadata(ctx context.Context) (*model.WorkflowMetadata, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}
	meta := generated.GetWorkflowMetadata()
	allResolverKeys := resolvers.Keys()

	objectTypes := make([]*model.WorkflowObjectTypeMetadata, 0, len(meta))
	for _, m := range meta {
		fields := make([]*model.WorkflowFieldMetadata, 0, len(m.EligibleFields))
		for _, f := range m.EligibleFields {
			fields = append(fields, &model.WorkflowFieldMetadata{
				Name:  f.Name,
				Label: f.Label,
				Type:  f.Type,
			})
		}

		edges := workflowgenerated.WorkflowEligibleEdges[m.Type.String()]
		if edges == nil {
			edges = []string{}
		} else {
			// Copy to avoid exposing the shared backing array.
			edges = append([]string(nil), edges...)
		}

		objectTypes = append(objectTypes, &model.WorkflowObjectTypeMetadata{
			Type:           m.Type.String(),
			Label:          m.Label,
			Description:    m.Description,
			EligibleFields: fields,
			EligibleEdges:  edges,
			ResolverKeys:   allResolverKeys,
		})
	}

	return &model.WorkflowMetadata{
		ObjectTypes: objectTypes,
	}, nil
}
