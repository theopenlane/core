// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgenerated

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/pkg/enums"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _GroupPermission_objectType(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermission) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermission_objectType,
		func(ctx context.Context) (any, error) { return obj.ObjectType, nil },
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupPermission_objectType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermission_permissions(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermission) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermission_permissions,
		func(ctx context.Context) (any, error) { return obj.Permissions, nil },
		nil,
		ec.marshalNPermission2githubᚗcomᚋtheopenlaneᚋcoreᚋpkgᚋenumsᚐPermission,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupPermission_permissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Permission does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermission_id(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermission) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermission_id,
		func(ctx context.Context) (any, error) { return obj.ID, nil },
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupPermission_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermission_displayID(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermission) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermission_displayID,
		func(ctx context.Context) (any, error) { return obj.DisplayID, nil },
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GroupPermission_displayID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermission_name(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermission) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermission_name,
		func(ctx context.Context) (any, error) { return obj.Name, nil },
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GroupPermission_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermission",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermissionConnection_edges(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermissionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermissionConnection_edges,
		func(ctx context.Context) (any, error) { return obj.Edges, nil },
		nil,
		ec.marshalOGroupPermissionEdge2ᚕᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionEdge,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GroupPermissionConnection_edges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermissionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_GroupPermissionEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_GroupPermissionEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupPermissionEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermissionConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermissionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermissionConnection_pageInfo,
		func(ctx context.Context) (any, error) { return obj.PageInfo, nil },
		nil,
		ec.marshalNPageInfo2ᚖentgoᚗioᚋcontribᚋentgqlᚐPageInfo,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupPermissionConnection_pageInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermissionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermissionConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermissionConnection) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermissionConnection_totalCount,
		func(ctx context.Context) (any, error) { return obj.TotalCount, nil },
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupPermissionConnection_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermissionConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermissionEdge_node(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermissionEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermissionEdge_node,
		func(ctx context.Context) (any, error) { return obj.Node, nil },
		nil,
		ec.marshalOGroupPermission2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermission,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_GroupPermissionEdge_node(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermissionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "objectType":
				return ec.fieldContext_GroupPermission_objectType(ctx, field)
			case "permissions":
				return ec.fieldContext_GroupPermission_permissions(ctx, field)
			case "id":
				return ec.fieldContext_GroupPermission_id(ctx, field)
			case "displayID":
				return ec.fieldContext_GroupPermission_displayID(ctx, field)
			case "name":
				return ec.fieldContext_GroupPermission_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupPermission", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupPermissionEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *model.GroupPermissionEdge) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_GroupPermissionEdge_cursor,
		func(ctx context.Context) (any, error) { return obj.Cursor, nil },
		nil,
		ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_GroupPermissionEdge_cursor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupPermissionEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputGroupMembersInput(ctx context.Context, obj any) (model.GroupMembersInput, error) {
	var it model.GroupMembersInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"role", "userID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "role":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
			data, err := ec.unmarshalOGroupMembershipRole2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋpkgᚋenumsᚐRole(ctx, v)
			if err != nil {
				return it, err
			}
			it.Role = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGroupPermissionOrder(ctx context.Context, obj any) (model.GroupPermissionOrder, error) {
	var it model.GroupPermissionOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNGroupPermissionOrderField2githubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGroupPermissionWhereInput(ctx context.Context, obj any) (model.GroupPermissionWhereInput, error) {
	var it model.GroupPermissionWhereInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "objectType", "objectTypeNEQ", "objectTypeIn", "objectTypeNotIn", "objectTypeGT", "objectTypeGTE", "objectTypeLT", "objectTypeLTE", "objectTypeContains", "objectTypeHasPrefix", "objectTypeHasSuffix", "objectTypeIsNil", "objectTypeNotNil", "objectTypeEqualFold", "objectTypeContainsFold", "permission", "permissionNEQ", "permissionIn", "permissionNotIn", "permissionGT", "permissionGTE", "permissionLT", "permissionLTE", "permissionContains", "permissionHasPrefix", "permissionHasSuffix", "permissionIsNil", "permissionNotNil", "permissionEqualFold", "permissionContainsFold"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOGroupPermissionWhereInput2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOGroupPermissionWhereInput2ᚕᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOGroupPermissionWhereInput2ᚕᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNeq = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGt = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGte = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLt = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLte = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "objectType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectType = data
		case "objectTypeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeNeq = data
		case "objectTypeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeIn = data
		case "objectTypeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeNotIn = data
		case "objectTypeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeGt = data
		case "objectTypeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeGte = data
		case "objectTypeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeLt = data
		case "objectTypeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeLte = data
		case "objectTypeContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeContains = data
		case "objectTypeHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeHasPrefix = data
		case "objectTypeHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeHasSuffix = data
		case "objectTypeIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeIsNil"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeIsNil = data
		case "objectTypeNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeNotNil"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeNotNil = data
		case "objectTypeEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeEqualFold = data
		case "objectTypeContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("objectTypeContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectTypeContainsFold = data
		case "permission":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permission"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Permission = data
		case "permissionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionNeq = data
		case "permissionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionIn = data
		case "permissionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionNotIn = data
		case "permissionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionGt = data
		case "permissionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionGte = data
		case "permissionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionLt = data
		case "permissionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionLte = data
		case "permissionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionContains = data
		case "permissionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionHasPrefix = data
		case "permissionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionHasSuffix = data
		case "permissionIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionIsNil"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionIsNil = data
		case "permissionNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionNotNil"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionNotNil = data
		case "permissionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionEqualFold = data
		case "permissionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissionContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermissionContainsFold = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var groupPermissionImplementors = []string{"GroupPermission", "Node"}

func (ec *executionContext) _GroupPermission(ctx context.Context, sel ast.SelectionSet, obj *model.GroupPermission) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupPermissionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupPermission")
		case "objectType":
			out.Values[i] = ec._GroupPermission_objectType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "permissions":
			out.Values[i] = ec._GroupPermission_permissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "id":
			out.Values[i] = ec._GroupPermission_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayID":
			out.Values[i] = ec._GroupPermission_displayID(ctx, field, obj)
		case "name":
			out.Values[i] = ec._GroupPermission_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupPermissionConnectionImplementors = []string{"GroupPermissionConnection"}

func (ec *executionContext) _GroupPermissionConnection(ctx context.Context, sel ast.SelectionSet, obj *model.GroupPermissionConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupPermissionConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupPermissionConnection")
		case "edges":
			out.Values[i] = ec._GroupPermissionConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._GroupPermissionConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._GroupPermissionConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupPermissionEdgeImplementors = []string{"GroupPermissionEdge"}

func (ec *executionContext) _GroupPermissionEdge(ctx context.Context, sel ast.SelectionSet, obj *model.GroupPermissionEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupPermissionEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupPermissionEdge")
		case "node":
			out.Values[i] = ec._GroupPermissionEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._GroupPermissionEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNGroupMembersInput2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupMembersInput(ctx context.Context, v any) (*model.GroupMembersInput, error) {
	res, err := ec.unmarshalInputGroupMembersInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroupPermissionConnection2githubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionConnection(ctx context.Context, sel ast.SelectionSet, v model.GroupPermissionConnection) graphql.Marshaler {
	return ec._GroupPermissionConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroupPermissionConnection2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionConnection(ctx context.Context, sel ast.SelectionSet, v *model.GroupPermissionConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupPermissionConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGroupPermissionOrderField2githubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionOrderField(ctx context.Context, v any) (model.GroupPermissionOrderField, error) {
	var res model.GroupPermissionOrderField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroupPermissionOrderField2githubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionOrderField(ctx context.Context, sel ast.SelectionSet, v model.GroupPermissionOrderField) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNGroupPermissionWhereInput2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionWhereInput(ctx context.Context, v any) (*model.GroupPermissionWhereInput, error) {
	res, err := ec.unmarshalInputGroupPermissionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPermission2githubᚗcomᚋtheopenlaneᚋcoreᚋpkgᚋenumsᚐPermission(ctx context.Context, v any) (enums.Permission, error) {
	var res enums.Permission
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPermission2githubᚗcomᚋtheopenlaneᚋcoreᚋpkgᚋenumsᚐPermission(ctx context.Context, sel ast.SelectionSet, v enums.Permission) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOGroupMembersInput2ᚕᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupMembersInputᚄ(ctx context.Context, v any) ([]*model.GroupMembersInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.GroupMembersInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGroupMembersInput2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupMembersInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGroupPermission2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermission(ctx context.Context, sel ast.SelectionSet, v *model.GroupPermission) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupPermission(ctx, sel, v)
}

func (ec *executionContext) marshalOGroupPermissionEdge2ᚕᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionEdge(ctx context.Context, sel ast.SelectionSet, v []*model.GroupPermissionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGroupPermissionEdge2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGroupPermissionEdge2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionEdge(ctx context.Context, sel ast.SelectionSet, v *model.GroupPermissionEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupPermissionEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGroupPermissionWhereInput2ᚕᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionWhereInputᚄ(ctx context.Context, v any) ([]*model.GroupPermissionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.GroupPermissionWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGroupPermissionWhereInput2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGroupPermissionWhereInput2ᚖgithubᚗcomᚋtheopenlaneᚋcoreᚋinternalᚋgraphapiᚋmodelᚐGroupPermissionWhereInput(ctx context.Context, v any) (*model.GroupPermissionWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGroupPermissionWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

// endregion ***************************** type.gotpl *****************************
