package graphapi

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"strings"
	"time"

	"entgo.io/contrib/entgql"
	"github.com/theopenlane/core/internal/graphapi/model"
)

// AuditLogs is the resolver for the auditLogs field.
func (r *queryResolver) AuditLogs(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *model.AuditLogWhereInput) (*model.AuditLogConnection, error) {
	var (
		auditLogs [][]string
		err       error
	)

	if where != nil && where.Table != nil {
		auditLogs, err = withTransactionalMutation(ctx).AuditWithFilter(ctx, *where.Table)
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "audit logs"})
		}
	} else {
		auditLogs, err = withTransactionalMutation(ctx).Audit(ctx)
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "audit logs"})
		}
	}

	count := len(auditLogs) - 1

	logs := &model.AuditLogConnection{
		Edges:      []*model.AuditLogEdge{},
		TotalCount: count,
	}

	for i, auditLog := range auditLogs {
		// skip the header
		if i == 0 {
			continue
		}

		// Response format:
		// Table RefId HistoryTime Operation Changes UpdatedBy
		// [0]   [1]   [2]         [3]       [4]      [5]
		tableName := strings.TrimSuffix(auditLog[0], "History")
		objectID := auditLog[1]

		// Thu Jul 18 17:30:19 2024
		ts, err := time.Parse("Mon Jan 02 15:04:05 2006", auditLog[2])
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "audit logs"})
		}

		op := auditLog[3]
		changes := strings.Split(auditLog[4], "\n")
		updatedBy := auditLog[5]

		// filter the response back
		if where != nil {
			// filter by operation
			if where.Operation != nil && !strings.EqualFold(*where.Operation, op) {
				continue
			}

			// filter by updated by
			if where.UpdatedBy != nil && *where.UpdatedBy != updatedBy {
				continue
			}

			// filter by object ID
			if where.RefID != nil && *where.RefID != objectID {
				continue
			}

			// filter by time
			if where.After != nil {
				after := *where.After
				if !after.Before(ts) {
					continue
				}
			}

			if where.Before != nil {
				if !where.Before.After(ts) {
					continue
				}
			}
		}

		edge := model.AuditLogEdge{
			Node: &model.AuditLog{
				Table:     &tableName,
				ID:        objectID,
				Time:      &ts,
				Operation: &op,
				Changes:   changes,
				UpdatedBy: &updatedBy,
			},
		}

		logs.Edges = append(logs.Edges, &edge)
	}

	return logs, nil
}
