// THIS CODE IS REGENERATED BY github.com/theopenlane/gqlgen-plugins. DO NOT EDIT.
package graphapi

import (
	"context"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/workflowevent"
	"github.com/theopenlane/core/internal/ent/generated/workflowinstance"
	"github.com/theopenlane/core/internal/ent/generated/workflowobjectref"
	"github.com/theopenlane/core/internal/ent/generated/workflowproposal"
	"github.com/theopenlane/core/internal/graphapi/common"
)

// workflowResolverHasPending checks if the object has any pending workflow proposals (draft or submitted).
func workflowResolverHasPending(ctx context.Context, objectType string, objectID string) (bool, error) {
	if objectID == "" {
		return false, nil
	}

	wfType := enums.ToWorkflowObjectType(objectType)
	if wfType == nil {
		return false, nil
	}

	query := withTransactionalMutation(ctx).WorkflowObjectRef.Query()
	query = generated.ApplyWorkflowObjectRefObjectPredicate(query, *wfType, objectID)

	exists, err := query.Where(
		workflowobjectref.HasWorkflowProposalsWith(
			workflowproposal.StateIn(
				enums.WorkflowProposalStateDraft,
				enums.WorkflowProposalStateSubmitted,
			),
		),
	).Exist(ctx)
	if err != nil {
		return false, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	return exists, nil
}

// workflowResolverHasHistory checks if the object has any workflow history (completed or failed instances).
func workflowResolverHasHistory(ctx context.Context, objectType string, objectID string) (bool, error) {
	if objectID == "" {
		return false, nil
	}

	wfType := enums.ToWorkflowObjectType(objectType)
	if wfType == nil {
		return false, nil
	}

	query := withTransactionalMutation(ctx).WorkflowInstance.Query()
	query = generated.ApplyWorkflowInstanceObjectPredicate(query, *wfType, objectID)

	exists, err := query.Where(
		workflowinstance.StateIn(
			enums.WorkflowInstanceStateCompleted,
			enums.WorkflowInstanceStateFailed,
		),
	).Exist(ctx)
	if err != nil {
		return false, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	return exists, nil
}

// workflowResolverActiveInstances returns all active workflow instances (running or paused) for the object.
func workflowResolverActiveInstances(ctx context.Context, objectType string, objectID string) ([]*generated.WorkflowInstance, error) {
	query, err := workflowResolverInstanceQuery(ctx, objectType, objectID)
	if err != nil || query == nil {
		return nil, err
	}

	query = query.Where(
		workflowinstance.StateIn(
			enums.WorkflowInstanceStateRunning,
			enums.WorkflowInstanceStatePaused,
		),
	).Order(
		workflowinstance.ByLastEvaluatedAt(sql.OrderDesc()),
		workflowinstance.ByUpdatedAt(sql.OrderDesc()),
	)

	res, err := query.All(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	return res, nil
}

// workflowResolverActiveInstance returns the most recent active workflow instance for the object.
// If none exist, it returns nil without error.
func workflowResolverActiveInstance(ctx context.Context, objectType string, objectID string) (*generated.WorkflowInstance, error) {
	instances, err := workflowResolverActiveInstances(ctx, objectType, objectID)
	if err != nil {
		return nil, err
	}

	if len(instances) == 0 {
		return nil, nil
	}

	return instances[0], nil
}

// workflowResolverTimeline returns the workflow event timeline for an object across all its workflow instances.
func workflowResolverTimeline(ctx context.Context, objectType string, objectID string, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy []*generated.WorkflowEventOrder, where *generated.WorkflowEventWhereInput, includeEmitFailures *bool) (*generated.WorkflowEventConnection, error) {
	if objectID == "" {
		return &generated.WorkflowEventConnection{}, nil
	}

	wfType := enums.ToWorkflowObjectType(objectType)
	if wfType == nil {
		return &generated.WorkflowEventConnection{}, nil
	}

	// Get all workflow instance IDs for this object
	instanceIDs, err := workflowResolverInstanceIDs(ctx, *wfType, objectID)
	if err != nil {
		return nil, err
	}

	if len(instanceIDs) == 0 {
		return &generated.WorkflowEventConnection{}, nil
	}

	// Set default ordering
	if orderBy == nil {
		orderBy = []*generated.WorkflowEventOrder{
			{
				Field:     generated.WorkflowEventOrderFieldCreatedAt,
				Direction: entgql.OrderDirectionAsc,
			},
		}
	}

	query, err := withTransactionalMutation(ctx).WorkflowEvent.Query().CollectFields(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowevent"})
	}

	if where == nil {
		where = &generated.WorkflowEventWhereInput{}
	}

	// Filter to events for this object's workflow instances
	query = query.Where(workflowevent.WorkflowInstanceIDIn(instanceIDs...))

	// Filter to timeline event types
	includeFailures := includeEmitFailures != nil && *includeEmitFailures
	timelineEventTypes := workflowTimelineEventTypes(includeFailures)
	query = query.Where(workflowevent.EventTypeIn(timelineEventTypes...))

	res, err := query.Paginate(
		ctx,
		after,
		first,
		before,
		last,
		generated.WithWorkflowEventOrder(orderBy),
		generated.WithWorkflowEventFilter(where.Filter),
	)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowevent"})
	}

	return res, nil
}

// workflowResolverInstanceIDs returns all workflow instance IDs for the given object.
func workflowResolverInstanceIDs(ctx context.Context, wfType enums.WorkflowObjectType, objectID string) ([]string, error) {
	query := withTransactionalMutation(ctx).WorkflowInstance.Query()
	query = generated.ApplyWorkflowInstanceObjectPredicate(query, wfType, objectID)

	return query.IDs(ctx)
}

// workflowResolverInstanceQuery builds a base query for workflow instances associated with the object.
func workflowResolverInstanceQuery(ctx context.Context, objectType string, objectID string) (*generated.WorkflowInstanceQuery, error) {
	if objectID == "" {
		return nil, nil
	}

	wfType := enums.ToWorkflowObjectType(objectType)
	if wfType == nil {
		return nil, nil
	}

	query, err := withTransactionalMutation(ctx).WorkflowInstance.Query().CollectFields(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	query = generated.ApplyWorkflowInstanceObjectPredicate(query, *wfType, objectID)

	return query, nil
}

// workflowTimelineEventTypes returns the event types included in timeline queries.
func workflowTimelineEventTypes(includeEmitFailures bool) []enums.WorkflowEventType {
	eventTypes := []enums.WorkflowEventType{
		enums.WorkflowEventTypeInstanceTriggered,
		enums.WorkflowEventTypeAssignmentCreated,
		enums.WorkflowEventTypeActionCompleted,
		enums.WorkflowEventTypeInstanceCompleted,
	}

	if includeEmitFailures {
		eventTypes = append(eventTypes,
			enums.WorkflowEventTypeEmitFailed,
			enums.WorkflowEventTypeEmitRecovered,
			enums.WorkflowEventTypeEmitFailedTerminal,
		)
	}

	return eventTypes
}
