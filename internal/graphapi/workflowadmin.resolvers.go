package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"

	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignmenttarget"
	"github.com/theopenlane/core/internal/graphapi/common"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/internal/workflows"
	"github.com/theopenlane/core/internal/workflows/engine"
	"github.com/theopenlane/utils/rout"
)

// ForceCompleteWorkflowInstance is the resolver for the forceCompleteWorkflowInstance field.
func (r *mutationResolver) ForceCompleteWorkflowInstance(ctx context.Context, id string, applyProposal *bool) (*model.WorkflowInstanceAdminPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	apply := true
	if applyProposal != nil {
		apply = *applyProposal
	}

	instance, err := r.forceCompleteWorkflowInstance(ctx, id, apply)
	if err != nil {
		return nil, err
	}

	return &model.WorkflowInstanceAdminPayload{
		WorkflowInstance: instance,
	}, nil
}

// CancelWorkflowInstance is the resolver for the cancelWorkflowInstance field.
func (r *mutationResolver) CancelWorkflowInstance(ctx context.Context, id string, reason *string) (*model.WorkflowInstanceAdminPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	instance, err := r.cancelWorkflowInstance(ctx, id, reason)
	if err != nil {
		return nil, err
	}

	return &model.WorkflowInstanceAdminPayload{
		WorkflowInstance: instance,
	}, nil
}

// BulkForceCompleteWorkflowInstances is the resolver for the bulkForceCompleteWorkflowInstances field.
func (r *mutationResolver) BulkForceCompleteWorkflowInstances(ctx context.Context, ids []string, applyProposal *bool) (*model.WorkflowInstanceBulkAdminPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	apply := true
	if applyProposal != nil {
		apply = *applyProposal
	}

	updatedIDs := make([]string, 0, len(ids))
	for _, id := range ids {
		instance, err := r.forceCompleteWorkflowInstance(ctx, id, apply)
		if err != nil {
			return nil, err
		}
		updatedIDs = append(updatedIDs, instance.ID)
	}

	return &model.WorkflowInstanceBulkAdminPayload{
		UpdatedIDs: updatedIDs,
	}, nil
}

// BulkCancelWorkflowInstances is the resolver for the bulkCancelWorkflowInstances field.
func (r *mutationResolver) BulkCancelWorkflowInstances(ctx context.Context, ids []string, reason *string) (*model.WorkflowInstanceBulkAdminPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	updatedIDs := make([]string, 0, len(ids))
	for _, id := range ids {
		instance, err := r.cancelWorkflowInstance(ctx, id, reason)
		if err != nil {
			return nil, err
		}
		updatedIDs = append(updatedIDs, instance.ID)
	}

	return &model.WorkflowInstanceBulkAdminPayload{
		UpdatedIDs: updatedIDs,
	}, nil
}

// AdminReassignWorkflowAssignment is the resolver for the adminReassignWorkflowAssignment field.
func (r *mutationResolver) AdminReassignWorkflowAssignment(ctx context.Context, input model.ReassignWorkflowAssignmentInput) (*model.WorkflowAssignmentReassignPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	if len(input.Targets) == 0 {
		return nil, fmt.Errorf("%w: assignment requires at least one target", rout.ErrBadRequest)
	}

	allowCtx := workflows.AllowContext(ctx)
	assignment, err := r.db.WorkflowAssignment.Get(allowCtx, input.ID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowassignment"})
	}

	if err := r.requireWorkflowAdmin(ctx, assignment.OwnerID); err != nil {
		return nil, err
	}

	if assignment.OwnerID != "" {
		allowCtx, err = common.SetOrganizationInAuthContext(allowCtx, &assignment.OwnerID)
		if err != nil {
			return nil, err
		}
	}

	instance, err := r.db.WorkflowInstance.Get(allowCtx, assignment.WorkflowInstanceID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	objectType, objectID, err := workflowInstanceObjectContext(ctx, r.db, instance)
	if err != nil {
		return nil, err
	}
	if objectID == "" || objectType == "" {
		return nil, fmt.Errorf("%w: assignment missing workflow object context", rout.ErrBadRequest)
	}

	obj := &workflows.Object{ID: objectID, Type: objectType}
	entity, err := workflows.LoadWorkflowObject(allowCtx, r.db, objectType.String(), objectID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowobject"})
	}
	obj.Node = entity

	targets := make([]workflows.TargetConfig, 0, len(input.Targets))
	for _, target := range input.Targets {
		targets = append(targets, workflows.TargetConfig{
			Type:        target.Type,
			ID:          derefString(target.ID),
			ResolverKey: derefString(target.ResolverKey),
		})
	}

	if err := validateTargets(targets); err != nil {
		return nil, err
	}

	wfEngine, ok := r.db.WorkflowEngine.(*engine.WorkflowEngine)
	if !ok || wfEngine == nil {
		return nil, ErrWorkflowsDisabled
	}

	skipCtx := workflows.WithSkipEventEmission(allowCtx)
	workflows.MarkSkipEventEmission(skipCtx)

	if _, err := r.db.WorkflowAssignmentTarget.Delete().
		Where(workflowassignmenttarget.WorkflowAssignmentIDEQ(assignment.ID)).
		Exec(skipCtx); err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionDelete, Object: "workflowassignmenttarget"})
	}

	resolvedCount := 0
	for _, target := range targets {
		userIDs, err := wfEngine.ResolveTargets(allowCtx, target, obj)
		if err != nil {
			return nil, err
		}
		for _, userID := range userIDs {
			resolvedCount++
			targetCreate := r.db.WorkflowAssignmentTarget.Create().
				SetWorkflowAssignmentID(assignment.ID).
				SetTargetType(target.Type).
				SetTargetUserID(userID).
				SetOwnerID(assignment.OwnerID)

			switch target.Type {
			case enums.WorkflowTargetTypeGroup:
				if target.ID != "" {
					targetCreate.SetTargetGroupID(target.ID)
				}
			case enums.WorkflowTargetTypeResolver:
				if target.ResolverKey != "" {
					targetCreate.SetResolverKey(target.ResolverKey)
				}
			}

			if err := targetCreate.Exec(skipCtx); err != nil {
				if !generated.IsConstraintError(err) {
					return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "workflowassignmenttarget"})
				}
			}
		}
	}

	if resolvedCount == 0 {
		return nil, fmt.Errorf("%w: no assignment targets resolved", rout.ErrBadRequest)
	}

	updated, err := r.db.WorkflowAssignment.UpdateOneID(assignment.ID).
		SetStatus(enums.WorkflowAssignmentStatusPending).
		ClearDecidedAt().
		ClearActorUserID().
		ClearNotes().
		ClearRejectionMetadata().
		ClearMetadata().
		Save(skipCtx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowassignment"})
	}

	updated, err = r.db.WorkflowAssignment.Get(allowCtx, assignment.ID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowassignment"})
	}

	return &model.WorkflowAssignmentReassignPayload{
		WorkflowAssignment: updated,
	}, nil
}
