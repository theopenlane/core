package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"time"

	"github.com/samber/lo"

	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/common/models"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignment"
	"github.com/theopenlane/core/internal/ent/generated/workflowassignmenttarget"
	"github.com/theopenlane/core/internal/ent/generated/workflowinstance"
	"github.com/theopenlane/core/internal/graphapi/common"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/internal/workflows"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/utils/rout"
)

// ForceCompleteWorkflowInstance is the resolver for the forceCompleteWorkflowInstance field.
func (r *mutationResolver) ForceCompleteWorkflowInstance(ctx context.Context, id string, applyProposal *bool) (*model.WorkflowInstanceAdminPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}
	if id == "" {
		return nil, rout.NewMissingRequiredFieldError("id")
	}

	client := withTransactionalMutation(ctx)
	instance, err := client.WorkflowInstance.Get(ctx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	if lo.FromPtrOr(applyProposal, true) && instance.WorkflowProposalID != "" {
		objectType, objectID, err := workflowInstanceObjectContext(ctx, client, instance)
		if err != nil {
			return nil, err
		}

		if objectID != "" {
			allowCtx := workflows.AllowContext(ctx)
			proposal, err := client.WorkflowProposal.Get(allowCtx, instance.WorkflowProposalID)
			if err != nil {
				return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
			}

			bypassCtx := workflows.AllowBypassContext(ctx)
			if err := workflows.ApplyObjectFieldUpdates(bypassCtx, client, objectType, objectID, proposal.Changes); err != nil {
				return nil, err
			}

			if err := client.WorkflowProposal.UpdateOneID(proposal.ID).
				SetState(enums.WorkflowProposalStateApplied).
				SetApprovedHash(proposal.ProposedHash).
				Exec(allowCtx); err != nil {
				return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
			}
		}
	}

	allowCtx := workflows.AllowContext(ctx)
	if _, err := client.WorkflowInstance.Update().
		Where(workflowinstance.IDEQ(id)).
		SetState(enums.WorkflowInstanceStateCompleted).
		Save(allowCtx); err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowinstance"})
	}

	updated, err := client.WorkflowInstance.Get(allowCtx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	return &model.WorkflowInstanceAdminPayload{
		WorkflowInstance: updated,
	}, nil
}

// CancelWorkflowInstance is the resolver for the cancelWorkflowInstance field.
func (r *mutationResolver) CancelWorkflowInstance(ctx context.Context, id string, reason *string) (*model.WorkflowInstanceAdminPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}
	if id == "" {
		return nil, rout.NewMissingRequiredFieldError("id")
	}

	client := withTransactionalMutation(ctx)
	allowCtx := workflows.AllowContext(ctx)

	if _, err := client.WorkflowInstance.Update().
		Where(workflowinstance.IDEQ(id)).
		SetState(enums.WorkflowInstanceStateFailed).
		Save(allowCtx); err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowinstance"})
	}

	pendingAssignments, err := client.WorkflowAssignment.Query().
		Where(
			workflowassignment.WorkflowInstanceIDEQ(id),
			workflowassignment.StatusEQ(enums.WorkflowAssignmentStatusPending),
		).
		All(allowCtx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowassignment"})
	}

	if len(pendingAssignments) > 0 {
		decidedAt := time.Now().UTC()
		rejectionReason := lo.CoalesceOrEmpty(lo.FromPtrOr(reason, ""), "workflow instance cancelled")
		userID, _ := auth.GetSubjectIDFromContext(ctx)

		for _, assignment := range pendingAssignments {
			rejectionMeta := models.WorkflowAssignmentRejection{
				ActionKey:        assignment.ApprovalMetadata.ActionKey,
				RejectionReason:  rejectionReason,
				RejectedAt:       decidedAt.Format(time.RFC3339),
				RejectedByUserID: userID,
				RejectedHash:     "",
			}

			update := client.WorkflowAssignment.UpdateOneID(assignment.ID).
				SetStatus(enums.WorkflowAssignmentStatusRejected).
				SetRejectionMetadata(rejectionMeta).
				SetDecidedAt(decidedAt)

			if userID != "" {
				update = update.SetActorUserID(userID)
			}

			if err := update.Exec(allowCtx); err != nil {
				return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowassignment"})
			}
		}
	}

	updated, err := client.WorkflowInstance.Get(allowCtx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	return &model.WorkflowInstanceAdminPayload{
		WorkflowInstance: updated,
	}, nil
}

// BulkForceCompleteWorkflowInstances is the resolver for the bulkForceCompleteWorkflowInstances field.
func (r *mutationResolver) BulkForceCompleteWorkflowInstances(ctx context.Context, ids []string, applyProposal *bool) (*model.WorkflowInstanceBulkAdminPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	updatedIDs := make([]string, 0, len(ids))
	for _, id := range ids {
		res, err := r.ForceCompleteWorkflowInstance(ctx, id, applyProposal)
		if err != nil {
			return nil, err
		}
		if res != nil && res.WorkflowInstance != nil {
			updatedIDs = append(updatedIDs, res.WorkflowInstance.ID)
		}
	}

	return &model.WorkflowInstanceBulkAdminPayload{
		UpdatedIDs: updatedIDs,
	}, nil
}

// BulkCancelWorkflowInstances is the resolver for the bulkCancelWorkflowInstances field.
func (r *mutationResolver) BulkCancelWorkflowInstances(ctx context.Context, ids []string, reason *string) (*model.WorkflowInstanceBulkAdminPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}
	if len(ids) == 0 {
		return nil, rout.NewMissingRequiredFieldError("ids")
	}

	updatedIDs := make([]string, 0, len(ids))
	for _, id := range ids {
		res, err := r.CancelWorkflowInstance(ctx, id, reason)
		if err != nil {
			return nil, err
		}
		if res != nil && res.WorkflowInstance != nil {
			updatedIDs = append(updatedIDs, res.WorkflowInstance.ID)
		}
	}

	return &model.WorkflowInstanceBulkAdminPayload{
		UpdatedIDs: updatedIDs,
	}, nil
}

// AdminReassignWorkflowAssignment is the resolver for the adminReassignWorkflowAssignment field.
func (r *mutationResolver) AdminReassignWorkflowAssignment(ctx context.Context, input model.ReassignWorkflowAssignmentInput) (*model.WorkflowAssignmentReassignPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	if input.ID == "" {
		return nil, rout.NewMissingRequiredFieldError("id")
	}
	if len(input.Targets) == 0 {
		return nil, rout.NewMissingRequiredFieldError("targets")
	}

	client := withTransactionalMutation(ctx)
	assignment, err := client.WorkflowAssignment.Get(ctx, input.ID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowassignment"})
	}

	allowCtx := workflows.AllowContext(ctx)

	if _, err := client.WorkflowAssignmentTarget.Delete().
		Where(workflowassignmenttarget.WorkflowAssignmentIDEQ(assignment.ID)).
		Exec(allowCtx); err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionDelete, Object: "workflowassignmenttarget"})
	}

	instance, err := client.WorkflowInstance.Get(allowCtx, assignment.WorkflowInstanceID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	objectType, objectID, err := workflowInstanceObjectContext(ctx, client, instance)
	if err != nil {
		return nil, err
	}

	var obj *workflows.Object
	if objectType != "" && objectID != "" {
		obj = &workflows.Object{ID: objectID, Type: objectType}
		if node, err := workflows.LoadWorkflowObject(allowCtx, client, objectType.String(), objectID); err == nil {
			obj.Node = node
		}
	}

	createdAny := false
	for _, target := range input.Targets {
		if target == nil {
			continue
		}

		userIDs, resolverKey, groupID, err := resolveWorkflowAssignmentTargetUsers(allowCtx, client, obj, target)
		if err != nil {
			return nil, err
		}

		for _, userID := range userIDs {
			create := client.WorkflowAssignmentTarget.Create().
				SetWorkflowAssignmentID(assignment.ID).
				SetTargetType(target.Type).
				SetTargetUserID(userID)

			if groupID != "" {
				create.SetTargetGroupID(groupID)
			}
			if resolverKey != "" {
				create.SetResolverKey(resolverKey)
			}
			if assignment.OwnerID != "" {
				create.SetOwnerID(assignment.OwnerID)
			}

			if err := create.Exec(allowCtx); err != nil {
				if generated.IsConstraintError(err) {
					continue
				}
				return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "workflowassignmenttarget"})
			}

			createdAny = true
		}
	}

	if !createdAny {
		return nil, rout.ErrBadRequest
	}

	updated, err := assignment.Update().
		SetStatus(enums.WorkflowAssignmentStatusPending).
		ClearDecidedAt().
		ClearActorUserID().
		ClearActorGroupID().
		ClearRejectionMetadata().
		ClearInvalidationMetadata().
		Save(allowCtx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowassignment"})
	}

	return &model.WorkflowAssignmentReassignPayload{
		WorkflowAssignment: updated,
	}, nil
}
