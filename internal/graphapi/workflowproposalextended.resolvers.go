package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/stoewer/go-strcase"
	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/workflowinstance"
	"github.com/theopenlane/core/internal/ent/generated/workflowproposal"
	"github.com/theopenlane/core/internal/graphapi/common"
	gqlgenerated "github.com/theopenlane/core/internal/graphapi/generated"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/internal/workflows"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/utils/rout"
)

// UpdateWorkflowProposalChanges is the resolver for the updateWorkflowProposalChanges field.
func (r *mutationResolver) UpdateWorkflowProposalChanges(ctx context.Context, input model.UpdateWorkflowProposalChangesInput) (*model.WorkflowProposalUpdatePayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	// this is required to fetch the proposal but the requireworkflowObjectEditAccess check
	// enforces permissions
	allowCtx := workflows.AllowContext(ctx)
	proposal, err := r.db.WorkflowProposal.Get(allowCtx, input.ID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	objectType, objectID, err := workflowProposalObjectContext(ctx, r.db, proposal)
	if err != nil {
		return nil, err
	}

	if err := r.requireWorkflowObjectEditAccess(ctx, objectType, objectID); err != nil {
		return nil, err
	}

	if proposal.State != enums.WorkflowProposalStateDraft {
		return nil, fmt.Errorf("%w: workflow proposal is not in draft state", rout.ErrBadRequest)
	}

	if err := validateWorkflowProposalChanges(proposal.DomainKey, objectType, input.Changes); err != nil {
		return nil, err
	}

	proposedHash, err := workflows.ComputeProposalHash(input.Changes)
	if err != nil {
		return nil, err
	}

	if proposal.OwnerID != "" {
		if err := auth.SetOrganizationIDInAuthContext(allowCtx, proposal.OwnerID); err != nil {
			return nil, err
		}
	}

	updated, err := r.db.WorkflowProposal.UpdateOneID(proposal.ID).
		SetChanges(input.Changes).
		SetProposedHash(proposedHash).
		SetRevision(proposal.Revision + 1).
		Save(allowCtx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	return &model.WorkflowProposalUpdatePayload{
		WorkflowProposal: updated,
	}, nil
}

// SubmitWorkflowProposal is the resolver for the submitWorkflowProposal field.
func (r *mutationResolver) SubmitWorkflowProposal(ctx context.Context, id string) (*model.WorkflowProposalSubmitPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	allowCtx := workflows.AllowContext(ctx)
	proposal, err := r.db.WorkflowProposal.Get(allowCtx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	objectType, objectID, err := workflowProposalObjectContext(ctx, r.db, proposal)
	if err != nil {
		return nil, err
	}
	if err := r.requireWorkflowObjectEditAccess(ctx, objectType, objectID); err != nil {
		return nil, err
	}

	if proposal.State != enums.WorkflowProposalStateDraft {
		return nil, fmt.Errorf("%w: workflow proposal is not in draft state", rout.ErrBadRequest)
	}

	if err := validateWorkflowProposalChanges(proposal.DomainKey, objectType, proposal.Changes); err != nil {
		return nil, err
	}

	userID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil || userID == "" {
		return nil, rout.ErrPermissionDenied
	}

	if proposal.OwnerID != "" {
		if err := auth.SetOrganizationIDInAuthContext(allowCtx, proposal.OwnerID); err != nil {
			return nil, err
		}
	}

	proposedHash := proposal.ProposedHash
	if proposedHash == "" && len(proposal.Changes) > 0 {
		proposedHash, err = workflows.ComputeProposalHash(proposal.Changes)
		if err != nil {
			return nil, err
		}
	}

	now := time.Now().UTC()
	updated, err := r.db.WorkflowProposal.UpdateOneID(proposal.ID).
		SetState(enums.WorkflowProposalStateSubmitted).
		SetSubmittedAt(now).
		SetSubmittedByUserID(userID).
		SetProposedHash(proposedHash).
		Save(allowCtx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	return &model.WorkflowProposalSubmitPayload{
		WorkflowProposal: updated,
	}, nil
}

// WithdrawWorkflowProposal is the resolver for the withdrawWorkflowProposal field.
func (r *mutationResolver) WithdrawWorkflowProposal(ctx context.Context, id string, reason *string) (*model.WorkflowProposalWithdrawPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	allowCtx := workflows.AllowContext(ctx)
	proposal, err := r.db.WorkflowProposal.Get(allowCtx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	objectType, objectID, err := workflowProposalObjectContext(ctx, r.db, proposal)
	if err != nil {
		return nil, err
	}
	if err := r.requireWorkflowObjectEditAccess(ctx, objectType, objectID); err != nil {
		return nil, err
	}

	switch proposal.State {
	case enums.WorkflowProposalStateDraft, enums.WorkflowProposalStateSubmitted:
	default:
		return nil, fmt.Errorf("%w: workflow proposal is not withdrawable", rout.ErrBadRequest)
	}

	userID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil || userID == "" {
		return nil, rout.ErrPermissionDenied
	}

	if proposal.OwnerID != "" {
		if err := auth.SetOrganizationIDInAuthContext(allowCtx, proposal.OwnerID); err != nil {
			return nil, err
		}
	}

	instances, err := r.db.WorkflowInstance.Query().
		Where(
			workflowinstance.WorkflowProposalIDEQ(proposal.ID),
			workflowinstance.Not(workflowinstance.StateIn(
				enums.WorkflowInstanceStateCompleted,
				enums.WorkflowInstanceStateFailed,
			)),
			workflowinstance.OwnerIDEQ(proposal.OwnerID),
		).
		All(allowCtx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	for _, instance := range instances {
		if err := closeWorkflowAssignments(ctx, r.db, instance.ID, proposal.OwnerID, enums.WorkflowAssignmentStatusRejected, userID, reason); err != nil {
			return nil, err
		}

		if err := r.db.WorkflowInstance.UpdateOneID(instance.ID).
			SetState(enums.WorkflowInstanceStateFailed).
			Exec(allowCtx); err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowinstance"})
		}
	}

	updated, err := r.db.WorkflowProposal.UpdateOneID(proposal.ID).
		SetState(enums.WorkflowProposalStateSuperseded).
		Save(allowCtx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	return &model.WorkflowProposalWithdrawPayload{
		WorkflowProposal: updated,
	}, nil
}

// WorkflowProposal is the resolver for the workflowProposal field.
func (r *queryResolver) WorkflowProposal(ctx context.Context, id string) (*generated.WorkflowProposal, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	allowCtx := workflows.AllowContext(ctx)
	proposal, err := r.db.WorkflowProposal.Get(allowCtx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	objectType, objectID, err := workflowProposalObjectContext(ctx, r.db, proposal)
	if err != nil {
		return nil, err
	}
	if objectID == "" {
		return nil, rout.ErrPermissionDenied
	}

	if err := r.requireWorkflowObjectEditAccess(ctx, objectType, objectID); err != nil {
		if errors.Is(err, rout.ErrPermissionDenied) {
			userID, err := auth.GetSubjectIDFromContext(ctx)
			if err != nil || userID == "" {
				return nil, rout.ErrPermissionDenied
			}
			isApprover, err := workflowProposalHasApprover(ctx, r.db, proposal.ID, userID)
			if err != nil {
				return nil, err
			}
			if !isApprover {
				return nil, err
			}
		} else {
			return nil, err
		}
	}

	return proposal, nil
}

// WorkflowProposalsForObject is the resolver for the workflowProposalsForObject field.
func (r *queryResolver) WorkflowProposalsForObject(ctx context.Context, objectType string, objectID string, includeStates []enums.WorkflowProposalState) ([]*generated.WorkflowProposal, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	normalizedType := strcase.UpperCamelCase(objectType)
	objType := enums.ToWorkflowObjectType(normalizedType)
	if objType == nil {
		objType = enums.ToWorkflowObjectType(objectType)
	}
	if objType == nil {
		return nil, fmt.Errorf("%w: invalid workflow object type %q", rout.ErrBadRequest, objectType)
	}

	if err := r.requireWorkflowObjectEditAccess(ctx, *objType, objectID); err != nil {
		return nil, err
	}

	allowCtx := workflows.AllowContext(ctx)
	ownerID, err := workflows.ObjectOwnerID(allowCtx, r.db, *objType, objectID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowobject"})
	}
	if ownerID != "" {
		if err := auth.SetOrganizationIDInAuthContext(allowCtx, ownerID); err != nil {
			return nil, err
		}
	}

	objRefIDs, err := workflows.ObjectRefIDs(allowCtx, r.db, &workflows.Object{
		ID:   objectID,
		Type: *objType,
	})
	if err != nil {
		return nil, err
	}
	if len(objRefIDs) == 0 {
		return []*generated.WorkflowProposal{}, nil
	}

	states := includeStates
	if len(states) == 0 {
		states = []enums.WorkflowProposalState{
			enums.WorkflowProposalStateDraft,
			enums.WorkflowProposalStateSubmitted,
		}
	}

	proposals, err := r.db.WorkflowProposal.Query().
		Where(
			workflowproposal.WorkflowObjectRefIDIn(objRefIDs...),
			workflowproposal.StateIn(states...),
		).
		All(allowCtx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	return proposals, nil
}

// Preview is the resolver for the preview field.
func (r *workflowProposalResolver) Preview(ctx context.Context, obj *generated.WorkflowProposal) (*model.WorkflowProposalPreview, error) {
	return r.workflowProposalPreview(ctx, obj)
}

// WorkflowProposal returns gqlgenerated.WorkflowProposalResolver implementation.
func (r *Resolver) WorkflowProposal() gqlgenerated.WorkflowProposalResolver {
	return &workflowProposalResolver{r}
}

type workflowProposalResolver struct{ *Resolver }
