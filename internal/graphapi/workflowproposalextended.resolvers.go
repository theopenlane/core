package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"time"

	"github.com/theopenlane/core/common/enums"
	"github.com/theopenlane/core/common/models"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/workflowinstance"
	"github.com/theopenlane/core/internal/ent/generated/workflowproposal"
	"github.com/theopenlane/core/internal/graphapi/common"
	gqlgenerated "github.com/theopenlane/core/internal/graphapi/generated"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/internal/workflows"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/utils/rout"
)

// UpdateWorkflowProposalChanges is the resolver for the updateWorkflowProposalChanges field.
func (r *mutationResolver) UpdateWorkflowProposalChanges(ctx context.Context, input model.UpdateWorkflowProposalChangesInput) (*model.WorkflowProposalUpdatePayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	if input.ID == "" {
		return nil, rout.NewMissingRequiredFieldError("id")
	}

	proposedHash, err := workflows.ComputeProposalHash(input.Changes)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	res, err := withTransactionalMutation(ctx).WorkflowProposal.UpdateOneID(input.ID).
		SetChanges(input.Changes).
		SetProposedHash(proposedHash).
		AddRevision(1).
		Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	return &model.WorkflowProposalUpdatePayload{
		WorkflowProposal: res,
	}, nil
}

// SubmitWorkflowProposal is the resolver for the submitWorkflowProposal field.
func (r *mutationResolver) SubmitWorkflowProposal(ctx context.Context, id string) (*model.WorkflowProposalSubmitPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	if id == "" {
		return nil, rout.NewMissingRequiredFieldError("id")
	}

	client := withTransactionalMutation(ctx)
	proposal, err := client.WorkflowProposal.Get(ctx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	if proposal.State == enums.WorkflowProposalStateSubmitted {
		return &model.WorkflowProposalSubmitPayload{
			WorkflowProposal: proposal,
		}, nil
	}
	if proposal.State != enums.WorkflowProposalStateDraft {
		return nil, rout.ErrPermissionDenied
	}

	proposedHash, err := workflows.ComputeProposalHash(proposal.Changes)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	update := proposal.Update().
		SetState(enums.WorkflowProposalStateSubmitted).
		SetSubmittedAt(time.Now().UTC()).
		SetProposedHash(proposedHash)

	if userID, err := auth.GetSubjectIDFromContext(ctx); err == nil && userID != "" {
		update.SetSubmittedByUserID(userID)
	}

	res, err := update.Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	return &model.WorkflowProposalSubmitPayload{
		WorkflowProposal: res,
	}, nil
}

// WithdrawWorkflowProposal is the resolver for the withdrawWorkflowProposal field.
func (r *mutationResolver) WithdrawWorkflowProposal(ctx context.Context, id string, reason *string) (*model.WorkflowProposalWithdrawPayload, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	if id == "" {
		return nil, rout.NewMissingRequiredFieldError("id")
	}

	client := withTransactionalMutation(ctx)
	proposal, err := client.WorkflowProposal.Get(ctx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	switch proposal.State {
	case enums.WorkflowProposalStateSuperseded:
		return &model.WorkflowProposalWithdrawPayload{WorkflowProposal: proposal}, nil
	case enums.WorkflowProposalStateApplied:
		return nil, rout.ErrPermissionDenied
	}

	res, err := proposal.Update().SetState(enums.WorkflowProposalStateSuperseded).Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "workflowproposal"})
	}

	return &model.WorkflowProposalWithdrawPayload{
		WorkflowProposal: res,
	}, nil
}

// WorkflowProposal is the resolver for the workflowProposal field.
func (r *queryResolver) WorkflowProposal(ctx context.Context, id string) (*generated.WorkflowProposal, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	res, err := withTransactionalMutation(ctx).WorkflowProposal.Query().Where(workflowproposal.ID(id)).Only(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	return res, nil
}

// WorkflowProposalsForObject is the resolver for the workflowProposalsForObject field.
func (r *queryResolver) WorkflowProposalsForObject(ctx context.Context, objectType string, objectID string, includeStates []enums.WorkflowProposalState) ([]*generated.WorkflowProposal, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	if objectType == "" {
		return nil, rout.NewMissingRequiredFieldError("objectType")
	}
	if objectID == "" {
		return nil, rout.NewMissingRequiredFieldError("objectID")
	}

	objType := enums.ToWorkflowObjectType(objectType)
	if objType == nil {
		return nil, rout.InvalidField("objectType")
	}

	objRefIDs, err := workflows.ObjectRefIDs(ctx, withTransactionalMutation(ctx), &workflows.Object{
		ID:   objectID,
		Type: *objType,
	})
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	if len(objRefIDs) == 0 {
		return []*generated.WorkflowProposal{}, nil
	}

	query := withTransactionalMutation(ctx).WorkflowProposal.Query().
		Where(workflowproposal.WorkflowObjectRefIDIn(objRefIDs...))
	if len(includeStates) > 0 {
		query = query.Where(workflowproposal.StateIn(includeStates...))
	}

	res, err := query.All(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowproposal"})
	}

	return res, nil
}

// Preview is the resolver for the preview field.
func (r *workflowProposalResolver) Preview(ctx context.Context, obj *generated.WorkflowProposal) (*model.WorkflowProposalPreview, error) {
	if !workflowsEnabled(r.db) {
		return nil, ErrWorkflowsDisabled
	}

	if obj == nil {
		return nil, nil
	}

	client := withTransactionalMutation(ctx)
	allowCtx := workflows.AllowContext(ctx)

	instance, err := client.WorkflowInstance.Query().
		Where(workflowinstance.WorkflowProposalIDEQ(obj.ID)).
		Order(generated.Desc(workflowinstance.FieldCreatedAt)).
		First(allowCtx)
	if err != nil && !generated.IsNotFound(err) {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowinstance"})
	}

	if instance == nil {
		ref, err := client.WorkflowObjectRef.Get(allowCtx, obj.WorkflowObjectRefID)
		if err != nil {
			if generated.IsNotFound(err) {
				return nil, nil
			}
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "workflowobjectref"})
		}

		objRef, err := workflows.ObjectFromRef(ref)
		if err != nil || objRef == nil {
			return nil, err
		}

		instance = &generated.WorkflowInstance{
			WorkflowProposalID: obj.ID,
			OwnerID:            ref.OwnerID,
			Context: models.WorkflowInstanceContext{
				ObjectType: objRef.Type,
				ObjectID:   objRef.ID,
			},
		}
	}

	return r.workflowInstanceProposalPreview(ctx, instance)
}

// WorkflowProposal returns gqlgenerated.WorkflowProposalResolver implementation.
func (r *Resolver) WorkflowProposal() gqlgenerated.WorkflowProposalResolver {
	return &workflowProposalResolver{r}
}

type workflowProposalResolver struct{ *Resolver }
