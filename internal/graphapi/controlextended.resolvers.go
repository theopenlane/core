package graphapi

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"
	"slices"

	"entgo.io/contrib/entgql"
	"github.com/rs/zerolog/log"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/predicate"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/gqlgen-plugins/graphutils"
	"github.com/theopenlane/utils/rout"
)

// CreateControlsByClone is the resolver for the createControlsByClone field.
func (r *mutationResolver) CreateControlsByClone(ctx context.Context, input *model.CloneControlInput) (*model.ControlBulkCreatePayload, error) {
	// set the organization in the auth context if its not done for us
	if err := setOrganizationInAuthContext(ctx, input.OwnerID); err != nil {
		log.Error().Err(err).Msg("failed to set organization in auth context")

		return nil, rout.NewMissingRequiredFieldError("owner_id")
	}

	// if a standard is provided, clone those controls
	if input.StandardID != nil {
		res, err := r.cloneControlsFromStandard(ctx, *input.StandardID, input.ProgramID)
		if err != nil {
			return nil, parseRequestError(generated.ErrPermissionDenied, action{action: ActionCreate, object: "control"})
		}

		return &model.ControlBulkCreatePayload{
			Controls: res,
		}, nil
	}

	// otherwise get existing controls and clone
	// TODO(sfunk): this is an expensive operation, we should limit the number of controls that can be cloned at once
	// or check the permissions and then bypass the permission checks when querying for subcontrols
	existingControls, err := withTransactionalMutation(ctx).Control.Query().
		Where(control.IDIn(input.ControlIDs...)).
		WithSubcontrols().
		WithStandard().
		All(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "control"})
	}

	if len(existingControls) == 0 {
		return nil, parseRequestError(generated.ErrPermissionDenied, action{action: ActionCreate, object: "control"})
	}

	createdControls, err := r.cloneControls(ctx, existingControls, input.ProgramID)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "control"})
	}

	return &model.ControlBulkCreatePayload{
		Controls: createdControls,
	}, nil
}

// ControlCategories is the resolver for the controlCategories field.
func (r *queryResolver) ControlCategories(ctx context.Context) ([]string, error) {
	categories, err := withTransactionalMutation(ctx).Control.Query().Select(control.FieldCategory).
		Where(control.CategoryNEQ("")).
		Unique(true).
		GroupBy(control.FieldCategory).
		Strings(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionGet, object: "categories"})
	}

	subcontrolCategories, err := withTransactionalMutation(ctx).Subcontrol.Query().Select(control.FieldCategory).
		Where(subcontrol.CategoryNEQ("")).
		Unique(true).
		GroupBy(control.FieldCategory).
		Strings(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionGet, object: "categories"})
	}

	for _, subcontrolCategory := range subcontrolCategories {
		// check if the subcontrol category already exists in the main categories
		if !slices.Contains(categories, subcontrolCategory) {
			// if not, append it to the main categories
			categories = append(categories, subcontrolCategory)
		}
	}

	// sort the categories to ensure consistent order
	slices.Sort(categories)

	if categories == nil {
		// if no subcategories are found, return an empty slice
		categories = []string{}
	}

	return categories, nil
}

// ControlSubcategories is the resolver for the controlSubcategories field.
func (r *queryResolver) ControlSubcategories(ctx context.Context) ([]string, error) {
	subcategories, err := withTransactionalMutation(ctx).Control.Query().Select(control.FieldSubcategory).
		Where(control.SubcategoryNEQ("")).
		Unique(true).
		GroupBy(control.FieldSubcategory).
		Strings(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionGet, object: "subcategories"})
	}

	subcontrolCategories, err := withTransactionalMutation(ctx).Subcontrol.Query().Select(control.FieldSubcategory).
		Where(subcontrol.SubcategoryNEQ("")).
		Unique(true).
		GroupBy(control.FieldSubcategory).
		Strings(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionGet, object: "subcategories"})
	}

	// append the subcontrol categories to the main categories
	for _, subcontrolCategory := range subcontrolCategories {
		// check if the subcontrol category already exists in the main subcategories
		if !slices.Contains(subcategories, subcontrolCategory) {
			// if not, append it to the main subcategories
			subcategories = append(subcategories, subcontrolCategory)
		}
	}

	// sort the subcategories to ensure consistent order
	slices.Sort(subcategories)

	if subcategories == nil {
		// if no subcategories are found, return an empty slice
		subcategories = []string{}
	}

	return subcategories, nil
}

// ControlCategoriesByFramework is the resolver for the controlCategoriesByFramework field.
func (r *queryResolver) ControlCategoriesByFramework(ctx context.Context, orderBy []*model.ControlCategoryOrder, where *generated.ControlWhereInput) ([]*model.ControlCategoryEdge, error) {
	return r.getAllCategories(ctx, control.FieldCategory, where)
}

// ControlSubcategoriesByFramework is the resolver for the controlSubcategoriesByFramework field.
func (r *queryResolver) ControlSubcategoriesByFramework(ctx context.Context, orderBy []*model.ControlCategoryOrder, where *generated.ControlWhereInput) ([]*model.ControlCategoryEdge, error) {
	return r.getAllCategories(ctx, control.FieldSubcategory, where)
}

// ControlsGroupByCategory is the resolver for the controlsGroupByCategory field.
func (r *queryResolver) ControlsGroupByCategory(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy []*generated.ControlOrder, where *generated.ControlWhereInput, category *string) (*model.ControlGroupConnection, error) {
	if category == nil && after != nil || before != nil {
		log.Info().Msg("category must be provided when using pagination with after or before")

		return nil, fmt.Errorf("%w: category must be provided when using pagination with after or before", rout.ErrBadRequest)
	}

	// set page limit if nothing was set
	first, last = graphutils.SetFirstLastDefaults(first, last, r.maxResultLimit)

	if orderBy == nil {
		orderBy = []*generated.ControlOrder{
			{
				Field:     generated.ControlOrderFieldCreatedAt,
				Direction: entgql.OrderDirectionDesc,
			},
		}
	}

	whereP, err := getControlWherePredicate(where)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionGet, object: "control"})
	}

	categories := []string{}
	if category == nil {
		// get all distinct non-empty categories from controls
		var err error
		categories, err = withTransactionalMutation(ctx).Control.Query().
			Select(control.FieldCategory).
			Where(func() predicate.Control {
				if whereP != nil {
					return control.And(control.CategoryNEQ(""), whereP)
				}
				return control.CategoryNEQ("")
			}()).
			Unique(true).
			GroupBy(control.FieldCategory).
			Strings(ctx)
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "control"})
		}

		// always add "No Category" for controls with empty/null categories
		categories = append(categories, noCategoryLabel)
	} else {
		categories = []string{*category}
	}

	// for each category, query the controls and return a connection
	result := &model.ControlGroupConnection{
		Edges: []*model.ControlGroupEdge{},
	}

	for _, category := range categories {
		var categoryFilter predicate.Control

		// handle the special "No Category" case
		if category == noCategoryLabel {
			categoryFilter = control.Or(control.CategoryEQ(""), control.CategoryIsNil())
		} else {
			categoryFilter = control.Category(category)
		}

		// combine category filters
		var combinedFilter predicate.Control
		if whereP != nil {
			combinedFilter = control.And(categoryFilter, whereP)
		} else {
			combinedFilter = categoryFilter
		}

		query, err := withTransactionalMutation(ctx).Control.Query().Where(
			combinedFilter,
		).CollectFields(ctx)
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "control"})
		}

		resp, err := query.Paginate(
			ctx,
			after,
			first,
			before,
			last,
			generated.WithControlOrder(orderBy))
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "control"})
		}

		controlGroupEdge := &model.ControlGroupEdge{
			Node: &model.ControlGroup{
				Category: category,
				Controls: resp,
			},
			PageInfo: &resp.PageInfo,
		}

		result.Edges = append(result.Edges, controlGroupEdge)
	}

	return result, nil
}
