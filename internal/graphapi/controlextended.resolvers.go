package graphapi

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"

	"entgo.io/contrib/entgql"
	"github.com/rs/zerolog/log"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/predicate"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/gqlgen-plugins/graphutils"
	"github.com/theopenlane/utils/rout"
)

// CreateControlsByClone is the resolver for the createControlsByClone field.
func (r *mutationResolver) CreateControlsByClone(ctx context.Context, input *model.CloneControlInput) (*model.ControlBulkCreatePayload, error) {
	// set the organization in the auth context if its not done for us
	if err := setOrganizationInAuthContext(ctx, input.OwnerID); err != nil {
		log.Error().Err(err).Msg("failed to set organization in auth context")

		return nil, rout.NewMissingRequiredFieldError("owner_id")
	}

	// if a standard is provided, clone those controls
	if input.StandardID != nil {
		res, err := r.cloneControlsFromStandard(ctx, *input.StandardID, input.ProgramID)
		if err != nil {
			return nil, parseRequestError(generated.ErrPermissionDenied, action{action: ActionCreate, object: "control"})
		}

		return &model.ControlBulkCreatePayload{
			Controls: res,
		}, nil
	}

	// otherwise get existing controls and clone
	// TODO(sfunk): this is an expensive operation, we should limit the number of controls that can be cloned at once
	// or check the permissions and then bypass the permission checks when querying for subcontrols
	existingControls, err := withTransactionalMutation(ctx).Control.Query().
		Where(control.IDIn(input.ControlIDs...)).
		WithSubcontrols().
		WithStandard().
		All(ctx)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "control"})
	}

	if len(existingControls) == 0 {
		return nil, parseRequestError(generated.ErrPermissionDenied, action{action: ActionCreate, object: "control"})
	}

	createdControls, err := r.cloneControls(ctx, existingControls, input.ProgramID)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionCreate, object: "control"})
	}

	return &model.ControlBulkCreatePayload{
		Controls: createdControls,
	}, nil
}

// ControlCategories is the resolver for the controlCategories field.
func (r *queryResolver) ControlCategories(ctx context.Context, orderBy []*model.ControlCategoryOrder, where *generated.ControlWhereInput) ([]*model.ControlCategoryEdge, error) {
	return r.getAllCategories(ctx, control.FieldCategory, where)
}

// ControlSubcategories is the resolver for the controlSubcategories field.
func (r *queryResolver) ControlSubcategories(ctx context.Context, orderBy []*model.ControlCategoryOrder, where *generated.ControlWhereInput) ([]*model.ControlCategoryEdge, error) {
	return r.getAllCategories(ctx, control.FieldSubcategory, where)
}

// ControlsGroupByCategory is the resolver for the controlsGroupByCategory field.
func (r *queryResolver) ControlsGroupByCategory(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy []*generated.ControlOrder, where *generated.ControlWhereInput, category *string) (*model.ControlGroupConnection, error) {
	if category == nil && after != nil || before != nil {
		log.Info().Msg("category must be provided when using pagination with after or before")

		return nil, fmt.Errorf("%w: category must be provided when using pagination with after or before", rout.ErrBadRequest)
	}

	// set page limit if nothing was set
	first, last = graphutils.SetFirstLastDefaults(first, last, r.maxResultLimit)

	if orderBy == nil {
		orderBy = []*generated.ControlOrder{
			{
				Field:     generated.ControlOrderFieldCreatedAt,
				Direction: entgql.OrderDirectionDesc,
			},
		}
	}

	whereP, err := getControlWherePredicate(where)
	if err != nil {
		return nil, parseRequestError(err, action{action: ActionGet, object: "control"})
	}

	categories := []string{}
	if category == nil {
		whereFilter := control.CategoryNEQ("")

		if whereP != nil {
			whereFilter = control.And(
				append([]predicate.Control{control.CategoryNEQ("")}, whereP)...,
			)

		}
		// get all distinct categories from controls
		var err error
		categories, err = withTransactionalMutation(ctx).Control.Query().
			Select(control.FieldCategory).
			Where(whereFilter).
			Unique(true).
			GroupBy(control.FieldCategory).
			Strings(ctx)
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "control"})
		}
	} else {
		categories = []string{*category}
	}

	// for each category, query the controls and return a connection
	result := &model.ControlGroupConnection{
		Edges: []*model.ControlGroupEdge{},
	}

	for _, category := range categories {
		query, err := withTransactionalMutation(ctx).Control.Query().Where(
			control.Category(category),
		).CollectFields(ctx)
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "control"})
		}

		resp, err := query.Paginate(
			ctx,
			after,
			first,
			before,
			last,
			generated.WithControlOrder(orderBy),
			generated.WithControlFilter(where.Filter))
		if err != nil {
			return nil, parseRequestError(err, action{action: ActionGet, object: "control"})
		}

		controlGroupEdge := &model.ControlGroupEdge{
			Node: &model.ControlGroup{
				Category: category,
				Controls: resp,
			},
			PageInfo: &resp.PageInfo,
		}

		result.Edges = append(result.Edges, controlGroupEdge)
	}

	return result, nil
}
