package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"
	"slices"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/theopenlane/core/common/models"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/ent/generated/control"
	"github.com/theopenlane/core/internal/ent/generated/predicate"
	"github.com/theopenlane/core/internal/ent/generated/subcontrol"
	"github.com/theopenlane/core/internal/graphapi/common"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/core/pkg/logx"
	"github.com/theopenlane/gqlgen-plugins/graphutils"
	"github.com/theopenlane/utils/rout"
)

// CreateControlsByClone is the resolver for the createControlsByClone field.
func (r *mutationResolver) CreateControlsByClone(ctx context.Context, input *model.CloneControlInput) (*model.ControlBulkCreatePayload, error) {
	logger := logx.FromContext(ctx)
	// set the organization in the auth context if its not done for us
	if err := common.SetOrganizationInAuthContext(ctx, input.OwnerID); err != nil {
		logger.Error().Err(err).Msg("failed to set organization in auth context")

		return nil, rout.NewMissingRequiredFieldError("owner_id")
	}

	filters := getCloneFilterOptions(input)

	// if a standard is provided, clone those controls
	if filterByStandard(filters) {
		res, err := r.cloneControlsFromStandard(ctx, filters, input.ProgramID)
		if err != nil {
			return nil, parseRequestError(ctx, generated.ErrPermissionDenied, common.Action{Action: common.ActionCreate, Object: "control"})
		}

		return &model.ControlBulkCreatePayload{
			Controls: res,
		}, nil
	}

	// otherwise get existing controls and clone
	// TODO(sfunk): this is an expensive operation, we should limit the number of controls that can be cloned at once
	// or check the permissions and then bypass the permission checks when querying for subcontrols
	existingControls, err := withTransactionalMutation(ctx).Control.Query().
		Where(control.IDIn(input.ControlIDs...)).
		WithSubcontrols().
		WithStandard().
		All(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
	}

	if len(existingControls) == 0 {
		return nil, parseRequestError(ctx, generated.ErrPermissionDenied, common.Action{Action: common.ActionCreate, Object: "control"})
	}

	createdControls, err := r.cloneControls(ctx, existingControls, input.ProgramID)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
	}

	return &model.ControlBulkCreatePayload{
		Controls: createdControls,
	}, nil
}

// CloneBulkCSVControl is the resolver for the cloneBulkCSVControl field.
func (r *mutationResolver) CloneBulkCSVControl(ctx context.Context, input graphql.Upload) (*model.ControlBulkCreatePayload, error) {
	logger := logx.FromContext(ctx)
	data, err := common.UnmarshalBulkData[model.CloneControlUploadInput](input)
	if err != nil {
		logger.Error().Err(err).Msg("failed to unmarshal bulk data")

		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
	}

	if len(data) == 0 {
		return nil, rout.NewMissingRequiredFieldError("input")
	}

	convertedInput, err := convertToCloneControlInput(data)
	if err != nil {
		logger.Error().Err(err).Msg("failed to convert clone control input")

		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
	}

	out := &model.ControlBulkCreatePayload{
		Controls: []*generated.Control{},
	}

	for _, ci := range convertedInput {
		res, err := r.CreateControlsByClone(ctx, ci)
		if err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
		}

		if res == nil || len(res.Controls) == 0 {
			continue
		}

		out.Controls = append(out.Controls, res.Controls...)
	}

	// check to see if there are additional control objects or implementations to create
	for _, c := range data {
		if c.RefCode == nil || *c.RefCode == "" {
			continue
		}

		controlID, isSubControl := getControlIDFromRefCode(*c.RefCode, out.Controls)
		if controlID == nil || *controlID == "" {
			logger.Warn().Str("ref_code", *c.RefCode).Msg("could not find control ID for ref code, skipping additional object/implementation creation")

			continue
		}

		commentIDs, err := r.createComment(ctx, c.OwnerID, c.Comment)
		if err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
		}

		if isSubControl {
			scInput, hasUpdate, convErr := getFieldsToUpdate[generated.UpdateSubcontrolInput](c)
			if convErr != nil {
				logger.Error().Err(convErr).Msg("error preparing subcontrol update fields")
			}

			if len(commentIDs) > 0 {
				if scInput == nil {
					scInput = &generated.UpdateSubcontrolInput{}
				}
				scInput.AddCommentIDs = commentIDs
				hasUpdate = true
			}

			if c.InternalPolicyID != nil {
				if scInput == nil {
					scInput = &generated.UpdateSubcontrolInput{}
				}
				scInput.AddInternalPolicyIDs = []string{*c.InternalPolicyID}
				hasUpdate = true
			}

			if hasUpdate || c.ImplementationGuidance != nil {
				base := r.db.Subcontrol.UpdateOneID(*controlID)

				if scInput != nil {
					base.SetInput(*scInput)
				}

				if c.ImplementationGuidance != nil {
					guidance := cleanImplementationGuidance(c.ImplementationGuidance)

					if guidance != nil {
						base.AppendImplementationGuidance([]models.ImplementationGuidance{*guidance})
					}
				}

				if err := base.Exec(ctx); err != nil {
					return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
				}
			}
		} else {
			cInput, hasUpdate, convErr := getFieldsToUpdate[generated.UpdateControlInput](c)
			if convErr != nil {
				logger.Error().Err(convErr).Msg("error preparing control update fields")
			}

			if len(commentIDs) > 0 {
				if cInput == nil {
					cInput = &generated.UpdateControlInput{}
				}
				cInput.AddCommentIDs = commentIDs
				hasUpdate = true
			}

			if c.InternalPolicyID != nil {
				if cInput == nil {
					cInput = &generated.UpdateControlInput{}
				}
				cInput.AddInternalPolicyIDs = []string{*c.InternalPolicyID}
				hasUpdate = true
			}

			if hasUpdate || c.ImplementationGuidance != nil {
				base := r.db.Control.UpdateOneID(*controlID)

				if cInput != nil {
					base.SetInput(*cInput)
				}

				if c.ImplementationGuidance != nil {
					guidance := cleanImplementationGuidance(c.ImplementationGuidance)

					if guidance != nil {
						base.AppendImplementationGuidance([]models.ImplementationGuidance{*guidance})
					}
				}

				if err := base.Exec(ctx); err != nil {
					return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
				}
			}
		}

		if err := r.createControlImplementation(ctx, c.OwnerID, *controlID, c.ControlImplementation); err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control implementation"})
		}

		if err := r.createControlObjective(ctx, c.OwnerID, *controlID, c.ControlObjective); err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control objective"})
		}
	}

	// get all control IDs
	controlIDs := []string{}
	for _, c := range out.Controls {
		controlIDs = append(controlIDs, c.ID)
	}

	// get the full control objects with implementations and objectives
	out.Controls, err = withTransactionalMutation(ctx).Control.Query().
		Where(control.IDIn(controlIDs...)).
		WithSubcontrols().
		WithControlImplementations().
		WithControlObjectives().
		All(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
	}

	if err := r.markSubcontrolsAsNotApplicable(ctx, data, out.Controls); err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "control"})
	}

	return out, nil
}

// ControlDiff is the resolver for the controlDiff field.
func (r *queryResolver) ControlDiff(ctx context.Context, input model.ControlDiffInput) (*model.ControlDiffPayload, error) {
	return r.controlDiff(ctx, input)
}

// ControlCategories is the resolver for the controlCategories field.
func (r *queryResolver) ControlCategories(ctx context.Context) ([]string, error) {
	categories, err := withTransactionalMutation(ctx).Control.Query().Select(control.FieldCategory).
		Where(control.CategoryNEQ("")).
		Unique(true).
		GroupBy(control.FieldCategory).
		Strings(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "categories"})
	}

	subcontrolCategories, err := withTransactionalMutation(ctx).Subcontrol.Query().Select(control.FieldCategory).
		Where(subcontrol.CategoryNEQ("")).
		Unique(true).
		GroupBy(control.FieldCategory).
		Strings(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "categories"})
	}

	for _, subcontrolCategory := range subcontrolCategories {
		// check if the subcontrol category already exists in the main categories
		if !slices.Contains(categories, subcontrolCategory) {
			// if not, append it to the main categories
			categories = append(categories, subcontrolCategory)
		}
	}

	// sort the categories to ensure consistent order
	slices.Sort(categories)

	if categories == nil {
		// if no subcategories are found, return an empty slice
		categories = []string{}
	}

	return categories, nil
}

// ControlSubcategories is the resolver for the controlSubcategories field.
func (r *queryResolver) ControlSubcategories(ctx context.Context) ([]string, error) {
	subcategories, err := withTransactionalMutation(ctx).Control.Query().Select(control.FieldSubcategory).
		Where(control.SubcategoryNEQ("")).
		Unique(true).
		GroupBy(control.FieldSubcategory).
		Strings(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "subcategories"})
	}

	subcontrolCategories, err := withTransactionalMutation(ctx).Subcontrol.Query().Select(control.FieldSubcategory).
		Where(subcontrol.SubcategoryNEQ("")).
		Unique(true).
		GroupBy(control.FieldSubcategory).
		Strings(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "subcategories"})
	}

	// append the subcontrol categories to the main categories
	for _, subcontrolCategory := range subcontrolCategories {
		// check if the subcontrol category already exists in the main subcategories
		if !slices.Contains(subcategories, subcontrolCategory) {
			// if not, append it to the main subcategories
			subcategories = append(subcategories, subcontrolCategory)
		}
	}

	// sort the subcategories to ensure consistent order
	slices.Sort(subcategories)

	if subcategories == nil {
		// if no subcategories are found, return an empty slice
		subcategories = []string{}
	}

	return subcategories, nil
}

// ControlCategoriesByFramework is the resolver for the controlCategoriesByFramework field.
func (r *queryResolver) ControlCategoriesByFramework(ctx context.Context, orderBy []*model.ControlCategoryOrder, where *generated.ControlWhereInput) ([]*model.ControlCategoryEdge, error) {
	return r.getAllCategories(ctx, control.FieldCategory, where)
}

// ControlSubcategoriesByFramework is the resolver for the controlSubcategoriesByFramework field.
func (r *queryResolver) ControlSubcategoriesByFramework(ctx context.Context, orderBy []*model.ControlCategoryOrder, where *generated.ControlWhereInput) ([]*model.ControlCategoryEdge, error) {
	return r.getAllCategories(ctx, control.FieldSubcategory, where)
}

// ControlsGroupByCategory is the resolver for the controlsGroupByCategory field.
func (r *queryResolver) ControlsGroupByCategory(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy []*generated.ControlOrder, where *generated.ControlWhereInput, category *string) (*model.ControlGroupConnection, error) {
	logger := logx.FromContext(ctx)
	if category == nil && after != nil || before != nil {
		logger.Info().Msg("category must be provided when using pagination with after or before")

		return nil, fmt.Errorf("%w: category must be provided when using pagination with after or before", rout.ErrBadRequest)
	}

	// set page limit if nothing was set
	first, last = graphutils.SetFirstLastDefaults(first, last, r.maxResultLimit)

	if orderBy == nil {
		orderBy = []*generated.ControlOrder{
			{
				Field:     generated.ControlOrderFieldCreatedAt,
				Direction: entgql.OrderDirectionDesc,
			},
		}
	}

	whereP, err := getControlWherePredicate(where)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "control"})
	}

	categories := []string{}
	if category == nil {
		// get all distinct non-empty categories from controls
		var err error
		categories, err = withTransactionalMutation(ctx).Control.Query().
			Select(control.FieldCategory).
			Where(func() predicate.Control {
				if whereP != nil {
					return control.And(control.CategoryNEQ(""), whereP)
				}
				return control.CategoryNEQ("")
			}()).
			Unique(true).
			GroupBy(control.FieldCategory).
			Strings(ctx)
		if err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "control"})
		}

		// always add "No Category" for controls with empty/null categories
		categories = append(categories, noCategoryLabel)
	} else {
		categories = []string{*category}
	}

	// for each category, query the controls and return a connection
	result := &model.ControlGroupConnection{
		Edges: []*model.ControlGroupEdge{},
	}

	for _, category := range categories {
		var categoryFilter predicate.Control

		// handle the special "No Category" case
		if category == noCategoryLabel {
			categoryFilter = control.Or(control.CategoryEQ(""), control.CategoryIsNil())
		} else {
			categoryFilter = control.Category(category)
		}

		// combine category filters
		var combinedFilter predicate.Control
		if whereP != nil {
			combinedFilter = control.And(categoryFilter, whereP)
		} else {
			combinedFilter = categoryFilter
		}

		query, err := withTransactionalMutation(ctx).Control.Query().Where(
			combinedFilter,
		).CollectFields(ctx)
		if err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "control"})
		}

		resp, err := query.Paginate(
			ctx,
			after,
			first,
			before,
			last,
			generated.WithControlOrder(orderBy))
		if err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionGet, Object: "control"})
		}

		controlGroupEdge := &model.ControlGroupEdge{
			Node: &model.ControlGroup{
				Category: category,
				Controls: resp,
			},
			PageInfo: &resp.PageInfo,
		}

		result.Edges = append(result.Edges, controlGroupEdge)
	}

	return result, nil
}
