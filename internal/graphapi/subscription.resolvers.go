package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"

	"github.com/theopenlane/core/internal/ent/generated"
	gqlgenerated "github.com/theopenlane/core/internal/graphapi/generated"
	"github.com/theopenlane/core/internal/graphsubscriptions"
	"github.com/theopenlane/iam/auth"
)

// NotificationCreated is the resolver for the notificationCreated field.
func (r *subscriptionResolver) NotificationCreated(ctx context.Context) (<-chan *generated.Notification, error) {
	userID, err := auth.GetSubjectIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get user ID from context: %w", err)
	}

	// Create a channel with the interface type for the subscription manager
	internalChan := make(chan graphsubscriptions.Notification, graphsubscriptions.TaskChannelBufferSize)
	r.Resolver.subscriptionManager.Subscribe(userID, internalChan)

	// Create a channel with the concrete type for the GraphQL response
	notifChan := make(chan *generated.Notification, graphsubscriptions.TaskChannelBufferSize)

	// Forward notifications from internal channel to GraphQL channel
	go func() {
		defer close(notifChan)
		for {
			select {
			case <-ctx.Done():
				r.Resolver.subscriptionManager.Unsubscribe(userID, internalChan)
				return
			case notif, ok := <-internalChan:
				if !ok {
					return
				}
				// Cast back to concrete type
				if concreteNotif, ok := notif.(*generated.Notification); ok {
					select {
					case notifChan <- concreteNotif:
					case <-ctx.Done():
						r.Resolver.subscriptionManager.Unsubscribe(userID, internalChan)
						return
					}
				}
			}
		}
	}()

	return notifChan, nil
}

// Subscription returns gqlgenerated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() gqlgenerated.SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
