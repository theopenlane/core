package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"
	"strings"

	"github.com/samber/lo"
	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/graphapi/common"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/utils/rout"
)

// ResolveVulnerability is the resolver for the resolveVulnerability field.
func (r *mutationResolver) ResolveVulnerability(ctx context.Context, id string, input model.ResolveVulnerabilityInput) (*model.VulnerabilityResolvePayload, error) {
	if id == "" {
		return nil, rout.NewMissingRequiredFieldError("id")
	}

	client := withTransactionalMutation(ctx)
	vuln, err := client.Vulnerability.Get(ctx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "vulnerability"})
	}

	status := strings.TrimSpace(input.Status)
	update := vuln.Update()
	if status != "" {
		update.SetStatus(status).SetOpen(false)
	}

	updated, err := update.Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "vulnerability"})
	}

	var review *generated.Review
	if lo.FromPtrOr(input.CreateReview, false) {
		title := strings.TrimSpace(lo.FromPtrOr(input.ReviewTitle, ""))
		if title == "" {
			title = lo.CoalesceOrEmpty(updated.DisplayName, updated.ExternalID)
			if title != "" {
				title = fmt.Sprintf("Resolution: %s", title)
			} else {
				title = "Vulnerability resolution"
			}
		}

		category := strings.TrimSpace(lo.FromPtrOr(input.ReviewCategory, ""))
		if category == "" {
			category = "resolution"
		}

		state := strings.TrimSpace(lo.FromPtrOr(input.ReviewState, status))

		reviewCreate := client.Review.Create().
			SetTitle(title).
			SetCategory(category).
			AddVulnerabilityIDs(updated.ID)

		if updated.OwnerID != "" {
			reviewCreate.SetOwnerID(updated.OwnerID)
		}

		if state != "" {
			reviewCreate.SetState(state)
		}

		if details := strings.TrimSpace(lo.FromPtrOr(input.Details, "")); details != "" {
			reviewCreate.SetDetails(details)
		} else if reason := strings.TrimSpace(lo.FromPtrOr(input.Reason, "")); reason != "" {
			reviewCreate.SetSummary(reason)
		}

		if caller, ok := auth.CallerFromContext(ctx); ok && caller != nil {
			if caller.SubjectType() == auth.UserSubjectType && caller.SubjectID != "" {
				reviewCreate.SetReviewerID(caller.SubjectID)
			}
		}

		review, err = reviewCreate.Save(ctx)
		if err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "review"})
		}
	}

	return &model.VulnerabilityResolvePayload{
		Vulnerability: updated,
		Review:        review,
	}, nil
}
