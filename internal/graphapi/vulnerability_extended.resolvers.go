package graphapi

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"
	"strings"

	"github.com/theopenlane/core/internal/ent/generated"
	"github.com/theopenlane/core/internal/graphapi/common"
	"github.com/theopenlane/core/internal/graphapi/model"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/utils/rout"
)

// ResolveVulnerability is the resolver for the resolveVulnerability field.
func (r *mutationResolver) ResolveVulnerability(ctx context.Context, id string, input model.ResolveVulnerabilityInput) (*model.VulnerabilityResolvePayload, error) {
	if id == "" {
		return nil, rout.NewMissingRequiredFieldError("id")
	}

	client := withTransactionalMutation(ctx)
	vuln, err := client.Vulnerability.Get(ctx, id)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "vulnerability"})
	}

	update := vuln.Update().SetStatus(input.Status)
	if strings.TrimSpace(input.Status) != "" {
		update.SetOpen(false)
	}

	updated, err := update.Save(ctx)
	if err != nil {
		return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionUpdate, Object: "vulnerability"})
	}

	var review *generated.Review
	if input.CreateReview != nil && *input.CreateReview {
		title := "Vulnerability resolution"
		if input.ReviewTitle != nil && strings.TrimSpace(*input.ReviewTitle) != "" {
			title = *input.ReviewTitle
		} else if updated.DisplayName != "" {
			title = fmt.Sprintf("Resolution: %s", updated.DisplayName)
		} else if updated.ExternalID != "" {
			title = fmt.Sprintf("Resolution: %s", updated.ExternalID)
		}

		reviewCreate := client.Review.Create().SetTitle(title)
		if updated.OwnerID != "" {
			reviewCreate.SetOwnerID(updated.OwnerID)
		}
		if input.ReviewCategory != nil && strings.TrimSpace(*input.ReviewCategory) != "" {
			reviewCreate.SetCategory(*input.ReviewCategory)
		} else {
			reviewCreate.SetCategory("resolution")
		}
		if input.ReviewState != nil && strings.TrimSpace(*input.ReviewState) != "" {
			reviewCreate.SetState(*input.ReviewState)
		} else if strings.TrimSpace(input.Status) != "" {
			reviewCreate.SetState(input.Status)
		}

		if input.Details != nil && strings.TrimSpace(*input.Details) != "" {
			reviewCreate.SetDetails(*input.Details)
		} else if input.Reason != nil && strings.TrimSpace(*input.Reason) != "" {
			reviewCreate.SetSummary(*input.Reason)
		}

		if userID, err := auth.GetSubjectIDFromContext(ctx); err == nil && userID != "" {
			reviewCreate.SetReviewerID(userID)
		}

		reviewCreate.AddVulnerabilityIDs(updated.ID)

		review, err = reviewCreate.Save(ctx)
		if err != nil {
			return nil, parseRequestError(ctx, err, common.Action{Action: common.ActionCreate, Object: "review"})
		}
	}

	return &model.VulnerabilityResolvePayload{
		Vulnerability: updated,
		Review:        review,
	}, nil
}
