package graphapi

import (
	"context"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/handler"
	echo "github.com/theopenlane/echox"
	"github.com/theopenlane/echox/middleware/echocontext"
	"github.com/theopenlane/iam/auth"
	"github.com/theopenlane/iam/sessions"
)

const (
	// AuthExtensionKey is the key used to store the auth data in the extensions map
	AuthExtensionKey = "auth"
	// ServerLatencyExtensionKey is the key used to store the server latency in the extensions map
	ServerLatencyExtensionKey = "server_latency"
	// TraceExtensionKey is the key used to store the trace id in the extensions map
	TraceExtensionKey = "trace_id"
)

// Auth contains the authentication data to be added to the extensions map
type Auth struct {
	// AuthenticationType is the type of authentication used, e.g. JWT, API key, etc.
	AuthenticationType auth.AuthenticationType `json:"authentication_type,omitempty"`
	// AuthorizedOrganization is the organization ID of the authenticated user
	AuthorizedOrganization string `json:"authorized_organization,omitempty"`
	// AccessToken is the access token used for authentication, if the user did an action (e.g. created a new organization)
	// that updated the access token, this will be the new access token
	AccessToken string `json:"access_token,omitempty"`
	// RefreshToken is the refresh token used for authentication, if the user did an action (e.g. created a new organization)
	// that updated the refresh token, this will be the new refresh token
	RefreshToken string `json:"refresh_token,omitempty"`
	// SessionID is the session token used for authentication
	SessionID string `json:"session_id,omitempty"`
}

// AddAllExtensions adds all the extensions to the server including auth, latency and trace
func AddAllExtensions(h *handler.Server) {
	// add the auth extension
	authExtension(h)
	// add the latency extension
	latencyExtension(h)
	// add the trace extension
	traceExtension(h)
}

// authExtension adds the auth data to the extensions map in the response
func authExtension(h *handler.Server) {
	h.AroundResponses(func(ctx context.Context, next graphql.ResponseHandler) *graphql.Response {
		resp := next(ctx)

		resp = initExtensionResponse(resp)

		resp.Extensions[AuthExtensionKey] = getAuthData(ctx)

		return resp
	})
}

// latencyExtension adds the server latency to the extensions map in the response
func latencyExtension(h *handler.Server) {
	h.AroundResponses(func(ctx context.Context, next graphql.ResponseHandler) *graphql.Response {
		start := time.Now()
		resp := next(ctx)
		latency := time.Since(start).String()

		resp = initExtensionResponse(resp)

		resp.Extensions[ServerLatencyExtensionKey] = latency

		return resp
	})
}

// traceExtension adds the trace id to the extensions map in the response
func traceExtension(h *handler.Server) {
	h.AroundResponses(func(ctx context.Context, next graphql.ResponseHandler) *graphql.Response {
		resp := next(ctx)

		traceID := getRequestID(ctx)

		resp = initExtensionResponse(resp)

		resp.Extensions[TraceExtensionKey] = traceID

		return resp
	})
}

// initExtensionResponse initializes the extensions map in the response to avoid nil pointer panics
func initExtensionResponse(resp *graphql.Response) *graphql.Response {
	if resp.Extensions == nil {
		resp.Extensions = make(map[string]interface{})
	}

	return resp
}

// getRequestID retrieves the trace request id from the context
// if the echo context is not available an empty string is returned
func getRequestID(ctx context.Context) string {
	c, err := echocontext.EchoContextFromContext(ctx)
	if err != nil {
		return ""
	}

	requestID := c.Request().Header.Get(echo.HeaderXRequestID) // request-id generated by reverse-proxy
	if requestID == "" {
		// missed request-id from proxy, got generated one by middleware.RequestID()
		requestID = c.Response().Header().Get(echo.HeaderXRequestID)
	}

	return requestID
}

// getAuthData retrieves the auth data from the context if available
// all errors are ignored because the auth data is optional
func getAuthData(ctx context.Context) Auth {
	ac, _ := auth.GetAuthenticatedUserContext(ctx)
	if ac == nil {
		// return early to prevent nil pointer panics
		return Auth{}
	}

	at, _ := auth.GetAccessTokenContext(ctx)
	rt, _ := auth.GetRefreshTokenContext(ctx)
	session, _ := sessions.SessionToken(ctx)

	return Auth{
		AuthenticationType:     ac.AuthenticationType,
		AuthorizedOrganization: ac.OrganizationID,
		AccessToken:            at,
		RefreshToken:           rt,
		SessionID:              session,
	}
}
