package registry

import (
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"runtime/debug"
	"strings"

	"github.com/rs/zerolog/log"
)

// Validator is for the types which need their own Validate function
// always define Validate on non-pointer level Spec.Validate instead of (*Spec).Validate
type Validator interface {
	Validate() error
}

// ValidateRecorder records varied errors after validating
type ValidateRecorder struct {
	// JSONSchemaErrs generated by vendor json schema
	JSONSchemaErrs []string `json:"jsonschemaErrs,omitempty"`
	// FormatErrs generated by the format function of the single field
	FormatErrs []string `json:"formatErrs,omitempty"`
	// GeneralErrs generated by Validate() of the Validator itself
	GeneralErrs []string `json:"generalErrs,omitempty"`
	// SystemErr stands internal error, which often means bugs
	SystemErr string `json:"systemErr,omitempty"`
}

func (vr *ValidateRecorder) recordJSONSchema(err error) {
	if err != nil {
		vr.JSONSchemaErrs = append(vr.JSONSchemaErrs, err.Error())
	}
}

func getFieldJSONName(field *reflect.StructField) string {
	fieldName := field.Name

	fieldNames := strings.Split(field.Tag.Get("json"), ",")
	if len(fieldNames) > 0 {
		fieldName = fieldNames[0]
	}

	return fieldName
}

func isOmitemptyField(field *reflect.StructField) bool {
	tags := strings.Split(field.Tag.Get("json"), ",")

	for _, tag := range tags {
		if tag == "omitempty" {
			return true
		}
	}

	return false
}

func (vr *ValidateRecorder) record(val *reflect.Value, field *reflect.StructField) {
	vr.recordFormat(val, field)
	vr.recordGeneral(val, field)
}

func (vr *ValidateRecorder) recordFormat(val *reflect.Value, field *reflect.StructField) {
	if field == nil {
		return
	}

	if isOmitemptyField(field) && val.IsZero() {
		return
	}

	tags := strings.Split(field.Tag.Get("jsonschema"), ",")
	for _, tag := range tags {
		nameValue := strings.Split(tag, "=")
		if len(nameValue) != 2 { // nolint:mnd
			continue
		}

		name, value := nameValue[0], nameValue[1]
		if name != "format" {
			continue
		}

		fn, ok := getFormatFunc(value)
		if !ok {
			log.Error().Msgf("unsupported format: %s", value)
			return
		}

		err := fn(val.Interface())
		if err != nil {
			vr.FormatErrs = append(vr.FormatErrs,
				fmt.Sprintf("%s: %s",
					getFieldJSONName(field),
					err.Error()))
		}
	}
}

// ErrValidatePanic is the error when the validate function panics
var ErrValidatePanic = errors.New("call validate panic")

func (vr *ValidateRecorder) recordGeneral(val *reflect.Value, field *reflect.StructField) {
	t := val.Type()
	if t.Kind() == reflect.Ptr {
		elemType := t.Elem()

		// NOTE: MethodByName returns the existence of the method
		// only if the method is defined on Spec instead of *Spec.
		// So we need to return here in case of calling Validate twice.
		if _, exists := elemType.MethodByName("Validate"); exists {
			return
		}
	}

	fieldName := val.Type().String()
	if field != nil {
		fieldName = getFieldJSONName(field)
	}

	v, ok := val.Interface().(Validator)
	if !ok {
		return
	}

	defer func() {
		if r := recover(); r != nil {
			err := fmt.Errorf("%w: for %T: %v", ErrValidatePanic, v, r)
			log.Error().Msgf("%v\n%s", err, debug.Stack())
			vr.recordSystem(err)
		}
	}()

	err := v.Validate()
	if err != nil {
		vr.GeneralErrs = append(vr.GeneralErrs, fmt.Sprintf("%s: %s",
			fieldName,
			err.Error()))
	}
}

func (vr *ValidateRecorder) recordSystem(err error) {
	if err != nil {
		vr.SystemErr = err.Error()
	}
}

// Error returns the string representation of the recorder
func (vr *ValidateRecorder) Error() string {
	return vr.String()
}

// String marshals the recorder to json and returns the string
func (vr *ValidateRecorder) String() string {
	if vr == nil {
		return ""
	}

	buff, err := json.Marshal(vr)
	if err != nil {
		log.Error().Err(err).Interface("recorder", vr).Msg("marshal to json failed")
	}

	return string(buff)
}

// Valid represents if the result is valid
func (vr *ValidateRecorder) Valid() bool {
	return len(vr.JSONSchemaErrs) == 0 && len(vr.FormatErrs) == 0 &&
		len(vr.GeneralErrs) == 0 && len(vr.SystemErr) == 0
}
