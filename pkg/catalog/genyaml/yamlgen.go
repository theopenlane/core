package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"sort"

	"github.com/dave/jennifer/jen"
	yaml "github.com/goccy/go-yaml"
	"github.com/urfave/cli/v2"

	"github.com/theopenlane/core/pkg/catalog"
)

// main is the entry point for the gencatalog CLI application and just a // little wrapper instead of having everything in main
func main() {
	if err := genyamlApp().Run(os.Args); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

var repoPath = "github.com/theopenlane/core/pkg/catalog"

// genyamlApp creates a CLI application for generating Go source files
// from a catalog YAML file - the thought process behind this is that
// it's generally easier to work with Go code than YAML, especially at
// runtime; contantly unmarshalling YAML within our app has performance
// and usability implications
func genyamlApp() *cli.App {
	app := &cli.App{
		Name:  "gencatalog",
		Usage: "Generate a Go source file from a catalog YAML file",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "in",
				Value:   "catalog.yaml",
				Usage:   "Path to the catalog YAML file",
				EnvVars: []string{"OPENLANE_CATALOG_FILE"},
			},
			&cli.StringFlag{
				Name:    "out",
				Value:   "./gencatalog/gencatalog.go",
				Usage:   "Output Go file (stdout if empty)",
				EnvVars: []string{"OPENLANE_CATALOG_OUTPUT"},
			},
		},
		Action: func(c *cli.Context) error {
			input := c.String("in")
			output := c.String("out")

			data, err := os.ReadFile(input)
			if err != nil {
				return err
			}

			var ct catalog.Catalog

			if err := yaml.Unmarshal(data, &ct); err != nil {
				return err
			}

			f := jen.NewFile("gencatalog")
			f.HeaderComment("Code generated by gencatalog.go; DO NOT EDIT.")
			f.Var().Id("DefaultCatalog").Op("=").Add(catalogLit(ct))

			buf := &bytes.Buffer{}
			if err := f.Render(buf); err != nil {
				return err
			}

			formatted, err := format.Source(buf.Bytes())
			if err != nil {
				return err
			}

			if output == "" {
				os.Stdout.Write(formatted)

				return nil
			}

			if err := os.WriteFile(output, formatted, 0600); err != nil { // nolint: mnd
				return err
			}

			return nil
		},
	}

	return app
}

// catalogLit generates the main block for catalog.Catalog
func catalogLit(c catalog.Catalog) *jen.Statement {
	return jen.Qual(repoPath, "Catalog").Values(jen.Dict{
		jen.Id("Version"): jen.Lit(c.Version),
		jen.Id("SHA"):     jen.Lit(c.SHA),
		jen.Id("Modules"): featureSetLit(c.Modules),
		jen.Id("Addons"):  featureSetLit(c.Addons),
	})
}

// featureSetLit generates a map for a FeatureSet, sorting the keys and
// creating a dict for the values
func featureSetLit(fs catalog.FeatureSet) *jen.Statement {
	keys := make([]string, 0, len(fs))

	for k := range fs {
		keys = append(keys, k)
	}

	sort.Strings(keys)

	dict := jen.Dict{}

	for _, k := range keys {
		dict[jen.Lit(k)] = featureLit(fs[k])
	}

	return jen.Map(jen.String()).Qual(repoPath, "Feature").Values(dict)
}

// featureLit generates the main structure for a catalog.Feature
func featureLit(f catalog.Feature) *jen.Statement {
	dict := jen.Dict{
		jen.Id("DisplayName"): jen.Lit(f.DisplayName),
		jen.Id("Description"): jen.Lit(f.Description),
		jen.Id("Audience"):    jen.Lit(f.Audience),
	}
	// Only emit Billing if not zero value
	if !isBillingEmpty(f.Billing) {
		// Make Billing a pointer in the generated struct
		dict[jen.Id("Billing")] = billingLit(f.Billing)
	}
	// Only emit Usage if non-nil
	if f.Usage != nil {
		dict[jen.Id("Usage")] = jen.Op("&").Add(usageLit(*f.Usage))
	}

	return jen.Qual(repoPath, "Feature").Values(dict)
}

// isBillingEmpty checks if all fields in Billing are zero values
func isBillingEmpty(b catalog.Billing) bool {
	return len(b.Prices) == 0
}

// billingLit generates a block for catalog.Billing, including Prices
// as a slice each representing a catalog.Price
// It uses jen.Index().Qual to create a slice of Prices
// and jen.Dict to create the Billing struct
// prices are sorted by their LookupKey for consistency
func billingLit(b catalog.Billing) *jen.Statement {
	items := make([]jen.Code, len(b.Prices))

	for i, p := range b.Prices {
		items[i] = priceLit(p)
	}

	return jen.Qual(repoPath, "Billing").Values(jen.Dict{
		jen.Id("Prices"): jen.Index().Qual(repoPath, "Price").Values(items...)})
}

// usageLit generates a block for catalog.Usage, currently only
// containing EvidenceStorageGB, but can be extended in the future
// if more fields are added to catalog.Usage
func usageLit(u catalog.Usage) *jen.Statement {
	return jen.Qual(repoPath, "Usage").Values(jen.Dict{
		jen.Id("EvidenceStorageGB"): jen.Lit(u.EvidenceStorageGB),
	})
}

// priceLit generates a list of elemtents for price
func priceLit(p catalog.Price) *jen.Statement {
	dict := jen.Dict{
		jen.Id("Interval"):   jen.Lit(p.Interval),
		jen.Id("UnitAmount"): jen.Lit(p.UnitAmount),
	}

	if p.PriceID != "" {
		dict[jen.Id("PriceID")] = jen.Lit(p.PriceID)
	}

	if p.Nickname != "" {
		dict[jen.Id("Nickname")] = jen.Lit(p.Nickname)
	}

	if p.LookupKey != "" {
		dict[jen.Id("LookupKey")] = jen.Lit(p.LookupKey)
	}

	if len(p.Metadata) > 0 {
		mkeys := make([]string, 0, len(p.Metadata))
		for k := range p.Metadata {
			mkeys = append(mkeys, k)
		}

		sort.Strings(mkeys)

		mdict := jen.Dict{}

		for _, k := range mkeys {
			mdict[jen.Lit(k)] = jen.Lit(p.Metadata[k])
		}

		dict[jen.Id("Metadata")] = jen.Map(jen.String()).String().Values(mdict)
	}

	return jen.Qual(repoPath, "Price").Values(dict)
}
