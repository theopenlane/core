package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"sort"

	"github.com/dave/jennifer/jen"
	yaml "github.com/goccy/go-yaml"

	"github.com/theopenlane/core/pkg/catalog"
)

func main() {
	var input string
	var output string
	flag.StringVar(&input, "in", "catalog.yaml", "path to catalog yaml")
	flag.StringVar(&output, "out", "./gencatalog/gencatalog.go", "output go file (stdout if empty)")
	flag.Parse()

	data, err := os.ReadFile(input)
	if err != nil {
		fmt.Fprintln(os.Stderr, "read catalog:", err)
		os.Exit(1)
	}

	var c catalog.Catalog

	if err := yaml.Unmarshal(data, &c); err != nil {
		fmt.Fprintln(os.Stderr, "parse catalog:", err)
		os.Exit(1)
	}

	f := jen.NewFile("gencatalog")
	f.HeaderComment("Code generated by gencatalog.go; DO NOT EDIT.")
	f.Var().Id("DefaultCatalog").Op("=").Add(catalogLit(c))

	buf := &bytes.Buffer{}
	if err := f.Render(buf); err != nil {
		fmt.Fprintln(os.Stderr, "render source:", err)
		os.Exit(1)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, "format source:", err)
		os.Exit(1)
	}

	if output == "" {
		os.Stdout.Write(formatted)
		return
	}

	if err := os.WriteFile(output, formatted, 0600); err != nil { // nolint: mnd
		fmt.Fprintln(os.Stderr, "write output:", err)
		os.Exit(1)
	}
}

func catalogLit(c catalog.Catalog) *jen.Statement {
	return jen.Qual("github.com/theopenlane/core/pkg/catalog", "Catalog").Values(jen.Dict{
		jen.Id("Version"): jen.Lit(c.Version),
		jen.Id("SHA"):     jen.Lit(c.SHA),
		jen.Id("Modules"): featureSetLit(c.Modules),
		jen.Id("Addons"):  featureSetLit(c.Addons),
	})
}

func featureSetLit(fs catalog.FeatureSet) *jen.Statement {
	keys := make([]string, 0, len(fs))

	for k := range fs {
		keys = append(keys, k)
	}

	sort.Strings(keys)
	dict := jen.Dict{}

	for _, k := range keys {
		dict[jen.Lit(k)] = featureLit(fs[k])
	}

	return jen.Map(jen.String()).Qual("github.com/theopenlane/core/pkg/catalog", "Feature").Values(dict)
}

func featureLit(f catalog.Feature) *jen.Statement {
	dict := jen.Dict{
		jen.Id("DisplayName"): jen.Lit(f.DisplayName),
		jen.Id("Description"): jen.Lit(f.Description),
		jen.Id("Audience"):    jen.Lit(f.Audience),
	}
	// Only emit Billing if not zero value
	if !isBillingEmpty(f.Billing) {
		// Make Billing a pointer in the generated struct
		dict[jen.Id("Billing")] = billingLit(f.Billing)
	}
	// Only emit Usage if non-nil
	if f.Usage != nil {
		dict[jen.Id("Usage")] = jen.Op("&").Add(usageLit(*f.Usage))
	}

	return jen.Qual("github.com/theopenlane/core/pkg/catalog", "Feature").Values(dict)
}

// isBillingEmpty checks if all fields in Billing are zero values.
func isBillingEmpty(b catalog.Billing) bool {
	return len(b.Prices) == 0
}

func billingLit(b catalog.Billing) *jen.Statement {
	items := make([]jen.Code, len(b.Prices))

	for i, p := range b.Prices {
		items[i] = priceLit(p)
	}

	return jen.Qual("github.com/theopenlane/core/pkg/catalog", "Billing").Values(jen.Dict{
		jen.Id("Prices"): jen.Index().Qual("github.com/theopenlane/core/pkg/catalog", "Price").Values(items...)})
}

func usageLit(u catalog.Usage) *jen.Statement {
	return jen.Qual("github.com/theopenlane/core/pkg/catalog", "Usage").Values(jen.Dict{
		jen.Id("EvidenceStorageGB"): jen.Lit(u.EvidenceStorageGB),
	})
}

func priceLit(p catalog.Price) *jen.Statement {
	dict := jen.Dict{
		jen.Id("Interval"):   jen.Lit(p.Interval),
		jen.Id("UnitAmount"): jen.Lit(p.UnitAmount),
	}

	if p.PriceID != "" {
		dict[jen.Id("PriceID")] = jen.Lit(p.PriceID)
	}

	if p.Nickname != "" {
		dict[jen.Id("Nickname")] = jen.Lit(p.Nickname)
	}

	if p.LookupKey != "" {
		dict[jen.Id("LookupKey")] = jen.Lit(p.LookupKey)
	}

	if len(p.Metadata) > 0 {
		mkeys := make([]string, 0, len(p.Metadata))
		for k := range p.Metadata {
			mkeys = append(mkeys, k)
		}

		sort.Strings(mkeys)
		mdict := jen.Dict{}

		for _, k := range mkeys {
			mdict[jen.Lit(k)] = jen.Lit(p.Metadata[k])
		}

		dict[jen.Id("Metadata")] = jen.Map(jen.String()).String().Values(mdict)
	}

	return jen.Qual("github.com/theopenlane/core/pkg/catalog", "Price").Values(dict)
}
