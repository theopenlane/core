// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package openlaneclient

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/core/pkg/models"
	"github.com/theopenlane/entx/history"
)

type APIToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt *time.Time `json:"revokedAt,omitempty"`
	// SSO verification time for the owning organization
	SsoAuthorizations *string       `json:"ssoAuthorizations,omitempty"`
	Owner             *Organization `json:"owner,omitempty"`
}

func (APIToken) IsNode() {}

// Return response for createBulkAPIToken mutation
type APITokenBulkCreatePayload struct {
	// Created apiTokens
	APITokens []*APIToken `json:"apiTokens,omitempty"`
}

// Return response for deleteBulkAPIToken mutation
type APITokenBulkDeletePayload struct {
	// Deleted apiToken IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type APITokenConnection struct {
	// A list of edges.
	Edges []*APITokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createAPIToken mutation
type APITokenCreatePayload struct {
	// Created apiToken
	APIToken *APIToken `json:"apiToken"`
}

// Return response for deleteAPIToken mutation
type APITokenDeletePayload struct {
	// Deleted apiToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type APITokenEdge struct {
	// The item at the end of the edge.
	Node *APIToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for APIToken connections
type APITokenOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order APITokens.
	Field APITokenOrderField `json:"field"`
}

// Return response for updateAPIToken mutation
type APITokenUpdatePayload struct {
	// Updated apiToken
	APIToken *APIToken `json:"apiToken"`
}

// APITokenWhereInput is used for filtering APIToken objects.
// Input was generated by ent.
type APITokenWhereInput struct {
	Not *APITokenWhereInput   `json:"not,omitempty"`
	And []*APITokenWhereInput `json:"and,omitempty"`
	Or  []*APITokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// is_active field predicates
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNeq    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  *bool `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil *bool `json:"isActiveNotNil,omitempty"`
	// revoked_reason field predicates
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNeq          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGt           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGte          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLt           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLte          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        *bool    `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       *bool    `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`
	// revoked_by field predicates
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNeq          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGt           *string  `json:"revokedByGT,omitempty"`
	RevokedByGte          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLt           *string  `json:"revokedByLT,omitempty"`
	RevokedByLte          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        *bool    `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       *bool    `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`
	// revoked_at field predicates
	RevokedAt       *time.Time   `json:"revokedAt,omitempty"`
	RevokedAtNeq    *time.Time   `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []*time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []*time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGt     *time.Time   `json:"revokedAtGT,omitempty"`
	RevokedAtGte    *time.Time   `json:"revokedAtGTE,omitempty"`
	RevokedAtLt     *time.Time   `json:"revokedAtLT,omitempty"`
	RevokedAtLte    *time.Time   `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  *bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil *bool        `json:"revokedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type ActionPlan struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the action_plan
	Name string `json:"name"`
	// status of the action_plan, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the action_plan, e.g. compliance, operational, health and safety, etc.
	ActionPlanType *string `json:"actionPlanType,omitempty"`
	// details of the action_plan
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the action_plan
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the action_plan should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the action_plan should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// the id of the group responsible for approving the action_plan
	ApproverID *string `json:"approverID,omitempty"`
	// the id of the group responsible for approving the action_plan
	DelegateID *string `json:"delegateID,omitempty"`
	Summary    *string `json:"summary,omitempty"`
	// auto-generated tag suggestions for the action_plan
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the action_plan
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the action_plan
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the action_plan
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the action_plan
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the action_plan
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the action_plan
	URL *string `json:"url,omitempty"`
	// This will contain the most recent file id if this action_plan was created from a file
	FileID *string `json:"fileID,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the action_plan
	ActionPlanKindName *string `json:"actionPlanKindName,omitempty"`
	// the kind of the action_plan
	ActionPlanKindID *string `json:"actionPlanKindID,omitempty"`
	// short title describing the action plan
	Title string `json:"title"`
	// detailed description of remediation steps and objectives
	Description *string `json:"description,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// timestamp when the action plan was completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// priority of the action plan
	Priority *enums.Priority `json:"priority,omitempty"`
	// indicates if the action plan requires explicit approval before closure
	RequiresApproval bool `json:"requiresApproval"`
	// true when the action plan is currently blocked
	Blocked bool `json:"blocked"`
	// context on why the action plan is blocked
	BlockerReason *string `json:"blockerReason,omitempty"`
	// additional structured metadata for the action plan
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload map[string]any `json:"rawPayload,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
	// the group of users who are responsible for approving the action_plan
	Approver *Group `json:"approver,omitempty"`
	// temporary delegates for the action_plan, used for temporary approval
	Delegate        *Group                   `json:"delegate,omitempty"`
	Owner           *Organization            `json:"owner,omitempty"`
	ActionPlanKind  *CustomTypeEnum          `json:"actionPlanKind,omitempty"`
	Risks           *RiskConnection          `json:"risks"`
	Controls        *ControlConnection       `json:"controls"`
	Programs        *ProgramConnection       `json:"programs"`
	Findings        *FindingConnection       `json:"findings"`
	Vulnerabilities *VulnerabilityConnection `json:"vulnerabilities"`
	Reviews         *ReviewConnection        `json:"reviews"`
	Remediations    *RemediationConnection   `json:"remediations"`
	Tasks           *TaskConnection          `json:"tasks"`
	Integrations    *IntegrationConnection   `json:"integrations"`
	File            *File                    `json:"file,omitempty"`
}

func (ActionPlan) IsNode() {}

// Return response for createBulkActionPlan mutation
type ActionPlanBulkCreatePayload struct {
	// Created actionPlans
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
}

// Return response for deleteBulkActionPlan mutation
type ActionPlanBulkDeletePayload struct {
	// Deleted actionPlan IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkActionPlan mutation
type ActionPlanBulkUpdatePayload struct {
	// Updated actionPlans
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
	// IDs of the updated actionPlans
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type ActionPlanConnection struct {
	// A list of edges.
	Edges []*ActionPlanEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createActionPlan mutation
type ActionPlanCreatePayload struct {
	// Created actionPlan
	ActionPlan *ActionPlan `json:"actionPlan"`
}

// Return response for deleteActionPlan mutation
type ActionPlanDeletePayload struct {
	// Deleted actionPlan ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ActionPlanEdge struct {
	// The item at the end of the edge.
	Node *ActionPlan `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ActionPlanHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the action_plan
	Name string `json:"name"`
	// status of the action_plan, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the action_plan, e.g. compliance, operational, health and safety, etc.
	ActionPlanType *string `json:"actionPlanType,omitempty"`
	// details of the action_plan
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the action_plan
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the action_plan should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the action_plan should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// the id of the group responsible for approving the action_plan
	ApproverID *string `json:"approverID,omitempty"`
	// the id of the group responsible for approving the action_plan
	DelegateID *string `json:"delegateID,omitempty"`
	Summary    *string `json:"summary,omitempty"`
	// auto-generated tag suggestions for the action_plan
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the action_plan
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the action_plan
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the action_plan
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the action_plan
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the action_plan
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the action_plan
	URL *string `json:"url,omitempty"`
	// This will contain the most recent file id if this action_plan was created from a file
	FileID *string `json:"fileID,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the action_plan
	ActionPlanKindName *string `json:"actionPlanKindName,omitempty"`
	// the kind of the action_plan
	ActionPlanKindID *string `json:"actionPlanKindID,omitempty"`
	// short title describing the action plan
	Title string `json:"title"`
	// detailed description of remediation steps and objectives
	Description *string `json:"description,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// timestamp when the action plan was completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// priority of the action plan
	Priority *enums.Priority `json:"priority,omitempty"`
	// indicates if the action plan requires explicit approval before closure
	RequiresApproval bool `json:"requiresApproval"`
	// true when the action plan is currently blocked
	Blocked bool `json:"blocked"`
	// context on why the action plan is blocked
	BlockerReason *string `json:"blockerReason,omitempty"`
	// additional structured metadata for the action plan
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload map[string]any `json:"rawPayload,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
}

func (ActionPlanHistory) IsNode() {}

// A connection to a list of items.
type ActionPlanHistoryConnection struct {
	// A list of edges.
	Edges []*ActionPlanHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ActionPlanHistoryEdge struct {
	// The item at the end of the edge.
	Node *ActionPlanHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ActionPlanHistory connections
type ActionPlanHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ActionPlanHistories.
	Field ActionPlanHistoryOrderField `json:"field"`
}

// ActionPlanHistoryWhereInput is used for filtering ActionPlanHistory objects.
// Input was generated by ent.
type ActionPlanHistoryWhereInput struct {
	Not *ActionPlanHistoryWhereInput   `json:"not,omitempty"`
	And []*ActionPlanHistoryWhereInput `json:"and,omitempty"`
	Or  []*ActionPlanHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// action_plan_type field predicates
	ActionPlanType             *string  `json:"actionPlanType,omitempty"`
	ActionPlanTypeNeq          *string  `json:"actionPlanTypeNEQ,omitempty"`
	ActionPlanTypeIn           []string `json:"actionPlanTypeIn,omitempty"`
	ActionPlanTypeNotIn        []string `json:"actionPlanTypeNotIn,omitempty"`
	ActionPlanTypeGt           *string  `json:"actionPlanTypeGT,omitempty"`
	ActionPlanTypeGte          *string  `json:"actionPlanTypeGTE,omitempty"`
	ActionPlanTypeLt           *string  `json:"actionPlanTypeLT,omitempty"`
	ActionPlanTypeLte          *string  `json:"actionPlanTypeLTE,omitempty"`
	ActionPlanTypeContains     *string  `json:"actionPlanTypeContains,omitempty"`
	ActionPlanTypeHasPrefix    *string  `json:"actionPlanTypeHasPrefix,omitempty"`
	ActionPlanTypeHasSuffix    *string  `json:"actionPlanTypeHasSuffix,omitempty"`
	ActionPlanTypeIsNil        *bool    `json:"actionPlanTypeIsNil,omitempty"`
	ActionPlanTypeNotNil       *bool    `json:"actionPlanTypeNotNil,omitempty"`
	ActionPlanTypeEqualFold    *string  `json:"actionPlanTypeEqualFold,omitempty"`
	ActionPlanTypeContainsFold *string  `json:"actionPlanTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// approver_id field predicates
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIdneq          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIdgt           *string  `json:"approverIDGT,omitempty"`
	ApproverIdgte          *string  `json:"approverIDGTE,omitempty"`
	ApproverIdlt           *string  `json:"approverIDLT,omitempty"`
	ApproverIdlte          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        *bool    `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       *bool    `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDIsNil        *bool    `json:"fileIDIsNil,omitempty"`
	FileIDNotNil       *bool    `json:"fileIDNotNil,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// action_plan_kind_name field predicates
	ActionPlanKindName             *string  `json:"actionPlanKindName,omitempty"`
	ActionPlanKindNameNeq          *string  `json:"actionPlanKindNameNEQ,omitempty"`
	ActionPlanKindNameIn           []string `json:"actionPlanKindNameIn,omitempty"`
	ActionPlanKindNameNotIn        []string `json:"actionPlanKindNameNotIn,omitempty"`
	ActionPlanKindNameGt           *string  `json:"actionPlanKindNameGT,omitempty"`
	ActionPlanKindNameGte          *string  `json:"actionPlanKindNameGTE,omitempty"`
	ActionPlanKindNameLt           *string  `json:"actionPlanKindNameLT,omitempty"`
	ActionPlanKindNameLte          *string  `json:"actionPlanKindNameLTE,omitempty"`
	ActionPlanKindNameContains     *string  `json:"actionPlanKindNameContains,omitempty"`
	ActionPlanKindNameHasPrefix    *string  `json:"actionPlanKindNameHasPrefix,omitempty"`
	ActionPlanKindNameHasSuffix    *string  `json:"actionPlanKindNameHasSuffix,omitempty"`
	ActionPlanKindNameIsNil        *bool    `json:"actionPlanKindNameIsNil,omitempty"`
	ActionPlanKindNameNotNil       *bool    `json:"actionPlanKindNameNotNil,omitempty"`
	ActionPlanKindNameEqualFold    *string  `json:"actionPlanKindNameEqualFold,omitempty"`
	ActionPlanKindNameContainsFold *string  `json:"actionPlanKindNameContainsFold,omitempty"`
	// action_plan_kind_id field predicates
	ActionPlanKindID             *string  `json:"actionPlanKindID,omitempty"`
	ActionPlanKindIdneq          *string  `json:"actionPlanKindIDNEQ,omitempty"`
	ActionPlanKindIDIn           []string `json:"actionPlanKindIDIn,omitempty"`
	ActionPlanKindIDNotIn        []string `json:"actionPlanKindIDNotIn,omitempty"`
	ActionPlanKindIdgt           *string  `json:"actionPlanKindIDGT,omitempty"`
	ActionPlanKindIdgte          *string  `json:"actionPlanKindIDGTE,omitempty"`
	ActionPlanKindIdlt           *string  `json:"actionPlanKindIDLT,omitempty"`
	ActionPlanKindIdlte          *string  `json:"actionPlanKindIDLTE,omitempty"`
	ActionPlanKindIDContains     *string  `json:"actionPlanKindIDContains,omitempty"`
	ActionPlanKindIDHasPrefix    *string  `json:"actionPlanKindIDHasPrefix,omitempty"`
	ActionPlanKindIDHasSuffix    *string  `json:"actionPlanKindIDHasSuffix,omitempty"`
	ActionPlanKindIDIsNil        *bool    `json:"actionPlanKindIDIsNil,omitempty"`
	ActionPlanKindIDNotNil       *bool    `json:"actionPlanKindIDNotNil,omitempty"`
	ActionPlanKindIDEqualFold    *string  `json:"actionPlanKindIDEqualFold,omitempty"`
	ActionPlanKindIDContainsFold *string  `json:"actionPlanKindIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// completed_at field predicates
	CompletedAt       *time.Time   `json:"completedAt,omitempty"`
	CompletedAtNeq    *time.Time   `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []*time.Time `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []*time.Time `json:"completedAtNotIn,omitempty"`
	CompletedAtGt     *time.Time   `json:"completedAtGT,omitempty"`
	CompletedAtGte    *time.Time   `json:"completedAtGTE,omitempty"`
	CompletedAtLt     *time.Time   `json:"completedAtLT,omitempty"`
	CompletedAtLte    *time.Time   `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  *bool        `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil *bool        `json:"completedAtNotNil,omitempty"`
	// priority field predicates
	Priority       *enums.Priority  `json:"priority,omitempty"`
	PriorityNeq    *enums.Priority  `json:"priorityNEQ,omitempty"`
	PriorityIn     []enums.Priority `json:"priorityIn,omitempty"`
	PriorityNotIn  []enums.Priority `json:"priorityNotIn,omitempty"`
	PriorityIsNil  *bool            `json:"priorityIsNil,omitempty"`
	PriorityNotNil *bool            `json:"priorityNotNil,omitempty"`
	// requires_approval field predicates
	RequiresApproval    *bool `json:"requiresApproval,omitempty"`
	RequiresApprovalNeq *bool `json:"requiresApprovalNEQ,omitempty"`
	// blocked field predicates
	Blocked    *bool `json:"blocked,omitempty"`
	BlockedNeq *bool `json:"blockedNEQ,omitempty"`
	// blocker_reason field predicates
	BlockerReason             *string  `json:"blockerReason,omitempty"`
	BlockerReasonNeq          *string  `json:"blockerReasonNEQ,omitempty"`
	BlockerReasonIn           []string `json:"blockerReasonIn,omitempty"`
	BlockerReasonNotIn        []string `json:"blockerReasonNotIn,omitempty"`
	BlockerReasonGt           *string  `json:"blockerReasonGT,omitempty"`
	BlockerReasonGte          *string  `json:"blockerReasonGTE,omitempty"`
	BlockerReasonLt           *string  `json:"blockerReasonLT,omitempty"`
	BlockerReasonLte          *string  `json:"blockerReasonLTE,omitempty"`
	BlockerReasonContains     *string  `json:"blockerReasonContains,omitempty"`
	BlockerReasonHasPrefix    *string  `json:"blockerReasonHasPrefix,omitempty"`
	BlockerReasonHasSuffix    *string  `json:"blockerReasonHasSuffix,omitempty"`
	BlockerReasonIsNil        *bool    `json:"blockerReasonIsNil,omitempty"`
	BlockerReasonNotNil       *bool    `json:"blockerReasonNotNil,omitempty"`
	BlockerReasonEqualFold    *string  `json:"blockerReasonEqualFold,omitempty"`
	BlockerReasonContainsFold *string  `json:"blockerReasonContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
}

// Ordering options for ActionPlan connections
type ActionPlanOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ActionPlans.
	Field ActionPlanOrderField `json:"field"`
}

// Return response for updateActionPlan mutation
type ActionPlanUpdatePayload struct {
	// Updated actionPlan
	ActionPlan *ActionPlan `json:"actionPlan"`
}

// ActionPlanWhereInput is used for filtering ActionPlan objects.
// Input was generated by ent.
type ActionPlanWhereInput struct {
	Not *ActionPlanWhereInput   `json:"not,omitempty"`
	And []*ActionPlanWhereInput `json:"and,omitempty"`
	Or  []*ActionPlanWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// action_plan_type field predicates
	ActionPlanType             *string  `json:"actionPlanType,omitempty"`
	ActionPlanTypeNeq          *string  `json:"actionPlanTypeNEQ,omitempty"`
	ActionPlanTypeIn           []string `json:"actionPlanTypeIn,omitempty"`
	ActionPlanTypeNotIn        []string `json:"actionPlanTypeNotIn,omitempty"`
	ActionPlanTypeGt           *string  `json:"actionPlanTypeGT,omitempty"`
	ActionPlanTypeGte          *string  `json:"actionPlanTypeGTE,omitempty"`
	ActionPlanTypeLt           *string  `json:"actionPlanTypeLT,omitempty"`
	ActionPlanTypeLte          *string  `json:"actionPlanTypeLTE,omitempty"`
	ActionPlanTypeContains     *string  `json:"actionPlanTypeContains,omitempty"`
	ActionPlanTypeHasPrefix    *string  `json:"actionPlanTypeHasPrefix,omitempty"`
	ActionPlanTypeHasSuffix    *string  `json:"actionPlanTypeHasSuffix,omitempty"`
	ActionPlanTypeIsNil        *bool    `json:"actionPlanTypeIsNil,omitempty"`
	ActionPlanTypeNotNil       *bool    `json:"actionPlanTypeNotNil,omitempty"`
	ActionPlanTypeEqualFold    *string  `json:"actionPlanTypeEqualFold,omitempty"`
	ActionPlanTypeContainsFold *string  `json:"actionPlanTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// approver_id field predicates
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIdneq          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIdgt           *string  `json:"approverIDGT,omitempty"`
	ApproverIdgte          *string  `json:"approverIDGTE,omitempty"`
	ApproverIdlt           *string  `json:"approverIDLT,omitempty"`
	ApproverIdlte          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        *bool    `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       *bool    `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDIsNil        *bool    `json:"fileIDIsNil,omitempty"`
	FileIDNotNil       *bool    `json:"fileIDNotNil,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// action_plan_kind_name field predicates
	ActionPlanKindName             *string  `json:"actionPlanKindName,omitempty"`
	ActionPlanKindNameNeq          *string  `json:"actionPlanKindNameNEQ,omitempty"`
	ActionPlanKindNameIn           []string `json:"actionPlanKindNameIn,omitempty"`
	ActionPlanKindNameNotIn        []string `json:"actionPlanKindNameNotIn,omitempty"`
	ActionPlanKindNameGt           *string  `json:"actionPlanKindNameGT,omitempty"`
	ActionPlanKindNameGte          *string  `json:"actionPlanKindNameGTE,omitempty"`
	ActionPlanKindNameLt           *string  `json:"actionPlanKindNameLT,omitempty"`
	ActionPlanKindNameLte          *string  `json:"actionPlanKindNameLTE,omitempty"`
	ActionPlanKindNameContains     *string  `json:"actionPlanKindNameContains,omitempty"`
	ActionPlanKindNameHasPrefix    *string  `json:"actionPlanKindNameHasPrefix,omitempty"`
	ActionPlanKindNameHasSuffix    *string  `json:"actionPlanKindNameHasSuffix,omitempty"`
	ActionPlanKindNameIsNil        *bool    `json:"actionPlanKindNameIsNil,omitempty"`
	ActionPlanKindNameNotNil       *bool    `json:"actionPlanKindNameNotNil,omitempty"`
	ActionPlanKindNameEqualFold    *string  `json:"actionPlanKindNameEqualFold,omitempty"`
	ActionPlanKindNameContainsFold *string  `json:"actionPlanKindNameContainsFold,omitempty"`
	// action_plan_kind_id field predicates
	ActionPlanKindID             *string  `json:"actionPlanKindID,omitempty"`
	ActionPlanKindIdneq          *string  `json:"actionPlanKindIDNEQ,omitempty"`
	ActionPlanKindIDIn           []string `json:"actionPlanKindIDIn,omitempty"`
	ActionPlanKindIDNotIn        []string `json:"actionPlanKindIDNotIn,omitempty"`
	ActionPlanKindIdgt           *string  `json:"actionPlanKindIDGT,omitempty"`
	ActionPlanKindIdgte          *string  `json:"actionPlanKindIDGTE,omitempty"`
	ActionPlanKindIdlt           *string  `json:"actionPlanKindIDLT,omitempty"`
	ActionPlanKindIdlte          *string  `json:"actionPlanKindIDLTE,omitempty"`
	ActionPlanKindIDContains     *string  `json:"actionPlanKindIDContains,omitempty"`
	ActionPlanKindIDHasPrefix    *string  `json:"actionPlanKindIDHasPrefix,omitempty"`
	ActionPlanKindIDHasSuffix    *string  `json:"actionPlanKindIDHasSuffix,omitempty"`
	ActionPlanKindIDIsNil        *bool    `json:"actionPlanKindIDIsNil,omitempty"`
	ActionPlanKindIDNotNil       *bool    `json:"actionPlanKindIDNotNil,omitempty"`
	ActionPlanKindIDEqualFold    *string  `json:"actionPlanKindIDEqualFold,omitempty"`
	ActionPlanKindIDContainsFold *string  `json:"actionPlanKindIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// completed_at field predicates
	CompletedAt       *time.Time   `json:"completedAt,omitempty"`
	CompletedAtNeq    *time.Time   `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []*time.Time `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []*time.Time `json:"completedAtNotIn,omitempty"`
	CompletedAtGt     *time.Time   `json:"completedAtGT,omitempty"`
	CompletedAtGte    *time.Time   `json:"completedAtGTE,omitempty"`
	CompletedAtLt     *time.Time   `json:"completedAtLT,omitempty"`
	CompletedAtLte    *time.Time   `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  *bool        `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil *bool        `json:"completedAtNotNil,omitempty"`
	// priority field predicates
	Priority       *enums.Priority  `json:"priority,omitempty"`
	PriorityNeq    *enums.Priority  `json:"priorityNEQ,omitempty"`
	PriorityIn     []enums.Priority `json:"priorityIn,omitempty"`
	PriorityNotIn  []enums.Priority `json:"priorityNotIn,omitempty"`
	PriorityIsNil  *bool            `json:"priorityIsNil,omitempty"`
	PriorityNotNil *bool            `json:"priorityNotNil,omitempty"`
	// requires_approval field predicates
	RequiresApproval    *bool `json:"requiresApproval,omitempty"`
	RequiresApprovalNeq *bool `json:"requiresApprovalNEQ,omitempty"`
	// blocked field predicates
	Blocked    *bool `json:"blocked,omitempty"`
	BlockedNeq *bool `json:"blockedNEQ,omitempty"`
	// blocker_reason field predicates
	BlockerReason             *string  `json:"blockerReason,omitempty"`
	BlockerReasonNeq          *string  `json:"blockerReasonNEQ,omitempty"`
	BlockerReasonIn           []string `json:"blockerReasonIn,omitempty"`
	BlockerReasonNotIn        []string `json:"blockerReasonNotIn,omitempty"`
	BlockerReasonGt           *string  `json:"blockerReasonGT,omitempty"`
	BlockerReasonGte          *string  `json:"blockerReasonGTE,omitempty"`
	BlockerReasonLt           *string  `json:"blockerReasonLT,omitempty"`
	BlockerReasonLte          *string  `json:"blockerReasonLTE,omitempty"`
	BlockerReasonContains     *string  `json:"blockerReasonContains,omitempty"`
	BlockerReasonHasPrefix    *string  `json:"blockerReasonHasPrefix,omitempty"`
	BlockerReasonHasSuffix    *string  `json:"blockerReasonHasSuffix,omitempty"`
	BlockerReasonIsNil        *bool    `json:"blockerReasonIsNil,omitempty"`
	BlockerReasonNotNil       *bool    `json:"blockerReasonNotNil,omitempty"`
	BlockerReasonEqualFold    *string  `json:"blockerReasonEqualFold,omitempty"`
	BlockerReasonContainsFold *string  `json:"blockerReasonContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// approver edge predicates
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// action_plan_kind edge predicates
	HasActionPlanKind     *bool                       `json:"hasActionPlanKind,omitempty"`
	HasActionPlanKindWith []*CustomTypeEnumWhereInput `json:"hasActionPlanKindWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// findings edge predicates
	HasFindings     *bool                `json:"hasFindings,omitempty"`
	HasFindingsWith []*FindingWhereInput `json:"hasFindingsWith,omitempty"`
	// vulnerabilities edge predicates
	HasVulnerabilities     *bool                      `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*VulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`
	// reviews edge predicates
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`
	// remediations edge predicates
	HasRemediations     *bool                    `json:"hasRemediations,omitempty"`
	HasRemediationsWith []*RemediationWhereInput `json:"hasRemediationsWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

// AddProgramMembershipInput is used for create ProgramMembership object under an existing program
type AddProgramMembershipInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

type Assessment struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the assessment, e.g. cloud providers, marketing team
	Name           string               `json:"name"`
	AssessmentType enums.AssessmentType `json:"assessmentType"`
	// the template id associated with this assessment. You can either provide this alone or provide both the jsonconfig and uischema
	TemplateID *string `json:"templateID,omitempty"`
	// the jsonschema object of the questionnaire. If not provided it will be inherited from the template.
	Jsonconfig map[string]any `json:"jsonconfig,omitempty"`
	// the uischema for the template to render in the UI. If not provided, it will be inherited from the template
	Uischema map[string]any `json:"uischema,omitempty"`
	// the duration in seconds that the user has to complete the assessment response, defaults to 7 days
	ResponseDueDuration *int64                        `json:"responseDueDuration,omitempty"`
	Owner               *Organization                 `json:"owner,omitempty"`
	BlockedGroups       *GroupConnection              `json:"blockedGroups"`
	Editors             *GroupConnection              `json:"editors"`
	Viewers             *GroupConnection              `json:"viewers"`
	Template            *Template                     `json:"template,omitempty"`
	AssessmentResponses *AssessmentResponseConnection `json:"assessmentResponses"`
}

func (Assessment) IsNode() {}

// Return response for deleteBulkAssessment mutation
type AssessmentBulkDeletePayload struct {
	// Deleted assessment IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type AssessmentConnection struct {
	// A list of edges.
	Edges []*AssessmentEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createAssessment mutation
type AssessmentCreatePayload struct {
	// Created assessment
	Assessment *Assessment `json:"assessment"`
}

// Return response for deleteAssessment mutation
type AssessmentDeletePayload struct {
	// Deleted assessment ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type AssessmentEdge struct {
	// The item at the end of the edge.
	Node *Assessment `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type AssessmentHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the assessment, e.g. cloud providers, marketing team
	Name           string               `json:"name"`
	AssessmentType enums.AssessmentType `json:"assessmentType"`
	// the template id associated with this assessment. You can either provide this alone or provide both the jsonconfig and uischema
	TemplateID *string `json:"templateID,omitempty"`
	// the jsonschema object of the questionnaire. If not provided it will be inherited from the template.
	Jsonconfig map[string]any `json:"jsonconfig,omitempty"`
	// the uischema for the template to render in the UI. If not provided, it will be inherited from the template
	Uischema map[string]any `json:"uischema,omitempty"`
	// the duration in seconds that the user has to complete the assessment response, defaults to 7 days
	ResponseDueDuration *int64 `json:"responseDueDuration,omitempty"`
}

func (AssessmentHistory) IsNode() {}

// A connection to a list of items.
type AssessmentHistoryConnection struct {
	// A list of edges.
	Edges []*AssessmentHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type AssessmentHistoryEdge struct {
	// The item at the end of the edge.
	Node *AssessmentHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for AssessmentHistory connections
type AssessmentHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order AssessmentHistories.
	Field AssessmentHistoryOrderField `json:"field"`
}

// AssessmentHistoryWhereInput is used for filtering AssessmentHistory objects.
// Input was generated by ent.
type AssessmentHistoryWhereInput struct {
	Not *AssessmentHistoryWhereInput   `json:"not,omitempty"`
	And []*AssessmentHistoryWhereInput `json:"and,omitempty"`
	Or  []*AssessmentHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// assessment_type field predicates
	AssessmentType      *enums.AssessmentType  `json:"assessmentType,omitempty"`
	AssessmentTypeNeq   *enums.AssessmentType  `json:"assessmentTypeNEQ,omitempty"`
	AssessmentTypeIn    []enums.AssessmentType `json:"assessmentTypeIn,omitempty"`
	AssessmentTypeNotIn []enums.AssessmentType `json:"assessmentTypeNotIn,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDIsNil        *bool    `json:"templateIDIsNil,omitempty"`
	TemplateIDNotNil       *bool    `json:"templateIDNotNil,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
	// response_due_duration field predicates
	ResponseDueDuration       *int64  `json:"responseDueDuration,omitempty"`
	ResponseDueDurationNeq    *int64  `json:"responseDueDurationNEQ,omitempty"`
	ResponseDueDurationIn     []int64 `json:"responseDueDurationIn,omitempty"`
	ResponseDueDurationNotIn  []int64 `json:"responseDueDurationNotIn,omitempty"`
	ResponseDueDurationGt     *int64  `json:"responseDueDurationGT,omitempty"`
	ResponseDueDurationGte    *int64  `json:"responseDueDurationGTE,omitempty"`
	ResponseDueDurationLt     *int64  `json:"responseDueDurationLT,omitempty"`
	ResponseDueDurationLte    *int64  `json:"responseDueDurationLTE,omitempty"`
	ResponseDueDurationIsNil  *bool   `json:"responseDueDurationIsNil,omitempty"`
	ResponseDueDurationNotNil *bool   `json:"responseDueDurationNotNil,omitempty"`
}

// Ordering options for Assessment connections
type AssessmentOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Assessments.
	Field AssessmentOrderField `json:"field"`
}

type AssessmentResponse struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the assessment this response is for
	AssessmentID string `json:"assessmentID"`
	// the email address of the recipient
	Email string `json:"email"`
	// the number of attempts made to perform email send to the recipient about this assessment, maximum of 5
	SendAttempts int64 `json:"sendAttempts"`
	// the current status of the assessment for this user
	Status enums.AssessmentResponseStatus `json:"status"`
	// when the assessment was assigned to the user
	AssignedAt time.Time `json:"assignedAt"`
	// when the user started the assessment
	StartedAt time.Time `json:"startedAt"`
	// when the user completed the assessment
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// when the assessment response is due
	DueDate *time.Time `json:"dueDate,omitempty"`
	// the document containing the user's response data
	DocumentDataID *string       `json:"documentDataID,omitempty"`
	Owner          *Organization `json:"owner,omitempty"`
	Assessment     *Assessment   `json:"assessment"`
	Document       *DocumentData `json:"document,omitempty"`
}

func (AssessmentResponse) IsNode() {}

// A connection to a list of items.
type AssessmentResponseConnection struct {
	// A list of edges.
	Edges []*AssessmentResponseEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createAssessmentResponse mutation
type AssessmentResponseCreatePayload struct {
	// Created assessmentResponse
	AssessmentResponse *AssessmentResponse `json:"assessmentResponse"`
}

// Return response for deleteAssessmentResponse mutation
type AssessmentResponseDeletePayload struct {
	// Deleted assessmentResponse ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type AssessmentResponseEdge struct {
	// The item at the end of the edge.
	Node *AssessmentResponse `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type AssessmentResponseHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the assessment this response is for
	AssessmentID string `json:"assessmentID"`
	// the email address of the recipient
	Email string `json:"email"`
	// the number of attempts made to perform email send to the recipient about this assessment, maximum of 5
	SendAttempts int64 `json:"sendAttempts"`
	// the current status of the assessment for this user
	Status enums.AssessmentResponseStatus `json:"status"`
	// when the assessment was assigned to the user
	AssignedAt time.Time `json:"assignedAt"`
	// when the user started the assessment
	StartedAt time.Time `json:"startedAt"`
	// when the user completed the assessment
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// when the assessment response is due
	DueDate *time.Time `json:"dueDate,omitempty"`
	// the document containing the user's response data
	DocumentDataID *string `json:"documentDataID,omitempty"`
}

func (AssessmentResponseHistory) IsNode() {}

// A connection to a list of items.
type AssessmentResponseHistoryConnection struct {
	// A list of edges.
	Edges []*AssessmentResponseHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type AssessmentResponseHistoryEdge struct {
	// The item at the end of the edge.
	Node *AssessmentResponseHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for AssessmentResponseHistory connections
type AssessmentResponseHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order AssessmentResponseHistories.
	Field AssessmentResponseHistoryOrderField `json:"field"`
}

// AssessmentResponseHistoryWhereInput is used for filtering AssessmentResponseHistory objects.
// Input was generated by ent.
type AssessmentResponseHistoryWhereInput struct {
	Not *AssessmentResponseHistoryWhereInput   `json:"not,omitempty"`
	And []*AssessmentResponseHistoryWhereInput `json:"and,omitempty"`
	Or  []*AssessmentResponseHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// assessment_id field predicates
	AssessmentID             *string  `json:"assessmentID,omitempty"`
	AssessmentIdneq          *string  `json:"assessmentIDNEQ,omitempty"`
	AssessmentIDIn           []string `json:"assessmentIDIn,omitempty"`
	AssessmentIDNotIn        []string `json:"assessmentIDNotIn,omitempty"`
	AssessmentIdgt           *string  `json:"assessmentIDGT,omitempty"`
	AssessmentIdgte          *string  `json:"assessmentIDGTE,omitempty"`
	AssessmentIdlt           *string  `json:"assessmentIDLT,omitempty"`
	AssessmentIdlte          *string  `json:"assessmentIDLTE,omitempty"`
	AssessmentIDContains     *string  `json:"assessmentIDContains,omitempty"`
	AssessmentIDHasPrefix    *string  `json:"assessmentIDHasPrefix,omitempty"`
	AssessmentIDHasSuffix    *string  `json:"assessmentIDHasSuffix,omitempty"`
	AssessmentIDEqualFold    *string  `json:"assessmentIDEqualFold,omitempty"`
	AssessmentIDContainsFold *string  `json:"assessmentIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// send_attempts field predicates
	SendAttempts      *int64  `json:"sendAttempts,omitempty"`
	SendAttemptsNeq   *int64  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int64 `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int64 `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGt    *int64  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGte   *int64  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLt    *int64  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLte   *int64  `json:"sendAttemptsLTE,omitempty"`
	// status field predicates
	Status      *enums.AssessmentResponseStatus  `json:"status,omitempty"`
	StatusNeq   *enums.AssessmentResponseStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.AssessmentResponseStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.AssessmentResponseStatus `json:"statusNotIn,omitempty"`
	// assigned_at field predicates
	AssignedAt      *time.Time   `json:"assignedAt,omitempty"`
	AssignedAtNeq   *time.Time   `json:"assignedAtNEQ,omitempty"`
	AssignedAtIn    []*time.Time `json:"assignedAtIn,omitempty"`
	AssignedAtNotIn []*time.Time `json:"assignedAtNotIn,omitempty"`
	AssignedAtGt    *time.Time   `json:"assignedAtGT,omitempty"`
	AssignedAtGte   *time.Time   `json:"assignedAtGTE,omitempty"`
	AssignedAtLt    *time.Time   `json:"assignedAtLT,omitempty"`
	AssignedAtLte   *time.Time   `json:"assignedAtLTE,omitempty"`
	// started_at field predicates
	StartedAt      *time.Time   `json:"startedAt,omitempty"`
	StartedAtNeq   *time.Time   `json:"startedAtNEQ,omitempty"`
	StartedAtIn    []*time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn []*time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGt    *time.Time   `json:"startedAtGT,omitempty"`
	StartedAtGte   *time.Time   `json:"startedAtGTE,omitempty"`
	StartedAtLt    *time.Time   `json:"startedAtLT,omitempty"`
	StartedAtLte   *time.Time   `json:"startedAtLTE,omitempty"`
	// completed_at field predicates
	CompletedAt       *time.Time   `json:"completedAt,omitempty"`
	CompletedAtNeq    *time.Time   `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []*time.Time `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []*time.Time `json:"completedAtNotIn,omitempty"`
	CompletedAtGt     *time.Time   `json:"completedAtGT,omitempty"`
	CompletedAtGte    *time.Time   `json:"completedAtGTE,omitempty"`
	CompletedAtLt     *time.Time   `json:"completedAtLT,omitempty"`
	CompletedAtLte    *time.Time   `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  *bool        `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil *bool        `json:"completedAtNotNil,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
}

// Ordering options for AssessmentResponse connections
type AssessmentResponseOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order AssessmentResponses.
	Field AssessmentResponseOrderField `json:"field"`
}

// AssessmentResponseWhereInput is used for filtering AssessmentResponse objects.
// Input was generated by ent.
type AssessmentResponseWhereInput struct {
	Not *AssessmentResponseWhereInput   `json:"not,omitempty"`
	And []*AssessmentResponseWhereInput `json:"and,omitempty"`
	Or  []*AssessmentResponseWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// assessment_id field predicates
	AssessmentID             *string  `json:"assessmentID,omitempty"`
	AssessmentIdneq          *string  `json:"assessmentIDNEQ,omitempty"`
	AssessmentIDIn           []string `json:"assessmentIDIn,omitempty"`
	AssessmentIDNotIn        []string `json:"assessmentIDNotIn,omitempty"`
	AssessmentIdgt           *string  `json:"assessmentIDGT,omitempty"`
	AssessmentIdgte          *string  `json:"assessmentIDGTE,omitempty"`
	AssessmentIdlt           *string  `json:"assessmentIDLT,omitempty"`
	AssessmentIdlte          *string  `json:"assessmentIDLTE,omitempty"`
	AssessmentIDContains     *string  `json:"assessmentIDContains,omitempty"`
	AssessmentIDHasPrefix    *string  `json:"assessmentIDHasPrefix,omitempty"`
	AssessmentIDHasSuffix    *string  `json:"assessmentIDHasSuffix,omitempty"`
	AssessmentIDEqualFold    *string  `json:"assessmentIDEqualFold,omitempty"`
	AssessmentIDContainsFold *string  `json:"assessmentIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// send_attempts field predicates
	SendAttempts      *int64  `json:"sendAttempts,omitempty"`
	SendAttemptsNeq   *int64  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int64 `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int64 `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGt    *int64  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGte   *int64  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLt    *int64  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLte   *int64  `json:"sendAttemptsLTE,omitempty"`
	// status field predicates
	Status      *enums.AssessmentResponseStatus  `json:"status,omitempty"`
	StatusNeq   *enums.AssessmentResponseStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.AssessmentResponseStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.AssessmentResponseStatus `json:"statusNotIn,omitempty"`
	// assigned_at field predicates
	AssignedAt      *time.Time   `json:"assignedAt,omitempty"`
	AssignedAtNeq   *time.Time   `json:"assignedAtNEQ,omitempty"`
	AssignedAtIn    []*time.Time `json:"assignedAtIn,omitempty"`
	AssignedAtNotIn []*time.Time `json:"assignedAtNotIn,omitempty"`
	AssignedAtGt    *time.Time   `json:"assignedAtGT,omitempty"`
	AssignedAtGte   *time.Time   `json:"assignedAtGTE,omitempty"`
	AssignedAtLt    *time.Time   `json:"assignedAtLT,omitempty"`
	AssignedAtLte   *time.Time   `json:"assignedAtLTE,omitempty"`
	// started_at field predicates
	StartedAt      *time.Time   `json:"startedAt,omitempty"`
	StartedAtNeq   *time.Time   `json:"startedAtNEQ,omitempty"`
	StartedAtIn    []*time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn []*time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGt    *time.Time   `json:"startedAtGT,omitempty"`
	StartedAtGte   *time.Time   `json:"startedAtGTE,omitempty"`
	StartedAtLt    *time.Time   `json:"startedAtLT,omitempty"`
	StartedAtLte   *time.Time   `json:"startedAtLTE,omitempty"`
	// completed_at field predicates
	CompletedAt       *time.Time   `json:"completedAt,omitempty"`
	CompletedAtNeq    *time.Time   `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []*time.Time `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []*time.Time `json:"completedAtNotIn,omitempty"`
	CompletedAtGt     *time.Time   `json:"completedAtGT,omitempty"`
	CompletedAtGte    *time.Time   `json:"completedAtGTE,omitempty"`
	CompletedAtLt     *time.Time   `json:"completedAtLT,omitempty"`
	CompletedAtLte    *time.Time   `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  *bool        `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil *bool        `json:"completedAtNotNil,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// assessment edge predicates
	HasAssessment     *bool                   `json:"hasAssessment,omitempty"`
	HasAssessmentWith []*AssessmentWhereInput `json:"hasAssessmentWith,omitempty"`
	// document edge predicates
	HasDocument     *bool                     `json:"hasDocument,omitempty"`
	HasDocumentWith []*DocumentDataWhereInput `json:"hasDocumentWith,omitempty"`
}

// Return response for updateAssessment mutation
type AssessmentUpdatePayload struct {
	// Updated assessment
	Assessment *Assessment `json:"assessment"`
}

// AssessmentWhereInput is used for filtering Assessment objects.
// Input was generated by ent.
type AssessmentWhereInput struct {
	Not *AssessmentWhereInput   `json:"not,omitempty"`
	And []*AssessmentWhereInput `json:"and,omitempty"`
	Or  []*AssessmentWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// assessment_type field predicates
	AssessmentType      *enums.AssessmentType  `json:"assessmentType,omitempty"`
	AssessmentTypeNeq   *enums.AssessmentType  `json:"assessmentTypeNEQ,omitempty"`
	AssessmentTypeIn    []enums.AssessmentType `json:"assessmentTypeIn,omitempty"`
	AssessmentTypeNotIn []enums.AssessmentType `json:"assessmentTypeNotIn,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDIsNil        *bool    `json:"templateIDIsNil,omitempty"`
	TemplateIDNotNil       *bool    `json:"templateIDNotNil,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
	// response_due_duration field predicates
	ResponseDueDuration       *int64  `json:"responseDueDuration,omitempty"`
	ResponseDueDurationNeq    *int64  `json:"responseDueDurationNEQ,omitempty"`
	ResponseDueDurationIn     []int64 `json:"responseDueDurationIn,omitempty"`
	ResponseDueDurationNotIn  []int64 `json:"responseDueDurationNotIn,omitempty"`
	ResponseDueDurationGt     *int64  `json:"responseDueDurationGT,omitempty"`
	ResponseDueDurationGte    *int64  `json:"responseDueDurationGTE,omitempty"`
	ResponseDueDurationLt     *int64  `json:"responseDueDurationLT,omitempty"`
	ResponseDueDurationLte    *int64  `json:"responseDueDurationLTE,omitempty"`
	ResponseDueDurationIsNil  *bool   `json:"responseDueDurationIsNil,omitempty"`
	ResponseDueDurationNotNil *bool   `json:"responseDueDurationNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// assessment_responses edge predicates
	HasAssessmentResponses     *bool                           `json:"hasAssessmentResponses,omitempty"`
	HasAssessmentResponsesWith []*AssessmentResponseWhereInput `json:"hasAssessmentResponsesWith,omitempty"`
}

type Asset struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the type of the asset, e.g. technology, domain, device, etc
	AssetType enums.AssetType `json:"assetType"`
	// the name of the asset, e.g. matts computer, office router, IP address, etc
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	// unique identifier like domain, device id, etc
	Identifier *string `json:"identifier,omitempty"`
	// the website of the asset, if applicable
	Website *string `json:"website,omitempty"`
	// the CPE (Common Platform Enumeration) of the asset, if applicable
	Cpe *string `json:"cpe,omitempty"`
	// the categories of the asset, e.g. web server, database, etc
	Categories    []string           `json:"categories,omitempty"`
	Owner         *Organization      `json:"owner,omitempty"`
	BlockedGroups *GroupConnection   `json:"blockedGroups"`
	Editors       *GroupConnection   `json:"editors"`
	Viewers       *GroupConnection   `json:"viewers"`
	Scans         *ScanConnection    `json:"scans"`
	Entities      *EntityConnection  `json:"entities"`
	Controls      *ControlConnection `json:"controls"`
}

func (Asset) IsNode() {}

// Return response for createBulkAsset mutation
type AssetBulkCreatePayload struct {
	// Created assets
	Assets []*Asset `json:"assets,omitempty"`
}

// Return response for deleteBulkAsset mutation
type AssetBulkDeletePayload struct {
	// Deleted asset IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type AssetConnection struct {
	// A list of edges.
	Edges []*AssetEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createAsset mutation
type AssetCreatePayload struct {
	// Created asset
	Asset *Asset `json:"asset"`
}

// Return response for deleteAsset mutation
type AssetDeletePayload struct {
	// Deleted asset ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type AssetEdge struct {
	// The item at the end of the edge.
	Node *Asset `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type AssetHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the type of the asset, e.g. technology, domain, device, etc
	AssetType enums.AssetType `json:"assetType"`
	// the name of the asset, e.g. matts computer, office router, IP address, etc
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	// unique identifier like domain, device id, etc
	Identifier *string `json:"identifier,omitempty"`
	// the website of the asset, if applicable
	Website *string `json:"website,omitempty"`
	// the CPE (Common Platform Enumeration) of the asset, if applicable
	Cpe *string `json:"cpe,omitempty"`
	// the categories of the asset, e.g. web server, database, etc
	Categories []string `json:"categories,omitempty"`
}

func (AssetHistory) IsNode() {}

// A connection to a list of items.
type AssetHistoryConnection struct {
	// A list of edges.
	Edges []*AssetHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type AssetHistoryEdge struct {
	// The item at the end of the edge.
	Node *AssetHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for AssetHistory connections
type AssetHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order AssetHistories.
	Field AssetHistoryOrderField `json:"field"`
}

// AssetHistoryWhereInput is used for filtering AssetHistory objects.
// Input was generated by ent.
type AssetHistoryWhereInput struct {
	Not *AssetHistoryWhereInput   `json:"not,omitempty"`
	And []*AssetHistoryWhereInput `json:"and,omitempty"`
	Or  []*AssetHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// asset_type field predicates
	AssetType      *enums.AssetType  `json:"assetType,omitempty"`
	AssetTypeNeq   *enums.AssetType  `json:"assetTypeNEQ,omitempty"`
	AssetTypeIn    []enums.AssetType `json:"assetTypeIn,omitempty"`
	AssetTypeNotIn []enums.AssetType `json:"assetTypeNotIn,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// identifier field predicates
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNeq          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGt           *string  `json:"identifierGT,omitempty"`
	IdentifierGte          *string  `json:"identifierGTE,omitempty"`
	IdentifierLt           *string  `json:"identifierLT,omitempty"`
	IdentifierLte          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierIsNil        *bool    `json:"identifierIsNil,omitempty"`
	IdentifierNotNil       *bool    `json:"identifierNotNil,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`
	// website field predicates
	Website             *string  `json:"website,omitempty"`
	WebsiteNeq          *string  `json:"websiteNEQ,omitempty"`
	WebsiteIn           []string `json:"websiteIn,omitempty"`
	WebsiteNotIn        []string `json:"websiteNotIn,omitempty"`
	WebsiteGt           *string  `json:"websiteGT,omitempty"`
	WebsiteGte          *string  `json:"websiteGTE,omitempty"`
	WebsiteLt           *string  `json:"websiteLT,omitempty"`
	WebsiteLte          *string  `json:"websiteLTE,omitempty"`
	WebsiteContains     *string  `json:"websiteContains,omitempty"`
	WebsiteHasPrefix    *string  `json:"websiteHasPrefix,omitempty"`
	WebsiteHasSuffix    *string  `json:"websiteHasSuffix,omitempty"`
	WebsiteIsNil        *bool    `json:"websiteIsNil,omitempty"`
	WebsiteNotNil       *bool    `json:"websiteNotNil,omitempty"`
	WebsiteEqualFold    *string  `json:"websiteEqualFold,omitempty"`
	WebsiteContainsFold *string  `json:"websiteContainsFold,omitempty"`
}

// Ordering options for Asset connections
type AssetOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Assets.
	Field AssetOrderField `json:"field"`
}

// Return response for updateAsset mutation
type AssetUpdatePayload struct {
	// Updated asset
	Asset *Asset `json:"asset"`
}

// AssetWhereInput is used for filtering Asset objects.
// Input was generated by ent.
type AssetWhereInput struct {
	Not *AssetWhereInput   `json:"not,omitempty"`
	And []*AssetWhereInput `json:"and,omitempty"`
	Or  []*AssetWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// asset_type field predicates
	AssetType      *enums.AssetType  `json:"assetType,omitempty"`
	AssetTypeNeq   *enums.AssetType  `json:"assetTypeNEQ,omitempty"`
	AssetTypeIn    []enums.AssetType `json:"assetTypeIn,omitempty"`
	AssetTypeNotIn []enums.AssetType `json:"assetTypeNotIn,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// identifier field predicates
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNeq          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGt           *string  `json:"identifierGT,omitempty"`
	IdentifierGte          *string  `json:"identifierGTE,omitempty"`
	IdentifierLt           *string  `json:"identifierLT,omitempty"`
	IdentifierLte          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierIsNil        *bool    `json:"identifierIsNil,omitempty"`
	IdentifierNotNil       *bool    `json:"identifierNotNil,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`
	// website field predicates
	Website             *string  `json:"website,omitempty"`
	WebsiteNeq          *string  `json:"websiteNEQ,omitempty"`
	WebsiteIn           []string `json:"websiteIn,omitempty"`
	WebsiteNotIn        []string `json:"websiteNotIn,omitempty"`
	WebsiteGt           *string  `json:"websiteGT,omitempty"`
	WebsiteGte          *string  `json:"websiteGTE,omitempty"`
	WebsiteLt           *string  `json:"websiteLT,omitempty"`
	WebsiteLte          *string  `json:"websiteLTE,omitempty"`
	WebsiteContains     *string  `json:"websiteContains,omitempty"`
	WebsiteHasPrefix    *string  `json:"websiteHasPrefix,omitempty"`
	WebsiteHasSuffix    *string  `json:"websiteHasSuffix,omitempty"`
	WebsiteIsNil        *bool    `json:"websiteIsNil,omitempty"`
	WebsiteNotNil       *bool    `json:"websiteNotNil,omitempty"`
	WebsiteEqualFold    *string  `json:"websiteEqualFold,omitempty"`
	WebsiteContainsFold *string  `json:"websiteContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// scans edge predicates
	HasScans     *bool             `json:"hasScans,omitempty"`
	HasScansWith []*ScanWhereInput `json:"hasScansWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
}

type AuditLog struct {
	Table     *string          `json:"table,omitempty"`
	Time      *time.Time       `json:"time,omitempty"`
	ID        string           `json:"id"`
	Operation *string          `json:"operation,omitempty"`
	Changes   []*models.Change `json:"changes,omitempty"`
	UpdatedBy *string          `json:"updatedBy,omitempty"`
}

func (AuditLog) IsNode() {}

// A connection to a list of items.
type AuditLogConnection struct {
	// A list of edges.
	Edges []*AuditLogEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type AuditLogEdge struct {
	// The item at the end of the edge.
	Node *AuditLog `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for AuditLog connections
type AuditLogOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order AuditLogs.
	Field models.AuditLogOrderField `json:"field"`
}

type AuditLogWhereInput struct {
	// reference ID from the main object table unique ID
	RefID *string `json:"refID,omitempty"`
	// User or service ID that made the update
	UpdatedBy *string `json:"updatedBy,omitempty"`
	// Operation of the entry, INSERT, DELETE, or UPDATE
	Operation *string `json:"operation,omitempty"`
	// Table (Object) that was updated. Required.
	Table string `json:"table"`
	// Before time to look for results
	Before *time.Time `json:"before,omitempty"`
	// After time to look for results
	After *time.Time `json:"after,omitempty"`
}

// CloneControlInput is used to clone controls and their subcontrols
// under an organization (ownerID)
type CloneControlInput struct {
	// controlIDs are the ids of the control to clone. If standardID or standardShortName are passed, this is ignored
	ControlIDs []string `json:"controlIDs,omitempty"`
	// refCodes are the refCodes to control. A standardID must be provided to lookup the refCode from.
	RefCodes []string `json:"refCodes,omitempty"`
	// standardID to clone all controls from into the organization
	StandardID *string `json:"standardID,omitempty"`
	// standardShortName to clone all controls from into the organization, if the standardID is provided that will take precedence
	StandardShortName *string `json:"standardShortName,omitempty"`
	// standardVersion is the version of the standard to use when filtering by short name, if not provided, the latest version will be used
	StandardVersion *string `json:"standardVersion,omitempty"`
	// categories to limit the controls that are cloned from a standard. If standardID is empty, this field is ignored
	Categories []string `json:"categories,omitempty"`
	// organization ID that the controls will be under
	OwnerID *string `json:"ownerID,omitempty"`
	// optional program ID to associate to the controls
	ProgramID *string `json:"programID,omitempty"`
}

// CloneControlUploadInput is used to clone controls and their subcontrols
// under an organization using a csv upload
type CloneControlUploadInput struct {
	// controlID is the id of the control to clone. If standardID or standardShortName are passed, this is ignored
	ControlID *string `json:"controlID,omitempty"`
	// refCodes are the refCodes to control. A standardID must be provided to lookup the refCode from.
	RefCode *string `json:"refCode,omitempty"`
	// standardID to clone all controls from into the organization
	StandardID *string `json:"standardID,omitempty"`
	// standardShortName to clone all controls from into the organization, if the standardID is provided that will take precedence
	StandardShortName *string `json:"standardShortName,omitempty"`
	// standardVersion is the version of the standard to use when filtering by short name, if not provided, the latest version will be used
	StandardVersion *string `json:"standardVersion,omitempty"`
	// organization ID that the controls will be under
	OwnerID *string `json:"ownerID,omitempty"`
	// controlImplementation is the implementation details of the control
	ControlImplementation *string `json:"controlImplementation,omitempty"`
	// controlObjective is the objective details of the control
	ControlObjective *string `json:"controlObjective,omitempty"`
	// implementationGuidance is guidance details on the implementation of the control
	ImplementationGuidance *string `json:"implementationGuidance,omitempty"`
	// comment to associate with the control that was created
	Comment *string `json:"comment,omitempty"`
	// internalPolicyIDs to associate with the created control
	InternalPolicyID *string `json:"internalPolicyID,omitempty"`
	// controlInput includes all the standard settings you can set on create of a control that can also be set during the creation via clone. Note that some fields like refCode, description, category, will be ignored
	// if the control is being clone from a system owned standard
	ControlInput *CreateControlInput `json:"controlInput,omitempty"`
}

type Contact struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName *string `json:"fullName,omitempty"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status   enums.UserStatus  `json:"status"`
	Owner    *Organization     `json:"owner,omitempty"`
	Entities *EntityConnection `json:"entities"`
	Files    *FileConnection   `json:"files"`
}

func (Contact) IsNode() {}

// Return response for createBulkContact mutation
type ContactBulkCreatePayload struct {
	// Created contacts
	Contacts []*Contact `json:"contacts,omitempty"`
}

// Return response for deleteBulkContact mutation
type ContactBulkDeletePayload struct {
	// Deleted contact IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkContact mutation
type ContactBulkUpdatePayload struct {
	// Updated contacts
	Contacts []*Contact `json:"contacts,omitempty"`
	// IDs of the updated contacts
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type ContactConnection struct {
	// A list of edges.
	Edges []*ContactEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createContact mutation
type ContactCreatePayload struct {
	// Created contact
	Contact *Contact `json:"contact"`
}

// Return response for deleteContact mutation
type ContactDeletePayload struct {
	// Deleted contact ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ContactEdge struct {
	// The item at the end of the edge.
	Node *Contact `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ContactHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName *string `json:"fullName,omitempty"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status enums.UserStatus `json:"status"`
}

func (ContactHistory) IsNode() {}

// A connection to a list of items.
type ContactHistoryConnection struct {
	// A list of edges.
	Edges []*ContactHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ContactHistoryEdge struct {
	// The item at the end of the edge.
	Node *ContactHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ContactHistory connections
type ContactHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ContactHistories.
	Field ContactHistoryOrderField `json:"field"`
}

// ContactHistoryWhereInput is used for filtering ContactHistory objects.
// Input was generated by ent.
type ContactHistoryWhereInput struct {
	Not *ContactHistoryWhereInput   `json:"not,omitempty"`
	And []*ContactHistoryWhereInput `json:"and,omitempty"`
	Or  []*ContactHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameIsNil        *bool    `json:"fullNameIsNil,omitempty"`
	FullNameNotNil       *bool    `json:"fullNameNotNil,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
}

// Ordering options for Contact connections
type ContactOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Contacts.
	Field ContactOrderField `json:"field"`
}

// Return response for updateContact mutation
type ContactUpdatePayload struct {
	// Updated contact
	Contact *Contact `json:"contact"`
}

// ContactWhereInput is used for filtering Contact objects.
// Input was generated by ent.
type ContactWhereInput struct {
	Not *ContactWhereInput   `json:"not,omitempty"`
	And []*ContactWhereInput `json:"and,omitempty"`
	Or  []*ContactWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameIsNil        *bool    `json:"fullNameIsNil,omitempty"`
	FullNameNotNil       *bool    `json:"fullNameNotNil,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Control struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// human readable title of the control for quick identification
	Title *string `json:"title,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// additional names (ref_codes) for the control
	Aliases []string `json:"aliases,omitempty"`
	// internal reference id of the control, can be used for internal tracking
	ReferenceID *string `json:"referenceID,omitempty"`
	// external auditor id of the control, can be used to map to external audit partner mappings
	AuditorReferenceID *string `json:"auditorReferenceID,omitempty"`
	// the id of the party responsible for the control, usually used when the control is implemented by a third party
	ResponsiblePartyID *string `json:"responsiblePartyID,omitempty"`
	// status of the control
	Status *enums.ControlStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// the reference framework for the control if it came from a standard, empty if not associated with a standard
	ReferenceFramework *string `json:"referenceFramework,omitempty"`
	// the reference framework revision for the control if it came from a standard, empty if not associated with a standard, allows for pulling in updates when the standard is updated
	ReferenceFrameworkRevision *string `json:"referenceFrameworkRevision,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the id of the group that owns the control
	ControlOwnerID *string `json:"controlOwnerID,omitempty"`
	// the id of the group that is temporarily delegated to own the control
	DelegateID *string `json:"delegateID,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the control
	ControlKindName *string `json:"controlKindName,omitempty"`
	// the kind of the control
	ControlKindID *string `json:"controlKindID,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the standard that the control belongs to, if applicable
	StandardID        *string                     `json:"standardID,omitempty"`
	Evidence          *EvidenceConnection         `json:"evidence"`
	ControlObjectives *ControlObjectiveConnection `json:"controlObjectives"`
	Tasks             *TaskConnection             `json:"tasks"`
	Narratives        *NarrativeConnection        `json:"narratives"`
	Risks             *RiskConnection             `json:"risks"`
	ActionPlans       *ActionPlanConnection       `json:"actionPlans"`
	Procedures        *ProcedureConnection        `json:"procedures"`
	InternalPolicies  *InternalPolicyConnection   `json:"internalPolicies"`
	Comments          *NoteConnection             `json:"comments"`
	// the group of users who are responsible for the control, will be assigned tasks, approval, etc.
	ControlOwner *Group `json:"controlOwner,omitempty"`
	// temporary delegate for the control, used for temporary control ownership
	Delegate *Group `json:"delegate,omitempty"`
	// the entity who is responsible for the control implementation when it is a third party
	ResponsibleParty       *Entity                          `json:"responsibleParty,omitempty"`
	Owner                  *Organization                    `json:"owner,omitempty"`
	BlockedGroups          *GroupConnection                 `json:"blockedGroups"`
	Editors                *GroupConnection                 `json:"editors"`
	ControlKind            *CustomTypeEnum                  `json:"controlKind,omitempty"`
	Standard               *Standard                        `json:"standard,omitempty"`
	Programs               *ProgramConnection               `json:"programs"`
	Assets                 *AssetConnection                 `json:"assets"`
	Scans                  *ScanConnection                  `json:"scans"`
	Findings               *FindingConnection               `json:"findings"`
	ControlImplementations *ControlImplementationConnection `json:"controlImplementations"`
	Subcontrols            *SubcontrolConnection            `json:"subcontrols"`
	ScheduledJobs          *ScheduledJobConnection          `json:"scheduledJobs"`
	MappedFromControls     *MappedControlConnection         `json:"mappedFromControls"`
	WorkflowObjectRefs     *WorkflowObjectRefConnection     `json:"workflowObjectRefs"`
	ControlMappings        *FindingControlConnection        `json:"controlMappings"`
}

func (Control) IsNode() {}

// Return response for createBulkControl mutation
type ControlBulkCreatePayload struct {
	// Created controls
	Controls []*Control `json:"controls,omitempty"`
}

// Return response for deleteBulkControl mutation
type ControlBulkDeletePayload struct {
	// Deleted control IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkControl mutation
type ControlBulkUpdatePayload struct {
	// Updated controls
	Controls []*Control `json:"controls,omitempty"`
	// IDs of the updated controls
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

type ControlCategory struct {
	Name               string  `json:"name"`
	ReferenceFramework *string `json:"referenceFramework,omitempty"`
}

// A connection to a list of items.
type ControlCategoryConnection struct {
	// A list of edges.
	Edges []*ControlCategoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlCategoryEdge struct {
	// The item at the end of the edge.
	Node *ControlCategory `json:"node"`
}

// Ordering options for ControlCategory connections
type ControlCategoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlCategories.
	Field ControlCategoryOrderField `json:"field"`
}

// A connection to a list of items.
type ControlConnection struct {
	// A list of edges.
	Edges []*ControlEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControl mutation
type ControlCreatePayload struct {
	// Created control
	Control *Control `json:"control"`
}

// Return response for deleteControl mutation
type ControlDeletePayload struct {
	// Deleted control ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlEdge struct {
	// The item at the end of the edge.
	Node *Control `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlGroup struct {
	Category string             `json:"category"`
	Controls *ControlConnection `json:"controls"`
}

type ControlGroupConnection struct {
	Edges []*ControlGroupEdge `json:"edges"`
}

type ControlGroupEdge struct {
	PageInfo *PageInfo     `json:"pageInfo"`
	Node     *ControlGroup `json:"node"`
}

type ControlHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// human readable title of the control for quick identification
	Title *string `json:"title,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// additional names (ref_codes) for the control
	Aliases []string `json:"aliases,omitempty"`
	// internal reference id of the control, can be used for internal tracking
	ReferenceID *string `json:"referenceID,omitempty"`
	// external auditor id of the control, can be used to map to external audit partner mappings
	AuditorReferenceID *string `json:"auditorReferenceID,omitempty"`
	// the id of the party responsible for the control, usually used when the control is implemented by a third party
	ResponsiblePartyID *string `json:"responsiblePartyID,omitempty"`
	// status of the control
	Status *enums.ControlStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// the reference framework for the control if it came from a standard, empty if not associated with a standard
	ReferenceFramework *string `json:"referenceFramework,omitempty"`
	// the reference framework revision for the control if it came from a standard, empty if not associated with a standard, allows for pulling in updates when the standard is updated
	ReferenceFrameworkRevision *string `json:"referenceFrameworkRevision,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the id of the group that owns the control
	ControlOwnerID *string `json:"controlOwnerID,omitempty"`
	// the id of the group that is temporarily delegated to own the control
	DelegateID *string `json:"delegateID,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the control
	ControlKindName *string `json:"controlKindName,omitempty"`
	// the kind of the control
	ControlKindID *string `json:"controlKindID,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the standard that the control belongs to, if applicable
	StandardID *string `json:"standardID,omitempty"`
}

func (ControlHistory) IsNode() {}

// A connection to a list of items.
type ControlHistoryConnection struct {
	// A list of edges.
	Edges []*ControlHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ControlHistory connections
type ControlHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlHistories.
	Field ControlHistoryOrderField `json:"field"`
}

// ControlHistoryWhereInput is used for filtering ControlHistory objects.
// Input was generated by ent.
type ControlHistoryWhereInput struct {
	Not *ControlHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// reference_id field predicates
	ReferenceID             *string  `json:"referenceID,omitempty"`
	ReferenceIdneq          *string  `json:"referenceIDNEQ,omitempty"`
	ReferenceIDIn           []string `json:"referenceIDIn,omitempty"`
	ReferenceIDNotIn        []string `json:"referenceIDNotIn,omitempty"`
	ReferenceIdgt           *string  `json:"referenceIDGT,omitempty"`
	ReferenceIdgte          *string  `json:"referenceIDGTE,omitempty"`
	ReferenceIdlt           *string  `json:"referenceIDLT,omitempty"`
	ReferenceIdlte          *string  `json:"referenceIDLTE,omitempty"`
	ReferenceIDContains     *string  `json:"referenceIDContains,omitempty"`
	ReferenceIDHasPrefix    *string  `json:"referenceIDHasPrefix,omitempty"`
	ReferenceIDHasSuffix    *string  `json:"referenceIDHasSuffix,omitempty"`
	ReferenceIDIsNil        *bool    `json:"referenceIDIsNil,omitempty"`
	ReferenceIDNotNil       *bool    `json:"referenceIDNotNil,omitempty"`
	ReferenceIDEqualFold    *string  `json:"referenceIDEqualFold,omitempty"`
	ReferenceIDContainsFold *string  `json:"referenceIDContainsFold,omitempty"`
	// auditor_reference_id field predicates
	AuditorReferenceID             *string  `json:"auditorReferenceID,omitempty"`
	AuditorReferenceIdneq          *string  `json:"auditorReferenceIDNEQ,omitempty"`
	AuditorReferenceIDIn           []string `json:"auditorReferenceIDIn,omitempty"`
	AuditorReferenceIDNotIn        []string `json:"auditorReferenceIDNotIn,omitempty"`
	AuditorReferenceIdgt           *string  `json:"auditorReferenceIDGT,omitempty"`
	AuditorReferenceIdgte          *string  `json:"auditorReferenceIDGTE,omitempty"`
	AuditorReferenceIdlt           *string  `json:"auditorReferenceIDLT,omitempty"`
	AuditorReferenceIdlte          *string  `json:"auditorReferenceIDLTE,omitempty"`
	AuditorReferenceIDContains     *string  `json:"auditorReferenceIDContains,omitempty"`
	AuditorReferenceIDHasPrefix    *string  `json:"auditorReferenceIDHasPrefix,omitempty"`
	AuditorReferenceIDHasSuffix    *string  `json:"auditorReferenceIDHasSuffix,omitempty"`
	AuditorReferenceIDIsNil        *bool    `json:"auditorReferenceIDIsNil,omitempty"`
	AuditorReferenceIDNotNil       *bool    `json:"auditorReferenceIDNotNil,omitempty"`
	AuditorReferenceIDEqualFold    *string  `json:"auditorReferenceIDEqualFold,omitempty"`
	AuditorReferenceIDContainsFold *string  `json:"auditorReferenceIDContainsFold,omitempty"`
	// responsible_party_id field predicates
	ResponsiblePartyID             *string  `json:"responsiblePartyID,omitempty"`
	ResponsiblePartyIdneq          *string  `json:"responsiblePartyIDNEQ,omitempty"`
	ResponsiblePartyIDIn           []string `json:"responsiblePartyIDIn,omitempty"`
	ResponsiblePartyIDNotIn        []string `json:"responsiblePartyIDNotIn,omitempty"`
	ResponsiblePartyIdgt           *string  `json:"responsiblePartyIDGT,omitempty"`
	ResponsiblePartyIdgte          *string  `json:"responsiblePartyIDGTE,omitempty"`
	ResponsiblePartyIdlt           *string  `json:"responsiblePartyIDLT,omitempty"`
	ResponsiblePartyIdlte          *string  `json:"responsiblePartyIDLTE,omitempty"`
	ResponsiblePartyIDContains     *string  `json:"responsiblePartyIDContains,omitempty"`
	ResponsiblePartyIDHasPrefix    *string  `json:"responsiblePartyIDHasPrefix,omitempty"`
	ResponsiblePartyIDHasSuffix    *string  `json:"responsiblePartyIDHasSuffix,omitempty"`
	ResponsiblePartyIDIsNil        *bool    `json:"responsiblePartyIDIsNil,omitempty"`
	ResponsiblePartyIDNotNil       *bool    `json:"responsiblePartyIDNotNil,omitempty"`
	ResponsiblePartyIDEqualFold    *string  `json:"responsiblePartyIDEqualFold,omitempty"`
	ResponsiblePartyIDContainsFold *string  `json:"responsiblePartyIDContainsFold,omitempty"`
	// status field predicates
	Status       *enums.ControlStatus  `json:"status,omitempty"`
	StatusNeq    *enums.ControlStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ControlStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ControlStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                 `json:"statusNotNil,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// reference_framework field predicates
	ReferenceFramework             *string  `json:"referenceFramework,omitempty"`
	ReferenceFrameworkNeq          *string  `json:"referenceFrameworkNEQ,omitempty"`
	ReferenceFrameworkIn           []string `json:"referenceFrameworkIn,omitempty"`
	ReferenceFrameworkNotIn        []string `json:"referenceFrameworkNotIn,omitempty"`
	ReferenceFrameworkGt           *string  `json:"referenceFrameworkGT,omitempty"`
	ReferenceFrameworkGte          *string  `json:"referenceFrameworkGTE,omitempty"`
	ReferenceFrameworkLt           *string  `json:"referenceFrameworkLT,omitempty"`
	ReferenceFrameworkLte          *string  `json:"referenceFrameworkLTE,omitempty"`
	ReferenceFrameworkContains     *string  `json:"referenceFrameworkContains,omitempty"`
	ReferenceFrameworkHasPrefix    *string  `json:"referenceFrameworkHasPrefix,omitempty"`
	ReferenceFrameworkHasSuffix    *string  `json:"referenceFrameworkHasSuffix,omitempty"`
	ReferenceFrameworkIsNil        *bool    `json:"referenceFrameworkIsNil,omitempty"`
	ReferenceFrameworkNotNil       *bool    `json:"referenceFrameworkNotNil,omitempty"`
	ReferenceFrameworkEqualFold    *string  `json:"referenceFrameworkEqualFold,omitempty"`
	ReferenceFrameworkContainsFold *string  `json:"referenceFrameworkContainsFold,omitempty"`
	// reference_framework_revision field predicates
	ReferenceFrameworkRevision             *string  `json:"referenceFrameworkRevision,omitempty"`
	ReferenceFrameworkRevisionNeq          *string  `json:"referenceFrameworkRevisionNEQ,omitempty"`
	ReferenceFrameworkRevisionIn           []string `json:"referenceFrameworkRevisionIn,omitempty"`
	ReferenceFrameworkRevisionNotIn        []string `json:"referenceFrameworkRevisionNotIn,omitempty"`
	ReferenceFrameworkRevisionGt           *string  `json:"referenceFrameworkRevisionGT,omitempty"`
	ReferenceFrameworkRevisionGte          *string  `json:"referenceFrameworkRevisionGTE,omitempty"`
	ReferenceFrameworkRevisionLt           *string  `json:"referenceFrameworkRevisionLT,omitempty"`
	ReferenceFrameworkRevisionLte          *string  `json:"referenceFrameworkRevisionLTE,omitempty"`
	ReferenceFrameworkRevisionContains     *string  `json:"referenceFrameworkRevisionContains,omitempty"`
	ReferenceFrameworkRevisionHasPrefix    *string  `json:"referenceFrameworkRevisionHasPrefix,omitempty"`
	ReferenceFrameworkRevisionHasSuffix    *string  `json:"referenceFrameworkRevisionHasSuffix,omitempty"`
	ReferenceFrameworkRevisionIsNil        *bool    `json:"referenceFrameworkRevisionIsNil,omitempty"`
	ReferenceFrameworkRevisionNotNil       *bool    `json:"referenceFrameworkRevisionNotNil,omitempty"`
	ReferenceFrameworkRevisionEqualFold    *string  `json:"referenceFrameworkRevisionEqualFold,omitempty"`
	ReferenceFrameworkRevisionContainsFold *string  `json:"referenceFrameworkRevisionContainsFold,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// control_owner_id field predicates
	ControlOwnerID             *string  `json:"controlOwnerID,omitempty"`
	ControlOwnerIdneq          *string  `json:"controlOwnerIDNEQ,omitempty"`
	ControlOwnerIDIn           []string `json:"controlOwnerIDIn,omitempty"`
	ControlOwnerIDNotIn        []string `json:"controlOwnerIDNotIn,omitempty"`
	ControlOwnerIdgt           *string  `json:"controlOwnerIDGT,omitempty"`
	ControlOwnerIdgte          *string  `json:"controlOwnerIDGTE,omitempty"`
	ControlOwnerIdlt           *string  `json:"controlOwnerIDLT,omitempty"`
	ControlOwnerIdlte          *string  `json:"controlOwnerIDLTE,omitempty"`
	ControlOwnerIDContains     *string  `json:"controlOwnerIDContains,omitempty"`
	ControlOwnerIDHasPrefix    *string  `json:"controlOwnerIDHasPrefix,omitempty"`
	ControlOwnerIDHasSuffix    *string  `json:"controlOwnerIDHasSuffix,omitempty"`
	ControlOwnerIDIsNil        *bool    `json:"controlOwnerIDIsNil,omitempty"`
	ControlOwnerIDNotNil       *bool    `json:"controlOwnerIDNotNil,omitempty"`
	ControlOwnerIDEqualFold    *string  `json:"controlOwnerIDEqualFold,omitempty"`
	ControlOwnerIDContainsFold *string  `json:"controlOwnerIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// control_kind_name field predicates
	ControlKindName             *string  `json:"controlKindName,omitempty"`
	ControlKindNameNeq          *string  `json:"controlKindNameNEQ,omitempty"`
	ControlKindNameIn           []string `json:"controlKindNameIn,omitempty"`
	ControlKindNameNotIn        []string `json:"controlKindNameNotIn,omitempty"`
	ControlKindNameGt           *string  `json:"controlKindNameGT,omitempty"`
	ControlKindNameGte          *string  `json:"controlKindNameGTE,omitempty"`
	ControlKindNameLt           *string  `json:"controlKindNameLT,omitempty"`
	ControlKindNameLte          *string  `json:"controlKindNameLTE,omitempty"`
	ControlKindNameContains     *string  `json:"controlKindNameContains,omitempty"`
	ControlKindNameHasPrefix    *string  `json:"controlKindNameHasPrefix,omitempty"`
	ControlKindNameHasSuffix    *string  `json:"controlKindNameHasSuffix,omitempty"`
	ControlKindNameIsNil        *bool    `json:"controlKindNameIsNil,omitempty"`
	ControlKindNameNotNil       *bool    `json:"controlKindNameNotNil,omitempty"`
	ControlKindNameEqualFold    *string  `json:"controlKindNameEqualFold,omitempty"`
	ControlKindNameContainsFold *string  `json:"controlKindNameContainsFold,omitempty"`
	// control_kind_id field predicates
	ControlKindID             *string  `json:"controlKindID,omitempty"`
	ControlKindIdneq          *string  `json:"controlKindIDNEQ,omitempty"`
	ControlKindIDIn           []string `json:"controlKindIDIn,omitempty"`
	ControlKindIDNotIn        []string `json:"controlKindIDNotIn,omitempty"`
	ControlKindIdgt           *string  `json:"controlKindIDGT,omitempty"`
	ControlKindIdgte          *string  `json:"controlKindIDGTE,omitempty"`
	ControlKindIdlt           *string  `json:"controlKindIDLT,omitempty"`
	ControlKindIdlte          *string  `json:"controlKindIDLTE,omitempty"`
	ControlKindIDContains     *string  `json:"controlKindIDContains,omitempty"`
	ControlKindIDHasPrefix    *string  `json:"controlKindIDHasPrefix,omitempty"`
	ControlKindIDHasSuffix    *string  `json:"controlKindIDHasSuffix,omitempty"`
	ControlKindIDIsNil        *bool    `json:"controlKindIDIsNil,omitempty"`
	ControlKindIDNotNil       *bool    `json:"controlKindIDNotNil,omitempty"`
	ControlKindIDEqualFold    *string  `json:"controlKindIDEqualFold,omitempty"`
	ControlKindIDContainsFold *string  `json:"controlKindIDContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
}

type ControlImplementation struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// status of the %s, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details       *string               `json:"details,omitempty"`
	Owner         *Organization         `json:"owner,omitempty"`
	BlockedGroups *GroupConnection      `json:"blockedGroups"`
	Editors       *GroupConnection      `json:"editors"`
	Viewers       *GroupConnection      `json:"viewers"`
	Controls      *ControlConnection    `json:"controls"`
	Subcontrols   *SubcontrolConnection `json:"subcontrols"`
	Tasks         *TaskConnection       `json:"tasks"`
}

func (ControlImplementation) IsNode() {}

// Return response for createBulkControlImplementation mutation
type ControlImplementationBulkCreatePayload struct {
	// Created controlImplementations
	ControlImplementations []*ControlImplementation `json:"controlImplementations,omitempty"`
}

// Return response for deleteBulkControlImplementation mutation
type ControlImplementationBulkDeletePayload struct {
	// Deleted controlImplementation IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type ControlImplementationConnection struct {
	// A list of edges.
	Edges []*ControlImplementationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControlImplementation mutation
type ControlImplementationCreatePayload struct {
	// Created controlImplementation
	ControlImplementation *ControlImplementation `json:"controlImplementation"`
}

// Return response for deleteControlImplementation mutation
type ControlImplementationDeletePayload struct {
	// Deleted controlImplementation ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlImplementationEdge struct {
	// The item at the end of the edge.
	Node *ControlImplementation `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlImplementationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// status of the %s, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details *string `json:"details,omitempty"`
}

func (ControlImplementationHistory) IsNode() {}

// A connection to a list of items.
type ControlImplementationHistoryConnection struct {
	// A list of edges.
	Edges []*ControlImplementationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlImplementationHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlImplementationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ControlImplementationHistory connections
type ControlImplementationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlImplementationHistories.
	Field ControlImplementationHistoryOrderField `json:"field"`
}

// ControlImplementationHistoryWhereInput is used for filtering ControlImplementationHistory objects.
// Input was generated by ent.
type ControlImplementationHistoryWhereInput struct {
	Not *ControlImplementationHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlImplementationHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlImplementationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// implementation_date field predicates
	ImplementationDate       *time.Time   `json:"implementationDate,omitempty"`
	ImplementationDateNeq    *time.Time   `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []*time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []*time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGt     *time.Time   `json:"implementationDateGT,omitempty"`
	ImplementationDateGte    *time.Time   `json:"implementationDateGTE,omitempty"`
	ImplementationDateLt     *time.Time   `json:"implementationDateLT,omitempty"`
	ImplementationDateLte    *time.Time   `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  *bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil *bool        `json:"implementationDateNotNil,omitempty"`
	// verified field predicates
	Verified       *bool `json:"verified,omitempty"`
	VerifiedNeq    *bool `json:"verifiedNEQ,omitempty"`
	VerifiedIsNil  *bool `json:"verifiedIsNil,omitempty"`
	VerifiedNotNil *bool `json:"verifiedNotNil,omitempty"`
	// verification_date field predicates
	VerificationDate       *time.Time   `json:"verificationDate,omitempty"`
	VerificationDateNeq    *time.Time   `json:"verificationDateNEQ,omitempty"`
	VerificationDateIn     []*time.Time `json:"verificationDateIn,omitempty"`
	VerificationDateNotIn  []*time.Time `json:"verificationDateNotIn,omitempty"`
	VerificationDateGt     *time.Time   `json:"verificationDateGT,omitempty"`
	VerificationDateGte    *time.Time   `json:"verificationDateGTE,omitempty"`
	VerificationDateLt     *time.Time   `json:"verificationDateLT,omitempty"`
	VerificationDateLte    *time.Time   `json:"verificationDateLTE,omitempty"`
	VerificationDateIsNil  *bool        `json:"verificationDateIsNil,omitempty"`
	VerificationDateNotNil *bool        `json:"verificationDateNotNil,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
}

// Ordering options for ControlImplementation connections
type ControlImplementationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlImplementations.
	Field ControlImplementationOrderField `json:"field"`
}

// Return response for updateControlImplementation mutation
type ControlImplementationUpdatePayload struct {
	// Updated controlImplementation
	ControlImplementation *ControlImplementation `json:"controlImplementation"`
}

// ControlImplementationWhereInput is used for filtering ControlImplementation objects.
// Input was generated by ent.
type ControlImplementationWhereInput struct {
	Not *ControlImplementationWhereInput   `json:"not,omitempty"`
	And []*ControlImplementationWhereInput `json:"and,omitempty"`
	Or  []*ControlImplementationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// implementation_date field predicates
	ImplementationDate       *time.Time   `json:"implementationDate,omitempty"`
	ImplementationDateNeq    *time.Time   `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []*time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []*time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGt     *time.Time   `json:"implementationDateGT,omitempty"`
	ImplementationDateGte    *time.Time   `json:"implementationDateGTE,omitempty"`
	ImplementationDateLt     *time.Time   `json:"implementationDateLT,omitempty"`
	ImplementationDateLte    *time.Time   `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  *bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil *bool        `json:"implementationDateNotNil,omitempty"`
	// verified field predicates
	Verified       *bool `json:"verified,omitempty"`
	VerifiedNeq    *bool `json:"verifiedNEQ,omitempty"`
	VerifiedIsNil  *bool `json:"verifiedIsNil,omitempty"`
	VerifiedNotNil *bool `json:"verifiedNotNil,omitempty"`
	// verification_date field predicates
	VerificationDate       *time.Time   `json:"verificationDate,omitempty"`
	VerificationDateNeq    *time.Time   `json:"verificationDateNEQ,omitempty"`
	VerificationDateIn     []*time.Time `json:"verificationDateIn,omitempty"`
	VerificationDateNotIn  []*time.Time `json:"verificationDateNotIn,omitempty"`
	VerificationDateGt     *time.Time   `json:"verificationDateGT,omitempty"`
	VerificationDateGte    *time.Time   `json:"verificationDateGTE,omitempty"`
	VerificationDateLt     *time.Time   `json:"verificationDateLT,omitempty"`
	VerificationDateLte    *time.Time   `json:"verificationDateLTE,omitempty"`
	VerificationDateIsNil  *bool        `json:"verificationDateIsNil,omitempty"`
	VerificationDateNotNil *bool        `json:"verificationDateNotNil,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

type ControlObjective struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *enums.ObjectiveStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory      *string                   `json:"subcategory,omitempty"`
	Owner            *Organization             `json:"owner,omitempty"`
	BlockedGroups    *GroupConnection          `json:"blockedGroups"`
	Editors          *GroupConnection          `json:"editors"`
	Viewers          *GroupConnection          `json:"viewers"`
	Programs         *ProgramConnection        `json:"programs"`
	Evidence         *EvidenceConnection       `json:"evidence"`
	Controls         *ControlConnection        `json:"controls"`
	Subcontrols      *SubcontrolConnection     `json:"subcontrols"`
	InternalPolicies *InternalPolicyConnection `json:"internalPolicies"`
	Procedures       *ProcedureConnection      `json:"procedures"`
	Risks            *RiskConnection           `json:"risks"`
	Narratives       *NarrativeConnection      `json:"narratives"`
	Tasks            *TaskConnection           `json:"tasks"`
}

func (ControlObjective) IsNode() {}

// Return response for createBulkControlObjective mutation
type ControlObjectiveBulkCreatePayload struct {
	// Created controlObjectives
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
}

// Return response for deleteBulkControlObjective mutation
type ControlObjectiveBulkDeletePayload struct {
	// Deleted controlObjective IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type ControlObjectiveConnection struct {
	// A list of edges.
	Edges []*ControlObjectiveEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControlObjective mutation
type ControlObjectiveCreatePayload struct {
	// Created controlObjective
	ControlObjective *ControlObjective `json:"controlObjective"`
}

// Return response for deleteControlObjective mutation
type ControlObjectiveDeletePayload struct {
	// Deleted controlObjective ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlObjectiveEdge struct {
	// The item at the end of the edge.
	Node *ControlObjective `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlObjectiveHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *enums.ObjectiveStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
}

func (ControlObjectiveHistory) IsNode() {}

// A connection to a list of items.
type ControlObjectiveHistoryConnection struct {
	// A list of edges.
	Edges []*ControlObjectiveHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlObjectiveHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlObjectiveHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ControlObjectiveHistory connections
type ControlObjectiveHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlObjectiveHistories.
	Field ControlObjectiveHistoryOrderField `json:"field"`
}

// ControlObjectiveHistoryWhereInput is used for filtering ControlObjectiveHistory objects.
// Input was generated by ent.
type ControlObjectiveHistoryWhereInput struct {
	Not *ControlObjectiveHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlObjectiveHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlObjectiveHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// desired_outcome field predicates
	DesiredOutcome             *string  `json:"desiredOutcome,omitempty"`
	DesiredOutcomeNeq          *string  `json:"desiredOutcomeNEQ,omitempty"`
	DesiredOutcomeIn           []string `json:"desiredOutcomeIn,omitempty"`
	DesiredOutcomeNotIn        []string `json:"desiredOutcomeNotIn,omitempty"`
	DesiredOutcomeGt           *string  `json:"desiredOutcomeGT,omitempty"`
	DesiredOutcomeGte          *string  `json:"desiredOutcomeGTE,omitempty"`
	DesiredOutcomeLt           *string  `json:"desiredOutcomeLT,omitempty"`
	DesiredOutcomeLte          *string  `json:"desiredOutcomeLTE,omitempty"`
	DesiredOutcomeContains     *string  `json:"desiredOutcomeContains,omitempty"`
	DesiredOutcomeHasPrefix    *string  `json:"desiredOutcomeHasPrefix,omitempty"`
	DesiredOutcomeHasSuffix    *string  `json:"desiredOutcomeHasSuffix,omitempty"`
	DesiredOutcomeIsNil        *bool    `json:"desiredOutcomeIsNil,omitempty"`
	DesiredOutcomeNotNil       *bool    `json:"desiredOutcomeNotNil,omitempty"`
	DesiredOutcomeEqualFold    *string  `json:"desiredOutcomeEqualFold,omitempty"`
	DesiredOutcomeContainsFold *string  `json:"desiredOutcomeContainsFold,omitempty"`
	// status field predicates
	Status       *enums.ObjectiveStatus  `json:"status,omitempty"`
	StatusNeq    *enums.ObjectiveStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ObjectiveStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ObjectiveStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                   `json:"statusNotNil,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_objective_type field predicates
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNeq          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGt           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGte          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLt           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLte          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        *bool    `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       *bool    `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
}

// Ordering options for ControlObjective connections
type ControlObjectiveOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlObjectives.
	Field ControlObjectiveOrderField `json:"field"`
}

// Return response for updateControlObjective mutation
type ControlObjectiveUpdatePayload struct {
	// Updated controlObjective
	ControlObjective *ControlObjective `json:"controlObjective"`
}

// ControlObjectiveWhereInput is used for filtering ControlObjective objects.
// Input was generated by ent.
type ControlObjectiveWhereInput struct {
	Not *ControlObjectiveWhereInput   `json:"not,omitempty"`
	And []*ControlObjectiveWhereInput `json:"and,omitempty"`
	Or  []*ControlObjectiveWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// desired_outcome field predicates
	DesiredOutcome             *string  `json:"desiredOutcome,omitempty"`
	DesiredOutcomeNeq          *string  `json:"desiredOutcomeNEQ,omitempty"`
	DesiredOutcomeIn           []string `json:"desiredOutcomeIn,omitempty"`
	DesiredOutcomeNotIn        []string `json:"desiredOutcomeNotIn,omitempty"`
	DesiredOutcomeGt           *string  `json:"desiredOutcomeGT,omitempty"`
	DesiredOutcomeGte          *string  `json:"desiredOutcomeGTE,omitempty"`
	DesiredOutcomeLt           *string  `json:"desiredOutcomeLT,omitempty"`
	DesiredOutcomeLte          *string  `json:"desiredOutcomeLTE,omitempty"`
	DesiredOutcomeContains     *string  `json:"desiredOutcomeContains,omitempty"`
	DesiredOutcomeHasPrefix    *string  `json:"desiredOutcomeHasPrefix,omitempty"`
	DesiredOutcomeHasSuffix    *string  `json:"desiredOutcomeHasSuffix,omitempty"`
	DesiredOutcomeIsNil        *bool    `json:"desiredOutcomeIsNil,omitempty"`
	DesiredOutcomeNotNil       *bool    `json:"desiredOutcomeNotNil,omitempty"`
	DesiredOutcomeEqualFold    *string  `json:"desiredOutcomeEqualFold,omitempty"`
	DesiredOutcomeContainsFold *string  `json:"desiredOutcomeContainsFold,omitempty"`
	// status field predicates
	Status       *enums.ObjectiveStatus  `json:"status,omitempty"`
	StatusNeq    *enums.ObjectiveStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ObjectiveStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ObjectiveStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                   `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                   `json:"statusNotNil,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_objective_type field predicates
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNeq          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGt           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGte          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLt           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLte          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        *bool    `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       *bool    `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

// Ordering options for Control connections
type ControlOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Controls.
	Field ControlOrderField `json:"field"`
}

// Return response for updateControl mutation
type ControlUpdatePayload struct {
	// Updated control
	Control *Control `json:"control"`
}

// ControlWhereInput is used for filtering Control objects.
// Input was generated by ent.
type ControlWhereInput struct {
	Not *ControlWhereInput   `json:"not,omitempty"`
	And []*ControlWhereInput `json:"and,omitempty"`
	Or  []*ControlWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// reference_id field predicates
	ReferenceID             *string  `json:"referenceID,omitempty"`
	ReferenceIdneq          *string  `json:"referenceIDNEQ,omitempty"`
	ReferenceIDIn           []string `json:"referenceIDIn,omitempty"`
	ReferenceIDNotIn        []string `json:"referenceIDNotIn,omitempty"`
	ReferenceIdgt           *string  `json:"referenceIDGT,omitempty"`
	ReferenceIdgte          *string  `json:"referenceIDGTE,omitempty"`
	ReferenceIdlt           *string  `json:"referenceIDLT,omitempty"`
	ReferenceIdlte          *string  `json:"referenceIDLTE,omitempty"`
	ReferenceIDContains     *string  `json:"referenceIDContains,omitempty"`
	ReferenceIDHasPrefix    *string  `json:"referenceIDHasPrefix,omitempty"`
	ReferenceIDHasSuffix    *string  `json:"referenceIDHasSuffix,omitempty"`
	ReferenceIDIsNil        *bool    `json:"referenceIDIsNil,omitempty"`
	ReferenceIDNotNil       *bool    `json:"referenceIDNotNil,omitempty"`
	ReferenceIDEqualFold    *string  `json:"referenceIDEqualFold,omitempty"`
	ReferenceIDContainsFold *string  `json:"referenceIDContainsFold,omitempty"`
	// auditor_reference_id field predicates
	AuditorReferenceID             *string  `json:"auditorReferenceID,omitempty"`
	AuditorReferenceIdneq          *string  `json:"auditorReferenceIDNEQ,omitempty"`
	AuditorReferenceIDIn           []string `json:"auditorReferenceIDIn,omitempty"`
	AuditorReferenceIDNotIn        []string `json:"auditorReferenceIDNotIn,omitempty"`
	AuditorReferenceIdgt           *string  `json:"auditorReferenceIDGT,omitempty"`
	AuditorReferenceIdgte          *string  `json:"auditorReferenceIDGTE,omitempty"`
	AuditorReferenceIdlt           *string  `json:"auditorReferenceIDLT,omitempty"`
	AuditorReferenceIdlte          *string  `json:"auditorReferenceIDLTE,omitempty"`
	AuditorReferenceIDContains     *string  `json:"auditorReferenceIDContains,omitempty"`
	AuditorReferenceIDHasPrefix    *string  `json:"auditorReferenceIDHasPrefix,omitempty"`
	AuditorReferenceIDHasSuffix    *string  `json:"auditorReferenceIDHasSuffix,omitempty"`
	AuditorReferenceIDIsNil        *bool    `json:"auditorReferenceIDIsNil,omitempty"`
	AuditorReferenceIDNotNil       *bool    `json:"auditorReferenceIDNotNil,omitempty"`
	AuditorReferenceIDEqualFold    *string  `json:"auditorReferenceIDEqualFold,omitempty"`
	AuditorReferenceIDContainsFold *string  `json:"auditorReferenceIDContainsFold,omitempty"`
	// responsible_party_id field predicates
	ResponsiblePartyID             *string  `json:"responsiblePartyID,omitempty"`
	ResponsiblePartyIdneq          *string  `json:"responsiblePartyIDNEQ,omitempty"`
	ResponsiblePartyIDIn           []string `json:"responsiblePartyIDIn,omitempty"`
	ResponsiblePartyIDNotIn        []string `json:"responsiblePartyIDNotIn,omitempty"`
	ResponsiblePartyIdgt           *string  `json:"responsiblePartyIDGT,omitempty"`
	ResponsiblePartyIdgte          *string  `json:"responsiblePartyIDGTE,omitempty"`
	ResponsiblePartyIdlt           *string  `json:"responsiblePartyIDLT,omitempty"`
	ResponsiblePartyIdlte          *string  `json:"responsiblePartyIDLTE,omitempty"`
	ResponsiblePartyIDContains     *string  `json:"responsiblePartyIDContains,omitempty"`
	ResponsiblePartyIDHasPrefix    *string  `json:"responsiblePartyIDHasPrefix,omitempty"`
	ResponsiblePartyIDHasSuffix    *string  `json:"responsiblePartyIDHasSuffix,omitempty"`
	ResponsiblePartyIDIsNil        *bool    `json:"responsiblePartyIDIsNil,omitempty"`
	ResponsiblePartyIDNotNil       *bool    `json:"responsiblePartyIDNotNil,omitempty"`
	ResponsiblePartyIDEqualFold    *string  `json:"responsiblePartyIDEqualFold,omitempty"`
	ResponsiblePartyIDContainsFold *string  `json:"responsiblePartyIDContainsFold,omitempty"`
	// status field predicates
	Status       *enums.ControlStatus  `json:"status,omitempty"`
	StatusNeq    *enums.ControlStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ControlStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ControlStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                 `json:"statusNotNil,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// reference_framework field predicates
	ReferenceFramework             *string  `json:"referenceFramework,omitempty"`
	ReferenceFrameworkNeq          *string  `json:"referenceFrameworkNEQ,omitempty"`
	ReferenceFrameworkIn           []string `json:"referenceFrameworkIn,omitempty"`
	ReferenceFrameworkNotIn        []string `json:"referenceFrameworkNotIn,omitempty"`
	ReferenceFrameworkGt           *string  `json:"referenceFrameworkGT,omitempty"`
	ReferenceFrameworkGte          *string  `json:"referenceFrameworkGTE,omitempty"`
	ReferenceFrameworkLt           *string  `json:"referenceFrameworkLT,omitempty"`
	ReferenceFrameworkLte          *string  `json:"referenceFrameworkLTE,omitempty"`
	ReferenceFrameworkContains     *string  `json:"referenceFrameworkContains,omitempty"`
	ReferenceFrameworkHasPrefix    *string  `json:"referenceFrameworkHasPrefix,omitempty"`
	ReferenceFrameworkHasSuffix    *string  `json:"referenceFrameworkHasSuffix,omitempty"`
	ReferenceFrameworkIsNil        *bool    `json:"referenceFrameworkIsNil,omitempty"`
	ReferenceFrameworkNotNil       *bool    `json:"referenceFrameworkNotNil,omitempty"`
	ReferenceFrameworkEqualFold    *string  `json:"referenceFrameworkEqualFold,omitempty"`
	ReferenceFrameworkContainsFold *string  `json:"referenceFrameworkContainsFold,omitempty"`
	// reference_framework_revision field predicates
	ReferenceFrameworkRevision             *string  `json:"referenceFrameworkRevision,omitempty"`
	ReferenceFrameworkRevisionNeq          *string  `json:"referenceFrameworkRevisionNEQ,omitempty"`
	ReferenceFrameworkRevisionIn           []string `json:"referenceFrameworkRevisionIn,omitempty"`
	ReferenceFrameworkRevisionNotIn        []string `json:"referenceFrameworkRevisionNotIn,omitempty"`
	ReferenceFrameworkRevisionGt           *string  `json:"referenceFrameworkRevisionGT,omitempty"`
	ReferenceFrameworkRevisionGte          *string  `json:"referenceFrameworkRevisionGTE,omitempty"`
	ReferenceFrameworkRevisionLt           *string  `json:"referenceFrameworkRevisionLT,omitempty"`
	ReferenceFrameworkRevisionLte          *string  `json:"referenceFrameworkRevisionLTE,omitempty"`
	ReferenceFrameworkRevisionContains     *string  `json:"referenceFrameworkRevisionContains,omitempty"`
	ReferenceFrameworkRevisionHasPrefix    *string  `json:"referenceFrameworkRevisionHasPrefix,omitempty"`
	ReferenceFrameworkRevisionHasSuffix    *string  `json:"referenceFrameworkRevisionHasSuffix,omitempty"`
	ReferenceFrameworkRevisionIsNil        *bool    `json:"referenceFrameworkRevisionIsNil,omitempty"`
	ReferenceFrameworkRevisionNotNil       *bool    `json:"referenceFrameworkRevisionNotNil,omitempty"`
	ReferenceFrameworkRevisionEqualFold    *string  `json:"referenceFrameworkRevisionEqualFold,omitempty"`
	ReferenceFrameworkRevisionContainsFold *string  `json:"referenceFrameworkRevisionContainsFold,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// control_owner_id field predicates
	ControlOwnerID             *string  `json:"controlOwnerID,omitempty"`
	ControlOwnerIdneq          *string  `json:"controlOwnerIDNEQ,omitempty"`
	ControlOwnerIDIn           []string `json:"controlOwnerIDIn,omitempty"`
	ControlOwnerIDNotIn        []string `json:"controlOwnerIDNotIn,omitempty"`
	ControlOwnerIdgt           *string  `json:"controlOwnerIDGT,omitempty"`
	ControlOwnerIdgte          *string  `json:"controlOwnerIDGTE,omitempty"`
	ControlOwnerIdlt           *string  `json:"controlOwnerIDLT,omitempty"`
	ControlOwnerIdlte          *string  `json:"controlOwnerIDLTE,omitempty"`
	ControlOwnerIDContains     *string  `json:"controlOwnerIDContains,omitempty"`
	ControlOwnerIDHasPrefix    *string  `json:"controlOwnerIDHasPrefix,omitempty"`
	ControlOwnerIDHasSuffix    *string  `json:"controlOwnerIDHasSuffix,omitempty"`
	ControlOwnerIDIsNil        *bool    `json:"controlOwnerIDIsNil,omitempty"`
	ControlOwnerIDNotNil       *bool    `json:"controlOwnerIDNotNil,omitempty"`
	ControlOwnerIDEqualFold    *string  `json:"controlOwnerIDEqualFold,omitempty"`
	ControlOwnerIDContainsFold *string  `json:"controlOwnerIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// control_kind_name field predicates
	ControlKindName             *string  `json:"controlKindName,omitempty"`
	ControlKindNameNeq          *string  `json:"controlKindNameNEQ,omitempty"`
	ControlKindNameIn           []string `json:"controlKindNameIn,omitempty"`
	ControlKindNameNotIn        []string `json:"controlKindNameNotIn,omitempty"`
	ControlKindNameGt           *string  `json:"controlKindNameGT,omitempty"`
	ControlKindNameGte          *string  `json:"controlKindNameGTE,omitempty"`
	ControlKindNameLt           *string  `json:"controlKindNameLT,omitempty"`
	ControlKindNameLte          *string  `json:"controlKindNameLTE,omitempty"`
	ControlKindNameContains     *string  `json:"controlKindNameContains,omitempty"`
	ControlKindNameHasPrefix    *string  `json:"controlKindNameHasPrefix,omitempty"`
	ControlKindNameHasSuffix    *string  `json:"controlKindNameHasSuffix,omitempty"`
	ControlKindNameIsNil        *bool    `json:"controlKindNameIsNil,omitempty"`
	ControlKindNameNotNil       *bool    `json:"controlKindNameNotNil,omitempty"`
	ControlKindNameEqualFold    *string  `json:"controlKindNameEqualFold,omitempty"`
	ControlKindNameContainsFold *string  `json:"controlKindNameContainsFold,omitempty"`
	// control_kind_id field predicates
	ControlKindID             *string  `json:"controlKindID,omitempty"`
	ControlKindIdneq          *string  `json:"controlKindIDNEQ,omitempty"`
	ControlKindIDIn           []string `json:"controlKindIDIn,omitempty"`
	ControlKindIDNotIn        []string `json:"controlKindIDNotIn,omitempty"`
	ControlKindIdgt           *string  `json:"controlKindIDGT,omitempty"`
	ControlKindIdgte          *string  `json:"controlKindIDGTE,omitempty"`
	ControlKindIdlt           *string  `json:"controlKindIDLT,omitempty"`
	ControlKindIdlte          *string  `json:"controlKindIDLTE,omitempty"`
	ControlKindIDContains     *string  `json:"controlKindIDContains,omitempty"`
	ControlKindIDHasPrefix    *string  `json:"controlKindIDHasPrefix,omitempty"`
	ControlKindIDHasSuffix    *string  `json:"controlKindIDHasSuffix,omitempty"`
	ControlKindIDIsNil        *bool    `json:"controlKindIDIsNil,omitempty"`
	ControlKindIDNotNil       *bool    `json:"controlKindIDNotNil,omitempty"`
	ControlKindIDEqualFold    *string  `json:"controlKindIDEqualFold,omitempty"`
	ControlKindIDContainsFold *string  `json:"controlKindIDContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// control_owner edge predicates
	HasControlOwner     *bool              `json:"hasControlOwner,omitempty"`
	HasControlOwnerWith []*GroupWhereInput `json:"hasControlOwnerWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// responsible_party edge predicates
	HasResponsibleParty     *bool               `json:"hasResponsibleParty,omitempty"`
	HasResponsiblePartyWith []*EntityWhereInput `json:"hasResponsiblePartyWith,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// control_kind edge predicates
	HasControlKind     *bool                       `json:"hasControlKind,omitempty"`
	HasControlKindWith []*CustomTypeEnumWhereInput `json:"hasControlKindWith,omitempty"`
	// standard edge predicates
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// scans edge predicates
	HasScans     *bool             `json:"hasScans,omitempty"`
	HasScansWith []*ScanWhereInput `json:"hasScansWith,omitempty"`
	// findings edge predicates
	HasFindings     *bool                `json:"hasFindings,omitempty"`
	HasFindingsWith []*FindingWhereInput `json:"hasFindingsWith,omitempty"`
	// control_implementations edge predicates
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// scheduled_jobs edge predicates
	HasScheduledJobs     *bool                     `json:"hasScheduledJobs,omitempty"`
	HasScheduledJobsWith []*ScheduledJobWhereInput `json:"hasScheduledJobsWith,omitempty"`
	// mapped_to_controls edge predicates
	HasMappedToControls     *bool                      `json:"hasMappedToControls,omitempty"`
	HasMappedToControlsWith []*MappedControlWhereInput `json:"hasMappedToControlsWith,omitempty"`
	// mapped_from_controls edge predicates
	HasMappedFromControls     *bool                      `json:"hasMappedFromControls,omitempty"`
	HasMappedFromControlsWith []*MappedControlWhereInput `json:"hasMappedFromControlsWith,omitempty"`
	// workflow_object_refs edge predicates
	HasWorkflowObjectRefs     *bool                          `json:"hasWorkflowObjectRefs,omitempty"`
	HasWorkflowObjectRefsWith []*WorkflowObjectRefWhereInput `json:"hasWorkflowObjectRefsWith,omitempty"`
	// control_mappings edge predicates
	HasControlMappings     *bool                       `json:"hasControlMappings,omitempty"`
	HasControlMappingsWith []*FindingControlWhereInput `json:"hasControlMappingsWith,omitempty"`
}

// CreateAPITokenInput is used for create APIToken object.
// Input was generated by ent.
type CreateAPITokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt *time.Time `json:"revokedAt,omitempty"`
	OwnerID   *string    `json:"ownerID,omitempty"`
}

// CreateActionPlanInput is used for create ActionPlan object.
// Input was generated by ent.
type CreateActionPlanInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the action_plan
	Name string `json:"name"`
	// status of the action_plan, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the action_plan, e.g. compliance, operational, health and safety, etc.
	ActionPlanType *string `json:"actionPlanType,omitempty"`
	// details of the action_plan
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the action_plan
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the action_plan should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the action_plan should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// auto-generated tag suggestions for the action_plan
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the action_plan
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the action_plan
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the action_plan
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the action_plan
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the action_plan
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the action_plan
	URL *string `json:"url,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the action_plan
	ActionPlanKindName *string `json:"actionPlanKindName,omitempty"`
	// short title describing the action plan
	Title string `json:"title"`
	// detailed description of remediation steps and objectives
	Description *string `json:"description,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// timestamp when the action plan was completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// priority of the action plan
	Priority *enums.Priority `json:"priority,omitempty"`
	// indicates if the action plan requires explicit approval before closure
	RequiresApproval *bool `json:"requiresApproval,omitempty"`
	// true when the action plan is currently blocked
	Blocked *bool `json:"blocked,omitempty"`
	// context on why the action plan is blocked
	BlockerReason *string `json:"blockerReason,omitempty"`
	// additional structured metadata for the action plan
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload map[string]any `json:"rawPayload,omitempty"`
	// source of the action plan
	Source           *string  `json:"source,omitempty"`
	ApproverID       *string  `json:"approverID,omitempty"`
	DelegateID       *string  `json:"delegateID,omitempty"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	ActionPlanKindID *string  `json:"actionPlanKindID,omitempty"`
	RiskIDs          []string `json:"riskIDs,omitempty"`
	ControlIDs       []string `json:"controlIDs,omitempty"`
	ProgramIDs       []string `json:"programIDs,omitempty"`
	FindingIDs       []string `json:"findingIDs,omitempty"`
	VulnerabilityIDs []string `json:"vulnerabilityIDs,omitempty"`
	ReviewIDs        []string `json:"reviewIDs,omitempty"`
	RemediationIDs   []string `json:"remediationIDs,omitempty"`
	TaskIDs          []string `json:"taskIDs,omitempty"`
	IntegrationIDs   []string `json:"integrationIDs,omitempty"`
	FileID           *string  `json:"fileID,omitempty"`
}

// CreateAssessmentInput is used for create Assessment object.
// Input was generated by ent.
type CreateAssessmentInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the assessment, e.g. cloud providers, marketing team
	Name           string                `json:"name"`
	AssessmentType *enums.AssessmentType `json:"assessmentType,omitempty"`
	// the jsonschema object of the questionnaire. If not provided it will be inherited from the template.
	Jsonconfig map[string]any `json:"jsonconfig,omitempty"`
	// the uischema for the template to render in the UI. If not provided, it will be inherited from the template
	Uischema map[string]any `json:"uischema,omitempty"`
	// the duration in seconds that the user has to complete the assessment response, defaults to 7 days
	ResponseDueDuration   *int64   `json:"responseDueDuration,omitempty"`
	OwnerID               *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs       []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs             []string `json:"editorIDs,omitempty"`
	ViewerIDs             []string `json:"viewerIDs,omitempty"`
	TemplateID            *string  `json:"templateID,omitempty"`
	AssessmentResponseIDs []string `json:"assessmentResponseIDs,omitempty"`
}

// CreateAssessmentResponseInput is used for create AssessmentResponse object.
// Input was generated by ent.
type CreateAssessmentResponseInput struct {
	// the email address of the recipient
	Email string `json:"email"`
	// when the assessment response is due
	DueDate      *time.Time `json:"dueDate,omitempty"`
	OwnerID      *string    `json:"ownerID,omitempty"`
	AssessmentID string     `json:"assessmentID"`
	DocumentID   *string    `json:"documentID,omitempty"`
}

// CreateAssetInput is used for create Asset object.
// Input was generated by ent.
type CreateAssetInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the type of the asset, e.g. technology, domain, device, etc
	AssetType *enums.AssetType `json:"assetType,omitempty"`
	// the name of the asset, e.g. matts computer, office router, IP address, etc
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	// unique identifier like domain, device id, etc
	Identifier *string `json:"identifier,omitempty"`
	// the website of the asset, if applicable
	Website *string `json:"website,omitempty"`
	// the CPE (Common Platform Enumeration) of the asset, if applicable
	Cpe *string `json:"cpe,omitempty"`
	// the categories of the asset, e.g. web server, database, etc
	Categories      []string `json:"categories,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string `json:"editorIDs,omitempty"`
	ViewerIDs       []string `json:"viewerIDs,omitempty"`
	ScanIDs         []string `json:"scanIDs,omitempty"`
	EntityIDs       []string `json:"entityIDs,omitempty"`
	ControlIDs      []string `json:"controlIDs,omitempty"`
}

// CreateContactInput is used for create Contact object.
// Input was generated by ent.
type CreateContactInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the full name of the contact
	FullName *string `json:"fullName,omitempty"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status    *enums.UserStatus `json:"status,omitempty"`
	OwnerID   *string           `json:"ownerID,omitempty"`
	EntityIDs []string          `json:"entityIDs,omitempty"`
	FileIDs   []string          `json:"fileIDs,omitempty"`
}

// CreateControlImplementationInput is used for create ControlImplementation object.
// Input was generated by ent.
type CreateControlImplementationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// status of the %s, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details         *string  `json:"details,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string `json:"editorIDs,omitempty"`
	ViewerIDs       []string `json:"viewerIDs,omitempty"`
	ControlIDs      []string `json:"controlIDs,omitempty"`
	SubcontrolIDs   []string `json:"subcontrolIDs,omitempty"`
	TaskIDs         []string `json:"taskIDs,omitempty"`
}

// CreateControlInput is used for create Control object.
// Input was generated by ent.
type CreateControlInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// human readable title of the control for quick identification
	Title *string `json:"title,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// additional names (ref_codes) for the control
	Aliases []string `json:"aliases,omitempty"`
	// internal reference id of the control, can be used for internal tracking
	ReferenceID *string `json:"referenceID,omitempty"`
	// external auditor id of the control, can be used to map to external audit partner mappings
	AuditorReferenceID *string `json:"auditorReferenceID,omitempty"`
	// status of the control
	Status *enums.ControlStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// the reference framework for the control if it came from a standard, empty if not associated with a standard
	ReferenceFramework *string `json:"referenceFramework,omitempty"`
	// the reference framework revision for the control if it came from a standard, empty if not associated with a standard, allows for pulling in updates when the standard is updated
	ReferenceFrameworkRevision *string `json:"referenceFrameworkRevision,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the control
	ControlKindName *string `json:"controlKindName,omitempty"`
	// the unique reference code for the control
	RefCode                  string   `json:"refCode"`
	EvidenceIDs              []string `json:"evidenceIDs,omitempty"`
	ControlObjectiveIDs      []string `json:"controlObjectiveIDs,omitempty"`
	TaskIDs                  []string `json:"taskIDs,omitempty"`
	NarrativeIDs             []string `json:"narrativeIDs,omitempty"`
	RiskIDs                  []string `json:"riskIDs,omitempty"`
	ActionPlanIDs            []string `json:"actionPlanIDs,omitempty"`
	ProcedureIDs             []string `json:"procedureIDs,omitempty"`
	InternalPolicyIDs        []string `json:"internalPolicyIDs,omitempty"`
	CommentIDs               []string `json:"commentIDs,omitempty"`
	ControlOwnerID           *string  `json:"controlOwnerID,omitempty"`
	DelegateID               *string  `json:"delegateID,omitempty"`
	ResponsiblePartyID       *string  `json:"responsiblePartyID,omitempty"`
	OwnerID                  *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs          []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs                []string `json:"editorIDs,omitempty"`
	ControlKindID            *string  `json:"controlKindID,omitempty"`
	StandardID               *string  `json:"standardID,omitempty"`
	ProgramIDs               []string `json:"programIDs,omitempty"`
	AssetIDs                 []string `json:"assetIDs,omitempty"`
	ScanIDs                  []string `json:"scanIDs,omitempty"`
	FindingIDs               []string `json:"findingIDs,omitempty"`
	ControlImplementationIDs []string `json:"controlImplementationIDs,omitempty"`
	SubcontrolIDs            []string `json:"subcontrolIDs,omitempty"`
	ScheduledJobIDs          []string `json:"scheduledJobIDs,omitempty"`
	WorkflowObjectRefIDs     []string `json:"workflowObjectRefIDs,omitempty"`
}

// CreateControlObjectiveInput is used for create ControlObjective object.
// Input was generated by ent.
type CreateControlObjectiveInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *enums.ObjectiveStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory       *string  `json:"subcategory,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string `json:"editorIDs,omitempty"`
	ViewerIDs         []string `json:"viewerIDs,omitempty"`
	ProgramIDs        []string `json:"programIDs,omitempty"`
	EvidenceIDs       []string `json:"evidenceIDs,omitempty"`
	ControlIDs        []string `json:"controlIDs,omitempty"`
	SubcontrolIDs     []string `json:"subcontrolIDs,omitempty"`
	InternalPolicyIDs []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs      []string `json:"procedureIDs,omitempty"`
	RiskIDs           []string `json:"riskIDs,omitempty"`
	NarrativeIDs      []string `json:"narrativeIDs,omitempty"`
	TaskIDs           []string `json:"taskIDs,omitempty"`
}

type CreateControlWithSubcontrolsInput struct {
	Control     *CreateControlInput      `json:"control,omitempty"`
	Subcontrols []*CreateSubcontrolInput `json:"subcontrols,omitempty"`
}

// CreateCustomDomainInput is used for create CustomDomain object.
// Input was generated by ent.
type CreateCustomDomainInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the custom domain
	CnameRecord       string  `json:"cnameRecord"`
	OwnerID           *string `json:"ownerID,omitempty"`
	MappableDomainID  string  `json:"mappableDomainID"`
	DNSVerificationID *string `json:"dnsVerificationID,omitempty"`
}

// CreateCustomTypeEnumInput is used for create CustomTypeEnum object.
// Input was generated by ent.
type CreateCustomTypeEnumInput struct {
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of object the type applies to, for example task
	ObjectType string `json:"objectType"`
	// the field on the object the type applies to, for example kind or category
	Field *string `json:"field,omitempty"`
	// The name of the enum value, for example evidence request
	Name string `json:"name"`
	// The description of the custom type
	Description *string `json:"description,omitempty"`
	// The color of the tag definition in hex format
	Color *string `json:"color,omitempty"`
	// The icon of the custom type enum in SVG format
	Icon              *string  `json:"icon,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	TaskIDs           []string `json:"taskIDs,omitempty"`
	ControlIDs        []string `json:"controlIDs,omitempty"`
	SubcontrolIDs     []string `json:"subcontrolIDs,omitempty"`
	RiskIDs           []string `json:"riskIDs,omitempty"`
	RiskCategoryIDs   []string `json:"riskCategoryIDs,omitempty"`
	InternalPolicyIDs []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs      []string `json:"procedureIDs,omitempty"`
	ActionPlanIDs     []string `json:"actionPlanIDs,omitempty"`
	ProgramIDs        []string `json:"programIDs,omitempty"`
}

// CreateDNSVerificationInput is used for create DNSVerification object.
// Input was generated by ent.
type CreateDNSVerificationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The ID of the custom domain in cloudflare
	CloudflareHostnameID string `json:"cloudflareHostnameID"`
	// the name of the dns txt record
	DNSTxtRecord string `json:"dnsTxtRecord"`
	// the expected value of the dns txt record
	DNSTxtValue string `json:"dnsTxtValue"`
	// Status of the domain verification
	DNSVerificationStatus *enums.DNSVerificationStatus `json:"dnsVerificationStatus,omitempty"`
	// Reason of the dns verification status, for giving the user diagnostic info
	DNSVerificationStatusReason *string `json:"dnsVerificationStatusReason,omitempty"`
	// Path under /.well-known/acme-challenge/ to serve the ACME challenge
	AcmeChallengePath *string `json:"acmeChallengePath,omitempty"`
	// the expected value of the acme challenge record
	ExpectedAcmeChallengeValue *string `json:"expectedAcmeChallengeValue,omitempty"`
	// Status of the ACME challenge validation
	AcmeChallengeStatus *enums.SSLVerificationStatus `json:"acmeChallengeStatus,omitempty"`
	OwnerID             *string                      `json:"ownerID,omitempty"`
	CustomDomainIDs     []string                     `json:"customDomainIDs,omitempty"`
}

// CreateDirectoryAccountInput is used for create DirectoryAccount object.
// Input was generated by ent.
type CreateDirectoryAccountInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// stable identifier from the directory system
	ExternalID string `json:"externalID"`
	// optional secondary identifier such as Azure immutable ID
	SecondaryKey *string `json:"secondaryKey,omitempty"`
	// lower-cased primary email address, if present
	CanonicalEmail *string `json:"canonicalEmail,omitempty"`
	// provider supplied display name
	DisplayName *string `json:"displayName,omitempty"`
	// first name reported by the provider
	GivenName *string `json:"givenName,omitempty"`
	// last name reported by the provider
	FamilyName *string `json:"familyName,omitempty"`
	// title captured at sync time
	JobTitle *string `json:"jobTitle,omitempty"`
	// department captured at sync time
	Department *string `json:"department,omitempty"`
	// organizational unit or OU path the account lives under
	OrganizationUnit *string `json:"organizationUnit,omitempty"`
	// type of principal represented in the directory
	AccountType *enums.DirectoryAccountType `json:"accountType,omitempty"`
	// lifecycle status returned by the directory
	Status *enums.DirectoryAccountStatus `json:"status,omitempty"`
	// multi-factor authentication state reported by the directory
	MfaState *enums.DirectoryAccountMFAState `json:"mfaState,omitempty"`
	// last IP address observed by the provider, if any
	LastSeenIP *string `json:"lastSeenIP,omitempty"`
	// timestamp of the most recent login reported by the provider
	LastLoginAt *time.Time `json:"lastLoginAt,omitempty"`
	// time when this snapshot was recorded
	ObservedAt *time.Time `json:"observedAt,omitempty"`
	// hash of the normalized profile payload for change detection
	ProfileHash *string `json:"profileHash,omitempty"`
	// flattened attribute bag used for filtering/diffing
	Profile map[string]any `json:"profile,omitempty"`
	// cursor or ETag supplied by the source system for auditing
	SourceVersion        *string  `json:"sourceVersion,omitempty"`
	OwnerID              *string  `json:"ownerID,omitempty"`
	IntegrationID        string   `json:"integrationID"`
	DirectorySyncRunID   string   `json:"directorySyncRunID"`
	GroupIDs             []string `json:"groupIDs,omitempty"`
	WorkflowObjectRefIDs []string `json:"workflowObjectRefIDs,omitempty"`
}

// CreateDirectoryGroupInput is used for create DirectoryGroup object.
// Input was generated by ent.
type CreateDirectoryGroupInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// stable identifier from the directory system
	ExternalID string `json:"externalID"`
	// primary group email address, when applicable
	Email *string `json:"email,omitempty"`
	// directory supplied display name
	DisplayName *string `json:"displayName,omitempty"`
	// free-form description captured at sync time
	Description *string `json:"description,omitempty"`
	// provider classification such as security, distribution, or dynamic
	Classification *enums.DirectoryGroupClassification `json:"classification,omitempty"`
	// lifecycle status reported by the directory
	Status *enums.DirectoryGroupStatus `json:"status,omitempty"`
	// true when directory settings allow sharing outside the tenant
	ExternalSharingAllowed *bool `json:"externalSharingAllowed,omitempty"`
	// member count reported by the directory
	MemberCount *int64 `json:"memberCount,omitempty"`
	// time when this snapshot was recorded
	ObservedAt *time.Time `json:"observedAt,omitempty"`
	// hash of the normalized payload for diffing
	ProfileHash *string `json:"profileHash,omitempty"`
	// flattened attribute bag used for filtering/diffing
	Profile map[string]any `json:"profile,omitempty"`
	// cursor or ETag supplied by the source system for auditing
	SourceVersion        *string  `json:"sourceVersion,omitempty"`
	OwnerID              *string  `json:"ownerID,omitempty"`
	IntegrationID        string   `json:"integrationID"`
	DirectorySyncRunID   string   `json:"directorySyncRunID"`
	WorkflowObjectRefIDs []string `json:"workflowObjectRefIDs,omitempty"`
}

// CreateDirectoryMembershipInput is used for create DirectoryMembership object.
// Input was generated by ent.
type CreateDirectoryMembershipInput struct {
	// membership role reported by the provider
	Role *enums.DirectoryMembershipRole `json:"role,omitempty"`
	// mechanism used to populate the membership (api, scim, csv, etc)
	Source *string `json:"source,omitempty"`
	// first time the membership was detected
	FirstSeenAt *time.Time `json:"firstSeenAt,omitempty"`
	// most recent time the membership was detected
	LastSeenAt *time.Time `json:"lastSeenAt,omitempty"`
	// time when this record was created
	ObservedAt *time.Time `json:"observedAt,omitempty"`
	// sync run identifier that most recently confirmed this membership
	LastConfirmedRunID *string `json:"lastConfirmedRunID,omitempty"`
	// raw metadata associated with this membership from the provider
	Metadata             map[string]any `json:"metadata,omitempty"`
	OwnerID              *string        `json:"ownerID,omitempty"`
	IntegrationID        string         `json:"integrationID"`
	DirectorySyncRunID   string         `json:"directorySyncRunID"`
	DirectoryAccountID   string         `json:"directoryAccountID"`
	DirectoryGroupID     string         `json:"directoryGroupID"`
	EventIDs             []string       `json:"eventIDs,omitempty"`
	WorkflowObjectRefIDs []string       `json:"workflowObjectRefIDs,omitempty"`
}

// CreateDirectorySyncRunInput is used for create DirectorySyncRun object.
// Input was generated by ent.
type CreateDirectorySyncRunInput struct {
	// current state of the sync run
	Status *enums.DirectorySyncRunStatus `json:"status,omitempty"`
	// time the sync started
	StartedAt *time.Time `json:"startedAt,omitempty"`
	// time the sync finished
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// cursor or checkpoint returned by the provider for the next run
	SourceCursor *string `json:"sourceCursor,omitempty"`
	// total records processed during this run
	FullCount *int64 `json:"fullCount,omitempty"`
	// number of records that changed compared to the prior run
	DeltaCount *int64 `json:"deltaCount,omitempty"`
	// serialized error information when the run failed
	Error *string `json:"error,omitempty"`
	// object storage file identifier for the manifest captured during the run
	RawManifestFileID *string `json:"rawManifestFileID,omitempty"`
	// additional provider-specific stats for the run
	Stats               map[string]any `json:"stats,omitempty"`
	OwnerID             *string        `json:"ownerID,omitempty"`
	IntegrationID       string         `json:"integrationID"`
	DirectoryAccountIDs []string       `json:"directoryAccountIDs,omitempty"`
	DirectoryGroupIDs   []string       `json:"directoryGroupIDs,omitempty"`
}

// CreateDocumentDataInput is used for create DocumentData object.
// Input was generated by ent.
type CreateDocumentDataInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the json data of the document
	Data       map[string]any `json:"data"`
	OwnerID    *string        `json:"ownerID,omitempty"`
	TemplateID *string        `json:"templateID,omitempty"`
	EntityIDs  []string       `json:"entityIDs,omitempty"`
	FileIDs    []string       `json:"fileIDs,omitempty"`
}

// CreateEntityInput is used for create Entity object.
// Input was generated by ent.
type CreateEntityInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// status of the entity
	Status          *string          `json:"status,omitempty"`
	OwnerID         *string          `json:"ownerID,omitempty"`
	BlockedGroupIDs []string         `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string         `json:"editorIDs,omitempty"`
	ViewerIDs       []string         `json:"viewerIDs,omitempty"`
	ContactIDs      []string         `json:"contactIDs,omitempty"`
	DocumentIDs     []string         `json:"documentIDs,omitempty"`
	NoteIDs         []string         `json:"noteIDs,omitempty"`
	FileIDs         []string         `json:"fileIDs,omitempty"`
	AssetIDs        []string         `json:"assetIDs,omitempty"`
	ScanIDs         []string         `json:"scanIDs,omitempty"`
	EntityTypeID    *string          `json:"entityTypeID,omitempty"`
	Note            *CreateNoteInput `json:"note,omitempty"`
}

// CreateEntityTypeInput is used for create EntityType object.
// Input was generated by ent.
type CreateEntityTypeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the entity
	Name      string   `json:"name"`
	OwnerID   *string  `json:"ownerID,omitempty"`
	EntityIDs []string `json:"entityIDs,omitempty"`
}

// CreateEventInput is used for create Event object.
// Input was generated by ent.
type CreateEventInput struct {
	// tags associated with the object
	Tags                   []string       `json:"tags,omitempty"`
	EventID                *string        `json:"eventID,omitempty"`
	CorrelationID          *string        `json:"correlationID,omitempty"`
	EventType              string         `json:"eventType"`
	Metadata               map[string]any `json:"metadata,omitempty"`
	UserIDs                []string       `json:"userIDs,omitempty"`
	GroupIDs               []string       `json:"groupIDs,omitempty"`
	IntegrationIDs         []string       `json:"integrationIDs,omitempty"`
	OrganizationIDs        []string       `json:"organizationIDs,omitempty"`
	InviteIDs              []string       `json:"inviteIDs,omitempty"`
	PersonalAccessTokenIDs []string       `json:"personalAccessTokenIDs,omitempty"`
	SecretIDs              []string       `json:"secretIDs,omitempty"`
	SubscriberIDs          []string       `json:"subscriberIDs,omitempty"`
	FileIDs                []string       `json:"fileIDs,omitempty"`
	OrgSubscriptionIDs     []string       `json:"orgSubscriptionIDs,omitempty"`
}

// CreateEvidenceInput is used for create Evidence object.
// Input was generated by ent.
type CreateEvidenceInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate *time.Time `json:"creationDate,omitempty"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL *string `json:"url,omitempty"`
	// the status of the evidence, ready, approved, needs renewal, missing artifact, rejected
	Status                   *enums.EvidenceStatus `json:"status,omitempty"`
	OwnerID                  *string               `json:"ownerID,omitempty"`
	ControlIDs               []string              `json:"controlIDs,omitempty"`
	SubcontrolIDs            []string              `json:"subcontrolIDs,omitempty"`
	ControlObjectiveIDs      []string              `json:"controlObjectiveIDs,omitempty"`
	ControlImplementationIDs []string              `json:"controlImplementationIDs,omitempty"`
	FileIDs                  []string              `json:"fileIDs,omitempty"`
	ProgramIDs               []string              `json:"programIDs,omitempty"`
	TaskIDs                  []string              `json:"taskIDs,omitempty"`
	CommentIDs               []string              `json:"commentIDs,omitempty"`
}

// CreateExportInput is used for create Export object.
// Input was generated by ent.
type CreateExportInput struct {
	// the type of export, e.g., control, policy, etc.
	ExportType enums.ExportType `json:"exportType"`
	// the format of export, e.g., csv and others
	Format *enums.ExportFormat `json:"format,omitempty"`
	// the specific fields to include in the export (defaults to only the id if not provided)
	Fields []string `json:"fields,omitempty"`
	// the specific filters to run against the exported data. This should be a well formatted graphql query
	Filters  *string  `json:"filters,omitempty"`
	OwnerID  *string  `json:"ownerID,omitempty"`
	EventIDs []string `json:"eventIDs,omitempty"`
	FileIDs  []string `json:"fileIDs,omitempty"`
}

// CreateFileInput is used for create File object.
// Input was generated by ent.
type CreateFileInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath *string `json:"storagePath,omitempty"`
	// additional metadata about the file
	Metadata map[string]any `json:"metadata,omitempty"`
	// the region the file is stored in, if applicable
	StorageRegion *string `json:"storageRegion,omitempty"`
	// the storage provider the file is stored in, if applicable
	StorageProvider        *string    `json:"storageProvider,omitempty"`
	LastAccessedAt         *time.Time `json:"lastAccessedAt,omitempty"`
	OrganizationIDs        []string   `json:"organizationIDs,omitempty"`
	GroupIDs               []string   `json:"groupIDs,omitempty"`
	ContactIDs             []string   `json:"contactIDs,omitempty"`
	EntityIDs              []string   `json:"entityIDs,omitempty"`
	OrganizationSettingIDs []string   `json:"organizationSettingIDs,omitempty"`
	TemplateIDs            []string   `json:"templateIDs,omitempty"`
	DocumentIDs            []string   `json:"documentIDs,omitempty"`
	ProgramIDs             []string   `json:"programIDs,omitempty"`
	EvidenceIDs            []string   `json:"evidenceIDs,omitempty"`
	EventIDs               []string   `json:"eventIDs,omitempty"`
	TrustCenterSettingIDs  []string   `json:"trustCenterSettingIDs,omitempty"`
	IntegrationIDs         []string   `json:"integrationIDs,omitempty"`
	SecretIDs              []string   `json:"secretIDs,omitempty"`
	TrustcenterEntityIDs   []string   `json:"trustcenterEntityIDs,omitempty"`
}

// CreateFindingControlInput is used for create FindingControl object.
// Input was generated by ent.
type CreateFindingControlInput struct {
	// external identifier for the standard provided by the source system such as iso or hipaa
	ExternalStandard *string `json:"externalStandard,omitempty"`
	// version for the external standard provided by the source system
	ExternalStandardVersion *string `json:"externalStandardVersion,omitempty"`
	// control identifier provided by the source system such as A.5.10
	ExternalControlID *string `json:"externalControlID,omitempty"`
	// the integration source that provided the mapping
	Source *string `json:"source,omitempty"`
	// additional metadata about the control mapping from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// timestamp when the mapping was first observed
	DiscoveredAt *models.DateTime `json:"discoveredAt,omitempty"`
	FindingID    string           `json:"findingID"`
	ControlID    string           `json:"controlID"`
	StandardID   *string          `json:"standardID,omitempty"`
}

// CreateFindingInput is used for create Finding object.
// Input was generated by ent.
type CreateFindingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the finding
	ExternalID *string `json:"externalID,omitempty"`
	// the owner of the finding
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// system that produced the finding, e.g. gcp_scc
	Source *string `json:"source,omitempty"`
	// resource identifier provided by the source system
	ResourceName *string `json:"resourceName,omitempty"`
	// display name for the finding when provided by the source
	DisplayName *string `json:"displayName,omitempty"`
	// state reported by the source system, such as ACTIVE or INACTIVE
	State *string `json:"state,omitempty"`
	// primary category of the finding
	Category *string `json:"category,omitempty"`
	// normalized categories for the finding
	Categories []string `json:"categories,omitempty"`
	// classification provided by the source, e.g. MISCONFIGURATION
	FindingClass *string `json:"findingClass,omitempty"`
	// severity label for the finding
	Severity *string `json:"severity,omitempty"`
	// numeric severity score for the finding if provided
	NumericSeverity *float64 `json:"numericSeverity,omitempty"`
	// aggregated score such as CVSS for the finding
	Score *float64 `json:"score,omitempty"`
	// impact score or rating for the finding
	Impact *float64 `json:"impact,omitempty"`
	// exploitability score or rating for the finding
	Exploitability *float64 `json:"exploitability,omitempty"`
	// priority assigned to the finding
	Priority *string `json:"priority,omitempty"`
	// indicates if the finding is still open
	Open *bool `json:"open,omitempty"`
	// true when the finding blocks production changes
	BlocksProduction *bool `json:"blocksProduction,omitempty"`
	// true when the finding affects production systems
	Production *bool `json:"production,omitempty"`
	// true when the finding is publicly disclosed
	Public *bool `json:"public,omitempty"`
	// true when the finding has been validated by the security team
	Validated *bool `json:"validated,omitempty"`
	// identifier for the assessment that generated the finding
	AssessmentID *string `json:"assessmentID,omitempty"`
	// long form description of the finding
	Description *string `json:"description,omitempty"`
	// short recommendation text from the source system (deprecated upstream)
	Recommendation *string `json:"recommendation,omitempty"`
	// markdown formatted remediation guidance for the finding
	RecommendedActions *string `json:"recommendedActions,omitempty"`
	// reference links for the finding
	References []string `json:"references,omitempty"`
	// steps required to reproduce the finding
	StepsToReproduce []string `json:"stepsToReproduce,omitempty"`
	// targets impacted by the finding such as projects or applications
	Targets []string `json:"targets,omitempty"`
	// structured details about the impacted targets
	TargetDetails map[string]any `json:"targetDetails,omitempty"`
	// attack vector string such as a CVSS vector
	Vector *string `json:"vector,omitempty"`
	// remediation service level agreement in days
	RemediationSLA *int64 `json:"remediationSLA,omitempty"`
	// lifecycle status of the finding
	Status *string `json:"status,omitempty"`
	// timestamp when the finding was last observed by the source
	EventTime *models.DateTime `json:"eventTime,omitempty"`
	// timestamp when the finding was first reported by the source
	ReportedAt *models.DateTime `json:"reportedAt,omitempty"`
	// timestamp when the source last updated the finding
	SourceUpdatedAt *models.DateTime `json:"sourceUpdatedAt,omitempty"`
	// link to the finding in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the finding from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload           map[string]any `json:"rawPayload,omitempty"`
	OwnerID              *string        `json:"ownerID,omitempty"`
	BlockedGroupIDs      []string       `json:"blockedGroupIDs,omitempty"`
	EditorIDs            []string       `json:"editorIDs,omitempty"`
	ViewerIDs            []string       `json:"viewerIDs,omitempty"`
	IntegrationIDs       []string       `json:"integrationIDs,omitempty"`
	VulnerabilityIDs     []string       `json:"vulnerabilityIDs,omitempty"`
	ActionPlanIDs        []string       `json:"actionPlanIDs,omitempty"`
	ControlIDs           []string       `json:"controlIDs,omitempty"`
	SubcontrolIDs        []string       `json:"subcontrolIDs,omitempty"`
	RiskIDs              []string       `json:"riskIDs,omitempty"`
	ProgramIDs           []string       `json:"programIDs,omitempty"`
	AssetIDs             []string       `json:"assetIDs,omitempty"`
	EntityIDs            []string       `json:"entityIDs,omitempty"`
	ScanIDs              []string       `json:"scanIDs,omitempty"`
	TaskIDs              []string       `json:"taskIDs,omitempty"`
	RemediationIDs       []string       `json:"remediationIDs,omitempty"`
	ReviewIDs            []string       `json:"reviewIDs,omitempty"`
	CommentIDs           []string       `json:"commentIDs,omitempty"`
	FileIDs              []string       `json:"fileIDs,omitempty"`
	WorkflowObjectRefIDs []string       `json:"workflowObjectRefIDs,omitempty"`
}

type CreateFullProgramInput struct {
	Program          *CreateProgramInput                  `json:"program"`
	Controls         []*CreateControlWithSubcontrolsInput `json:"controls,omitempty"`
	Risks            []*CreateRiskInput                   `json:"risks,omitempty"`
	InternalPolicies []*CreateInternalPolicyInput         `json:"internalPolicies,omitempty"`
	Procedures       []*CreateProcedureInput              `json:"procedures,omitempty"`
	Members          []*CreateMemberWithProgramInput      `json:"members,omitempty"`
	StandardID       *string                              `json:"standardID,omitempty"`
}

// CreateGroupInput is used for create Group object.
// Input was generated by ent.
type CreateGroupInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// the SCIM external ID for the group
	ScimExternalID *string `json:"scimExternalID,omitempty"`
	// the SCIM displayname for the group
	ScimDisplayName *string `json:"scimDisplayName,omitempty"`
	// whether the SCIM group is marked as active
	ScimActive *bool `json:"scimActive,omitempty"`
	// the SCIM group mailing list email
	ScimGroupMailing                     *string                  `json:"scimGroupMailing,omitempty"`
	OwnerID                              *string                  `json:"ownerID,omitempty"`
	ProgramEditorIDs                     []string                 `json:"programEditorIDs,omitempty"`
	ProgramBlockedGroupIDs               []string                 `json:"programBlockedGroupIDs,omitempty"`
	ProgramViewerIDs                     []string                 `json:"programViewerIDs,omitempty"`
	RiskEditorIDs                        []string                 `json:"riskEditorIDs,omitempty"`
	RiskBlockedGroupIDs                  []string                 `json:"riskBlockedGroupIDs,omitempty"`
	RiskViewerIDs                        []string                 `json:"riskViewerIDs,omitempty"`
	ControlObjectiveEditorIDs            []string                 `json:"controlObjectiveEditorIDs,omitempty"`
	ControlObjectiveBlockedGroupIDs      []string                 `json:"controlObjectiveBlockedGroupIDs,omitempty"`
	ControlObjectiveViewerIDs            []string                 `json:"controlObjectiveViewerIDs,omitempty"`
	NarrativeEditorIDs                   []string                 `json:"narrativeEditorIDs,omitempty"`
	NarrativeBlockedGroupIDs             []string                 `json:"narrativeBlockedGroupIDs,omitempty"`
	NarrativeViewerIDs                   []string                 `json:"narrativeViewerIDs,omitempty"`
	ControlImplementationEditorIDs       []string                 `json:"controlImplementationEditorIDs,omitempty"`
	ControlImplementationBlockedGroupIDs []string                 `json:"controlImplementationBlockedGroupIDs,omitempty"`
	ControlImplementationViewerIDs       []string                 `json:"controlImplementationViewerIDs,omitempty"`
	ScanEditorIDs                        []string                 `json:"scanEditorIDs,omitempty"`
	ScanBlockedGroupIDs                  []string                 `json:"scanBlockedGroupIDs,omitempty"`
	ScanViewerIDs                        []string                 `json:"scanViewerIDs,omitempty"`
	EntityEditorIDs                      []string                 `json:"entityEditorIDs,omitempty"`
	EntityBlockedGroupIDs                []string                 `json:"entityBlockedGroupIDs,omitempty"`
	EntityViewerIDs                      []string                 `json:"entityViewerIDs,omitempty"`
	ProcedureEditorIDs                   []string                 `json:"procedureEditorIDs,omitempty"`
	ProcedureBlockedGroupIDs             []string                 `json:"procedureBlockedGroupIDs,omitempty"`
	InternalPolicyEditorIDs              []string                 `json:"internalPolicyEditorIDs,omitempty"`
	InternalPolicyBlockedGroupIDs        []string                 `json:"internalPolicyBlockedGroupIDs,omitempty"`
	ControlEditorIDs                     []string                 `json:"controlEditorIDs,omitempty"`
	ControlBlockedGroupIDs               []string                 `json:"controlBlockedGroupIDs,omitempty"`
	MappedControlEditorIDs               []string                 `json:"mappedControlEditorIDs,omitempty"`
	MappedControlBlockedGroupIDs         []string                 `json:"mappedControlBlockedGroupIDs,omitempty"`
	SettingID                            *string                  `json:"settingID,omitempty"`
	EventIDs                             []string                 `json:"eventIDs,omitempty"`
	IntegrationIDs                       []string                 `json:"integrationIDs,omitempty"`
	FileIDs                              []string                 `json:"fileIDs,omitempty"`
	TaskIDs                              []string                 `json:"taskIDs,omitempty"`
	CreateGroupSettings                  *CreateGroupSettingInput `json:"createGroupSettings,omitempty"`
}

// CreateGroupMembershipInput is used for create GroupMembership object.
// Input was generated by ent.
type CreateGroupMembershipInput struct {
	Role     *enums.Role `json:"role,omitempty"`
	GroupID  string      `json:"groupID"`
	UserID   string      `json:"userID"`
	EventIDs []string    `json:"eventIDs,omitempty"`
}

// CreateGroupSettingInput is used for create GroupSetting object.
// Input was generated by ent.
type CreateGroupSettingInput struct {
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool   `json:"syncToGithub,omitempty"`
	GroupID      *string `json:"groupID,omitempty"`
}

// CreateHushInput is used for create Hush object.
// Input was generated by ent.
type CreateHushInput struct {
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// the secret value
	SecretValue *string `json:"secretValue,omitempty"`
	// a credential set, typically where you have multiple tokens or keys that compose one credential such as when accessing s3 and using access key ID, secret key, etc.
	CredentialSet *models.CredentialSet `json:"credentialSet,omitempty"`
	// additional metadata about the credential
	Metadata   map[string]any `json:"metadata,omitempty"`
	LastUsedAt *time.Time     `json:"lastUsedAt,omitempty"`
	// when the token expires
	ExpiresAt      *time.Time `json:"expiresAt,omitempty"`
	OwnerID        *string    `json:"ownerID,omitempty"`
	IntegrationIDs []string   `json:"integrationIDs,omitempty"`
	FileIDs        []string   `json:"fileIDs,omitempty"`
	EventIDs       []string   `json:"eventIDs,omitempty"`
}

// CreateInternalPolicyInput is used for create InternalPolicy object.
// Input was generated by ent.
type CreateInternalPolicyInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// status of the policy, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the policy, e.g. compliance, operational, health and safety, etc.
	PolicyType *string `json:"policyType,omitempty"`
	// details of the policy
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the policy
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the policy should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the policy should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// auto-generated tag suggestions for the policy
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the policy
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the policy
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the policy
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the policy
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the policy
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the policy
	URL *string `json:"url,omitempty"`
	// the kind of the internal_policy
	InternalPolicyKindName   *string  `json:"internalPolicyKindName,omitempty"`
	OwnerID                  *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs          []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs                []string `json:"editorIDs,omitempty"`
	ApproverID               *string  `json:"approverID,omitempty"`
	DelegateID               *string  `json:"delegateID,omitempty"`
	InternalPolicyKindID     *string  `json:"internalPolicyKindID,omitempty"`
	ControlObjectiveIDs      []string `json:"controlObjectiveIDs,omitempty"`
	ControlImplementationIDs []string `json:"controlImplementationIDs,omitempty"`
	ControlIDs               []string `json:"controlIDs,omitempty"`
	SubcontrolIDs            []string `json:"subcontrolIDs,omitempty"`
	ProcedureIDs             []string `json:"procedureIDs,omitempty"`
	NarrativeIDs             []string `json:"narrativeIDs,omitempty"`
	TaskIDs                  []string `json:"taskIDs,omitempty"`
	RiskIDs                  []string `json:"riskIDs,omitempty"`
	ProgramIDs               []string `json:"programIDs,omitempty"`
	FileID                   *string  `json:"fileID,omitempty"`
	CommentIDs               []string `json:"commentIDs,omitempty"`
	WorkflowObjectRefIDs     []string `json:"workflowObjectRefIDs,omitempty"`
}

// CreateInviteInput is used for create Invite object.
// Input was generated by ent.
type CreateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts *int64 `json:"sendAttempts,omitempty"`
	// the user who initiated the invitation
	RequestorID *string `json:"requestorID,omitempty"`
	// indicates if this invitation is for transferring organization ownership - when accepted, current owner becomes admin and invitee becomes owner
	OwnershipTransfer *bool    `json:"ownershipTransfer,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	EventIDs          []string `json:"eventIDs,omitempty"`
	GroupIDs          []string `json:"groupIDs,omitempty"`
}

// CreateJobResultInput is used for create JobResult object.
// Input was generated by ent.
type CreateJobResultInput struct {
	// the status of this job. did it fail? did it succeed?
	Status enums.JobExecutionStatus `json:"status"`
	// the exit code from the script that was executed
	ExitCode int64 `json:"exitCode"`
	// The time the job finished it's execution. This is different from the db insertion time
	FinishedAt *time.Time `json:"finishedAt,omitempty"`
	// The time the job started it's execution. This is different from the db insertion time
	StartedAt *time.Time `json:"startedAt,omitempty"`
	// the log output from the job
	Log            *string `json:"log,omitempty"`
	OwnerID        *string `json:"ownerID,omitempty"`
	ScheduledJobID string  `json:"scheduledJobID"`
	FileID         string  `json:"fileID"`
}

// CreateJobRunnerInput is used for create JobRunner object.
// Input was generated by ent.
type CreateJobRunnerInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the runner
	Name string `json:"name"`
	// the IP address of this runner
	IPAddress *string `json:"ipAddress,omitempty"`
	// the last time this runner was seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the version of the runner
	Version *string `json:"version,omitempty"`
	// the operating system of the runner
	Os                *string  `json:"os,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	JobRunnerTokenIDs []string `json:"jobRunnerTokenIDs,omitempty"`
}

// CreateJobRunnerRegistrationTokenInput is used for create JobRunnerRegistrationToken object.
// Input was generated by ent.
type CreateJobRunnerRegistrationTokenInput struct {
	// tags associated with the object
	Tags        []string   `json:"tags,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	OwnerID     *string    `json:"ownerID,omitempty"`
	JobRunnerID *string    `json:"jobRunnerID,omitempty"`
}

// CreateJobRunnerTokenInput is used for create JobRunnerToken object.
// Input was generated by ent.
type CreateJobRunnerTokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// when the token expires
	ExpiresAt  *time.Time `json:"expiresAt,omitempty"`
	LastUsedAt *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt    *time.Time `json:"revokedAt,omitempty"`
	OwnerID      *string    `json:"ownerID,omitempty"`
	JobRunnerIDs []string   `json:"jobRunnerIDs,omitempty"`
}

// CreateJobTemplateInput is used for create JobTemplate object.
// Input was generated by ent.
type CreateJobTemplateInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the title of the job
	Title string `json:"title"`
	// the short description of the job and what it does
	Description *string `json:"description,omitempty"`
	// the platform to use to execute this job, e.g. golang, typescript, python, etc.
	Platform enums.JobPlatformType `json:"platform"`
	// the url from where to download the script from
	DownloadURL string `json:"downloadURL"`
	// the json configuration to run this job, which could be used to template a job, e.g. { "account_name": "my-account" }
	Configuration models.JobConfiguration `json:"configuration,omitempty"`
	// cron schedule to run the job in cron 6-field syntax, e.g. 0 0 0 * * *
	Cron    *string `json:"cron,omitempty"`
	OwnerID *string `json:"ownerID,omitempty"`
}

// CreateMappableDomainInput is used for create MappableDomain object.
// Input was generated by ent.
type CreateMappableDomainInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// Name of the mappable domain
	Name string `json:"name"`
	// DNS Zone ID of the mappable domain.
	ZoneID          string   `json:"zoneID"`
	CustomDomainIDs []string `json:"customDomainIDs,omitempty"`
}

// CreateMappedControlInput is used for create MappedControl object.
// Input was generated by ent.
type CreateMappedControlInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType *enums.MappingType `json:"mappingType,omitempty"`
	// description of how the two controls are related
	Relation *string `json:"relation,omitempty"`
	// percentage (0-100) of confidence in the mapping
	Confidence *int64 `json:"confidence,omitempty"`
	// source of the mapping, e.g. manual, suggested, etc.
	Source            *enums.MappingSource `json:"source,omitempty"`
	OwnerID           *string              `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string             `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string             `json:"editorIDs,omitempty"`
	FromControlIDs    []string             `json:"fromControlIDs,omitempty"`
	ToControlIDs      []string             `json:"toControlIDs,omitempty"`
	FromSubcontrolIDs []string             `json:"fromSubcontrolIDs,omitempty"`
	ToSubcontrolIDs   []string             `json:"toSubcontrolIDs,omitempty"`
	// the ref code(s) of the control(s) prefixed with the standard for the from side of the mapping, e.g. SOC2::CC1.1
	FromControlRefCodes []string `json:"fromControlRefCodes,omitempty"`
	// the ref code(s) of the subcontrol(s) prefixed with the standard for the from side of the mapping, e.g. SOC2::CC1.1-POF1
	FromSubcontrolRefCodes []string `json:"fromSubcontrolRefCodes,omitempty"`
	// the ref code(s) of the control(s) prefixed with the standard for the to side of the mapping, e.g. SOC2::CC1.1
	ToControlRefCodes []string `json:"toControlRefCodes,omitempty"`
	// the ref code(s) of the subcontrol(s) prefixed with the standard for the to side of the mapping, e.g. SOC2::CC1.1-POF1
	ToSubcontrolRefCodes []string `json:"toSubcontrolRefCodes,omitempty"`
}

type CreateMemberWithProgramInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

// CreateNarrativeInput is used for create Narrative object.
// Input was generated by ent.
type CreateNarrativeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details           *string  `json:"details,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string `json:"editorIDs,omitempty"`
	ViewerIDs         []string `json:"viewerIDs,omitempty"`
	SatisfyIDs        []string `json:"satisfyIDs,omitempty"`
	ProgramIDs        []string `json:"programIDs,omitempty"`
	InternalPolicyIDs []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs      []string `json:"procedureIDs,omitempty"`
}

// CreateNoteInput is used for create Note object.
// Input was generated by ent.
type CreateNoteInput struct {
	// the text of the note
	Text             string   `json:"text"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	TaskID           *string  `json:"taskID,omitempty"`
	ControlID        *string  `json:"controlID,omitempty"`
	SubcontrolID     *string  `json:"subcontrolID,omitempty"`
	ProcedureID      *string  `json:"procedureID,omitempty"`
	RiskID           *string  `json:"riskID,omitempty"`
	InternalPolicyID *string  `json:"internalPolicyID,omitempty"`
	EvidenceID       *string  `json:"evidenceID,omitempty"`
	TrustCenterID    *string  `json:"trustCenterID,omitempty"`
	FileIDs          []string `json:"fileIDs,omitempty"`
}

// CreateNotificationInput is used for create Notification object.
// Input was generated by ent.
type CreateNotificationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the type of notification - organization or user
	NotificationType enums.NotificationType `json:"notificationType"`
	// the event type this notification is related to (e.g., task.created, control.updated)
	ObjectType string `json:"objectType"`
	// the title of the notification
	Title string `json:"title"`
	// the body text of the notification
	Body string `json:"body"`
	// structured payload containing IDs, links, and other notification data
	Data map[string]any `json:"data,omitempty"`
	// the time the notification was read
	ReadAt *models.DateTime `json:"readAt,omitempty"`
	// the channels this notification should be sent to (IN_APP, SLACK, EMAIL)
	Channels []string `json:"channels,omitempty"`
	// the topic of the notification
	Topic   *string `json:"topic,omitempty"`
	OwnerID *string `json:"ownerID,omitempty"`
}

// CreateOnboardingInput is used for create Onboarding object.
// Input was generated by ent.
type CreateOnboardingInput struct {
	// name of the company
	CompanyName string `json:"companyName"`
	// domains associated with the company
	Domains []string `json:"domains,omitempty"`
	// details given about the company during the onboarding process, including things such as company size, sector, etc
	CompanyDetails map[string]any `json:"companyDetails,omitempty"`
	// details given about the user during the onboarding process, including things such as name, job title, department, etc
	UserDetails map[string]any `json:"userDetails,omitempty"`
	// details given about the compliance requirements during the onboarding process, such as coming with existing policies, controls, risk assessments, etc
	Compliance     map[string]any `json:"compliance,omitempty"`
	OrganizationID *string        `json:"organizationID,omitempty"`
}

// CreateOrgMembershipInput is used for create OrgMembership object.
// Input was generated by ent.
type CreateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	OrganizationID string      `json:"organizationID"`
	UserID         string      `json:"userID"`
	EventIDs       []string    `json:"eventIDs,omitempty"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb                       *bool                           `json:"dedicatedDb,omitempty"`
	ControlCreatorIDs                 []string                        `json:"controlCreatorIDs,omitempty"`
	ControlImplementationCreatorIDs   []string                        `json:"controlImplementationCreatorIDs,omitempty"`
	ControlObjectiveCreatorIDs        []string                        `json:"controlObjectiveCreatorIDs,omitempty"`
	EvidenceCreatorIDs                []string                        `json:"evidenceCreatorIDs,omitempty"`
	GroupCreatorIDs                   []string                        `json:"groupCreatorIDs,omitempty"`
	InternalPolicyCreatorIDs          []string                        `json:"internalPolicyCreatorIDs,omitempty"`
	MappedControlCreatorIDs           []string                        `json:"mappedControlCreatorIDs,omitempty"`
	NarrativeCreatorIDs               []string                        `json:"narrativeCreatorIDs,omitempty"`
	ProcedureCreatorIDs               []string                        `json:"procedureCreatorIDs,omitempty"`
	ProgramCreatorIDs                 []string                        `json:"programCreatorIDs,omitempty"`
	RiskCreatorIDs                    []string                        `json:"riskCreatorIDs,omitempty"`
	ScheduledJobCreatorIDs            []string                        `json:"scheduledJobCreatorIDs,omitempty"`
	StandardCreatorIDs                []string                        `json:"standardCreatorIDs,omitempty"`
	TemplateCreatorIDs                []string                        `json:"templateCreatorIDs,omitempty"`
	SubprocessorCreatorIDs            []string                        `json:"subprocessorCreatorIDs,omitempty"`
	TrustCenterDocCreatorIDs          []string                        `json:"trustCenterDocCreatorIDs,omitempty"`
	TrustCenterSubprocessorCreatorIDs []string                        `json:"trustCenterSubprocessorCreatorIDs,omitempty"`
	ParentID                          *string                         `json:"parentID,omitempty"`
	SettingID                         *string                         `json:"settingID,omitempty"`
	PersonalAccessTokenIDs            []string                        `json:"personalAccessTokenIDs,omitempty"`
	APITokenIDs                       []string                        `json:"apiTokenIDs,omitempty"`
	FileIDs                           []string                        `json:"fileIDs,omitempty"`
	EventIDs                          []string                        `json:"eventIDs,omitempty"`
	SecretIDs                         []string                        `json:"secretIDs,omitempty"`
	AvatarFileID                      *string                         `json:"avatarFileID,omitempty"`
	GroupIDs                          []string                        `json:"groupIDs,omitempty"`
	TemplateIDs                       []string                        `json:"templateIDs,omitempty"`
	IntegrationIDs                    []string                        `json:"integrationIDs,omitempty"`
	DocumentIDs                       []string                        `json:"documentIDs,omitempty"`
	OrgSubscriptionIDs                []string                        `json:"orgSubscriptionIDs,omitempty"`
	InviteIDs                         []string                        `json:"inviteIDs,omitempty"`
	SubscriberIDs                     []string                        `json:"subscriberIDs,omitempty"`
	EntityIDs                         []string                        `json:"entityIDs,omitempty"`
	EntityTypeIDs                     []string                        `json:"entityTypeIDs,omitempty"`
	ContactIDs                        []string                        `json:"contactIDs,omitempty"`
	NoteIDs                           []string                        `json:"noteIDs,omitempty"`
	TaskIDs                           []string                        `json:"taskIDs,omitempty"`
	ProgramIDs                        []string                        `json:"programIDs,omitempty"`
	ProcedureIDs                      []string                        `json:"procedureIDs,omitempty"`
	InternalPolicyIDs                 []string                        `json:"internalPolicyIDs,omitempty"`
	RiskIDs                           []string                        `json:"riskIDs,omitempty"`
	ControlObjectiveIDs               []string                        `json:"controlObjectiveIDs,omitempty"`
	NarrativeIDs                      []string                        `json:"narrativeIDs,omitempty"`
	ControlIDs                        []string                        `json:"controlIDs,omitempty"`
	SubcontrolIDs                     []string                        `json:"subcontrolIDs,omitempty"`
	ControlImplementationIDs          []string                        `json:"controlImplementationIDs,omitempty"`
	MappedControlIDs                  []string                        `json:"mappedControlIDs,omitempty"`
	EvidenceIDs                       []string                        `json:"evidenceIDs,omitempty"`
	StandardIDs                       []string                        `json:"standardIDs,omitempty"`
	ActionPlanIDs                     []string                        `json:"actionPlanIDs,omitempty"`
	CustomDomainIDs                   []string                        `json:"customDomainIDs,omitempty"`
	JobRunnerIDs                      []string                        `json:"jobRunnerIDs,omitempty"`
	JobRunnerTokenIDs                 []string                        `json:"jobRunnerTokenIDs,omitempty"`
	JobRunnerRegistrationTokenIDs     []string                        `json:"jobRunnerRegistrationTokenIDs,omitempty"`
	DNSVerificationIDs                []string                        `json:"dnsVerificationIDs,omitempty"`
	JobTemplateIDs                    []string                        `json:"jobTemplateIDs,omitempty"`
	ScheduledJobIDs                   []string                        `json:"scheduledJobIDs,omitempty"`
	JobResultIDs                      []string                        `json:"jobResultIDs,omitempty"`
	ScheduledJobRunIDs                []string                        `json:"scheduledJobRunIDs,omitempty"`
	TrustCenterIDs                    []string                        `json:"trustCenterIDs,omitempty"`
	AssetIDs                          []string                        `json:"assetIDs,omitempty"`
	ScanIDs                           []string                        `json:"scanIDs,omitempty"`
	SubprocessorIDs                   []string                        `json:"subprocessorIDs,omitempty"`
	ExportIDs                         []string                        `json:"exportIDs,omitempty"`
	TrustCenterWatermarkConfigIDs     []string                        `json:"trustCenterWatermarkConfigIDs,omitempty"`
	ImpersonationEventIDs             []string                        `json:"impersonationEventIDs,omitempty"`
	AssessmentIDs                     []string                        `json:"assessmentIDs,omitempty"`
	AssessmentResponseIDs             []string                        `json:"assessmentResponseIDs,omitempty"`
	CustomTypeEnumIDs                 []string                        `json:"customTypeEnumIDs,omitempty"`
	TagDefinitionIDs                  []string                        `json:"tagDefinitionIDs,omitempty"`
	RemediationIDs                    []string                        `json:"remediationIDs,omitempty"`
	FindingIDs                        []string                        `json:"findingIDs,omitempty"`
	ReviewIDs                         []string                        `json:"reviewIDs,omitempty"`
	VulnerabilityIDs                  []string                        `json:"vulnerabilityIDs,omitempty"`
	WorkflowDefinitionIDs             []string                        `json:"workflowDefinitionIDs,omitempty"`
	WorkflowInstanceIDs               []string                        `json:"workflowInstanceIDs,omitempty"`
	WorkflowEventIDs                  []string                        `json:"workflowEventIDs,omitempty"`
	WorkflowAssignmentIDs             []string                        `json:"workflowAssignmentIDs,omitempty"`
	WorkflowAssignmentTargetIDs       []string                        `json:"workflowAssignmentTargetIDs,omitempty"`
	WorkflowObjectRefIDs              []string                        `json:"workflowObjectRefIDs,omitempty"`
	DirectoryAccountIDs               []string                        `json:"directoryAccountIDs,omitempty"`
	DirectoryGroupIDs                 []string                        `json:"directoryGroupIDs,omitempty"`
	DirectorySyncRunIDs               []string                        `json:"directorySyncRunIDs,omitempty"`
	CreateOrgSettings                 *CreateOrganizationSettingInput `json:"createOrgSettings,omitempty"`
}

// CreateOrganizationSettingInput is used for create OrganizationSetting object.
// Input was generated by ent.
type CreateOrganizationSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled *bool `json:"billingNotificationsEnabled,omitempty"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string `json:"allowedEmailDomains,omitempty"`
	// allow users who can successfully confirm their email or who login via social providers with an email that matches the organizations configured allowed domain to auto-join the organization
	AllowMatchingDomainsAutojoin *bool `json:"allowMatchingDomainsAutojoin,omitempty"`
	// SSO provider type for the organization
	IdentityProvider *enums.SSOProvider `json:"identityProvider,omitempty"`
	// client ID for SSO integration
	IdentityProviderClientID *string `json:"identityProviderClientID,omitempty"`
	// client secret for SSO integration
	IdentityProviderClientSecret *string `json:"identityProviderClientSecret,omitempty"`
	// metadata URL for the SSO provider
	IdentityProviderMetadataEndpoint *string `json:"identityProviderMetadataEndpoint,omitempty"`
	// SAML entity ID for the SSO provider
	IdentityProviderEntityID *string `json:"identityProviderEntityID,omitempty"`
	// OIDC discovery URL for the SSO provider
	OidcDiscoveryEndpoint *string `json:"oidcDiscoveryEndpoint,omitempty"`
	// the sign in URL to be used for SAML-based authentication
	SamlSigninURL *string `json:"samlSigninURL,omitempty"`
	// the SAML issuer
	SamlIssuer *string `json:"samlIssuer,omitempty"`
	// the x509 certificate used to validate SAML responses
	SamlCert *string `json:"samlCert,omitempty"`
	// enforce SSO authentication for organization members
	IdentityProviderLoginEnforced *bool `json:"identityProviderLoginEnforced,omitempty"`
	// enforce 2fa / multifactor authentication for organization members
	MultifactorAuthEnforced *bool `json:"multifactorAuthEnforced,omitempty"`
	// unique token used to receive compliance webhook events
	ComplianceWebhookToken *string  `json:"complianceWebhookToken,omitempty"`
	OrganizationID         *string  `json:"organizationID,omitempty"`
	FileIDs                []string `json:"fileIDs,omitempty"`
}

// CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
// Input was generated by ent.
type CreatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive        *bool    `json:"isActive,omitempty"`
	OrganizationIDs []string `json:"organizationIDs,omitempty"`
	EventIDs        []string `json:"eventIDs,omitempty"`
}

// CreateProcedureInput is used for create Procedure object.
// Input was generated by ent.
type CreateProcedureInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// status of the procedure, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the procedure, e.g. compliance, operational, health and safety, etc.
	ProcedureType *string `json:"procedureType,omitempty"`
	// details of the procedure
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the procedure
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the procedure should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the procedure should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// auto-generated tag suggestions for the procedure
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the procedure
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the procedure
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the procedure
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the procedure
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the procedure
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the procedure
	URL *string `json:"url,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the procedure
	ProcedureKindName *string  `json:"procedureKindName,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string `json:"editorIDs,omitempty"`
	ApproverID        *string  `json:"approverID,omitempty"`
	DelegateID        *string  `json:"delegateID,omitempty"`
	ProcedureKindID   *string  `json:"procedureKindID,omitempty"`
	ControlIDs        []string `json:"controlIDs,omitempty"`
	SubcontrolIDs     []string `json:"subcontrolIDs,omitempty"`
	InternalPolicyIDs []string `json:"internalPolicyIDs,omitempty"`
	ProgramIDs        []string `json:"programIDs,omitempty"`
	NarrativeIDs      []string `json:"narrativeIDs,omitempty"`
	RiskIDs           []string `json:"riskIDs,omitempty"`
	TaskIDs           []string `json:"taskIDs,omitempty"`
	CommentIDs        []string `json:"commentIDs,omitempty"`
	FileID            *string  `json:"fileID,omitempty"`
}

// CreateProgramInput is used for create Program object.
// Input was generated by ent.
type CreateProgramInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the kind of the program
	ProgramKindName *string `json:"programKindName,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status *enums.ProgramStatus `json:"status,omitempty"`
	// the type of the program
	ProgramType *enums.ProgramType `json:"programType,omitempty"`
	// the short name of the compliance standard the program is based on, only used for framework type programs
	FrameworkName *string `json:"frameworkName,omitempty"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady *bool `json:"auditorReady,omitempty"`
	// can the auditor write comments
	AuditorWriteComments *bool `json:"auditorWriteComments,omitempty"`
	// can the auditor read comments
	AuditorReadComments *bool `json:"auditorReadComments,omitempty"`
	// the name of the audit firm conducting the audit
	AuditFirm *string `json:"auditFirm,omitempty"`
	// the full name of the auditor conducting the audit
	Auditor *string `json:"auditor,omitempty"`
	// the email of the auditor conducting the audit
	AuditorEmail        *string  `json:"auditorEmail,omitempty"`
	OwnerID             *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs     []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs           []string `json:"editorIDs,omitempty"`
	ViewerIDs           []string `json:"viewerIDs,omitempty"`
	ProgramKindID       *string  `json:"programKindID,omitempty"`
	ControlIDs          []string `json:"controlIDs,omitempty"`
	SubcontrolIDs       []string `json:"subcontrolIDs,omitempty"`
	ControlObjectiveIDs []string `json:"controlObjectiveIDs,omitempty"`
	InternalPolicyIDs   []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs        []string `json:"procedureIDs,omitempty"`
	RiskIDs             []string `json:"riskIDs,omitempty"`
	TaskIDs             []string `json:"taskIDs,omitempty"`
	NoteIDs             []string `json:"noteIDs,omitempty"`
	FileIDs             []string `json:"fileIDs,omitempty"`
	EvidenceIDs         []string `json:"evidenceIDs,omitempty"`
	NarrativeIDs        []string `json:"narrativeIDs,omitempty"`
	ActionPlanIDs       []string `json:"actionPlanIDs,omitempty"`
	ProgramOwnerID      *string  `json:"programOwnerID,omitempty"`
}

// CreateProgramMembershipInput is used for create ProgramMembership object.
// Input was generated by ent.
type CreateProgramMembershipInput struct {
	Role      *enums.Role `json:"role,omitempty"`
	ProgramID string      `json:"programID"`
	UserID    string      `json:"userID"`
}

type CreateProgramWithMembersInput struct {
	// program input for the base program details
	Program *CreateProgramInput `json:"program"`
	// members to add to the program
	Members []*CreateMemberWithProgramInput `json:"members,omitempty"`
	// standardID to clone all controls from into the organization and associated with the program
	StandardID *string `json:"standardID,omitempty"`
	// standardShortName to clone all controls from into the organization, if the standardID is provided that will take precedence
	StandardShortName *string `json:"standardShortName,omitempty"`
	// standardVersion is the version of the standard to use when filtering by short name, if not provided, the latest version will be used
	StandardVersion *string `json:"standardVersion,omitempty"`
	// categories to limit the controls that are cloned from a standard. If standardID is empty, this field is ignored
	Categories []string `json:"categories,omitempty"`
}

// CreateRemediationInput is used for create Remediation object.
// Input was generated by ent.
type CreateRemediationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the remediation
	ExternalID *string `json:"externalID,omitempty"`
	// external identifier from the integration source for the remediation
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// title or short description of the remediation effort
	Title *string `json:"title,omitempty"`
	// state of the remediation, such as pending or completed
	State *string `json:"state,omitempty"`
	// intent or goal of the remediation effort
	Intent *string `json:"intent,omitempty"`
	// summary of the remediation approach
	Summary *string `json:"summary,omitempty"`
	// detailed explanation of the remediation steps
	Explanation *string `json:"explanation,omitempty"`
	// specific instructions or steps to implement the remediation
	Instructions *string `json:"instructions,omitempty"`
	// reference to the owner responsible for remediation
	OwnerReference *string `json:"ownerReference,omitempty"`
	// source code repository URI associated with the remediation
	RepositoryURI *string `json:"repositoryURI,omitempty"`
	// pull request URI associated with the remediation
	PullRequestURI *string `json:"pullRequestURI,omitempty"`
	// reference to a tracking ticket for the remediation
	TicketReference *string `json:"ticketReference,omitempty"`
	// timestamp when the remediation is due
	DueAt *models.DateTime `json:"dueAt,omitempty"`
	// timestamp when the remediation was completed
	CompletedAt *models.DateTime `json:"completedAt,omitempty"`
	// timestamp when an automated pull request was generated
	PrGeneratedAt *models.DateTime `json:"prGeneratedAt,omitempty"`
	// details about any errors encountered during remediation automation
	Error *string `json:"error,omitempty"`
	// system that produced the remediation record
	Source *string `json:"source,omitempty"`
	// link to the remediation in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the remediation from the source system
	Metadata         map[string]any `json:"metadata,omitempty"`
	OwnerID          *string        `json:"ownerID,omitempty"`
	BlockedGroupIDs  []string       `json:"blockedGroupIDs,omitempty"`
	EditorIDs        []string       `json:"editorIDs,omitempty"`
	ViewerIDs        []string       `json:"viewerIDs,omitempty"`
	IntegrationIDs   []string       `json:"integrationIDs,omitempty"`
	FindingIDs       []string       `json:"findingIDs,omitempty"`
	VulnerabilityIDs []string       `json:"vulnerabilityIDs,omitempty"`
	ActionPlanIDs    []string       `json:"actionPlanIDs,omitempty"`
	TaskIDs          []string       `json:"taskIDs,omitempty"`
	ControlIDs       []string       `json:"controlIDs,omitempty"`
	SubcontrolIDs    []string       `json:"subcontrolIDs,omitempty"`
	RiskIDs          []string       `json:"riskIDs,omitempty"`
	ProgramIDs       []string       `json:"programIDs,omitempty"`
	AssetIDs         []string       `json:"assetIDs,omitempty"`
	EntityIDs        []string       `json:"entityIDs,omitempty"`
	ReviewIDs        []string       `json:"reviewIDs,omitempty"`
	CommentIDs       []string       `json:"commentIDs,omitempty"`
	FileIDs          []string       `json:"fileIDs,omitempty"`
}

// CreateReviewInput is used for create Review object.
// Input was generated by ent.
type CreateReviewInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the review
	ExternalID *string `json:"externalID,omitempty"`
	// external identifier from the integration source for the review
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// title of the review
	Title string `json:"title"`
	// state of the review
	State *string `json:"state,omitempty"`
	// category for the review record
	Category *string `json:"category,omitempty"`
	// classification or sensitivity of the review record
	Classification *string `json:"classification,omitempty"`
	// summary text for the review
	Summary *string `json:"summary,omitempty"`
	// detailed notes captured during the review
	Details *string `json:"details,omitempty"`
	// person or system that created the review
	Reporter *string `json:"reporter,omitempty"`
	// true when the review has been approved
	Approved *bool `json:"approved,omitempty"`
	// timestamp when the review was completed
	ReviewedAt *models.DateTime `json:"reviewedAt,omitempty"`
	// timestamp when the review was reported or opened
	ReportedAt *models.DateTime `json:"reportedAt,omitempty"`
	// timestamp when the review was approved
	ApprovedAt *models.DateTime `json:"approvedAt,omitempty"`
	// system that produced the review record
	Source *string `json:"source,omitempty"`
	// link to the review in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the review from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload       map[string]any `json:"rawPayload,omitempty"`
	OwnerID          *string        `json:"ownerID,omitempty"`
	BlockedGroupIDs  []string       `json:"blockedGroupIDs,omitempty"`
	EditorIDs        []string       `json:"editorIDs,omitempty"`
	ViewerIDs        []string       `json:"viewerIDs,omitempty"`
	IntegrationIDs   []string       `json:"integrationIDs,omitempty"`
	FindingIDs       []string       `json:"findingIDs,omitempty"`
	VulnerabilityIDs []string       `json:"vulnerabilityIDs,omitempty"`
	ActionPlanIDs    []string       `json:"actionPlanIDs,omitempty"`
	RemediationIDs   []string       `json:"remediationIDs,omitempty"`
	ControlIDs       []string       `json:"controlIDs,omitempty"`
	SubcontrolIDs    []string       `json:"subcontrolIDs,omitempty"`
	RiskIDs          []string       `json:"riskIDs,omitempty"`
	ProgramIDs       []string       `json:"programIDs,omitempty"`
	AssetIDs         []string       `json:"assetIDs,omitempty"`
	EntityIDs        []string       `json:"entityIDs,omitempty"`
	TaskIDs          []string       `json:"taskIDs,omitempty"`
	ReviewerID       *string        `json:"reviewerID,omitempty"`
	CommentIDs       []string       `json:"commentIDs,omitempty"`
	FileIDs          []string       `json:"fileIDs,omitempty"`
}

// CreateRiskInput is used for create Risk object.
// Input was generated by ent.
type CreateRiskInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the kind of the risk
	RiskKindName *string `json:"riskKindName,omitempty"`
	// the category of the risk
	RiskCategoryName *string `json:"riskCategoryName,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// status of the risk - identified, mitigated, accepted, closed, transferred, and archived.
	Status *enums.RiskStatus `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// category of the risk, e.g. human resources, operations, IT, etc.
	Category *string `json:"category,omitempty"`
	// impact of the risk -critical, high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// score of the risk based on impact and likelihood (1-4 unlikely, 5-9 likely, 10-16 highly likely, 17-20 critical)
	Score *int64 `json:"score,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// details of the risk
	Details *string `json:"details,omitempty"`
	// business costs associated with the risk
	BusinessCosts     *string  `json:"businessCosts,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string `json:"editorIDs,omitempty"`
	ViewerIDs         []string `json:"viewerIDs,omitempty"`
	RiskKindID        *string  `json:"riskKindID,omitempty"`
	RiskCategoryID    *string  `json:"riskCategoryID,omitempty"`
	ControlIDs        []string `json:"controlIDs,omitempty"`
	SubcontrolIDs     []string `json:"subcontrolIDs,omitempty"`
	ProcedureIDs      []string `json:"procedureIDs,omitempty"`
	InternalPolicyIDs []string `json:"internalPolicyIDs,omitempty"`
	ProgramIDs        []string `json:"programIDs,omitempty"`
	ActionPlanIDs     []string `json:"actionPlanIDs,omitempty"`
	TaskIDs           []string `json:"taskIDs,omitempty"`
	AssetIDs          []string `json:"assetIDs,omitempty"`
	EntityIDs         []string `json:"entityIDs,omitempty"`
	ScanIDs           []string `json:"scanIDs,omitempty"`
	StakeholderID     *string  `json:"stakeholderID,omitempty"`
	DelegateID        *string  `json:"delegateID,omitempty"`
	CommentIDs        []string `json:"commentIDs,omitempty"`
}

// CreateScanInput is used for create Scan object.
// Input was generated by ent.
type CreateScanInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the target of the scan, e.g., a domain name or IP address, codebase
	Target string `json:"target"`
	// the type of scan, e.g., domain scan, vulnerability scan, provider scan
	ScanType *enums.ScanType `json:"scanType,omitempty"`
	// additional metadata for the scan, e.g., scan configuration, options, etc
	Metadata map[string]any `json:"metadata,omitempty"`
	// the status of the scan, e.g., processing, completed, failed
	Status          *enums.ScanStatus `json:"status,omitempty"`
	OwnerID         *string           `json:"ownerID,omitempty"`
	BlockedGroupIDs []string          `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string          `json:"editorIDs,omitempty"`
	ViewerIDs       []string          `json:"viewerIDs,omitempty"`
	AssetIDs        []string          `json:"assetIDs,omitempty"`
	EntityIDs       []string          `json:"entityIDs,omitempty"`
}

// CreateScheduledJobInput is used for create ScheduledJob object.
// Input was generated by ent.
type CreateScheduledJobInput struct {
	// whether the scheduled job is active
	Active *bool `json:"active,omitempty"`
	// the json configuration to run this job, which could be used to template a job, e.g. { "account_name": "my-account" }
	Configuration models.JobConfiguration `json:"configuration,omitempty"`
	// cron 6-field syntax, defaults to the job template's cron if not provided
	Cron          *string  `json:"cron,omitempty"`
	OwnerID       *string  `json:"ownerID,omitempty"`
	JobTemplateID string   `json:"jobTemplateID"`
	ControlIDs    []string `json:"controlIDs,omitempty"`
	SubcontrolIDs []string `json:"subcontrolIDs,omitempty"`
	JobRunnerID   *string  `json:"jobRunnerID,omitempty"`
}

// CreateScheduledJobRunInput is used for create ScheduledJobRun object.
// Input was generated by ent.
type CreateScheduledJobRunInput struct {
	// The status of the job to be executed. By default will be pending but when
	// 			scheduled on a runner, this will change to acquired.
	Status *enums.ScheduledJobRunStatus `json:"status,omitempty"`
	// When should this job execute on the agent. Since we might potentially schedule a few minutes before
	ExpectedExecutionTime time.Time `json:"expectedExecutionTime"`
	// the script that will be executed by the agent.
	// This script will be templated with the values from the configuration on the job
	Script         string  `json:"script"`
	OwnerID        *string `json:"ownerID,omitempty"`
	ScheduledJobID string  `json:"scheduledJobID"`
	JobRunnerID    string  `json:"jobRunnerID"`
}

// CreateStandardInput is used for create Standard object.
// Input was generated by ent.
type CreateStandardInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// long description of the standard with details of what is covered
	Description *string `json:"description,omitempty"`
	// URL to the logo of the governing body
	GoverningBodyLogoURL *string `json:"governingBodyLogoURL,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, draft, and archived
	Status *enums.StandardStatus `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for system owned standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for system owned standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// type of the standard - cybersecurity, healthcare , financial, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version                  *string  `json:"version,omitempty"`
	OwnerID                  *string  `json:"ownerID,omitempty"`
	ControlIDs               []string `json:"controlIDs,omitempty"`
	TrustCenterComplianceIDs []string `json:"trustCenterComplianceIDs,omitempty"`
	TrustCenterDocIDs        []string `json:"trustCenterDocIDs,omitempty"`
	LogoFileID               *string  `json:"logoFileID,omitempty"`
}

// CreateSubcontrolInput is used for create Subcontrol object.
// Input was generated by ent.
type CreateSubcontrolInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// human readable title of the control for quick identification
	Title *string `json:"title,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// additional names (ref_codes) for the control
	Aliases []string `json:"aliases,omitempty"`
	// internal reference id of the control, can be used for internal tracking
	ReferenceID *string `json:"referenceID,omitempty"`
	// external auditor id of the control, can be used to map to external audit partner mappings
	AuditorReferenceID *string `json:"auditorReferenceID,omitempty"`
	// status of the control
	Status *enums.ControlStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// the reference framework for the control if it came from a standard, empty if not associated with a standard
	ReferenceFramework *string `json:"referenceFramework,omitempty"`
	// the reference framework revision for the control if it came from a standard, empty if not associated with a standard, allows for pulling in updates when the standard is updated
	ReferenceFrameworkRevision *string `json:"referenceFrameworkRevision,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the subcontrol
	SubcontrolKindName *string `json:"subcontrolKindName,omitempty"`
	// the unique reference code for the control
	RefCode                  string   `json:"refCode"`
	EvidenceIDs              []string `json:"evidenceIDs,omitempty"`
	ControlObjectiveIDs      []string `json:"controlObjectiveIDs,omitempty"`
	TaskIDs                  []string `json:"taskIDs,omitempty"`
	NarrativeIDs             []string `json:"narrativeIDs,omitempty"`
	RiskIDs                  []string `json:"riskIDs,omitempty"`
	ActionPlanIDs            []string `json:"actionPlanIDs,omitempty"`
	ProcedureIDs             []string `json:"procedureIDs,omitempty"`
	InternalPolicyIDs        []string `json:"internalPolicyIDs,omitempty"`
	CommentIDs               []string `json:"commentIDs,omitempty"`
	ControlOwnerID           *string  `json:"controlOwnerID,omitempty"`
	DelegateID               *string  `json:"delegateID,omitempty"`
	ResponsiblePartyID       *string  `json:"responsiblePartyID,omitempty"`
	OwnerID                  *string  `json:"ownerID,omitempty"`
	SubcontrolKindID         *string  `json:"subcontrolKindID,omitempty"`
	ControlID                string   `json:"controlID"`
	ControlImplementationIDs []string `json:"controlImplementationIDs,omitempty"`
	ScheduledJobIDs          []string `json:"scheduledJobIDs,omitempty"`
}

// CreateSubprocessorInput is used for create Subprocessor object.
// Input was generated by ent.
type CreateSubprocessorInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// name of the standard body
	Name string `json:"name"`
	// description of the subprocessor
	Description *string `json:"description,omitempty"`
	// URL of the logo
	LogoRemoteURL              *string  `json:"logoRemoteURL,omitempty"`
	OwnerID                    *string  `json:"ownerID,omitempty"`
	LogoFileID                 *string  `json:"logoFileID,omitempty"`
	TrustCenterSubprocessorIDs []string `json:"trustCenterSubprocessorIDs,omitempty"`
}

// CreateSubscriberInput is used for create Subscriber object.
// Input was generated by ent.
type CreateSubscriberInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string  `json:"phoneNumber,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateTFASettingInput is used for create TFASetting object.
// Input was generated by ent.
type CreateTFASettingInput struct {
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool `json:"totpAllowed,omitempty"`
}

// CreateTagDefinitionInput is used for create TagDefinition object.
// Input was generated by ent.
type CreateTagDefinitionInput struct {
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// The name of the tag definition
	Name string `json:"name"`
	// common aliases or misspellings for the tag definition
	Aliases []string `json:"aliases,omitempty"`
	// The description of the tag definition
	Description *string `json:"description,omitempty"`
	// The color of the tag definition in hex format
	Color   *string `json:"color,omitempty"`
	OwnerID *string `json:"ownerID,omitempty"`
}

// CreateTaskInput is used for create Task object.
// Input was generated by ent.
type CreateTaskInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the kind of the task
	TaskKindName *string `json:"taskKindName,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status *enums.TaskStatus `json:"status,omitempty"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *models.DateTime `json:"due,omitempty"`
	// the completion date of the task
	Completed *models.DateTime `json:"completed,omitempty"`
	// indicates if the task was generated by the system
	SystemGenerated *bool `json:"systemGenerated,omitempty"`
	// an optional external reference URL for the task
	ExternalReferenceURL     []string `json:"externalReferenceURL,omitempty"`
	OwnerID                  *string  `json:"ownerID,omitempty"`
	TaskKindID               *string  `json:"taskKindID,omitempty"`
	AssignerID               *string  `json:"assignerID,omitempty"`
	AssigneeID               *string  `json:"assigneeID,omitempty"`
	CommentIDs               []string `json:"commentIDs,omitempty"`
	GroupIDs                 []string `json:"groupIDs,omitempty"`
	InternalPolicyIDs        []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs             []string `json:"procedureIDs,omitempty"`
	ControlIDs               []string `json:"controlIDs,omitempty"`
	SubcontrolIDs            []string `json:"subcontrolIDs,omitempty"`
	ControlObjectiveIDs      []string `json:"controlObjectiveIDs,omitempty"`
	ProgramIDs               []string `json:"programIDs,omitempty"`
	RiskIDs                  []string `json:"riskIDs,omitempty"`
	ControlImplementationIDs []string `json:"controlImplementationIDs,omitempty"`
	ActionPlanIDs            []string `json:"actionPlanIDs,omitempty"`
	EvidenceIDs              []string `json:"evidenceIDs,omitempty"`
	WorkflowObjectRefIDs     []string `json:"workflowObjectRefIDs,omitempty"`
	ParentID                 *string  `json:"parentID,omitempty"`
	TaskIDs                  []string `json:"taskIDs,omitempty"`
}

// CreateTemplateInput is used for create Template object.
// Input was generated by ent.
type CreateTemplateInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the kind of template, e.g. questionnaire
	Kind *enums.TemplateKind `json:"kind,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema      map[string]any `json:"uischema,omitempty"`
	OwnerID       *string        `json:"ownerID,omitempty"`
	DocumentIDs   []string       `json:"documentIDs,omitempty"`
	FileIDs       []string       `json:"fileIDs,omitempty"`
	TrustCenterID *string        `json:"trustCenterID,omitempty"`
	AssessmentIDs []string       `json:"assessmentIDs,omitempty"`
}

// CreateTrustCenterComplianceInput is used for create TrustCenterCompliance object.
// Input was generated by ent.
type CreateTrustCenterComplianceInput struct {
	// tags associated with the object
	Tags          []string `json:"tags,omitempty"`
	TrustCenterID *string  `json:"trustCenterID,omitempty"`
	StandardID    string   `json:"standardID"`
}

// CreateTrustCenterDocInput is used for create TrustCenterDoc object.
// Input was generated by ent.
type CreateTrustCenterDocInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// title of the document
	Title string `json:"title"`
	// category of the document
	Category string `json:"category"`
	// whether watermarking is enabled for the document. this will only take effect if watermarking is configured for the trust center
	WatermarkingEnabled *bool `json:"watermarkingEnabled,omitempty"`
	// status of the watermarking
	WatermarkStatus *enums.WatermarkStatus `json:"watermarkStatus,omitempty"`
	// visibility of the document
	Visibility     *enums.TrustCenterDocumentVisibility `json:"visibility,omitempty"`
	TrustCenterID  *string                              `json:"trustCenterID,omitempty"`
	StandardID     *string                              `json:"standardID,omitempty"`
	FileID         *string                              `json:"fileID,omitempty"`
	OriginalFileID *string                              `json:"originalFileID,omitempty"`
}

// Input for createTrustCenterDomain mutation
type CreateTrustCenterDomainInput struct {
	// the name of the custom domain
	CnameRecord string `json:"cnameRecord"`
	// trust center ID
	TrustCenterID string `json:"trustCenterID"`
}

// CreateTrustCenterInput is used for create TrustCenter object.
// Input was generated by ent.
type CreateTrustCenterInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// Pirsch domain ID
	PirschDomainID *string `json:"pirschDomainID,omitempty"`
	// Pirsch ID code
	PirschIdentificationCode *string `json:"pirschIdentificationCode,omitempty"`
	// preview status of the trust center
	PreviewStatus              *enums.TrustCenterPreviewStatus `json:"previewStatus,omitempty"`
	OwnerID                    *string                         `json:"ownerID,omitempty"`
	CustomDomainID             *string                         `json:"customDomainID,omitempty"`
	PreviewDomainID            *string                         `json:"previewDomainID,omitempty"`
	SettingID                  *string                         `json:"settingID,omitempty"`
	PreviewSettingID           *string                         `json:"previewSettingID,omitempty"`
	WatermarkConfigID          *string                         `json:"watermarkConfigID,omitempty"`
	TrustCenterSubprocessorIDs []string                        `json:"trustCenterSubprocessorIDs,omitempty"`
	TrustCenterDocIDs          []string                        `json:"trustCenterDocIDs,omitempty"`
	TrustCenterComplianceIDs   []string                        `json:"trustCenterComplianceIDs,omitempty"`
	TemplateIDs                []string                        `json:"templateIDs,omitempty"`
	PostIDs                    []string                        `json:"postIDs,omitempty"`
	TrustcenterEntityIDs       []string                        `json:"trustcenterEntityIDs,omitempty"`
	CreateTrustCenterSetting   *CreateTrustCenterSettingInput  `json:"createTrustCenterSetting,omitempty"`
}

type CreateTrustCenterNDAInput struct {
	// trust center id
	TrustCenterID string `json:"trustCenterID"`
}

// CreateTrustCenterSettingInput is used for create TrustCenterSetting object.
// Input was generated by ent.
type CreateTrustCenterSettingInput struct {
	// the ID of the trust center the settings belong to
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// title of the trust center
	Title *string `json:"title,omitempty"`
	// overview of the trust center
	Overview *string `json:"overview,omitempty"`
	// URL of the logo
	LogoRemoteURL *string `json:"logoRemoteURL,omitempty"`
	// URL of the favicon
	FaviconRemoteURL *string `json:"faviconRemoteURL,omitempty"`
	// Theme mode for the trust center
	ThemeMode *enums.TrustCenterThemeMode `json:"themeMode,omitempty"`
	// primary color for the trust center
	PrimaryColor *string `json:"primaryColor,omitempty"`
	// font for the trust center
	Font *string `json:"font,omitempty"`
	// foreground color for the trust center
	ForegroundColor *string `json:"foregroundColor,omitempty"`
	// background color for the trust center
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	// accent/brand color for the trust center
	AccentColor *string `json:"accentColor,omitempty"`
	// secondary background color for the trust center
	SecondaryBackgroundColor *string `json:"secondaryBackgroundColor,omitempty"`
	// secondary foreground color for the trust center
	SecondaryForegroundColor *string `json:"secondaryForegroundColor,omitempty"`
	// environment of the trust center
	Environment   *enums.TrustCenterEnvironment `json:"environment,omitempty"`
	FileIDs       []string                      `json:"fileIDs,omitempty"`
	LogoFileID    *string                       `json:"logoFileID,omitempty"`
	FaviconFileID *string                       `json:"faviconFileID,omitempty"`
}

// CreateTrustCenterSubprocessorInput is used for create TrustCenterSubprocessor object.
// Input was generated by ent.
type CreateTrustCenterSubprocessorInput struct {
	// country codes or country where the subprocessor is located
	Countries []string `json:"countries,omitempty"`
	// Category of the subprocessor, e.g. 'Data Warehouse' or 'Infrastructure Hosting'
	Category       string  `json:"category"`
	TrustCenterID  *string `json:"trustCenterID,omitempty"`
	SubprocessorID string  `json:"subprocessorID"`
}

// CreateTrustCenterWatermarkConfigInput is used for create TrustCenterWatermarkConfig object.
// Input was generated by ent.
type CreateTrustCenterWatermarkConfigInput struct {
	// ID of the trust center
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// whether the watermarking is enabled for all trust center documents, default is true
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// text to watermark the document with
	Text *string `json:"text,omitempty"`
	// font size of the watermark text
	FontSize *float64 `json:"fontSize,omitempty"`
	// opacity of the watermark text
	Opacity *float64 `json:"opacity,omitempty"`
	// rotation of the watermark text
	Rotation *float64 `json:"rotation,omitempty"`
	// color of the watermark text
	Color *string `json:"color,omitempty"`
	// font of the watermark text
	Font           *enums.Font `json:"font,omitempty"`
	OwnerID        *string     `json:"ownerID,omitempty"`
	TrustCenterIDs []string    `json:"trustCenterIDs,omitempty"`
	FileID         *string     `json:"fileID,omitempty"`
}

// CreateTrustcenterEntityInput is used for create TrustcenterEntity object.
// Input was generated by ent.
type CreateTrustcenterEntityInput struct {
	// URL of customer's website
	URL *string `json:"url,omitempty"`
	// The name of the tag definition
	Name          string  `json:"name"`
	LogoFileID    *string `json:"logoFileID,omitempty"`
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	EntityTypeID  *string `json:"entityTypeID,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the last auth provider used to login
	LastLoginProvider *enums.AuthProvider `json:"lastLoginProvider,omitempty"`
	// user password hash
	Password *string `json:"password,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role *enums.Role `json:"role,omitempty"`
	// the SCIM external ID for the user
	ScimExternalID *string `json:"scimExternalID,omitempty"`
	// the SCIM username for the user
	ScimUsername *string `json:"scimUsername,omitempty"`
	// whether the SCIM user is active
	ScimActive *bool `json:"scimActive,omitempty"`
	// the SCIM preferred language for the user
	ScimPreferredLanguage *string `json:"scimPreferredLanguage,omitempty"`
	// the SCIM locale for the user
	ScimLocale               *string  `json:"scimLocale,omitempty"`
	PersonalAccessTokenIDs   []string `json:"personalAccessTokenIDs,omitempty"`
	TfaSettingIDs            []string `json:"tfaSettingIDs,omitempty"`
	SettingID                string   `json:"settingID"`
	GroupIDs                 []string `json:"groupIDs,omitempty"`
	OrganizationIDs          []string `json:"organizationIDs,omitempty"`
	WebauthnIDs              []string `json:"webauthnIDs,omitempty"`
	AvatarFileID             *string  `json:"avatarFileID,omitempty"`
	EventIDs                 []string `json:"eventIDs,omitempty"`
	ActionPlanIDs            []string `json:"actionPlanIDs,omitempty"`
	SubcontrolIDs            []string `json:"subcontrolIDs,omitempty"`
	AssignerTaskIDs          []string `json:"assignerTaskIDs,omitempty"`
	AssigneeTaskIDs          []string `json:"assigneeTaskIDs,omitempty"`
	ProgramIDs               []string `json:"programIDs,omitempty"`
	ProgramsOwnedIDs         []string `json:"programsOwnedIDs,omitempty"`
	ImpersonationEventIDs    []string `json:"impersonationEventIDs,omitempty"`
	TargetedImpersonationIDs []string `json:"targetedImpersonationIDs,omitempty"`
}

// CreateUserSettingInput is used for create UserSetting object.
// Input was generated by ent.
type CreateUserSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool   `json:"isTfaEnabled,omitempty"`
	UserID       *string `json:"userID,omitempty"`
	DefaultOrgID *string `json:"defaultOrgID,omitempty"`
}

// CreateVulnerabilityInput is used for create Vulnerability object.
// Input was generated by ent.
type CreateVulnerabilityInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// owner of the vulnerability
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// external identifier from the integration source for the vulnerability
	ExternalID string `json:"externalID"`
	// CVE identifier for the vulnerability when applicable
	CveID *string `json:"cveID,omitempty"`
	// system that produced the vulnerability record
	Source *string `json:"source,omitempty"`
	// display name for the vulnerability when provided
	DisplayName *string `json:"displayName,omitempty"`
	// category of the vulnerability such as application or infrastructure
	Category *string `json:"category,omitempty"`
	// severity label for the vulnerability
	Severity *string `json:"severity,omitempty"`
	// overall score such as CVSS for the vulnerability
	Score *float64 `json:"score,omitempty"`
	// impact score or rating for the vulnerability
	Impact *float64 `json:"impact,omitempty"`
	// exploitability score or rating for the vulnerability
	Exploitability *float64 `json:"exploitability,omitempty"`
	// priority assigned to the vulnerability
	Priority *string `json:"priority,omitempty"`
	// lifecycle status of the vulnerability
	Status *string `json:"status,omitempty"`
	// short summary of the vulnerability details
	Summary *string `json:"summary,omitempty"`
	// long form description of the vulnerability
	Description *string `json:"description,omitempty"`
	// attack vector string such as a CVSS vector
	Vector *string `json:"vector,omitempty"`
	// remediation service level agreement in days
	RemediationSLA *int64 `json:"remediationSLA,omitempty"`
	// indicates if the vulnerability is still open
	Open *bool `json:"open,omitempty"`
	// true when the vulnerability blocks production changes
	Blocking *bool `json:"blocking,omitempty"`
	// true when the vulnerability affects production systems
	Production *bool `json:"production,omitempty"`
	// true when the vulnerability is publicly disclosed
	Public *bool `json:"public,omitempty"`
	// true when the vulnerability has been validated by the security team
	Validated *bool `json:"validated,omitempty"`
	// reference links for the vulnerability
	References []string `json:"references,omitempty"`
	// targets or assets impacted by the vulnerability
	Impacts []string `json:"impacts,omitempty"`
	// timestamp when the vulnerability was published
	PublishedAt *models.DateTime `json:"publishedAt,omitempty"`
	// timestamp when the vulnerability was discovered in the environment
	DiscoveredAt *models.DateTime `json:"discoveredAt,omitempty"`
	// timestamp when the source last updated the vulnerability
	SourceUpdatedAt *models.DateTime `json:"sourceUpdatedAt,omitempty"`
	// link to the vulnerability in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the vulnerability from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload      map[string]any `json:"rawPayload,omitempty"`
	OwnerID         *string        `json:"ownerID,omitempty"`
	BlockedGroupIDs []string       `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string       `json:"editorIDs,omitempty"`
	ViewerIDs       []string       `json:"viewerIDs,omitempty"`
	IntegrationIDs  []string       `json:"integrationIDs,omitempty"`
	FindingIDs      []string       `json:"findingIDs,omitempty"`
	ActionPlanIDs   []string       `json:"actionPlanIDs,omitempty"`
	ControlIDs      []string       `json:"controlIDs,omitempty"`
	SubcontrolIDs   []string       `json:"subcontrolIDs,omitempty"`
	RiskIDs         []string       `json:"riskIDs,omitempty"`
	ProgramIDs      []string       `json:"programIDs,omitempty"`
	AssetIDs        []string       `json:"assetIDs,omitempty"`
	EntityIDs       []string       `json:"entityIDs,omitempty"`
	ScanIDs         []string       `json:"scanIDs,omitempty"`
	TaskIDs         []string       `json:"taskIDs,omitempty"`
	RemediationIDs  []string       `json:"remediationIDs,omitempty"`
	ReviewIDs       []string       `json:"reviewIDs,omitempty"`
	CommentIDs      []string       `json:"commentIDs,omitempty"`
	FileIDs         []string       `json:"fileIDs,omitempty"`
}

// CreateWorkflowAssignmentInput is used for create WorkflowAssignment object.
// Input was generated by ent.
type CreateWorkflowAssignmentInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// Unique key for the assignment within the workflow instance
	AssignmentKey string `json:"assignmentKey"`
	// Role assigned to the target, e.g. APPROVER
	Role *string `json:"role,omitempty"`
	// Optional label for the assignment
	Label *string `json:"label,omitempty"`
	// Whether this assignment is required for workflow progression
	Required *bool `json:"required,omitempty"`
	// Current status of the assignment
	Status *enums.WorkflowAssignmentStatus `json:"status,omitempty"`
	// Optional metadata for the assignment
	Metadata map[string]any `json:"metadata,omitempty"`
	// Timestamp when the assignment was decided
	DecidedAt *time.Time `json:"decidedAt,omitempty"`
	// Optional notes about the assignment
	Notes                       *string  `json:"notes,omitempty"`
	OwnerID                     *string  `json:"ownerID,omitempty"`
	WorkflowInstanceID          string   `json:"workflowInstanceID"`
	WorkflowAssignmentTargetIDs []string `json:"workflowAssignmentTargetIDs,omitempty"`
	UserID                      *string  `json:"userID,omitempty"`
	GroupID                     *string  `json:"groupID,omitempty"`
}

// CreateWorkflowAssignmentTargetInput is used for create WorkflowAssignmentTarget object.
// Input was generated by ent.
type CreateWorkflowAssignmentTargetInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// Type of the target (USER, GROUP, ROLE, RESOLVER)
	TargetType enums.WorkflowTargetType `json:"targetType"`
	// Resolver key when target_type is RESOLVER
	ResolverKey          *string `json:"resolverKey,omitempty"`
	OwnerID              *string `json:"ownerID,omitempty"`
	WorkflowAssignmentID string  `json:"workflowAssignmentID"`
	UserID               *string `json:"userID,omitempty"`
	GroupID              *string `json:"groupID,omitempty"`
}

// CreateWorkflowDefinitionInput is used for create WorkflowDefinition object.
// Input was generated by ent.
type CreateWorkflowDefinitionInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// Name of the workflow definition
	Name string `json:"name"`
	// Optional description of the workflow definition
	Description *string `json:"description,omitempty"`
	// Kind of workflow, e.g. APPROVAL, LIFECYCLE, NOTIFICATION
	WorkflowKind enums.WorkflowKind `json:"workflowKind"`
	// Type of schema this workflow applies to
	SchemaType string `json:"schemaType"`
	// Revision number for this definition
	Revision *int64 `json:"revision,omitempty"`
	// Whether this definition is a draft
	Draft *bool `json:"draft,omitempty"`
	// When this definition was published
	PublishedAt *time.Time `json:"publishedAt,omitempty"`
	// Suppress duplicate triggers within this window per object/definition
	CooldownSeconds *int64 `json:"cooldownSeconds,omitempty"`
	// Whether this is the default workflow for the schema type
	IsDefault *bool `json:"isDefault,omitempty"`
	// Whether the workflow definition is active
	Active *bool `json:"active,omitempty"`
	// Derived: normalized operations from definition for prefiltering; not user editable
	TriggerOperations []string `json:"triggerOperations,omitempty"`
	// Derived: normalized fields from definition for prefiltering; not user editable
	TriggerFields []string `json:"triggerFields,omitempty"`
	// Typed document describing triggers, conditions, and actions
	DefinitionJSON *models.WorkflowDefinitionDocument `json:"definitionJSON,omitempty"`
	// Cached list of fields that should trigger workflow evaluation
	TrackedFields    []string `json:"trackedFields,omitempty"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	TagDefinitionIDs []string `json:"tagDefinitionIDs,omitempty"`
	GroupIDs         []string `json:"groupIDs,omitempty"`
}

// CreateWorkflowEventInput is used for create WorkflowEvent object.
// Input was generated by ent.
type CreateWorkflowEventInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// Type of event, typically the action kind
	EventType enums.WorkflowEventType `json:"eventType"`
	// Payload for the event; stored raw
	Payload            *models.WorkflowEventPayload `json:"payload,omitempty"`
	OwnerID            *string                      `json:"ownerID,omitempty"`
	WorkflowInstanceID string                       `json:"workflowInstanceID"`
}

// CreateWorkflowInstanceInput is used for create WorkflowInstance object.
// Input was generated by ent.
type CreateWorkflowInstanceInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// Current state of the workflow instance
	State *enums.WorkflowInstanceState `json:"state,omitempty"`
	// Optional context for the workflow instance
	Context *models.WorkflowInstanceContext `json:"context,omitempty"`
	// Timestamp when the workflow was last evaluated
	LastEvaluatedAt *time.Time `json:"lastEvaluatedAt,omitempty"`
	// Copy of definition JSON used for this instance
	DefinitionSnapshot    *models.WorkflowDefinitionDocument `json:"definitionSnapshot,omitempty"`
	OwnerID               *string                            `json:"ownerID,omitempty"`
	WorkflowDefinitionID  string                             `json:"workflowDefinitionID"`
	WorkflowAssignmentIDs []string                           `json:"workflowAssignmentIDs,omitempty"`
	WorkflowEventIDs      []string                           `json:"workflowEventIDs,omitempty"`
	WorkflowObjectRefIDs  []string                           `json:"workflowObjectRefIDs,omitempty"`
}

// CreateWorkflowObjectRefInput is used for create WorkflowObjectRef object.
// Input was generated by ent.
type CreateWorkflowObjectRefInput struct {
	OwnerID            *string `json:"ownerID,omitempty"`
	WorkflowInstanceID string  `json:"workflowInstanceID"`
	ControlID          *string `json:"controlID,omitempty"`
	TaskID             *string `json:"taskID,omitempty"`
	InternalPolicyID   *string `json:"internalPolicyID,omitempty"`
	FindingID          *string `json:"findingID,omitempty"`
	DirectoryAccountID *string `json:"directoryAccountID,omitempty"`
	DirectoryGroupID   *string `json:"directoryGroupID,omitempty"`
}

type CustomDomain struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the custom domain
	CnameRecord string `json:"cnameRecord"`
	// The mappable domain id that this custom domain maps to
	MappableDomainID string `json:"mappableDomainID"`
	// The ID of the dns verification record
	DNSVerificationID *string          `json:"dnsVerificationID,omitempty"`
	Owner             *Organization    `json:"owner,omitempty"`
	MappableDomain    *MappableDomain  `json:"mappableDomain"`
	DNSVerification   *DNSVerification `json:"dnsVerification,omitempty"`
}

func (CustomDomain) IsNode() {}

// Return response for createBulkCustomDomain mutation
type CustomDomainBulkCreatePayload struct {
	// Created customDomains
	CustomDomains []*CustomDomain `json:"customDomains,omitempty"`
}

// Return response for deleteBulkCustomDomain mutation
type CustomDomainBulkDeletePayload struct {
	// Deleted customDomain IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type CustomDomainConnection struct {
	// A list of edges.
	Edges []*CustomDomainEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createCustomDomain mutation
type CustomDomainCreatePayload struct {
	// Created customDomain
	CustomDomain *CustomDomain `json:"customDomain"`
}

// Return response for deleteCustomDomain mutation
type CustomDomainDeletePayload struct {
	// Deleted customDomain ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type CustomDomainEdge struct {
	// The item at the end of the edge.
	Node *CustomDomain `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type CustomDomainHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the custom domain
	CnameRecord string `json:"cnameRecord"`
	// The mappable domain id that this custom domain maps to
	MappableDomainID string `json:"mappableDomainID"`
	// The ID of the dns verification record
	DNSVerificationID *string `json:"dnsVerificationID,omitempty"`
}

func (CustomDomainHistory) IsNode() {}

// A connection to a list of items.
type CustomDomainHistoryConnection struct {
	// A list of edges.
	Edges []*CustomDomainHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type CustomDomainHistoryEdge struct {
	// The item at the end of the edge.
	Node *CustomDomainHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for CustomDomainHistory connections
type CustomDomainHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order CustomDomainHistories.
	Field CustomDomainHistoryOrderField `json:"field"`
}

// CustomDomainHistoryWhereInput is used for filtering CustomDomainHistory objects.
// Input was generated by ent.
type CustomDomainHistoryWhereInput struct {
	Not *CustomDomainHistoryWhereInput   `json:"not,omitempty"`
	And []*CustomDomainHistoryWhereInput `json:"and,omitempty"`
	Or  []*CustomDomainHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// cname_record field predicates
	CnameRecord             *string  `json:"cnameRecord,omitempty"`
	CnameRecordNeq          *string  `json:"cnameRecordNEQ,omitempty"`
	CnameRecordIn           []string `json:"cnameRecordIn,omitempty"`
	CnameRecordNotIn        []string `json:"cnameRecordNotIn,omitempty"`
	CnameRecordGt           *string  `json:"cnameRecordGT,omitempty"`
	CnameRecordGte          *string  `json:"cnameRecordGTE,omitempty"`
	CnameRecordLt           *string  `json:"cnameRecordLT,omitempty"`
	CnameRecordLte          *string  `json:"cnameRecordLTE,omitempty"`
	CnameRecordContains     *string  `json:"cnameRecordContains,omitempty"`
	CnameRecordHasPrefix    *string  `json:"cnameRecordHasPrefix,omitempty"`
	CnameRecordHasSuffix    *string  `json:"cnameRecordHasSuffix,omitempty"`
	CnameRecordEqualFold    *string  `json:"cnameRecordEqualFold,omitempty"`
	CnameRecordContainsFold *string  `json:"cnameRecordContainsFold,omitempty"`
	// mappable_domain_id field predicates
	MappableDomainID             *string  `json:"mappableDomainID,omitempty"`
	MappableDomainIdneq          *string  `json:"mappableDomainIDNEQ,omitempty"`
	MappableDomainIDIn           []string `json:"mappableDomainIDIn,omitempty"`
	MappableDomainIDNotIn        []string `json:"mappableDomainIDNotIn,omitempty"`
	MappableDomainIdgt           *string  `json:"mappableDomainIDGT,omitempty"`
	MappableDomainIdgte          *string  `json:"mappableDomainIDGTE,omitempty"`
	MappableDomainIdlt           *string  `json:"mappableDomainIDLT,omitempty"`
	MappableDomainIdlte          *string  `json:"mappableDomainIDLTE,omitempty"`
	MappableDomainIDContains     *string  `json:"mappableDomainIDContains,omitempty"`
	MappableDomainIDHasPrefix    *string  `json:"mappableDomainIDHasPrefix,omitempty"`
	MappableDomainIDHasSuffix    *string  `json:"mappableDomainIDHasSuffix,omitempty"`
	MappableDomainIDEqualFold    *string  `json:"mappableDomainIDEqualFold,omitempty"`
	MappableDomainIDContainsFold *string  `json:"mappableDomainIDContainsFold,omitempty"`
	// dns_verification_id field predicates
	DNSVerificationID             *string  `json:"dnsVerificationID,omitempty"`
	DNSVerificationIdneq          *string  `json:"dnsVerificationIDNEQ,omitempty"`
	DNSVerificationIDIn           []string `json:"dnsVerificationIDIn,omitempty"`
	DNSVerificationIDNotIn        []string `json:"dnsVerificationIDNotIn,omitempty"`
	DNSVerificationIdgt           *string  `json:"dnsVerificationIDGT,omitempty"`
	DNSVerificationIdgte          *string  `json:"dnsVerificationIDGTE,omitempty"`
	DNSVerificationIdlt           *string  `json:"dnsVerificationIDLT,omitempty"`
	DNSVerificationIdlte          *string  `json:"dnsVerificationIDLTE,omitempty"`
	DNSVerificationIDContains     *string  `json:"dnsVerificationIDContains,omitempty"`
	DNSVerificationIDHasPrefix    *string  `json:"dnsVerificationIDHasPrefix,omitempty"`
	DNSVerificationIDHasSuffix    *string  `json:"dnsVerificationIDHasSuffix,omitempty"`
	DNSVerificationIDIsNil        *bool    `json:"dnsVerificationIDIsNil,omitempty"`
	DNSVerificationIDNotNil       *bool    `json:"dnsVerificationIDNotNil,omitempty"`
	DNSVerificationIDEqualFold    *string  `json:"dnsVerificationIDEqualFold,omitempty"`
	DNSVerificationIDContainsFold *string  `json:"dnsVerificationIDContainsFold,omitempty"`
}

// Ordering options for CustomDomain connections
type CustomDomainOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order CustomDomains.
	Field CustomDomainOrderField `json:"field"`
}

// Return response for updateCustomDomain mutation
type CustomDomainUpdatePayload struct {
	// Updated customDomain
	CustomDomain *CustomDomain `json:"customDomain"`
}

// CustomDomainWhereInput is used for filtering CustomDomain objects.
// Input was generated by ent.
type CustomDomainWhereInput struct {
	Not *CustomDomainWhereInput   `json:"not,omitempty"`
	And []*CustomDomainWhereInput `json:"and,omitempty"`
	Or  []*CustomDomainWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// cname_record field predicates
	CnameRecord             *string  `json:"cnameRecord,omitempty"`
	CnameRecordNeq          *string  `json:"cnameRecordNEQ,omitempty"`
	CnameRecordIn           []string `json:"cnameRecordIn,omitempty"`
	CnameRecordNotIn        []string `json:"cnameRecordNotIn,omitempty"`
	CnameRecordGt           *string  `json:"cnameRecordGT,omitempty"`
	CnameRecordGte          *string  `json:"cnameRecordGTE,omitempty"`
	CnameRecordLt           *string  `json:"cnameRecordLT,omitempty"`
	CnameRecordLte          *string  `json:"cnameRecordLTE,omitempty"`
	CnameRecordContains     *string  `json:"cnameRecordContains,omitempty"`
	CnameRecordHasPrefix    *string  `json:"cnameRecordHasPrefix,omitempty"`
	CnameRecordHasSuffix    *string  `json:"cnameRecordHasSuffix,omitempty"`
	CnameRecordEqualFold    *string  `json:"cnameRecordEqualFold,omitempty"`
	CnameRecordContainsFold *string  `json:"cnameRecordContainsFold,omitempty"`
	// mappable_domain_id field predicates
	MappableDomainID             *string  `json:"mappableDomainID,omitempty"`
	MappableDomainIdneq          *string  `json:"mappableDomainIDNEQ,omitempty"`
	MappableDomainIDIn           []string `json:"mappableDomainIDIn,omitempty"`
	MappableDomainIDNotIn        []string `json:"mappableDomainIDNotIn,omitempty"`
	MappableDomainIdgt           *string  `json:"mappableDomainIDGT,omitempty"`
	MappableDomainIdgte          *string  `json:"mappableDomainIDGTE,omitempty"`
	MappableDomainIdlt           *string  `json:"mappableDomainIDLT,omitempty"`
	MappableDomainIdlte          *string  `json:"mappableDomainIDLTE,omitempty"`
	MappableDomainIDContains     *string  `json:"mappableDomainIDContains,omitempty"`
	MappableDomainIDHasPrefix    *string  `json:"mappableDomainIDHasPrefix,omitempty"`
	MappableDomainIDHasSuffix    *string  `json:"mappableDomainIDHasSuffix,omitempty"`
	MappableDomainIDEqualFold    *string  `json:"mappableDomainIDEqualFold,omitempty"`
	MappableDomainIDContainsFold *string  `json:"mappableDomainIDContainsFold,omitempty"`
	// dns_verification_id field predicates
	DNSVerificationID             *string  `json:"dnsVerificationID,omitempty"`
	DNSVerificationIdneq          *string  `json:"dnsVerificationIDNEQ,omitempty"`
	DNSVerificationIDIn           []string `json:"dnsVerificationIDIn,omitempty"`
	DNSVerificationIDNotIn        []string `json:"dnsVerificationIDNotIn,omitempty"`
	DNSVerificationIdgt           *string  `json:"dnsVerificationIDGT,omitempty"`
	DNSVerificationIdgte          *string  `json:"dnsVerificationIDGTE,omitempty"`
	DNSVerificationIdlt           *string  `json:"dnsVerificationIDLT,omitempty"`
	DNSVerificationIdlte          *string  `json:"dnsVerificationIDLTE,omitempty"`
	DNSVerificationIDContains     *string  `json:"dnsVerificationIDContains,omitempty"`
	DNSVerificationIDHasPrefix    *string  `json:"dnsVerificationIDHasPrefix,omitempty"`
	DNSVerificationIDHasSuffix    *string  `json:"dnsVerificationIDHasSuffix,omitempty"`
	DNSVerificationIDIsNil        *bool    `json:"dnsVerificationIDIsNil,omitempty"`
	DNSVerificationIDNotNil       *bool    `json:"dnsVerificationIDNotNil,omitempty"`
	DNSVerificationIDEqualFold    *string  `json:"dnsVerificationIDEqualFold,omitempty"`
	DNSVerificationIDContainsFold *string  `json:"dnsVerificationIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// mappable_domain edge predicates
	HasMappableDomain     *bool                       `json:"hasMappableDomain,omitempty"`
	HasMappableDomainWith []*MappableDomainWhereInput `json:"hasMappableDomainWith,omitempty"`
	// dns_verification edge predicates
	HasDNSVerification     *bool                        `json:"hasDNSVerification,omitempty"`
	HasDNSVerificationWith []*DNSVerificationWhereInput `json:"hasDNSVerificationWith,omitempty"`
}

type CustomTypeEnum struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of object the type applies to, for example task
	ObjectType string `json:"objectType"`
	// the field on the object the type applies to, for example kind or category
	Field string `json:"field"`
	// The name of the enum value, for example evidence request
	Name string `json:"name"`
	// The description of the custom type
	Description *string `json:"description,omitempty"`
	// The color of the tag definition in hex format
	Color *string `json:"color,omitempty"`
	// The icon of the custom type enum in SVG format
	Icon             *string                   `json:"icon,omitempty"`
	Owner            *Organization             `json:"owner,omitempty"`
	Tasks            *TaskConnection           `json:"tasks"`
	Controls         *ControlConnection        `json:"controls"`
	Subcontrols      *SubcontrolConnection     `json:"subcontrols"`
	Risks            *RiskConnection           `json:"risks"`
	RiskCategories   *RiskConnection           `json:"riskCategories"`
	InternalPolicies *InternalPolicyConnection `json:"internalPolicies"`
	Procedures       *ProcedureConnection      `json:"procedures"`
	ActionPlans      *ActionPlanConnection     `json:"actionPlans"`
	Programs         *ProgramConnection        `json:"programs"`
}

func (CustomTypeEnum) IsNode() {}

// Return response for createBulkCustomTypeEnum mutation
type CustomTypeEnumBulkCreatePayload struct {
	// Created customTypeEnums
	CustomTypeEnums []*CustomTypeEnum `json:"customTypeEnums,omitempty"`
}

// A connection to a list of items.
type CustomTypeEnumConnection struct {
	// A list of edges.
	Edges []*CustomTypeEnumEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createCustomTypeEnum mutation
type CustomTypeEnumCreatePayload struct {
	// Created customTypeEnum
	CustomTypeEnum *CustomTypeEnum `json:"customTypeEnum"`
}

// Return response for deleteCustomTypeEnum mutation
type CustomTypeEnumDeletePayload struct {
	// Deleted customTypeEnum ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type CustomTypeEnumEdge struct {
	// The item at the end of the edge.
	Node *CustomTypeEnum `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for CustomTypeEnum connections
type CustomTypeEnumOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order CustomTypeEnums.
	Field CustomTypeEnumOrderField `json:"field"`
}

// Return response for updateCustomTypeEnum mutation
type CustomTypeEnumUpdatePayload struct {
	// Updated customTypeEnum
	CustomTypeEnum *CustomTypeEnum `json:"customTypeEnum"`
}

// CustomTypeEnumWhereInput is used for filtering CustomTypeEnum objects.
// Input was generated by ent.
type CustomTypeEnumWhereInput struct {
	Not *CustomTypeEnumWhereInput   `json:"not,omitempty"`
	And []*CustomTypeEnumWhereInput `json:"and,omitempty"`
	Or  []*CustomTypeEnumWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// object_type field predicates
	ObjectType             *string  `json:"objectType,omitempty"`
	ObjectTypeNeq          *string  `json:"objectTypeNEQ,omitempty"`
	ObjectTypeIn           []string `json:"objectTypeIn,omitempty"`
	ObjectTypeNotIn        []string `json:"objectTypeNotIn,omitempty"`
	ObjectTypeGt           *string  `json:"objectTypeGT,omitempty"`
	ObjectTypeGte          *string  `json:"objectTypeGTE,omitempty"`
	ObjectTypeLt           *string  `json:"objectTypeLT,omitempty"`
	ObjectTypeLte          *string  `json:"objectTypeLTE,omitempty"`
	ObjectTypeContains     *string  `json:"objectTypeContains,omitempty"`
	ObjectTypeHasPrefix    *string  `json:"objectTypeHasPrefix,omitempty"`
	ObjectTypeHasSuffix    *string  `json:"objectTypeHasSuffix,omitempty"`
	ObjectTypeEqualFold    *string  `json:"objectTypeEqualFold,omitempty"`
	ObjectTypeContainsFold *string  `json:"objectTypeContainsFold,omitempty"`
	// field field predicates
	Field             *string  `json:"field,omitempty"`
	FieldNeq          *string  `json:"fieldNEQ,omitempty"`
	FieldIn           []string `json:"fieldIn,omitempty"`
	FieldNotIn        []string `json:"fieldNotIn,omitempty"`
	FieldGt           *string  `json:"fieldGT,omitempty"`
	FieldGte          *string  `json:"fieldGTE,omitempty"`
	FieldLt           *string  `json:"fieldLT,omitempty"`
	FieldLte          *string  `json:"fieldLTE,omitempty"`
	FieldContains     *string  `json:"fieldContains,omitempty"`
	FieldHasPrefix    *string  `json:"fieldHasPrefix,omitempty"`
	FieldHasSuffix    *string  `json:"fieldHasSuffix,omitempty"`
	FieldEqualFold    *string  `json:"fieldEqualFold,omitempty"`
	FieldContainsFold *string  `json:"fieldContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// color field predicates
	Color             *string  `json:"color,omitempty"`
	ColorNeq          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGt           *string  `json:"colorGT,omitempty"`
	ColorGte          *string  `json:"colorGTE,omitempty"`
	ColorLt           *string  `json:"colorLT,omitempty"`
	ColorLte          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorIsNil        *bool    `json:"colorIsNil,omitempty"`
	ColorNotNil       *bool    `json:"colorNotNil,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`
	// icon field predicates
	Icon             *string  `json:"icon,omitempty"`
	IconNeq          *string  `json:"iconNEQ,omitempty"`
	IconIn           []string `json:"iconIn,omitempty"`
	IconNotIn        []string `json:"iconNotIn,omitempty"`
	IconGt           *string  `json:"iconGT,omitempty"`
	IconGte          *string  `json:"iconGTE,omitempty"`
	IconLt           *string  `json:"iconLT,omitempty"`
	IconLte          *string  `json:"iconLTE,omitempty"`
	IconContains     *string  `json:"iconContains,omitempty"`
	IconHasPrefix    *string  `json:"iconHasPrefix,omitempty"`
	IconHasSuffix    *string  `json:"iconHasSuffix,omitempty"`
	IconIsNil        *bool    `json:"iconIsNil,omitempty"`
	IconNotNil       *bool    `json:"iconNotNil,omitempty"`
	IconEqualFold    *string  `json:"iconEqualFold,omitempty"`
	IconContainsFold *string  `json:"iconContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// risk_categories edge predicates
	HasRiskCategories     *bool             `json:"hasRiskCategories,omitempty"`
	HasRiskCategoriesWith []*RiskWhereInput `json:"hasRiskCategoriesWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type DNSVerification struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// The ID of the custom domain in cloudflare
	CloudflareHostnameID string `json:"cloudflareHostnameID"`
	// the name of the dns txt record
	DNSTxtRecord string `json:"dnsTxtRecord"`
	// the expected value of the dns txt record
	DNSTxtValue string `json:"dnsTxtValue"`
	// Status of the domain verification
	DNSVerificationStatus enums.DNSVerificationStatus `json:"dnsVerificationStatus"`
	// Reason of the dns verification status, for giving the user diagnostic info
	DNSVerificationStatusReason *string `json:"dnsVerificationStatusReason,omitempty"`
	// Path under /.well-known/acme-challenge/ to serve the ACME challenge
	AcmeChallengePath *string `json:"acmeChallengePath,omitempty"`
	// the expected value of the acme challenge record
	ExpectedAcmeChallengeValue *string `json:"expectedAcmeChallengeValue,omitempty"`
	// Status of the ACME challenge validation
	AcmeChallengeStatus enums.SSLVerificationStatus `json:"acmeChallengeStatus"`
	// Reason of the ACME status, for giving the user diagnostic info
	AcmeChallengeStatusReason *string                 `json:"acmeChallengeStatusReason,omitempty"`
	Owner                     *Organization           `json:"owner,omitempty"`
	CustomDomains             *CustomDomainConnection `json:"customDomains"`
}

func (DNSVerification) IsNode() {}

// Return response for createBulkDNSVerification mutation
type DNSVerificationBulkCreatePayload struct {
	// Created dnsVerifications
	DNSVerifications []*DNSVerification `json:"dnsVerifications,omitempty"`
}

// Return response for deleteBulkDNSVerification mutation
type DNSVerificationBulkDeletePayload struct {
	// Deleted dnsVerification IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type DNSVerificationConnection struct {
	// A list of edges.
	Edges []*DNSVerificationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDNSVerification mutation
type DNSVerificationCreatePayload struct {
	// Created dnsVerification
	DNSVerification *DNSVerification `json:"dnsVerification"`
}

// Return response for deleteDNSVerification mutation
type DNSVerificationDeletePayload struct {
	// Deleted dnsVerification ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DNSVerificationEdge struct {
	// The item at the end of the edge.
	Node *DNSVerification `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DNSVerificationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// The ID of the custom domain in cloudflare
	CloudflareHostnameID string `json:"cloudflareHostnameID"`
	// the name of the dns txt record
	DNSTxtRecord string `json:"dnsTxtRecord"`
	// the expected value of the dns txt record
	DNSTxtValue string `json:"dnsTxtValue"`
	// Status of the domain verification
	DNSVerificationStatus enums.DNSVerificationStatus `json:"dnsVerificationStatus"`
	// Reason of the dns verification status, for giving the user diagnostic info
	DNSVerificationStatusReason *string `json:"dnsVerificationStatusReason,omitempty"`
	// Path under /.well-known/acme-challenge/ to serve the ACME challenge
	AcmeChallengePath *string `json:"acmeChallengePath,omitempty"`
	// the expected value of the acme challenge record
	ExpectedAcmeChallengeValue *string `json:"expectedAcmeChallengeValue,omitempty"`
	// Status of the ACME challenge validation
	AcmeChallengeStatus enums.SSLVerificationStatus `json:"acmeChallengeStatus"`
	// Reason of the ACME status, for giving the user diagnostic info
	AcmeChallengeStatusReason *string `json:"acmeChallengeStatusReason,omitempty"`
}

func (DNSVerificationHistory) IsNode() {}

// A connection to a list of items.
type DNSVerificationHistoryConnection struct {
	// A list of edges.
	Edges []*DNSVerificationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DNSVerificationHistoryEdge struct {
	// The item at the end of the edge.
	Node *DNSVerificationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for DNSVerificationHistory connections
type DNSVerificationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DNSVerificationHistories.
	Field DNSVerificationHistoryOrderField `json:"field"`
}

// DNSVerificationHistoryWhereInput is used for filtering DNSVerificationHistory objects.
// Input was generated by ent.
type DNSVerificationHistoryWhereInput struct {
	Not *DNSVerificationHistoryWhereInput   `json:"not,omitempty"`
	And []*DNSVerificationHistoryWhereInput `json:"and,omitempty"`
	Or  []*DNSVerificationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// cloudflare_hostname_id field predicates
	CloudflareHostnameID             *string  `json:"cloudflareHostnameID,omitempty"`
	CloudflareHostnameIdneq          *string  `json:"cloudflareHostnameIDNEQ,omitempty"`
	CloudflareHostnameIDIn           []string `json:"cloudflareHostnameIDIn,omitempty"`
	CloudflareHostnameIDNotIn        []string `json:"cloudflareHostnameIDNotIn,omitempty"`
	CloudflareHostnameIdgt           *string  `json:"cloudflareHostnameIDGT,omitempty"`
	CloudflareHostnameIdgte          *string  `json:"cloudflareHostnameIDGTE,omitempty"`
	CloudflareHostnameIdlt           *string  `json:"cloudflareHostnameIDLT,omitempty"`
	CloudflareHostnameIdlte          *string  `json:"cloudflareHostnameIDLTE,omitempty"`
	CloudflareHostnameIDContains     *string  `json:"cloudflareHostnameIDContains,omitempty"`
	CloudflareHostnameIDHasPrefix    *string  `json:"cloudflareHostnameIDHasPrefix,omitempty"`
	CloudflareHostnameIDHasSuffix    *string  `json:"cloudflareHostnameIDHasSuffix,omitempty"`
	CloudflareHostnameIDEqualFold    *string  `json:"cloudflareHostnameIDEqualFold,omitempty"`
	CloudflareHostnameIDContainsFold *string  `json:"cloudflareHostnameIDContainsFold,omitempty"`
	// dns_txt_record field predicates
	DNSTxtRecord             *string  `json:"dnsTxtRecord,omitempty"`
	DNSTxtRecordNeq          *string  `json:"dnsTxtRecordNEQ,omitempty"`
	DNSTxtRecordIn           []string `json:"dnsTxtRecordIn,omitempty"`
	DNSTxtRecordNotIn        []string `json:"dnsTxtRecordNotIn,omitempty"`
	DNSTxtRecordGt           *string  `json:"dnsTxtRecordGT,omitempty"`
	DNSTxtRecordGte          *string  `json:"dnsTxtRecordGTE,omitempty"`
	DNSTxtRecordLt           *string  `json:"dnsTxtRecordLT,omitempty"`
	DNSTxtRecordLte          *string  `json:"dnsTxtRecordLTE,omitempty"`
	DNSTxtRecordContains     *string  `json:"dnsTxtRecordContains,omitempty"`
	DNSTxtRecordHasPrefix    *string  `json:"dnsTxtRecordHasPrefix,omitempty"`
	DNSTxtRecordHasSuffix    *string  `json:"dnsTxtRecordHasSuffix,omitempty"`
	DNSTxtRecordEqualFold    *string  `json:"dnsTxtRecordEqualFold,omitempty"`
	DNSTxtRecordContainsFold *string  `json:"dnsTxtRecordContainsFold,omitempty"`
	// dns_txt_value field predicates
	DNSTxtValue             *string  `json:"dnsTxtValue,omitempty"`
	DNSTxtValueNeq          *string  `json:"dnsTxtValueNEQ,omitempty"`
	DNSTxtValueIn           []string `json:"dnsTxtValueIn,omitempty"`
	DNSTxtValueNotIn        []string `json:"dnsTxtValueNotIn,omitempty"`
	DNSTxtValueGt           *string  `json:"dnsTxtValueGT,omitempty"`
	DNSTxtValueGte          *string  `json:"dnsTxtValueGTE,omitempty"`
	DNSTxtValueLt           *string  `json:"dnsTxtValueLT,omitempty"`
	DNSTxtValueLte          *string  `json:"dnsTxtValueLTE,omitempty"`
	DNSTxtValueContains     *string  `json:"dnsTxtValueContains,omitempty"`
	DNSTxtValueHasPrefix    *string  `json:"dnsTxtValueHasPrefix,omitempty"`
	DNSTxtValueHasSuffix    *string  `json:"dnsTxtValueHasSuffix,omitempty"`
	DNSTxtValueEqualFold    *string  `json:"dnsTxtValueEqualFold,omitempty"`
	DNSTxtValueContainsFold *string  `json:"dnsTxtValueContainsFold,omitempty"`
	// dns_verification_status field predicates
	DNSVerificationStatus      *enums.DNSVerificationStatus  `json:"dnsVerificationStatus,omitempty"`
	DNSVerificationStatusNeq   *enums.DNSVerificationStatus  `json:"dnsVerificationStatusNEQ,omitempty"`
	DNSVerificationStatusIn    []enums.DNSVerificationStatus `json:"dnsVerificationStatusIn,omitempty"`
	DNSVerificationStatusNotIn []enums.DNSVerificationStatus `json:"dnsVerificationStatusNotIn,omitempty"`
	// dns_verification_status_reason field predicates
	DNSVerificationStatusReason             *string  `json:"dnsVerificationStatusReason,omitempty"`
	DNSVerificationStatusReasonNeq          *string  `json:"dnsVerificationStatusReasonNEQ,omitempty"`
	DNSVerificationStatusReasonIn           []string `json:"dnsVerificationStatusReasonIn,omitempty"`
	DNSVerificationStatusReasonNotIn        []string `json:"dnsVerificationStatusReasonNotIn,omitempty"`
	DNSVerificationStatusReasonGt           *string  `json:"dnsVerificationStatusReasonGT,omitempty"`
	DNSVerificationStatusReasonGte          *string  `json:"dnsVerificationStatusReasonGTE,omitempty"`
	DNSVerificationStatusReasonLt           *string  `json:"dnsVerificationStatusReasonLT,omitempty"`
	DNSVerificationStatusReasonLte          *string  `json:"dnsVerificationStatusReasonLTE,omitempty"`
	DNSVerificationStatusReasonContains     *string  `json:"dnsVerificationStatusReasonContains,omitempty"`
	DNSVerificationStatusReasonHasPrefix    *string  `json:"dnsVerificationStatusReasonHasPrefix,omitempty"`
	DNSVerificationStatusReasonHasSuffix    *string  `json:"dnsVerificationStatusReasonHasSuffix,omitempty"`
	DNSVerificationStatusReasonIsNil        *bool    `json:"dnsVerificationStatusReasonIsNil,omitempty"`
	DNSVerificationStatusReasonNotNil       *bool    `json:"dnsVerificationStatusReasonNotNil,omitempty"`
	DNSVerificationStatusReasonEqualFold    *string  `json:"dnsVerificationStatusReasonEqualFold,omitempty"`
	DNSVerificationStatusReasonContainsFold *string  `json:"dnsVerificationStatusReasonContainsFold,omitempty"`
	// acme_challenge_path field predicates
	AcmeChallengePath             *string  `json:"acmeChallengePath,omitempty"`
	AcmeChallengePathNeq          *string  `json:"acmeChallengePathNEQ,omitempty"`
	AcmeChallengePathIn           []string `json:"acmeChallengePathIn,omitempty"`
	AcmeChallengePathNotIn        []string `json:"acmeChallengePathNotIn,omitempty"`
	AcmeChallengePathGt           *string  `json:"acmeChallengePathGT,omitempty"`
	AcmeChallengePathGte          *string  `json:"acmeChallengePathGTE,omitempty"`
	AcmeChallengePathLt           *string  `json:"acmeChallengePathLT,omitempty"`
	AcmeChallengePathLte          *string  `json:"acmeChallengePathLTE,omitempty"`
	AcmeChallengePathContains     *string  `json:"acmeChallengePathContains,omitempty"`
	AcmeChallengePathHasPrefix    *string  `json:"acmeChallengePathHasPrefix,omitempty"`
	AcmeChallengePathHasSuffix    *string  `json:"acmeChallengePathHasSuffix,omitempty"`
	AcmeChallengePathIsNil        *bool    `json:"acmeChallengePathIsNil,omitempty"`
	AcmeChallengePathNotNil       *bool    `json:"acmeChallengePathNotNil,omitempty"`
	AcmeChallengePathEqualFold    *string  `json:"acmeChallengePathEqualFold,omitempty"`
	AcmeChallengePathContainsFold *string  `json:"acmeChallengePathContainsFold,omitempty"`
	// expected_acme_challenge_value field predicates
	ExpectedAcmeChallengeValue             *string  `json:"expectedAcmeChallengeValue,omitempty"`
	ExpectedAcmeChallengeValueNeq          *string  `json:"expectedAcmeChallengeValueNEQ,omitempty"`
	ExpectedAcmeChallengeValueIn           []string `json:"expectedAcmeChallengeValueIn,omitempty"`
	ExpectedAcmeChallengeValueNotIn        []string `json:"expectedAcmeChallengeValueNotIn,omitempty"`
	ExpectedAcmeChallengeValueGt           *string  `json:"expectedAcmeChallengeValueGT,omitempty"`
	ExpectedAcmeChallengeValueGte          *string  `json:"expectedAcmeChallengeValueGTE,omitempty"`
	ExpectedAcmeChallengeValueLt           *string  `json:"expectedAcmeChallengeValueLT,omitempty"`
	ExpectedAcmeChallengeValueLte          *string  `json:"expectedAcmeChallengeValueLTE,omitempty"`
	ExpectedAcmeChallengeValueContains     *string  `json:"expectedAcmeChallengeValueContains,omitempty"`
	ExpectedAcmeChallengeValueHasPrefix    *string  `json:"expectedAcmeChallengeValueHasPrefix,omitempty"`
	ExpectedAcmeChallengeValueHasSuffix    *string  `json:"expectedAcmeChallengeValueHasSuffix,omitempty"`
	ExpectedAcmeChallengeValueIsNil        *bool    `json:"expectedAcmeChallengeValueIsNil,omitempty"`
	ExpectedAcmeChallengeValueNotNil       *bool    `json:"expectedAcmeChallengeValueNotNil,omitempty"`
	ExpectedAcmeChallengeValueEqualFold    *string  `json:"expectedAcmeChallengeValueEqualFold,omitempty"`
	ExpectedAcmeChallengeValueContainsFold *string  `json:"expectedAcmeChallengeValueContainsFold,omitempty"`
	// acme_challenge_status field predicates
	AcmeChallengeStatus      *enums.SSLVerificationStatus  `json:"acmeChallengeStatus,omitempty"`
	AcmeChallengeStatusNeq   *enums.SSLVerificationStatus  `json:"acmeChallengeStatusNEQ,omitempty"`
	AcmeChallengeStatusIn    []enums.SSLVerificationStatus `json:"acmeChallengeStatusIn,omitempty"`
	AcmeChallengeStatusNotIn []enums.SSLVerificationStatus `json:"acmeChallengeStatusNotIn,omitempty"`
	// acme_challenge_status_reason field predicates
	AcmeChallengeStatusReason             *string  `json:"acmeChallengeStatusReason,omitempty"`
	AcmeChallengeStatusReasonNeq          *string  `json:"acmeChallengeStatusReasonNEQ,omitempty"`
	AcmeChallengeStatusReasonIn           []string `json:"acmeChallengeStatusReasonIn,omitempty"`
	AcmeChallengeStatusReasonNotIn        []string `json:"acmeChallengeStatusReasonNotIn,omitempty"`
	AcmeChallengeStatusReasonGt           *string  `json:"acmeChallengeStatusReasonGT,omitempty"`
	AcmeChallengeStatusReasonGte          *string  `json:"acmeChallengeStatusReasonGTE,omitempty"`
	AcmeChallengeStatusReasonLt           *string  `json:"acmeChallengeStatusReasonLT,omitempty"`
	AcmeChallengeStatusReasonLte          *string  `json:"acmeChallengeStatusReasonLTE,omitempty"`
	AcmeChallengeStatusReasonContains     *string  `json:"acmeChallengeStatusReasonContains,omitempty"`
	AcmeChallengeStatusReasonHasPrefix    *string  `json:"acmeChallengeStatusReasonHasPrefix,omitempty"`
	AcmeChallengeStatusReasonHasSuffix    *string  `json:"acmeChallengeStatusReasonHasSuffix,omitempty"`
	AcmeChallengeStatusReasonIsNil        *bool    `json:"acmeChallengeStatusReasonIsNil,omitempty"`
	AcmeChallengeStatusReasonNotNil       *bool    `json:"acmeChallengeStatusReasonNotNil,omitempty"`
	AcmeChallengeStatusReasonEqualFold    *string  `json:"acmeChallengeStatusReasonEqualFold,omitempty"`
	AcmeChallengeStatusReasonContainsFold *string  `json:"acmeChallengeStatusReasonContainsFold,omitempty"`
}

// Ordering options for DNSVerification connections
type DNSVerificationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DNSVerifications.
	Field DNSVerificationOrderField `json:"field"`
}

// Return response for updateDNSVerification mutation
type DNSVerificationUpdatePayload struct {
	// Updated dnsVerification
	DNSVerification *DNSVerification `json:"dnsVerification"`
}

// DNSVerificationWhereInput is used for filtering DNSVerification objects.
// Input was generated by ent.
type DNSVerificationWhereInput struct {
	Not *DNSVerificationWhereInput   `json:"not,omitempty"`
	And []*DNSVerificationWhereInput `json:"and,omitempty"`
	Or  []*DNSVerificationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// cloudflare_hostname_id field predicates
	CloudflareHostnameID             *string  `json:"cloudflareHostnameID,omitempty"`
	CloudflareHostnameIdneq          *string  `json:"cloudflareHostnameIDNEQ,omitempty"`
	CloudflareHostnameIDIn           []string `json:"cloudflareHostnameIDIn,omitempty"`
	CloudflareHostnameIDNotIn        []string `json:"cloudflareHostnameIDNotIn,omitempty"`
	CloudflareHostnameIdgt           *string  `json:"cloudflareHostnameIDGT,omitempty"`
	CloudflareHostnameIdgte          *string  `json:"cloudflareHostnameIDGTE,omitempty"`
	CloudflareHostnameIdlt           *string  `json:"cloudflareHostnameIDLT,omitempty"`
	CloudflareHostnameIdlte          *string  `json:"cloudflareHostnameIDLTE,omitempty"`
	CloudflareHostnameIDContains     *string  `json:"cloudflareHostnameIDContains,omitempty"`
	CloudflareHostnameIDHasPrefix    *string  `json:"cloudflareHostnameIDHasPrefix,omitempty"`
	CloudflareHostnameIDHasSuffix    *string  `json:"cloudflareHostnameIDHasSuffix,omitempty"`
	CloudflareHostnameIDEqualFold    *string  `json:"cloudflareHostnameIDEqualFold,omitempty"`
	CloudflareHostnameIDContainsFold *string  `json:"cloudflareHostnameIDContainsFold,omitempty"`
	// dns_txt_record field predicates
	DNSTxtRecord             *string  `json:"dnsTxtRecord,omitempty"`
	DNSTxtRecordNeq          *string  `json:"dnsTxtRecordNEQ,omitempty"`
	DNSTxtRecordIn           []string `json:"dnsTxtRecordIn,omitempty"`
	DNSTxtRecordNotIn        []string `json:"dnsTxtRecordNotIn,omitempty"`
	DNSTxtRecordGt           *string  `json:"dnsTxtRecordGT,omitempty"`
	DNSTxtRecordGte          *string  `json:"dnsTxtRecordGTE,omitempty"`
	DNSTxtRecordLt           *string  `json:"dnsTxtRecordLT,omitempty"`
	DNSTxtRecordLte          *string  `json:"dnsTxtRecordLTE,omitempty"`
	DNSTxtRecordContains     *string  `json:"dnsTxtRecordContains,omitempty"`
	DNSTxtRecordHasPrefix    *string  `json:"dnsTxtRecordHasPrefix,omitempty"`
	DNSTxtRecordHasSuffix    *string  `json:"dnsTxtRecordHasSuffix,omitempty"`
	DNSTxtRecordEqualFold    *string  `json:"dnsTxtRecordEqualFold,omitempty"`
	DNSTxtRecordContainsFold *string  `json:"dnsTxtRecordContainsFold,omitempty"`
	// dns_txt_value field predicates
	DNSTxtValue             *string  `json:"dnsTxtValue,omitempty"`
	DNSTxtValueNeq          *string  `json:"dnsTxtValueNEQ,omitempty"`
	DNSTxtValueIn           []string `json:"dnsTxtValueIn,omitempty"`
	DNSTxtValueNotIn        []string `json:"dnsTxtValueNotIn,omitempty"`
	DNSTxtValueGt           *string  `json:"dnsTxtValueGT,omitempty"`
	DNSTxtValueGte          *string  `json:"dnsTxtValueGTE,omitempty"`
	DNSTxtValueLt           *string  `json:"dnsTxtValueLT,omitempty"`
	DNSTxtValueLte          *string  `json:"dnsTxtValueLTE,omitempty"`
	DNSTxtValueContains     *string  `json:"dnsTxtValueContains,omitempty"`
	DNSTxtValueHasPrefix    *string  `json:"dnsTxtValueHasPrefix,omitempty"`
	DNSTxtValueHasSuffix    *string  `json:"dnsTxtValueHasSuffix,omitempty"`
	DNSTxtValueEqualFold    *string  `json:"dnsTxtValueEqualFold,omitempty"`
	DNSTxtValueContainsFold *string  `json:"dnsTxtValueContainsFold,omitempty"`
	// dns_verification_status field predicates
	DNSVerificationStatus      *enums.DNSVerificationStatus  `json:"dnsVerificationStatus,omitempty"`
	DNSVerificationStatusNeq   *enums.DNSVerificationStatus  `json:"dnsVerificationStatusNEQ,omitempty"`
	DNSVerificationStatusIn    []enums.DNSVerificationStatus `json:"dnsVerificationStatusIn,omitempty"`
	DNSVerificationStatusNotIn []enums.DNSVerificationStatus `json:"dnsVerificationStatusNotIn,omitempty"`
	// dns_verification_status_reason field predicates
	DNSVerificationStatusReason             *string  `json:"dnsVerificationStatusReason,omitempty"`
	DNSVerificationStatusReasonNeq          *string  `json:"dnsVerificationStatusReasonNEQ,omitempty"`
	DNSVerificationStatusReasonIn           []string `json:"dnsVerificationStatusReasonIn,omitempty"`
	DNSVerificationStatusReasonNotIn        []string `json:"dnsVerificationStatusReasonNotIn,omitempty"`
	DNSVerificationStatusReasonGt           *string  `json:"dnsVerificationStatusReasonGT,omitempty"`
	DNSVerificationStatusReasonGte          *string  `json:"dnsVerificationStatusReasonGTE,omitempty"`
	DNSVerificationStatusReasonLt           *string  `json:"dnsVerificationStatusReasonLT,omitempty"`
	DNSVerificationStatusReasonLte          *string  `json:"dnsVerificationStatusReasonLTE,omitempty"`
	DNSVerificationStatusReasonContains     *string  `json:"dnsVerificationStatusReasonContains,omitempty"`
	DNSVerificationStatusReasonHasPrefix    *string  `json:"dnsVerificationStatusReasonHasPrefix,omitempty"`
	DNSVerificationStatusReasonHasSuffix    *string  `json:"dnsVerificationStatusReasonHasSuffix,omitempty"`
	DNSVerificationStatusReasonIsNil        *bool    `json:"dnsVerificationStatusReasonIsNil,omitempty"`
	DNSVerificationStatusReasonNotNil       *bool    `json:"dnsVerificationStatusReasonNotNil,omitempty"`
	DNSVerificationStatusReasonEqualFold    *string  `json:"dnsVerificationStatusReasonEqualFold,omitempty"`
	DNSVerificationStatusReasonContainsFold *string  `json:"dnsVerificationStatusReasonContainsFold,omitempty"`
	// acme_challenge_path field predicates
	AcmeChallengePath             *string  `json:"acmeChallengePath,omitempty"`
	AcmeChallengePathNeq          *string  `json:"acmeChallengePathNEQ,omitempty"`
	AcmeChallengePathIn           []string `json:"acmeChallengePathIn,omitempty"`
	AcmeChallengePathNotIn        []string `json:"acmeChallengePathNotIn,omitempty"`
	AcmeChallengePathGt           *string  `json:"acmeChallengePathGT,omitempty"`
	AcmeChallengePathGte          *string  `json:"acmeChallengePathGTE,omitempty"`
	AcmeChallengePathLt           *string  `json:"acmeChallengePathLT,omitempty"`
	AcmeChallengePathLte          *string  `json:"acmeChallengePathLTE,omitempty"`
	AcmeChallengePathContains     *string  `json:"acmeChallengePathContains,omitempty"`
	AcmeChallengePathHasPrefix    *string  `json:"acmeChallengePathHasPrefix,omitempty"`
	AcmeChallengePathHasSuffix    *string  `json:"acmeChallengePathHasSuffix,omitempty"`
	AcmeChallengePathIsNil        *bool    `json:"acmeChallengePathIsNil,omitempty"`
	AcmeChallengePathNotNil       *bool    `json:"acmeChallengePathNotNil,omitempty"`
	AcmeChallengePathEqualFold    *string  `json:"acmeChallengePathEqualFold,omitempty"`
	AcmeChallengePathContainsFold *string  `json:"acmeChallengePathContainsFold,omitempty"`
	// expected_acme_challenge_value field predicates
	ExpectedAcmeChallengeValue             *string  `json:"expectedAcmeChallengeValue,omitempty"`
	ExpectedAcmeChallengeValueNeq          *string  `json:"expectedAcmeChallengeValueNEQ,omitempty"`
	ExpectedAcmeChallengeValueIn           []string `json:"expectedAcmeChallengeValueIn,omitempty"`
	ExpectedAcmeChallengeValueNotIn        []string `json:"expectedAcmeChallengeValueNotIn,omitempty"`
	ExpectedAcmeChallengeValueGt           *string  `json:"expectedAcmeChallengeValueGT,omitempty"`
	ExpectedAcmeChallengeValueGte          *string  `json:"expectedAcmeChallengeValueGTE,omitempty"`
	ExpectedAcmeChallengeValueLt           *string  `json:"expectedAcmeChallengeValueLT,omitempty"`
	ExpectedAcmeChallengeValueLte          *string  `json:"expectedAcmeChallengeValueLTE,omitempty"`
	ExpectedAcmeChallengeValueContains     *string  `json:"expectedAcmeChallengeValueContains,omitempty"`
	ExpectedAcmeChallengeValueHasPrefix    *string  `json:"expectedAcmeChallengeValueHasPrefix,omitempty"`
	ExpectedAcmeChallengeValueHasSuffix    *string  `json:"expectedAcmeChallengeValueHasSuffix,omitempty"`
	ExpectedAcmeChallengeValueIsNil        *bool    `json:"expectedAcmeChallengeValueIsNil,omitempty"`
	ExpectedAcmeChallengeValueNotNil       *bool    `json:"expectedAcmeChallengeValueNotNil,omitempty"`
	ExpectedAcmeChallengeValueEqualFold    *string  `json:"expectedAcmeChallengeValueEqualFold,omitempty"`
	ExpectedAcmeChallengeValueContainsFold *string  `json:"expectedAcmeChallengeValueContainsFold,omitempty"`
	// acme_challenge_status field predicates
	AcmeChallengeStatus      *enums.SSLVerificationStatus  `json:"acmeChallengeStatus,omitempty"`
	AcmeChallengeStatusNeq   *enums.SSLVerificationStatus  `json:"acmeChallengeStatusNEQ,omitempty"`
	AcmeChallengeStatusIn    []enums.SSLVerificationStatus `json:"acmeChallengeStatusIn,omitempty"`
	AcmeChallengeStatusNotIn []enums.SSLVerificationStatus `json:"acmeChallengeStatusNotIn,omitempty"`
	// acme_challenge_status_reason field predicates
	AcmeChallengeStatusReason             *string  `json:"acmeChallengeStatusReason,omitempty"`
	AcmeChallengeStatusReasonNeq          *string  `json:"acmeChallengeStatusReasonNEQ,omitempty"`
	AcmeChallengeStatusReasonIn           []string `json:"acmeChallengeStatusReasonIn,omitempty"`
	AcmeChallengeStatusReasonNotIn        []string `json:"acmeChallengeStatusReasonNotIn,omitempty"`
	AcmeChallengeStatusReasonGt           *string  `json:"acmeChallengeStatusReasonGT,omitempty"`
	AcmeChallengeStatusReasonGte          *string  `json:"acmeChallengeStatusReasonGTE,omitempty"`
	AcmeChallengeStatusReasonLt           *string  `json:"acmeChallengeStatusReasonLT,omitempty"`
	AcmeChallengeStatusReasonLte          *string  `json:"acmeChallengeStatusReasonLTE,omitempty"`
	AcmeChallengeStatusReasonContains     *string  `json:"acmeChallengeStatusReasonContains,omitempty"`
	AcmeChallengeStatusReasonHasPrefix    *string  `json:"acmeChallengeStatusReasonHasPrefix,omitempty"`
	AcmeChallengeStatusReasonHasSuffix    *string  `json:"acmeChallengeStatusReasonHasSuffix,omitempty"`
	AcmeChallengeStatusReasonIsNil        *bool    `json:"acmeChallengeStatusReasonIsNil,omitempty"`
	AcmeChallengeStatusReasonNotNil       *bool    `json:"acmeChallengeStatusReasonNotNil,omitempty"`
	AcmeChallengeStatusReasonEqualFold    *string  `json:"acmeChallengeStatusReasonEqualFold,omitempty"`
	AcmeChallengeStatusReasonContainsFold *string  `json:"acmeChallengeStatusReasonContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// custom_domains edge predicates
	HasCustomDomains     *bool                     `json:"hasCustomDomains,omitempty"`
	HasCustomDomainsWith []*CustomDomainWhereInput `json:"hasCustomDomainsWith,omitempty"`
}

type DirectoryAccount struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// integration that owns this directory account
	IntegrationID string `json:"integrationID"`
	// sync run that produced this snapshot
	DirectorySyncRunID string `json:"directorySyncRunID"`
	// stable identifier from the directory system
	ExternalID string `json:"externalID"`
	// optional secondary identifier such as Azure immutable ID
	SecondaryKey *string `json:"secondaryKey,omitempty"`
	// lower-cased primary email address, if present
	CanonicalEmail *string `json:"canonicalEmail,omitempty"`
	// provider supplied display name
	DisplayName *string `json:"displayName,omitempty"`
	// first name reported by the provider
	GivenName *string `json:"givenName,omitempty"`
	// last name reported by the provider
	FamilyName *string `json:"familyName,omitempty"`
	// title captured at sync time
	JobTitle *string `json:"jobTitle,omitempty"`
	// department captured at sync time
	Department *string `json:"department,omitempty"`
	// organizational unit or OU path the account lives under
	OrganizationUnit *string `json:"organizationUnit,omitempty"`
	// type of principal represented in the directory
	AccountType *enums.DirectoryAccountType `json:"accountType,omitempty"`
	// lifecycle status returned by the directory
	Status enums.DirectoryAccountStatus `json:"status"`
	// multi-factor authentication state reported by the directory
	MfaState enums.DirectoryAccountMFAState `json:"mfaState"`
	// last IP address observed by the provider, if any
	LastSeenIP *string `json:"lastSeenIP,omitempty"`
	// timestamp of the most recent login reported by the provider
	LastLoginAt *time.Time `json:"lastLoginAt,omitempty"`
	// time when this snapshot was recorded
	ObservedAt time.Time `json:"observedAt"`
	// hash of the normalized profile payload for change detection
	ProfileHash string `json:"profileHash"`
	// flattened attribute bag used for filtering/diffing
	Profile map[string]any `json:"profile,omitempty"`
	// object storage file identifier that holds the raw upstream payload
	RawProfileFileID *string `json:"rawProfileFileID,omitempty"`
	// cursor or ETag supplied by the source system for auditing
	SourceVersion *string       `json:"sourceVersion,omitempty"`
	Owner         *Organization `json:"owner,omitempty"`
	// integration that owns this directory account
	Integration *Integration `json:"integration"`
	// sync run that produced this snapshot
	DirectorySyncRun   *DirectorySyncRun              `json:"directorySyncRun"`
	Groups             *DirectoryGroupConnection      `json:"groups"`
	WorkflowObjectRefs *WorkflowObjectRefConnection   `json:"workflowObjectRefs"`
	Memberships        *DirectoryMembershipConnection `json:"memberships"`
}

func (DirectoryAccount) IsNode() {}

// Return response for createBulkDirectoryAccount mutation
type DirectoryAccountBulkCreatePayload struct {
	// Created directoryAccounts
	DirectoryAccounts []*DirectoryAccount `json:"directoryAccounts,omitempty"`
}

// A connection to a list of items.
type DirectoryAccountConnection struct {
	// A list of edges.
	Edges []*DirectoryAccountEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDirectoryAccount mutation
type DirectoryAccountCreatePayload struct {
	// Created directoryAccount
	DirectoryAccount *DirectoryAccount `json:"directoryAccount"`
}

// Return response for deleteDirectoryAccount mutation
type DirectoryAccountDeletePayload struct {
	// Deleted directoryAccount ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DirectoryAccountEdge struct {
	// The item at the end of the edge.
	Node *DirectoryAccount `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DirectoryAccountHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// integration that owns this directory account
	IntegrationID string `json:"integrationID"`
	// sync run that produced this snapshot
	DirectorySyncRunID string `json:"directorySyncRunID"`
	// stable identifier from the directory system
	ExternalID string `json:"externalID"`
	// optional secondary identifier such as Azure immutable ID
	SecondaryKey *string `json:"secondaryKey,omitempty"`
	// lower-cased primary email address, if present
	CanonicalEmail *string `json:"canonicalEmail,omitempty"`
	// provider supplied display name
	DisplayName *string `json:"displayName,omitempty"`
	// first name reported by the provider
	GivenName *string `json:"givenName,omitempty"`
	// last name reported by the provider
	FamilyName *string `json:"familyName,omitempty"`
	// title captured at sync time
	JobTitle *string `json:"jobTitle,omitempty"`
	// department captured at sync time
	Department *string `json:"department,omitempty"`
	// organizational unit or OU path the account lives under
	OrganizationUnit *string `json:"organizationUnit,omitempty"`
	// type of principal represented in the directory
	AccountType *enums.DirectoryAccountType `json:"accountType,omitempty"`
	// lifecycle status returned by the directory
	Status enums.DirectoryAccountStatus `json:"status"`
	// multi-factor authentication state reported by the directory
	MfaState enums.DirectoryAccountMFAState `json:"mfaState"`
	// last IP address observed by the provider, if any
	LastSeenIP *string `json:"lastSeenIP,omitempty"`
	// timestamp of the most recent login reported by the provider
	LastLoginAt *time.Time `json:"lastLoginAt,omitempty"`
	// time when this snapshot was recorded
	ObservedAt time.Time `json:"observedAt"`
	// hash of the normalized profile payload for change detection
	ProfileHash string `json:"profileHash"`
	// flattened attribute bag used for filtering/diffing
	Profile map[string]any `json:"profile,omitempty"`
	// object storage file identifier that holds the raw upstream payload
	RawProfileFileID *string `json:"rawProfileFileID,omitempty"`
	// cursor or ETag supplied by the source system for auditing
	SourceVersion *string `json:"sourceVersion,omitempty"`
}

func (DirectoryAccountHistory) IsNode() {}

// A connection to a list of items.
type DirectoryAccountHistoryConnection struct {
	// A list of edges.
	Edges []*DirectoryAccountHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DirectoryAccountHistoryEdge struct {
	// The item at the end of the edge.
	Node *DirectoryAccountHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for DirectoryAccountHistory connections
type DirectoryAccountHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DirectoryAccountHistories.
	Field DirectoryAccountHistoryOrderField `json:"field"`
}

// DirectoryAccountHistoryWhereInput is used for filtering DirectoryAccountHistory objects.
// Input was generated by ent.
type DirectoryAccountHistoryWhereInput struct {
	Not *DirectoryAccountHistoryWhereInput   `json:"not,omitempty"`
	And []*DirectoryAccountHistoryWhereInput `json:"and,omitempty"`
	Or  []*DirectoryAccountHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// integration_id field predicates
	IntegrationID             *string  `json:"integrationID,omitempty"`
	IntegrationIdneq          *string  `json:"integrationIDNEQ,omitempty"`
	IntegrationIDIn           []string `json:"integrationIDIn,omitempty"`
	IntegrationIDNotIn        []string `json:"integrationIDNotIn,omitempty"`
	IntegrationIdgt           *string  `json:"integrationIDGT,omitempty"`
	IntegrationIdgte          *string  `json:"integrationIDGTE,omitempty"`
	IntegrationIdlt           *string  `json:"integrationIDLT,omitempty"`
	IntegrationIdlte          *string  `json:"integrationIDLTE,omitempty"`
	IntegrationIDContains     *string  `json:"integrationIDContains,omitempty"`
	IntegrationIDHasPrefix    *string  `json:"integrationIDHasPrefix,omitempty"`
	IntegrationIDHasSuffix    *string  `json:"integrationIDHasSuffix,omitempty"`
	IntegrationIDEqualFold    *string  `json:"integrationIDEqualFold,omitempty"`
	IntegrationIDContainsFold *string  `json:"integrationIDContainsFold,omitempty"`
	// directory_sync_run_id field predicates
	DirectorySyncRunID             *string  `json:"directorySyncRunID,omitempty"`
	DirectorySyncRunIdneq          *string  `json:"directorySyncRunIDNEQ,omitempty"`
	DirectorySyncRunIDIn           []string `json:"directorySyncRunIDIn,omitempty"`
	DirectorySyncRunIDNotIn        []string `json:"directorySyncRunIDNotIn,omitempty"`
	DirectorySyncRunIdgt           *string  `json:"directorySyncRunIDGT,omitempty"`
	DirectorySyncRunIdgte          *string  `json:"directorySyncRunIDGTE,omitempty"`
	DirectorySyncRunIdlt           *string  `json:"directorySyncRunIDLT,omitempty"`
	DirectorySyncRunIdlte          *string  `json:"directorySyncRunIDLTE,omitempty"`
	DirectorySyncRunIDContains     *string  `json:"directorySyncRunIDContains,omitempty"`
	DirectorySyncRunIDHasPrefix    *string  `json:"directorySyncRunIDHasPrefix,omitempty"`
	DirectorySyncRunIDHasSuffix    *string  `json:"directorySyncRunIDHasSuffix,omitempty"`
	DirectorySyncRunIDEqualFold    *string  `json:"directorySyncRunIDEqualFold,omitempty"`
	DirectorySyncRunIDContainsFold *string  `json:"directorySyncRunIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// secondary_key field predicates
	SecondaryKey             *string  `json:"secondaryKey,omitempty"`
	SecondaryKeyNeq          *string  `json:"secondaryKeyNEQ,omitempty"`
	SecondaryKeyIn           []string `json:"secondaryKeyIn,omitempty"`
	SecondaryKeyNotIn        []string `json:"secondaryKeyNotIn,omitempty"`
	SecondaryKeyGt           *string  `json:"secondaryKeyGT,omitempty"`
	SecondaryKeyGte          *string  `json:"secondaryKeyGTE,omitempty"`
	SecondaryKeyLt           *string  `json:"secondaryKeyLT,omitempty"`
	SecondaryKeyLte          *string  `json:"secondaryKeyLTE,omitempty"`
	SecondaryKeyContains     *string  `json:"secondaryKeyContains,omitempty"`
	SecondaryKeyHasPrefix    *string  `json:"secondaryKeyHasPrefix,omitempty"`
	SecondaryKeyHasSuffix    *string  `json:"secondaryKeyHasSuffix,omitempty"`
	SecondaryKeyIsNil        *bool    `json:"secondaryKeyIsNil,omitempty"`
	SecondaryKeyNotNil       *bool    `json:"secondaryKeyNotNil,omitempty"`
	SecondaryKeyEqualFold    *string  `json:"secondaryKeyEqualFold,omitempty"`
	SecondaryKeyContainsFold *string  `json:"secondaryKeyContainsFold,omitempty"`
	// canonical_email field predicates
	CanonicalEmail             *string  `json:"canonicalEmail,omitempty"`
	CanonicalEmailNeq          *string  `json:"canonicalEmailNEQ,omitempty"`
	CanonicalEmailIn           []string `json:"canonicalEmailIn,omitempty"`
	CanonicalEmailNotIn        []string `json:"canonicalEmailNotIn,omitempty"`
	CanonicalEmailGt           *string  `json:"canonicalEmailGT,omitempty"`
	CanonicalEmailGte          *string  `json:"canonicalEmailGTE,omitempty"`
	CanonicalEmailLt           *string  `json:"canonicalEmailLT,omitempty"`
	CanonicalEmailLte          *string  `json:"canonicalEmailLTE,omitempty"`
	CanonicalEmailContains     *string  `json:"canonicalEmailContains,omitempty"`
	CanonicalEmailHasPrefix    *string  `json:"canonicalEmailHasPrefix,omitempty"`
	CanonicalEmailHasSuffix    *string  `json:"canonicalEmailHasSuffix,omitempty"`
	CanonicalEmailIsNil        *bool    `json:"canonicalEmailIsNil,omitempty"`
	CanonicalEmailNotNil       *bool    `json:"canonicalEmailNotNil,omitempty"`
	CanonicalEmailEqualFold    *string  `json:"canonicalEmailEqualFold,omitempty"`
	CanonicalEmailContainsFold *string  `json:"canonicalEmailContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// given_name field predicates
	GivenName             *string  `json:"givenName,omitempty"`
	GivenNameNeq          *string  `json:"givenNameNEQ,omitempty"`
	GivenNameIn           []string `json:"givenNameIn,omitempty"`
	GivenNameNotIn        []string `json:"givenNameNotIn,omitempty"`
	GivenNameGt           *string  `json:"givenNameGT,omitempty"`
	GivenNameGte          *string  `json:"givenNameGTE,omitempty"`
	GivenNameLt           *string  `json:"givenNameLT,omitempty"`
	GivenNameLte          *string  `json:"givenNameLTE,omitempty"`
	GivenNameContains     *string  `json:"givenNameContains,omitempty"`
	GivenNameHasPrefix    *string  `json:"givenNameHasPrefix,omitempty"`
	GivenNameHasSuffix    *string  `json:"givenNameHasSuffix,omitempty"`
	GivenNameIsNil        *bool    `json:"givenNameIsNil,omitempty"`
	GivenNameNotNil       *bool    `json:"givenNameNotNil,omitempty"`
	GivenNameEqualFold    *string  `json:"givenNameEqualFold,omitempty"`
	GivenNameContainsFold *string  `json:"givenNameContainsFold,omitempty"`
	// family_name field predicates
	FamilyName             *string  `json:"familyName,omitempty"`
	FamilyNameNeq          *string  `json:"familyNameNEQ,omitempty"`
	FamilyNameIn           []string `json:"familyNameIn,omitempty"`
	FamilyNameNotIn        []string `json:"familyNameNotIn,omitempty"`
	FamilyNameGt           *string  `json:"familyNameGT,omitempty"`
	FamilyNameGte          *string  `json:"familyNameGTE,omitempty"`
	FamilyNameLt           *string  `json:"familyNameLT,omitempty"`
	FamilyNameLte          *string  `json:"familyNameLTE,omitempty"`
	FamilyNameContains     *string  `json:"familyNameContains,omitempty"`
	FamilyNameHasPrefix    *string  `json:"familyNameHasPrefix,omitempty"`
	FamilyNameHasSuffix    *string  `json:"familyNameHasSuffix,omitempty"`
	FamilyNameIsNil        *bool    `json:"familyNameIsNil,omitempty"`
	FamilyNameNotNil       *bool    `json:"familyNameNotNil,omitempty"`
	FamilyNameEqualFold    *string  `json:"familyNameEqualFold,omitempty"`
	FamilyNameContainsFold *string  `json:"familyNameContainsFold,omitempty"`
	// job_title field predicates
	JobTitle             *string  `json:"jobTitle,omitempty"`
	JobTitleNeq          *string  `json:"jobTitleNEQ,omitempty"`
	JobTitleIn           []string `json:"jobTitleIn,omitempty"`
	JobTitleNotIn        []string `json:"jobTitleNotIn,omitempty"`
	JobTitleGt           *string  `json:"jobTitleGT,omitempty"`
	JobTitleGte          *string  `json:"jobTitleGTE,omitempty"`
	JobTitleLt           *string  `json:"jobTitleLT,omitempty"`
	JobTitleLte          *string  `json:"jobTitleLTE,omitempty"`
	JobTitleContains     *string  `json:"jobTitleContains,omitempty"`
	JobTitleHasPrefix    *string  `json:"jobTitleHasPrefix,omitempty"`
	JobTitleHasSuffix    *string  `json:"jobTitleHasSuffix,omitempty"`
	JobTitleIsNil        *bool    `json:"jobTitleIsNil,omitempty"`
	JobTitleNotNil       *bool    `json:"jobTitleNotNil,omitempty"`
	JobTitleEqualFold    *string  `json:"jobTitleEqualFold,omitempty"`
	JobTitleContainsFold *string  `json:"jobTitleContainsFold,omitempty"`
	// department field predicates
	Department             *string  `json:"department,omitempty"`
	DepartmentNeq          *string  `json:"departmentNEQ,omitempty"`
	DepartmentIn           []string `json:"departmentIn,omitempty"`
	DepartmentNotIn        []string `json:"departmentNotIn,omitempty"`
	DepartmentGt           *string  `json:"departmentGT,omitempty"`
	DepartmentGte          *string  `json:"departmentGTE,omitempty"`
	DepartmentLt           *string  `json:"departmentLT,omitempty"`
	DepartmentLte          *string  `json:"departmentLTE,omitempty"`
	DepartmentContains     *string  `json:"departmentContains,omitempty"`
	DepartmentHasPrefix    *string  `json:"departmentHasPrefix,omitempty"`
	DepartmentHasSuffix    *string  `json:"departmentHasSuffix,omitempty"`
	DepartmentIsNil        *bool    `json:"departmentIsNil,omitempty"`
	DepartmentNotNil       *bool    `json:"departmentNotNil,omitempty"`
	DepartmentEqualFold    *string  `json:"departmentEqualFold,omitempty"`
	DepartmentContainsFold *string  `json:"departmentContainsFold,omitempty"`
	// organization_unit field predicates
	OrganizationUnit             *string  `json:"organizationUnit,omitempty"`
	OrganizationUnitNeq          *string  `json:"organizationUnitNEQ,omitempty"`
	OrganizationUnitIn           []string `json:"organizationUnitIn,omitempty"`
	OrganizationUnitNotIn        []string `json:"organizationUnitNotIn,omitempty"`
	OrganizationUnitGt           *string  `json:"organizationUnitGT,omitempty"`
	OrganizationUnitGte          *string  `json:"organizationUnitGTE,omitempty"`
	OrganizationUnitLt           *string  `json:"organizationUnitLT,omitempty"`
	OrganizationUnitLte          *string  `json:"organizationUnitLTE,omitempty"`
	OrganizationUnitContains     *string  `json:"organizationUnitContains,omitempty"`
	OrganizationUnitHasPrefix    *string  `json:"organizationUnitHasPrefix,omitempty"`
	OrganizationUnitHasSuffix    *string  `json:"organizationUnitHasSuffix,omitempty"`
	OrganizationUnitIsNil        *bool    `json:"organizationUnitIsNil,omitempty"`
	OrganizationUnitNotNil       *bool    `json:"organizationUnitNotNil,omitempty"`
	OrganizationUnitEqualFold    *string  `json:"organizationUnitEqualFold,omitempty"`
	OrganizationUnitContainsFold *string  `json:"organizationUnitContainsFold,omitempty"`
	// account_type field predicates
	AccountType       *enums.DirectoryAccountType  `json:"accountType,omitempty"`
	AccountTypeNeq    *enums.DirectoryAccountType  `json:"accountTypeNEQ,omitempty"`
	AccountTypeIn     []enums.DirectoryAccountType `json:"accountTypeIn,omitempty"`
	AccountTypeNotIn  []enums.DirectoryAccountType `json:"accountTypeNotIn,omitempty"`
	AccountTypeIsNil  *bool                        `json:"accountTypeIsNil,omitempty"`
	AccountTypeNotNil *bool                        `json:"accountTypeNotNil,omitempty"`
	// status field predicates
	Status      *enums.DirectoryAccountStatus  `json:"status,omitempty"`
	StatusNeq   *enums.DirectoryAccountStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.DirectoryAccountStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.DirectoryAccountStatus `json:"statusNotIn,omitempty"`
	// mfa_state field predicates
	MfaState      *enums.DirectoryAccountMFAState  `json:"mfaState,omitempty"`
	MfaStateNeq   *enums.DirectoryAccountMFAState  `json:"mfaStateNEQ,omitempty"`
	MfaStateIn    []enums.DirectoryAccountMFAState `json:"mfaStateIn,omitempty"`
	MfaStateNotIn []enums.DirectoryAccountMFAState `json:"mfaStateNotIn,omitempty"`
	// last_seen_ip field predicates
	LastSeenIP             *string  `json:"lastSeenIP,omitempty"`
	LastSeenIpneq          *string  `json:"lastSeenIPNEQ,omitempty"`
	LastSeenIPIn           []string `json:"lastSeenIPIn,omitempty"`
	LastSeenIPNotIn        []string `json:"lastSeenIPNotIn,omitempty"`
	LastSeenIpgt           *string  `json:"lastSeenIPGT,omitempty"`
	LastSeenIpgte          *string  `json:"lastSeenIPGTE,omitempty"`
	LastSeenIplt           *string  `json:"lastSeenIPLT,omitempty"`
	LastSeenIplte          *string  `json:"lastSeenIPLTE,omitempty"`
	LastSeenIPContains     *string  `json:"lastSeenIPContains,omitempty"`
	LastSeenIPHasPrefix    *string  `json:"lastSeenIPHasPrefix,omitempty"`
	LastSeenIPHasSuffix    *string  `json:"lastSeenIPHasSuffix,omitempty"`
	LastSeenIPIsNil        *bool    `json:"lastSeenIPIsNil,omitempty"`
	LastSeenIPNotNil       *bool    `json:"lastSeenIPNotNil,omitempty"`
	LastSeenIPEqualFold    *string  `json:"lastSeenIPEqualFold,omitempty"`
	LastSeenIPContainsFold *string  `json:"lastSeenIPContainsFold,omitempty"`
	// last_login_at field predicates
	LastLoginAt       *time.Time   `json:"lastLoginAt,omitempty"`
	LastLoginAtNeq    *time.Time   `json:"lastLoginAtNEQ,omitempty"`
	LastLoginAtIn     []*time.Time `json:"lastLoginAtIn,omitempty"`
	LastLoginAtNotIn  []*time.Time `json:"lastLoginAtNotIn,omitempty"`
	LastLoginAtGt     *time.Time   `json:"lastLoginAtGT,omitempty"`
	LastLoginAtGte    *time.Time   `json:"lastLoginAtGTE,omitempty"`
	LastLoginAtLt     *time.Time   `json:"lastLoginAtLT,omitempty"`
	LastLoginAtLte    *time.Time   `json:"lastLoginAtLTE,omitempty"`
	LastLoginAtIsNil  *bool        `json:"lastLoginAtIsNil,omitempty"`
	LastLoginAtNotNil *bool        `json:"lastLoginAtNotNil,omitempty"`
	// observed_at field predicates
	ObservedAt      *time.Time   `json:"observedAt,omitempty"`
	ObservedAtNeq   *time.Time   `json:"observedAtNEQ,omitempty"`
	ObservedAtIn    []*time.Time `json:"observedAtIn,omitempty"`
	ObservedAtNotIn []*time.Time `json:"observedAtNotIn,omitempty"`
	ObservedAtGt    *time.Time   `json:"observedAtGT,omitempty"`
	ObservedAtGte   *time.Time   `json:"observedAtGTE,omitempty"`
	ObservedAtLt    *time.Time   `json:"observedAtLT,omitempty"`
	ObservedAtLte   *time.Time   `json:"observedAtLTE,omitempty"`
	// profile_hash field predicates
	ProfileHash             *string  `json:"profileHash,omitempty"`
	ProfileHashNeq          *string  `json:"profileHashNEQ,omitempty"`
	ProfileHashIn           []string `json:"profileHashIn,omitempty"`
	ProfileHashNotIn        []string `json:"profileHashNotIn,omitempty"`
	ProfileHashGt           *string  `json:"profileHashGT,omitempty"`
	ProfileHashGte          *string  `json:"profileHashGTE,omitempty"`
	ProfileHashLt           *string  `json:"profileHashLT,omitempty"`
	ProfileHashLte          *string  `json:"profileHashLTE,omitempty"`
	ProfileHashContains     *string  `json:"profileHashContains,omitempty"`
	ProfileHashHasPrefix    *string  `json:"profileHashHasPrefix,omitempty"`
	ProfileHashHasSuffix    *string  `json:"profileHashHasSuffix,omitempty"`
	ProfileHashEqualFold    *string  `json:"profileHashEqualFold,omitempty"`
	ProfileHashContainsFold *string  `json:"profileHashContainsFold,omitempty"`
	// source_version field predicates
	SourceVersion             *string  `json:"sourceVersion,omitempty"`
	SourceVersionNeq          *string  `json:"sourceVersionNEQ,omitempty"`
	SourceVersionIn           []string `json:"sourceVersionIn,omitempty"`
	SourceVersionNotIn        []string `json:"sourceVersionNotIn,omitempty"`
	SourceVersionGt           *string  `json:"sourceVersionGT,omitempty"`
	SourceVersionGte          *string  `json:"sourceVersionGTE,omitempty"`
	SourceVersionLt           *string  `json:"sourceVersionLT,omitempty"`
	SourceVersionLte          *string  `json:"sourceVersionLTE,omitempty"`
	SourceVersionContains     *string  `json:"sourceVersionContains,omitempty"`
	SourceVersionHasPrefix    *string  `json:"sourceVersionHasPrefix,omitempty"`
	SourceVersionHasSuffix    *string  `json:"sourceVersionHasSuffix,omitempty"`
	SourceVersionIsNil        *bool    `json:"sourceVersionIsNil,omitempty"`
	SourceVersionNotNil       *bool    `json:"sourceVersionNotNil,omitempty"`
	SourceVersionEqualFold    *string  `json:"sourceVersionEqualFold,omitempty"`
	SourceVersionContainsFold *string  `json:"sourceVersionContainsFold,omitempty"`
}

// Ordering options for DirectoryAccount connections
type DirectoryAccountOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DirectoryAccounts.
	Field DirectoryAccountOrderField `json:"field"`
}

// Return response for updateDirectoryAccount mutation
type DirectoryAccountUpdatePayload struct {
	// Updated directoryAccount
	DirectoryAccount *DirectoryAccount `json:"directoryAccount"`
}

// DirectoryAccountWhereInput is used for filtering DirectoryAccount objects.
// Input was generated by ent.
type DirectoryAccountWhereInput struct {
	Not *DirectoryAccountWhereInput   `json:"not,omitempty"`
	And []*DirectoryAccountWhereInput `json:"and,omitempty"`
	Or  []*DirectoryAccountWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// integration_id field predicates
	IntegrationID             *string  `json:"integrationID,omitempty"`
	IntegrationIdneq          *string  `json:"integrationIDNEQ,omitempty"`
	IntegrationIDIn           []string `json:"integrationIDIn,omitempty"`
	IntegrationIDNotIn        []string `json:"integrationIDNotIn,omitempty"`
	IntegrationIdgt           *string  `json:"integrationIDGT,omitempty"`
	IntegrationIdgte          *string  `json:"integrationIDGTE,omitempty"`
	IntegrationIdlt           *string  `json:"integrationIDLT,omitempty"`
	IntegrationIdlte          *string  `json:"integrationIDLTE,omitempty"`
	IntegrationIDContains     *string  `json:"integrationIDContains,omitempty"`
	IntegrationIDHasPrefix    *string  `json:"integrationIDHasPrefix,omitempty"`
	IntegrationIDHasSuffix    *string  `json:"integrationIDHasSuffix,omitempty"`
	IntegrationIDEqualFold    *string  `json:"integrationIDEqualFold,omitempty"`
	IntegrationIDContainsFold *string  `json:"integrationIDContainsFold,omitempty"`
	// directory_sync_run_id field predicates
	DirectorySyncRunID             *string  `json:"directorySyncRunID,omitempty"`
	DirectorySyncRunIdneq          *string  `json:"directorySyncRunIDNEQ,omitempty"`
	DirectorySyncRunIDIn           []string `json:"directorySyncRunIDIn,omitempty"`
	DirectorySyncRunIDNotIn        []string `json:"directorySyncRunIDNotIn,omitempty"`
	DirectorySyncRunIdgt           *string  `json:"directorySyncRunIDGT,omitempty"`
	DirectorySyncRunIdgte          *string  `json:"directorySyncRunIDGTE,omitempty"`
	DirectorySyncRunIdlt           *string  `json:"directorySyncRunIDLT,omitempty"`
	DirectorySyncRunIdlte          *string  `json:"directorySyncRunIDLTE,omitempty"`
	DirectorySyncRunIDContains     *string  `json:"directorySyncRunIDContains,omitempty"`
	DirectorySyncRunIDHasPrefix    *string  `json:"directorySyncRunIDHasPrefix,omitempty"`
	DirectorySyncRunIDHasSuffix    *string  `json:"directorySyncRunIDHasSuffix,omitempty"`
	DirectorySyncRunIDEqualFold    *string  `json:"directorySyncRunIDEqualFold,omitempty"`
	DirectorySyncRunIDContainsFold *string  `json:"directorySyncRunIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// secondary_key field predicates
	SecondaryKey             *string  `json:"secondaryKey,omitempty"`
	SecondaryKeyNeq          *string  `json:"secondaryKeyNEQ,omitempty"`
	SecondaryKeyIn           []string `json:"secondaryKeyIn,omitempty"`
	SecondaryKeyNotIn        []string `json:"secondaryKeyNotIn,omitempty"`
	SecondaryKeyGt           *string  `json:"secondaryKeyGT,omitempty"`
	SecondaryKeyGte          *string  `json:"secondaryKeyGTE,omitempty"`
	SecondaryKeyLt           *string  `json:"secondaryKeyLT,omitempty"`
	SecondaryKeyLte          *string  `json:"secondaryKeyLTE,omitempty"`
	SecondaryKeyContains     *string  `json:"secondaryKeyContains,omitempty"`
	SecondaryKeyHasPrefix    *string  `json:"secondaryKeyHasPrefix,omitempty"`
	SecondaryKeyHasSuffix    *string  `json:"secondaryKeyHasSuffix,omitempty"`
	SecondaryKeyIsNil        *bool    `json:"secondaryKeyIsNil,omitempty"`
	SecondaryKeyNotNil       *bool    `json:"secondaryKeyNotNil,omitempty"`
	SecondaryKeyEqualFold    *string  `json:"secondaryKeyEqualFold,omitempty"`
	SecondaryKeyContainsFold *string  `json:"secondaryKeyContainsFold,omitempty"`
	// canonical_email field predicates
	CanonicalEmail             *string  `json:"canonicalEmail,omitempty"`
	CanonicalEmailNeq          *string  `json:"canonicalEmailNEQ,omitempty"`
	CanonicalEmailIn           []string `json:"canonicalEmailIn,omitempty"`
	CanonicalEmailNotIn        []string `json:"canonicalEmailNotIn,omitempty"`
	CanonicalEmailGt           *string  `json:"canonicalEmailGT,omitempty"`
	CanonicalEmailGte          *string  `json:"canonicalEmailGTE,omitempty"`
	CanonicalEmailLt           *string  `json:"canonicalEmailLT,omitempty"`
	CanonicalEmailLte          *string  `json:"canonicalEmailLTE,omitempty"`
	CanonicalEmailContains     *string  `json:"canonicalEmailContains,omitempty"`
	CanonicalEmailHasPrefix    *string  `json:"canonicalEmailHasPrefix,omitempty"`
	CanonicalEmailHasSuffix    *string  `json:"canonicalEmailHasSuffix,omitempty"`
	CanonicalEmailIsNil        *bool    `json:"canonicalEmailIsNil,omitempty"`
	CanonicalEmailNotNil       *bool    `json:"canonicalEmailNotNil,omitempty"`
	CanonicalEmailEqualFold    *string  `json:"canonicalEmailEqualFold,omitempty"`
	CanonicalEmailContainsFold *string  `json:"canonicalEmailContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// given_name field predicates
	GivenName             *string  `json:"givenName,omitempty"`
	GivenNameNeq          *string  `json:"givenNameNEQ,omitempty"`
	GivenNameIn           []string `json:"givenNameIn,omitempty"`
	GivenNameNotIn        []string `json:"givenNameNotIn,omitempty"`
	GivenNameGt           *string  `json:"givenNameGT,omitempty"`
	GivenNameGte          *string  `json:"givenNameGTE,omitempty"`
	GivenNameLt           *string  `json:"givenNameLT,omitempty"`
	GivenNameLte          *string  `json:"givenNameLTE,omitempty"`
	GivenNameContains     *string  `json:"givenNameContains,omitempty"`
	GivenNameHasPrefix    *string  `json:"givenNameHasPrefix,omitempty"`
	GivenNameHasSuffix    *string  `json:"givenNameHasSuffix,omitempty"`
	GivenNameIsNil        *bool    `json:"givenNameIsNil,omitempty"`
	GivenNameNotNil       *bool    `json:"givenNameNotNil,omitempty"`
	GivenNameEqualFold    *string  `json:"givenNameEqualFold,omitempty"`
	GivenNameContainsFold *string  `json:"givenNameContainsFold,omitempty"`
	// family_name field predicates
	FamilyName             *string  `json:"familyName,omitempty"`
	FamilyNameNeq          *string  `json:"familyNameNEQ,omitempty"`
	FamilyNameIn           []string `json:"familyNameIn,omitempty"`
	FamilyNameNotIn        []string `json:"familyNameNotIn,omitempty"`
	FamilyNameGt           *string  `json:"familyNameGT,omitempty"`
	FamilyNameGte          *string  `json:"familyNameGTE,omitempty"`
	FamilyNameLt           *string  `json:"familyNameLT,omitempty"`
	FamilyNameLte          *string  `json:"familyNameLTE,omitempty"`
	FamilyNameContains     *string  `json:"familyNameContains,omitempty"`
	FamilyNameHasPrefix    *string  `json:"familyNameHasPrefix,omitempty"`
	FamilyNameHasSuffix    *string  `json:"familyNameHasSuffix,omitempty"`
	FamilyNameIsNil        *bool    `json:"familyNameIsNil,omitempty"`
	FamilyNameNotNil       *bool    `json:"familyNameNotNil,omitempty"`
	FamilyNameEqualFold    *string  `json:"familyNameEqualFold,omitempty"`
	FamilyNameContainsFold *string  `json:"familyNameContainsFold,omitempty"`
	// job_title field predicates
	JobTitle             *string  `json:"jobTitle,omitempty"`
	JobTitleNeq          *string  `json:"jobTitleNEQ,omitempty"`
	JobTitleIn           []string `json:"jobTitleIn,omitempty"`
	JobTitleNotIn        []string `json:"jobTitleNotIn,omitempty"`
	JobTitleGt           *string  `json:"jobTitleGT,omitempty"`
	JobTitleGte          *string  `json:"jobTitleGTE,omitempty"`
	JobTitleLt           *string  `json:"jobTitleLT,omitempty"`
	JobTitleLte          *string  `json:"jobTitleLTE,omitempty"`
	JobTitleContains     *string  `json:"jobTitleContains,omitempty"`
	JobTitleHasPrefix    *string  `json:"jobTitleHasPrefix,omitempty"`
	JobTitleHasSuffix    *string  `json:"jobTitleHasSuffix,omitempty"`
	JobTitleIsNil        *bool    `json:"jobTitleIsNil,omitempty"`
	JobTitleNotNil       *bool    `json:"jobTitleNotNil,omitempty"`
	JobTitleEqualFold    *string  `json:"jobTitleEqualFold,omitempty"`
	JobTitleContainsFold *string  `json:"jobTitleContainsFold,omitempty"`
	// department field predicates
	Department             *string  `json:"department,omitempty"`
	DepartmentNeq          *string  `json:"departmentNEQ,omitempty"`
	DepartmentIn           []string `json:"departmentIn,omitempty"`
	DepartmentNotIn        []string `json:"departmentNotIn,omitempty"`
	DepartmentGt           *string  `json:"departmentGT,omitempty"`
	DepartmentGte          *string  `json:"departmentGTE,omitempty"`
	DepartmentLt           *string  `json:"departmentLT,omitempty"`
	DepartmentLte          *string  `json:"departmentLTE,omitempty"`
	DepartmentContains     *string  `json:"departmentContains,omitempty"`
	DepartmentHasPrefix    *string  `json:"departmentHasPrefix,omitempty"`
	DepartmentHasSuffix    *string  `json:"departmentHasSuffix,omitempty"`
	DepartmentIsNil        *bool    `json:"departmentIsNil,omitempty"`
	DepartmentNotNil       *bool    `json:"departmentNotNil,omitempty"`
	DepartmentEqualFold    *string  `json:"departmentEqualFold,omitempty"`
	DepartmentContainsFold *string  `json:"departmentContainsFold,omitempty"`
	// organization_unit field predicates
	OrganizationUnit             *string  `json:"organizationUnit,omitempty"`
	OrganizationUnitNeq          *string  `json:"organizationUnitNEQ,omitempty"`
	OrganizationUnitIn           []string `json:"organizationUnitIn,omitempty"`
	OrganizationUnitNotIn        []string `json:"organizationUnitNotIn,omitempty"`
	OrganizationUnitGt           *string  `json:"organizationUnitGT,omitempty"`
	OrganizationUnitGte          *string  `json:"organizationUnitGTE,omitempty"`
	OrganizationUnitLt           *string  `json:"organizationUnitLT,omitempty"`
	OrganizationUnitLte          *string  `json:"organizationUnitLTE,omitempty"`
	OrganizationUnitContains     *string  `json:"organizationUnitContains,omitempty"`
	OrganizationUnitHasPrefix    *string  `json:"organizationUnitHasPrefix,omitempty"`
	OrganizationUnitHasSuffix    *string  `json:"organizationUnitHasSuffix,omitempty"`
	OrganizationUnitIsNil        *bool    `json:"organizationUnitIsNil,omitempty"`
	OrganizationUnitNotNil       *bool    `json:"organizationUnitNotNil,omitempty"`
	OrganizationUnitEqualFold    *string  `json:"organizationUnitEqualFold,omitempty"`
	OrganizationUnitContainsFold *string  `json:"organizationUnitContainsFold,omitempty"`
	// account_type field predicates
	AccountType       *enums.DirectoryAccountType  `json:"accountType,omitempty"`
	AccountTypeNeq    *enums.DirectoryAccountType  `json:"accountTypeNEQ,omitempty"`
	AccountTypeIn     []enums.DirectoryAccountType `json:"accountTypeIn,omitempty"`
	AccountTypeNotIn  []enums.DirectoryAccountType `json:"accountTypeNotIn,omitempty"`
	AccountTypeIsNil  *bool                        `json:"accountTypeIsNil,omitempty"`
	AccountTypeNotNil *bool                        `json:"accountTypeNotNil,omitempty"`
	// status field predicates
	Status      *enums.DirectoryAccountStatus  `json:"status,omitempty"`
	StatusNeq   *enums.DirectoryAccountStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.DirectoryAccountStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.DirectoryAccountStatus `json:"statusNotIn,omitempty"`
	// mfa_state field predicates
	MfaState      *enums.DirectoryAccountMFAState  `json:"mfaState,omitempty"`
	MfaStateNeq   *enums.DirectoryAccountMFAState  `json:"mfaStateNEQ,omitempty"`
	MfaStateIn    []enums.DirectoryAccountMFAState `json:"mfaStateIn,omitempty"`
	MfaStateNotIn []enums.DirectoryAccountMFAState `json:"mfaStateNotIn,omitempty"`
	// last_seen_ip field predicates
	LastSeenIP             *string  `json:"lastSeenIP,omitempty"`
	LastSeenIpneq          *string  `json:"lastSeenIPNEQ,omitempty"`
	LastSeenIPIn           []string `json:"lastSeenIPIn,omitempty"`
	LastSeenIPNotIn        []string `json:"lastSeenIPNotIn,omitempty"`
	LastSeenIpgt           *string  `json:"lastSeenIPGT,omitempty"`
	LastSeenIpgte          *string  `json:"lastSeenIPGTE,omitempty"`
	LastSeenIplt           *string  `json:"lastSeenIPLT,omitempty"`
	LastSeenIplte          *string  `json:"lastSeenIPLTE,omitempty"`
	LastSeenIPContains     *string  `json:"lastSeenIPContains,omitempty"`
	LastSeenIPHasPrefix    *string  `json:"lastSeenIPHasPrefix,omitempty"`
	LastSeenIPHasSuffix    *string  `json:"lastSeenIPHasSuffix,omitempty"`
	LastSeenIPIsNil        *bool    `json:"lastSeenIPIsNil,omitempty"`
	LastSeenIPNotNil       *bool    `json:"lastSeenIPNotNil,omitempty"`
	LastSeenIPEqualFold    *string  `json:"lastSeenIPEqualFold,omitempty"`
	LastSeenIPContainsFold *string  `json:"lastSeenIPContainsFold,omitempty"`
	// last_login_at field predicates
	LastLoginAt       *time.Time   `json:"lastLoginAt,omitempty"`
	LastLoginAtNeq    *time.Time   `json:"lastLoginAtNEQ,omitempty"`
	LastLoginAtIn     []*time.Time `json:"lastLoginAtIn,omitempty"`
	LastLoginAtNotIn  []*time.Time `json:"lastLoginAtNotIn,omitempty"`
	LastLoginAtGt     *time.Time   `json:"lastLoginAtGT,omitempty"`
	LastLoginAtGte    *time.Time   `json:"lastLoginAtGTE,omitempty"`
	LastLoginAtLt     *time.Time   `json:"lastLoginAtLT,omitempty"`
	LastLoginAtLte    *time.Time   `json:"lastLoginAtLTE,omitempty"`
	LastLoginAtIsNil  *bool        `json:"lastLoginAtIsNil,omitempty"`
	LastLoginAtNotNil *bool        `json:"lastLoginAtNotNil,omitempty"`
	// observed_at field predicates
	ObservedAt      *time.Time   `json:"observedAt,omitempty"`
	ObservedAtNeq   *time.Time   `json:"observedAtNEQ,omitempty"`
	ObservedAtIn    []*time.Time `json:"observedAtIn,omitempty"`
	ObservedAtNotIn []*time.Time `json:"observedAtNotIn,omitempty"`
	ObservedAtGt    *time.Time   `json:"observedAtGT,omitempty"`
	ObservedAtGte   *time.Time   `json:"observedAtGTE,omitempty"`
	ObservedAtLt    *time.Time   `json:"observedAtLT,omitempty"`
	ObservedAtLte   *time.Time   `json:"observedAtLTE,omitempty"`
	// profile_hash field predicates
	ProfileHash             *string  `json:"profileHash,omitempty"`
	ProfileHashNeq          *string  `json:"profileHashNEQ,omitempty"`
	ProfileHashIn           []string `json:"profileHashIn,omitempty"`
	ProfileHashNotIn        []string `json:"profileHashNotIn,omitempty"`
	ProfileHashGt           *string  `json:"profileHashGT,omitempty"`
	ProfileHashGte          *string  `json:"profileHashGTE,omitempty"`
	ProfileHashLt           *string  `json:"profileHashLT,omitempty"`
	ProfileHashLte          *string  `json:"profileHashLTE,omitempty"`
	ProfileHashContains     *string  `json:"profileHashContains,omitempty"`
	ProfileHashHasPrefix    *string  `json:"profileHashHasPrefix,omitempty"`
	ProfileHashHasSuffix    *string  `json:"profileHashHasSuffix,omitempty"`
	ProfileHashEqualFold    *string  `json:"profileHashEqualFold,omitempty"`
	ProfileHashContainsFold *string  `json:"profileHashContainsFold,omitempty"`
	// source_version field predicates
	SourceVersion             *string  `json:"sourceVersion,omitempty"`
	SourceVersionNeq          *string  `json:"sourceVersionNEQ,omitempty"`
	SourceVersionIn           []string `json:"sourceVersionIn,omitempty"`
	SourceVersionNotIn        []string `json:"sourceVersionNotIn,omitempty"`
	SourceVersionGt           *string  `json:"sourceVersionGT,omitempty"`
	SourceVersionGte          *string  `json:"sourceVersionGTE,omitempty"`
	SourceVersionLt           *string  `json:"sourceVersionLT,omitempty"`
	SourceVersionLte          *string  `json:"sourceVersionLTE,omitempty"`
	SourceVersionContains     *string  `json:"sourceVersionContains,omitempty"`
	SourceVersionHasPrefix    *string  `json:"sourceVersionHasPrefix,omitempty"`
	SourceVersionHasSuffix    *string  `json:"sourceVersionHasSuffix,omitempty"`
	SourceVersionIsNil        *bool    `json:"sourceVersionIsNil,omitempty"`
	SourceVersionNotNil       *bool    `json:"sourceVersionNotNil,omitempty"`
	SourceVersionEqualFold    *string  `json:"sourceVersionEqualFold,omitempty"`
	SourceVersionContainsFold *string  `json:"sourceVersionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// integration edge predicates
	HasIntegration     *bool                    `json:"hasIntegration,omitempty"`
	HasIntegrationWith []*IntegrationWhereInput `json:"hasIntegrationWith,omitempty"`
	// directory_sync_run edge predicates
	HasDirectorySyncRun     *bool                         `json:"hasDirectorySyncRun,omitempty"`
	HasDirectorySyncRunWith []*DirectorySyncRunWhereInput `json:"hasDirectorySyncRunWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool                       `json:"hasGroups,omitempty"`
	HasGroupsWith []*DirectoryGroupWhereInput `json:"hasGroupsWith,omitempty"`
	// workflow_object_refs edge predicates
	HasWorkflowObjectRefs     *bool                          `json:"hasWorkflowObjectRefs,omitempty"`
	HasWorkflowObjectRefsWith []*WorkflowObjectRefWhereInput `json:"hasWorkflowObjectRefsWith,omitempty"`
	// memberships edge predicates
	HasMemberships     *bool                            `json:"hasMemberships,omitempty"`
	HasMembershipsWith []*DirectoryMembershipWhereInput `json:"hasMembershipsWith,omitempty"`
}

type DirectoryGroup struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// integration that owns this directory group
	IntegrationID string `json:"integrationID"`
	// sync run that produced this snapshot
	DirectorySyncRunID string `json:"directorySyncRunID"`
	// stable identifier from the directory system
	ExternalID string `json:"externalID"`
	// primary group email address, when applicable
	Email *string `json:"email,omitempty"`
	// directory supplied display name
	DisplayName *string `json:"displayName,omitempty"`
	// free-form description captured at sync time
	Description *string `json:"description,omitempty"`
	// provider classification such as security, distribution, or dynamic
	Classification enums.DirectoryGroupClassification `json:"classification"`
	// lifecycle status reported by the directory
	Status enums.DirectoryGroupStatus `json:"status"`
	// true when directory settings allow sharing outside the tenant
	ExternalSharingAllowed *bool `json:"externalSharingAllowed,omitempty"`
	// member count reported by the directory
	MemberCount *int64 `json:"memberCount,omitempty"`
	// time when this snapshot was recorded
	ObservedAt time.Time `json:"observedAt"`
	// hash of the normalized payload for diffing
	ProfileHash string `json:"profileHash"`
	// flattened attribute bag used for filtering/diffing
	Profile map[string]any `json:"profile,omitempty"`
	// object storage file identifier containing the raw upstream payload
	RawProfileFileID *string `json:"rawProfileFileID,omitempty"`
	// cursor or ETag supplied by the source system for auditing
	SourceVersion *string       `json:"sourceVersion,omitempty"`
	Owner         *Organization `json:"owner,omitempty"`
	// integration that owns this directory group
	Integration *Integration `json:"integration"`
	// sync run that produced this snapshot
	DirectorySyncRun   *DirectorySyncRun              `json:"directorySyncRun"`
	Accounts           *DirectoryAccountConnection    `json:"accounts"`
	WorkflowObjectRefs *WorkflowObjectRefConnection   `json:"workflowObjectRefs"`
	Members            *DirectoryMembershipConnection `json:"members"`
}

func (DirectoryGroup) IsNode() {}

// Return response for createBulkDirectoryGroup mutation
type DirectoryGroupBulkCreatePayload struct {
	// Created directoryGroups
	DirectoryGroups []*DirectoryGroup `json:"directoryGroups,omitempty"`
}

// A connection to a list of items.
type DirectoryGroupConnection struct {
	// A list of edges.
	Edges []*DirectoryGroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDirectoryGroup mutation
type DirectoryGroupCreatePayload struct {
	// Created directoryGroup
	DirectoryGroup *DirectoryGroup `json:"directoryGroup"`
}

// Return response for deleteDirectoryGroup mutation
type DirectoryGroupDeletePayload struct {
	// Deleted directoryGroup ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DirectoryGroupEdge struct {
	// The item at the end of the edge.
	Node *DirectoryGroup `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DirectoryGroupHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// integration that owns this directory group
	IntegrationID string `json:"integrationID"`
	// sync run that produced this snapshot
	DirectorySyncRunID string `json:"directorySyncRunID"`
	// stable identifier from the directory system
	ExternalID string `json:"externalID"`
	// primary group email address, when applicable
	Email *string `json:"email,omitempty"`
	// directory supplied display name
	DisplayName *string `json:"displayName,omitempty"`
	// free-form description captured at sync time
	Description *string `json:"description,omitempty"`
	// provider classification such as security, distribution, or dynamic
	Classification enums.DirectoryGroupClassification `json:"classification"`
	// lifecycle status reported by the directory
	Status enums.DirectoryGroupStatus `json:"status"`
	// true when directory settings allow sharing outside the tenant
	ExternalSharingAllowed *bool `json:"externalSharingAllowed,omitempty"`
	// member count reported by the directory
	MemberCount *int64 `json:"memberCount,omitempty"`
	// time when this snapshot was recorded
	ObservedAt time.Time `json:"observedAt"`
	// hash of the normalized payload for diffing
	ProfileHash string `json:"profileHash"`
	// flattened attribute bag used for filtering/diffing
	Profile map[string]any `json:"profile,omitempty"`
	// object storage file identifier containing the raw upstream payload
	RawProfileFileID *string `json:"rawProfileFileID,omitempty"`
	// cursor or ETag supplied by the source system for auditing
	SourceVersion *string `json:"sourceVersion,omitempty"`
}

func (DirectoryGroupHistory) IsNode() {}

// A connection to a list of items.
type DirectoryGroupHistoryConnection struct {
	// A list of edges.
	Edges []*DirectoryGroupHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DirectoryGroupHistoryEdge struct {
	// The item at the end of the edge.
	Node *DirectoryGroupHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for DirectoryGroupHistory connections
type DirectoryGroupHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DirectoryGroupHistories.
	Field DirectoryGroupHistoryOrderField `json:"field"`
}

// DirectoryGroupHistoryWhereInput is used for filtering DirectoryGroupHistory objects.
// Input was generated by ent.
type DirectoryGroupHistoryWhereInput struct {
	Not *DirectoryGroupHistoryWhereInput   `json:"not,omitempty"`
	And []*DirectoryGroupHistoryWhereInput `json:"and,omitempty"`
	Or  []*DirectoryGroupHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// integration_id field predicates
	IntegrationID             *string  `json:"integrationID,omitempty"`
	IntegrationIdneq          *string  `json:"integrationIDNEQ,omitempty"`
	IntegrationIDIn           []string `json:"integrationIDIn,omitempty"`
	IntegrationIDNotIn        []string `json:"integrationIDNotIn,omitempty"`
	IntegrationIdgt           *string  `json:"integrationIDGT,omitempty"`
	IntegrationIdgte          *string  `json:"integrationIDGTE,omitempty"`
	IntegrationIdlt           *string  `json:"integrationIDLT,omitempty"`
	IntegrationIdlte          *string  `json:"integrationIDLTE,omitempty"`
	IntegrationIDContains     *string  `json:"integrationIDContains,omitempty"`
	IntegrationIDHasPrefix    *string  `json:"integrationIDHasPrefix,omitempty"`
	IntegrationIDHasSuffix    *string  `json:"integrationIDHasSuffix,omitempty"`
	IntegrationIDEqualFold    *string  `json:"integrationIDEqualFold,omitempty"`
	IntegrationIDContainsFold *string  `json:"integrationIDContainsFold,omitempty"`
	// directory_sync_run_id field predicates
	DirectorySyncRunID             *string  `json:"directorySyncRunID,omitempty"`
	DirectorySyncRunIdneq          *string  `json:"directorySyncRunIDNEQ,omitempty"`
	DirectorySyncRunIDIn           []string `json:"directorySyncRunIDIn,omitempty"`
	DirectorySyncRunIDNotIn        []string `json:"directorySyncRunIDNotIn,omitempty"`
	DirectorySyncRunIdgt           *string  `json:"directorySyncRunIDGT,omitempty"`
	DirectorySyncRunIdgte          *string  `json:"directorySyncRunIDGTE,omitempty"`
	DirectorySyncRunIdlt           *string  `json:"directorySyncRunIDLT,omitempty"`
	DirectorySyncRunIdlte          *string  `json:"directorySyncRunIDLTE,omitempty"`
	DirectorySyncRunIDContains     *string  `json:"directorySyncRunIDContains,omitempty"`
	DirectorySyncRunIDHasPrefix    *string  `json:"directorySyncRunIDHasPrefix,omitempty"`
	DirectorySyncRunIDHasSuffix    *string  `json:"directorySyncRunIDHasSuffix,omitempty"`
	DirectorySyncRunIDEqualFold    *string  `json:"directorySyncRunIDEqualFold,omitempty"`
	DirectorySyncRunIDContainsFold *string  `json:"directorySyncRunIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// classification field predicates
	Classification      *enums.DirectoryGroupClassification  `json:"classification,omitempty"`
	ClassificationNeq   *enums.DirectoryGroupClassification  `json:"classificationNEQ,omitempty"`
	ClassificationIn    []enums.DirectoryGroupClassification `json:"classificationIn,omitempty"`
	ClassificationNotIn []enums.DirectoryGroupClassification `json:"classificationNotIn,omitempty"`
	// status field predicates
	Status      *enums.DirectoryGroupStatus  `json:"status,omitempty"`
	StatusNeq   *enums.DirectoryGroupStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.DirectoryGroupStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.DirectoryGroupStatus `json:"statusNotIn,omitempty"`
	// external_sharing_allowed field predicates
	ExternalSharingAllowed       *bool `json:"externalSharingAllowed,omitempty"`
	ExternalSharingAllowedNeq    *bool `json:"externalSharingAllowedNEQ,omitempty"`
	ExternalSharingAllowedIsNil  *bool `json:"externalSharingAllowedIsNil,omitempty"`
	ExternalSharingAllowedNotNil *bool `json:"externalSharingAllowedNotNil,omitempty"`
	// member_count field predicates
	MemberCount       *int64  `json:"memberCount,omitempty"`
	MemberCountNeq    *int64  `json:"memberCountNEQ,omitempty"`
	MemberCountIn     []int64 `json:"memberCountIn,omitempty"`
	MemberCountNotIn  []int64 `json:"memberCountNotIn,omitempty"`
	MemberCountGt     *int64  `json:"memberCountGT,omitempty"`
	MemberCountGte    *int64  `json:"memberCountGTE,omitempty"`
	MemberCountLt     *int64  `json:"memberCountLT,omitempty"`
	MemberCountLte    *int64  `json:"memberCountLTE,omitempty"`
	MemberCountIsNil  *bool   `json:"memberCountIsNil,omitempty"`
	MemberCountNotNil *bool   `json:"memberCountNotNil,omitempty"`
	// observed_at field predicates
	ObservedAt      *time.Time   `json:"observedAt,omitempty"`
	ObservedAtNeq   *time.Time   `json:"observedAtNEQ,omitempty"`
	ObservedAtIn    []*time.Time `json:"observedAtIn,omitempty"`
	ObservedAtNotIn []*time.Time `json:"observedAtNotIn,omitempty"`
	ObservedAtGt    *time.Time   `json:"observedAtGT,omitempty"`
	ObservedAtGte   *time.Time   `json:"observedAtGTE,omitempty"`
	ObservedAtLt    *time.Time   `json:"observedAtLT,omitempty"`
	ObservedAtLte   *time.Time   `json:"observedAtLTE,omitempty"`
	// profile_hash field predicates
	ProfileHash             *string  `json:"profileHash,omitempty"`
	ProfileHashNeq          *string  `json:"profileHashNEQ,omitempty"`
	ProfileHashIn           []string `json:"profileHashIn,omitempty"`
	ProfileHashNotIn        []string `json:"profileHashNotIn,omitempty"`
	ProfileHashGt           *string  `json:"profileHashGT,omitempty"`
	ProfileHashGte          *string  `json:"profileHashGTE,omitempty"`
	ProfileHashLt           *string  `json:"profileHashLT,omitempty"`
	ProfileHashLte          *string  `json:"profileHashLTE,omitempty"`
	ProfileHashContains     *string  `json:"profileHashContains,omitempty"`
	ProfileHashHasPrefix    *string  `json:"profileHashHasPrefix,omitempty"`
	ProfileHashHasSuffix    *string  `json:"profileHashHasSuffix,omitempty"`
	ProfileHashEqualFold    *string  `json:"profileHashEqualFold,omitempty"`
	ProfileHashContainsFold *string  `json:"profileHashContainsFold,omitempty"`
	// source_version field predicates
	SourceVersion             *string  `json:"sourceVersion,omitempty"`
	SourceVersionNeq          *string  `json:"sourceVersionNEQ,omitempty"`
	SourceVersionIn           []string `json:"sourceVersionIn,omitempty"`
	SourceVersionNotIn        []string `json:"sourceVersionNotIn,omitempty"`
	SourceVersionGt           *string  `json:"sourceVersionGT,omitempty"`
	SourceVersionGte          *string  `json:"sourceVersionGTE,omitempty"`
	SourceVersionLt           *string  `json:"sourceVersionLT,omitempty"`
	SourceVersionLte          *string  `json:"sourceVersionLTE,omitempty"`
	SourceVersionContains     *string  `json:"sourceVersionContains,omitempty"`
	SourceVersionHasPrefix    *string  `json:"sourceVersionHasPrefix,omitempty"`
	SourceVersionHasSuffix    *string  `json:"sourceVersionHasSuffix,omitempty"`
	SourceVersionIsNil        *bool    `json:"sourceVersionIsNil,omitempty"`
	SourceVersionNotNil       *bool    `json:"sourceVersionNotNil,omitempty"`
	SourceVersionEqualFold    *string  `json:"sourceVersionEqualFold,omitempty"`
	SourceVersionContainsFold *string  `json:"sourceVersionContainsFold,omitempty"`
}

// Ordering options for DirectoryGroup connections
type DirectoryGroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DirectoryGroups.
	Field DirectoryGroupOrderField `json:"field"`
}

// Return response for updateDirectoryGroup mutation
type DirectoryGroupUpdatePayload struct {
	// Updated directoryGroup
	DirectoryGroup *DirectoryGroup `json:"directoryGroup"`
}

// DirectoryGroupWhereInput is used for filtering DirectoryGroup objects.
// Input was generated by ent.
type DirectoryGroupWhereInput struct {
	Not *DirectoryGroupWhereInput   `json:"not,omitempty"`
	And []*DirectoryGroupWhereInput `json:"and,omitempty"`
	Or  []*DirectoryGroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// integration_id field predicates
	IntegrationID             *string  `json:"integrationID,omitempty"`
	IntegrationIdneq          *string  `json:"integrationIDNEQ,omitempty"`
	IntegrationIDIn           []string `json:"integrationIDIn,omitempty"`
	IntegrationIDNotIn        []string `json:"integrationIDNotIn,omitempty"`
	IntegrationIdgt           *string  `json:"integrationIDGT,omitempty"`
	IntegrationIdgte          *string  `json:"integrationIDGTE,omitempty"`
	IntegrationIdlt           *string  `json:"integrationIDLT,omitempty"`
	IntegrationIdlte          *string  `json:"integrationIDLTE,omitempty"`
	IntegrationIDContains     *string  `json:"integrationIDContains,omitempty"`
	IntegrationIDHasPrefix    *string  `json:"integrationIDHasPrefix,omitempty"`
	IntegrationIDHasSuffix    *string  `json:"integrationIDHasSuffix,omitempty"`
	IntegrationIDEqualFold    *string  `json:"integrationIDEqualFold,omitempty"`
	IntegrationIDContainsFold *string  `json:"integrationIDContainsFold,omitempty"`
	// directory_sync_run_id field predicates
	DirectorySyncRunID             *string  `json:"directorySyncRunID,omitempty"`
	DirectorySyncRunIdneq          *string  `json:"directorySyncRunIDNEQ,omitempty"`
	DirectorySyncRunIDIn           []string `json:"directorySyncRunIDIn,omitempty"`
	DirectorySyncRunIDNotIn        []string `json:"directorySyncRunIDNotIn,omitempty"`
	DirectorySyncRunIdgt           *string  `json:"directorySyncRunIDGT,omitempty"`
	DirectorySyncRunIdgte          *string  `json:"directorySyncRunIDGTE,omitempty"`
	DirectorySyncRunIdlt           *string  `json:"directorySyncRunIDLT,omitempty"`
	DirectorySyncRunIdlte          *string  `json:"directorySyncRunIDLTE,omitempty"`
	DirectorySyncRunIDContains     *string  `json:"directorySyncRunIDContains,omitempty"`
	DirectorySyncRunIDHasPrefix    *string  `json:"directorySyncRunIDHasPrefix,omitempty"`
	DirectorySyncRunIDHasSuffix    *string  `json:"directorySyncRunIDHasSuffix,omitempty"`
	DirectorySyncRunIDEqualFold    *string  `json:"directorySyncRunIDEqualFold,omitempty"`
	DirectorySyncRunIDContainsFold *string  `json:"directorySyncRunIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// classification field predicates
	Classification      *enums.DirectoryGroupClassification  `json:"classification,omitempty"`
	ClassificationNeq   *enums.DirectoryGroupClassification  `json:"classificationNEQ,omitempty"`
	ClassificationIn    []enums.DirectoryGroupClassification `json:"classificationIn,omitempty"`
	ClassificationNotIn []enums.DirectoryGroupClassification `json:"classificationNotIn,omitempty"`
	// status field predicates
	Status      *enums.DirectoryGroupStatus  `json:"status,omitempty"`
	StatusNeq   *enums.DirectoryGroupStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.DirectoryGroupStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.DirectoryGroupStatus `json:"statusNotIn,omitempty"`
	// external_sharing_allowed field predicates
	ExternalSharingAllowed       *bool `json:"externalSharingAllowed,omitempty"`
	ExternalSharingAllowedNeq    *bool `json:"externalSharingAllowedNEQ,omitempty"`
	ExternalSharingAllowedIsNil  *bool `json:"externalSharingAllowedIsNil,omitempty"`
	ExternalSharingAllowedNotNil *bool `json:"externalSharingAllowedNotNil,omitempty"`
	// member_count field predicates
	MemberCount       *int64  `json:"memberCount,omitempty"`
	MemberCountNeq    *int64  `json:"memberCountNEQ,omitempty"`
	MemberCountIn     []int64 `json:"memberCountIn,omitempty"`
	MemberCountNotIn  []int64 `json:"memberCountNotIn,omitempty"`
	MemberCountGt     *int64  `json:"memberCountGT,omitempty"`
	MemberCountGte    *int64  `json:"memberCountGTE,omitempty"`
	MemberCountLt     *int64  `json:"memberCountLT,omitempty"`
	MemberCountLte    *int64  `json:"memberCountLTE,omitempty"`
	MemberCountIsNil  *bool   `json:"memberCountIsNil,omitempty"`
	MemberCountNotNil *bool   `json:"memberCountNotNil,omitempty"`
	// observed_at field predicates
	ObservedAt      *time.Time   `json:"observedAt,omitempty"`
	ObservedAtNeq   *time.Time   `json:"observedAtNEQ,omitempty"`
	ObservedAtIn    []*time.Time `json:"observedAtIn,omitempty"`
	ObservedAtNotIn []*time.Time `json:"observedAtNotIn,omitempty"`
	ObservedAtGt    *time.Time   `json:"observedAtGT,omitempty"`
	ObservedAtGte   *time.Time   `json:"observedAtGTE,omitempty"`
	ObservedAtLt    *time.Time   `json:"observedAtLT,omitempty"`
	ObservedAtLte   *time.Time   `json:"observedAtLTE,omitempty"`
	// profile_hash field predicates
	ProfileHash             *string  `json:"profileHash,omitempty"`
	ProfileHashNeq          *string  `json:"profileHashNEQ,omitempty"`
	ProfileHashIn           []string `json:"profileHashIn,omitempty"`
	ProfileHashNotIn        []string `json:"profileHashNotIn,omitempty"`
	ProfileHashGt           *string  `json:"profileHashGT,omitempty"`
	ProfileHashGte          *string  `json:"profileHashGTE,omitempty"`
	ProfileHashLt           *string  `json:"profileHashLT,omitempty"`
	ProfileHashLte          *string  `json:"profileHashLTE,omitempty"`
	ProfileHashContains     *string  `json:"profileHashContains,omitempty"`
	ProfileHashHasPrefix    *string  `json:"profileHashHasPrefix,omitempty"`
	ProfileHashHasSuffix    *string  `json:"profileHashHasSuffix,omitempty"`
	ProfileHashEqualFold    *string  `json:"profileHashEqualFold,omitempty"`
	ProfileHashContainsFold *string  `json:"profileHashContainsFold,omitempty"`
	// source_version field predicates
	SourceVersion             *string  `json:"sourceVersion,omitempty"`
	SourceVersionNeq          *string  `json:"sourceVersionNEQ,omitempty"`
	SourceVersionIn           []string `json:"sourceVersionIn,omitempty"`
	SourceVersionNotIn        []string `json:"sourceVersionNotIn,omitempty"`
	SourceVersionGt           *string  `json:"sourceVersionGT,omitempty"`
	SourceVersionGte          *string  `json:"sourceVersionGTE,omitempty"`
	SourceVersionLt           *string  `json:"sourceVersionLT,omitempty"`
	SourceVersionLte          *string  `json:"sourceVersionLTE,omitempty"`
	SourceVersionContains     *string  `json:"sourceVersionContains,omitempty"`
	SourceVersionHasPrefix    *string  `json:"sourceVersionHasPrefix,omitempty"`
	SourceVersionHasSuffix    *string  `json:"sourceVersionHasSuffix,omitempty"`
	SourceVersionIsNil        *bool    `json:"sourceVersionIsNil,omitempty"`
	SourceVersionNotNil       *bool    `json:"sourceVersionNotNil,omitempty"`
	SourceVersionEqualFold    *string  `json:"sourceVersionEqualFold,omitempty"`
	SourceVersionContainsFold *string  `json:"sourceVersionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// integration edge predicates
	HasIntegration     *bool                    `json:"hasIntegration,omitempty"`
	HasIntegrationWith []*IntegrationWhereInput `json:"hasIntegrationWith,omitempty"`
	// directory_sync_run edge predicates
	HasDirectorySyncRun     *bool                         `json:"hasDirectorySyncRun,omitempty"`
	HasDirectorySyncRunWith []*DirectorySyncRunWhereInput `json:"hasDirectorySyncRunWith,omitempty"`
	// accounts edge predicates
	HasAccounts     *bool                         `json:"hasAccounts,omitempty"`
	HasAccountsWith []*DirectoryAccountWhereInput `json:"hasAccountsWith,omitempty"`
	// workflow_object_refs edge predicates
	HasWorkflowObjectRefs     *bool                          `json:"hasWorkflowObjectRefs,omitempty"`
	HasWorkflowObjectRefsWith []*WorkflowObjectRefWhereInput `json:"hasWorkflowObjectRefsWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                            `json:"hasMembers,omitempty"`
	HasMembersWith []*DirectoryMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type DirectoryMembership struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// integration that owns this directory membership
	IntegrationID string `json:"integrationID"`
	// sync run that produced this snapshot
	DirectorySyncRunID string `json:"directorySyncRunID"`
	// directory account participating in this membership
	DirectoryAccountID string `json:"directoryAccountID"`
	// directory group associated with this membership
	DirectoryGroupID string `json:"directoryGroupID"`
	// membership role reported by the provider
	Role *enums.DirectoryMembershipRole `json:"role,omitempty"`
	// mechanism used to populate the membership (api, scim, csv, etc)
	Source *string `json:"source,omitempty"`
	// first time the membership was detected
	FirstSeenAt *time.Time `json:"firstSeenAt,omitempty"`
	// most recent time the membership was detected
	LastSeenAt *time.Time `json:"lastSeenAt,omitempty"`
	// time when this record was created
	ObservedAt time.Time `json:"observedAt"`
	// sync run identifier that most recently confirmed this membership
	LastConfirmedRunID *string `json:"lastConfirmedRunID,omitempty"`
	// raw metadata associated with this membership from the provider
	Metadata map[string]any `json:"metadata,omitempty"`
	Owner    *Organization  `json:"owner,omitempty"`
	// integration that owns this directory membership
	Integration *Integration `json:"integration"`
	// sync run that produced this snapshot
	DirectorySyncRun   *DirectorySyncRun            `json:"directorySyncRun"`
	DirectoryAccount   *DirectoryAccount            `json:"directoryAccount"`
	DirectoryGroup     *DirectoryGroup              `json:"directoryGroup"`
	Events             *EventConnection             `json:"events"`
	WorkflowObjectRefs *WorkflowObjectRefConnection `json:"workflowObjectRefs"`
}

func (DirectoryMembership) IsNode() {}

// Return response for createBulkDirectoryMembership mutation
type DirectoryMembershipBulkCreatePayload struct {
	// Created directoryMemberships
	DirectoryMemberships []*DirectoryMembership `json:"directoryMemberships,omitempty"`
}

// A connection to a list of items.
type DirectoryMembershipConnection struct {
	// A list of edges.
	Edges []*DirectoryMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDirectoryMembership mutation
type DirectoryMembershipCreatePayload struct {
	// Created directoryMembership
	DirectoryMembership *DirectoryMembership `json:"directoryMembership"`
}

// Return response for deleteDirectoryMembership mutation
type DirectoryMembershipDeletePayload struct {
	// Deleted directoryMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DirectoryMembershipEdge struct {
	// The item at the end of the edge.
	Node *DirectoryMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DirectoryMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// integration that owns this directory membership
	IntegrationID string `json:"integrationID"`
	// sync run that produced this snapshot
	DirectorySyncRunID string `json:"directorySyncRunID"`
	// directory account participating in this membership
	DirectoryAccountID string `json:"directoryAccountID"`
	// directory group associated with this membership
	DirectoryGroupID string `json:"directoryGroupID"`
	// membership role reported by the provider
	Role *enums.DirectoryMembershipRole `json:"role,omitempty"`
	// mechanism used to populate the membership (api, scim, csv, etc)
	Source *string `json:"source,omitempty"`
	// first time the membership was detected
	FirstSeenAt *time.Time `json:"firstSeenAt,omitempty"`
	// most recent time the membership was detected
	LastSeenAt *time.Time `json:"lastSeenAt,omitempty"`
	// time when this record was created
	ObservedAt time.Time `json:"observedAt"`
	// sync run identifier that most recently confirmed this membership
	LastConfirmedRunID *string `json:"lastConfirmedRunID,omitempty"`
	// raw metadata associated with this membership from the provider
	Metadata map[string]any `json:"metadata,omitempty"`
}

func (DirectoryMembershipHistory) IsNode() {}

// A connection to a list of items.
type DirectoryMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*DirectoryMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DirectoryMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *DirectoryMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for DirectoryMembershipHistory connections
type DirectoryMembershipHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DirectoryMembershipHistories.
	Field DirectoryMembershipHistoryOrderField `json:"field"`
}

// DirectoryMembershipHistoryWhereInput is used for filtering DirectoryMembershipHistory objects.
// Input was generated by ent.
type DirectoryMembershipHistoryWhereInput struct {
	Not *DirectoryMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*DirectoryMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*DirectoryMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// integration_id field predicates
	IntegrationID             *string  `json:"integrationID,omitempty"`
	IntegrationIdneq          *string  `json:"integrationIDNEQ,omitempty"`
	IntegrationIDIn           []string `json:"integrationIDIn,omitempty"`
	IntegrationIDNotIn        []string `json:"integrationIDNotIn,omitempty"`
	IntegrationIdgt           *string  `json:"integrationIDGT,omitempty"`
	IntegrationIdgte          *string  `json:"integrationIDGTE,omitempty"`
	IntegrationIdlt           *string  `json:"integrationIDLT,omitempty"`
	IntegrationIdlte          *string  `json:"integrationIDLTE,omitempty"`
	IntegrationIDContains     *string  `json:"integrationIDContains,omitempty"`
	IntegrationIDHasPrefix    *string  `json:"integrationIDHasPrefix,omitempty"`
	IntegrationIDHasSuffix    *string  `json:"integrationIDHasSuffix,omitempty"`
	IntegrationIDEqualFold    *string  `json:"integrationIDEqualFold,omitempty"`
	IntegrationIDContainsFold *string  `json:"integrationIDContainsFold,omitempty"`
	// directory_sync_run_id field predicates
	DirectorySyncRunID             *string  `json:"directorySyncRunID,omitempty"`
	DirectorySyncRunIdneq          *string  `json:"directorySyncRunIDNEQ,omitempty"`
	DirectorySyncRunIDIn           []string `json:"directorySyncRunIDIn,omitempty"`
	DirectorySyncRunIDNotIn        []string `json:"directorySyncRunIDNotIn,omitempty"`
	DirectorySyncRunIdgt           *string  `json:"directorySyncRunIDGT,omitempty"`
	DirectorySyncRunIdgte          *string  `json:"directorySyncRunIDGTE,omitempty"`
	DirectorySyncRunIdlt           *string  `json:"directorySyncRunIDLT,omitempty"`
	DirectorySyncRunIdlte          *string  `json:"directorySyncRunIDLTE,omitempty"`
	DirectorySyncRunIDContains     *string  `json:"directorySyncRunIDContains,omitempty"`
	DirectorySyncRunIDHasPrefix    *string  `json:"directorySyncRunIDHasPrefix,omitempty"`
	DirectorySyncRunIDHasSuffix    *string  `json:"directorySyncRunIDHasSuffix,omitempty"`
	DirectorySyncRunIDEqualFold    *string  `json:"directorySyncRunIDEqualFold,omitempty"`
	DirectorySyncRunIDContainsFold *string  `json:"directorySyncRunIDContainsFold,omitempty"`
	// directory_account_id field predicates
	DirectoryAccountID             *string  `json:"directoryAccountID,omitempty"`
	DirectoryAccountIdneq          *string  `json:"directoryAccountIDNEQ,omitempty"`
	DirectoryAccountIDIn           []string `json:"directoryAccountIDIn,omitempty"`
	DirectoryAccountIDNotIn        []string `json:"directoryAccountIDNotIn,omitempty"`
	DirectoryAccountIdgt           *string  `json:"directoryAccountIDGT,omitempty"`
	DirectoryAccountIdgte          *string  `json:"directoryAccountIDGTE,omitempty"`
	DirectoryAccountIdlt           *string  `json:"directoryAccountIDLT,omitempty"`
	DirectoryAccountIdlte          *string  `json:"directoryAccountIDLTE,omitempty"`
	DirectoryAccountIDContains     *string  `json:"directoryAccountIDContains,omitempty"`
	DirectoryAccountIDHasPrefix    *string  `json:"directoryAccountIDHasPrefix,omitempty"`
	DirectoryAccountIDHasSuffix    *string  `json:"directoryAccountIDHasSuffix,omitempty"`
	DirectoryAccountIDEqualFold    *string  `json:"directoryAccountIDEqualFold,omitempty"`
	DirectoryAccountIDContainsFold *string  `json:"directoryAccountIDContainsFold,omitempty"`
	// directory_group_id field predicates
	DirectoryGroupID             *string  `json:"directoryGroupID,omitempty"`
	DirectoryGroupIdneq          *string  `json:"directoryGroupIDNEQ,omitempty"`
	DirectoryGroupIDIn           []string `json:"directoryGroupIDIn,omitempty"`
	DirectoryGroupIDNotIn        []string `json:"directoryGroupIDNotIn,omitempty"`
	DirectoryGroupIdgt           *string  `json:"directoryGroupIDGT,omitempty"`
	DirectoryGroupIdgte          *string  `json:"directoryGroupIDGTE,omitempty"`
	DirectoryGroupIdlt           *string  `json:"directoryGroupIDLT,omitempty"`
	DirectoryGroupIdlte          *string  `json:"directoryGroupIDLTE,omitempty"`
	DirectoryGroupIDContains     *string  `json:"directoryGroupIDContains,omitempty"`
	DirectoryGroupIDHasPrefix    *string  `json:"directoryGroupIDHasPrefix,omitempty"`
	DirectoryGroupIDHasSuffix    *string  `json:"directoryGroupIDHasSuffix,omitempty"`
	DirectoryGroupIDEqualFold    *string  `json:"directoryGroupIDEqualFold,omitempty"`
	DirectoryGroupIDContainsFold *string  `json:"directoryGroupIDContainsFold,omitempty"`
	// role field predicates
	Role       *enums.DirectoryMembershipRole  `json:"role,omitempty"`
	RoleNeq    *enums.DirectoryMembershipRole  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.DirectoryMembershipRole `json:"roleIn,omitempty"`
	RoleNotIn  []enums.DirectoryMembershipRole `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool                           `json:"roleIsNil,omitempty"`
	RoleNotNil *bool                           `json:"roleNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// first_seen_at field predicates
	FirstSeenAt       *time.Time   `json:"firstSeenAt,omitempty"`
	FirstSeenAtNeq    *time.Time   `json:"firstSeenAtNEQ,omitempty"`
	FirstSeenAtIn     []*time.Time `json:"firstSeenAtIn,omitempty"`
	FirstSeenAtNotIn  []*time.Time `json:"firstSeenAtNotIn,omitempty"`
	FirstSeenAtGt     *time.Time   `json:"firstSeenAtGT,omitempty"`
	FirstSeenAtGte    *time.Time   `json:"firstSeenAtGTE,omitempty"`
	FirstSeenAtLt     *time.Time   `json:"firstSeenAtLT,omitempty"`
	FirstSeenAtLte    *time.Time   `json:"firstSeenAtLTE,omitempty"`
	FirstSeenAtIsNil  *bool        `json:"firstSeenAtIsNil,omitempty"`
	FirstSeenAtNotNil *bool        `json:"firstSeenAtNotNil,omitempty"`
	// last_seen_at field predicates
	LastSeenAt       *time.Time   `json:"lastSeenAt,omitempty"`
	LastSeenAtNeq    *time.Time   `json:"lastSeenAtNEQ,omitempty"`
	LastSeenAtIn     []*time.Time `json:"lastSeenAtIn,omitempty"`
	LastSeenAtNotIn  []*time.Time `json:"lastSeenAtNotIn,omitempty"`
	LastSeenAtGt     *time.Time   `json:"lastSeenAtGT,omitempty"`
	LastSeenAtGte    *time.Time   `json:"lastSeenAtGTE,omitempty"`
	LastSeenAtLt     *time.Time   `json:"lastSeenAtLT,omitempty"`
	LastSeenAtLte    *time.Time   `json:"lastSeenAtLTE,omitempty"`
	LastSeenAtIsNil  *bool        `json:"lastSeenAtIsNil,omitempty"`
	LastSeenAtNotNil *bool        `json:"lastSeenAtNotNil,omitempty"`
	// observed_at field predicates
	ObservedAt      *time.Time   `json:"observedAt,omitempty"`
	ObservedAtNeq   *time.Time   `json:"observedAtNEQ,omitempty"`
	ObservedAtIn    []*time.Time `json:"observedAtIn,omitempty"`
	ObservedAtNotIn []*time.Time `json:"observedAtNotIn,omitempty"`
	ObservedAtGt    *time.Time   `json:"observedAtGT,omitempty"`
	ObservedAtGte   *time.Time   `json:"observedAtGTE,omitempty"`
	ObservedAtLt    *time.Time   `json:"observedAtLT,omitempty"`
	ObservedAtLte   *time.Time   `json:"observedAtLTE,omitempty"`
	// last_confirmed_run_id field predicates
	LastConfirmedRunID             *string  `json:"lastConfirmedRunID,omitempty"`
	LastConfirmedRunIdneq          *string  `json:"lastConfirmedRunIDNEQ,omitempty"`
	LastConfirmedRunIDIn           []string `json:"lastConfirmedRunIDIn,omitempty"`
	LastConfirmedRunIDNotIn        []string `json:"lastConfirmedRunIDNotIn,omitempty"`
	LastConfirmedRunIdgt           *string  `json:"lastConfirmedRunIDGT,omitempty"`
	LastConfirmedRunIdgte          *string  `json:"lastConfirmedRunIDGTE,omitempty"`
	LastConfirmedRunIdlt           *string  `json:"lastConfirmedRunIDLT,omitempty"`
	LastConfirmedRunIdlte          *string  `json:"lastConfirmedRunIDLTE,omitempty"`
	LastConfirmedRunIDContains     *string  `json:"lastConfirmedRunIDContains,omitempty"`
	LastConfirmedRunIDHasPrefix    *string  `json:"lastConfirmedRunIDHasPrefix,omitempty"`
	LastConfirmedRunIDHasSuffix    *string  `json:"lastConfirmedRunIDHasSuffix,omitempty"`
	LastConfirmedRunIDIsNil        *bool    `json:"lastConfirmedRunIDIsNil,omitempty"`
	LastConfirmedRunIDNotNil       *bool    `json:"lastConfirmedRunIDNotNil,omitempty"`
	LastConfirmedRunIDEqualFold    *string  `json:"lastConfirmedRunIDEqualFold,omitempty"`
	LastConfirmedRunIDContainsFold *string  `json:"lastConfirmedRunIDContainsFold,omitempty"`
}

// Ordering options for DirectoryMembership connections
type DirectoryMembershipOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DirectoryMemberships.
	Field DirectoryMembershipOrderField `json:"field"`
}

// Return response for updateDirectoryMembership mutation
type DirectoryMembershipUpdatePayload struct {
	// Updated directoryMembership
	DirectoryMembership *DirectoryMembership `json:"directoryMembership"`
}

// DirectoryMembershipWhereInput is used for filtering DirectoryMembership objects.
// Input was generated by ent.
type DirectoryMembershipWhereInput struct {
	Not *DirectoryMembershipWhereInput   `json:"not,omitempty"`
	And []*DirectoryMembershipWhereInput `json:"and,omitempty"`
	Or  []*DirectoryMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// role field predicates
	Role       *enums.DirectoryMembershipRole  `json:"role,omitempty"`
	RoleNeq    *enums.DirectoryMembershipRole  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.DirectoryMembershipRole `json:"roleIn,omitempty"`
	RoleNotIn  []enums.DirectoryMembershipRole `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool                           `json:"roleIsNil,omitempty"`
	RoleNotNil *bool                           `json:"roleNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// first_seen_at field predicates
	FirstSeenAt       *time.Time   `json:"firstSeenAt,omitempty"`
	FirstSeenAtNeq    *time.Time   `json:"firstSeenAtNEQ,omitempty"`
	FirstSeenAtIn     []*time.Time `json:"firstSeenAtIn,omitempty"`
	FirstSeenAtNotIn  []*time.Time `json:"firstSeenAtNotIn,omitempty"`
	FirstSeenAtGt     *time.Time   `json:"firstSeenAtGT,omitempty"`
	FirstSeenAtGte    *time.Time   `json:"firstSeenAtGTE,omitempty"`
	FirstSeenAtLt     *time.Time   `json:"firstSeenAtLT,omitempty"`
	FirstSeenAtLte    *time.Time   `json:"firstSeenAtLTE,omitempty"`
	FirstSeenAtIsNil  *bool        `json:"firstSeenAtIsNil,omitempty"`
	FirstSeenAtNotNil *bool        `json:"firstSeenAtNotNil,omitempty"`
	// last_seen_at field predicates
	LastSeenAt       *time.Time   `json:"lastSeenAt,omitempty"`
	LastSeenAtNeq    *time.Time   `json:"lastSeenAtNEQ,omitempty"`
	LastSeenAtIn     []*time.Time `json:"lastSeenAtIn,omitempty"`
	LastSeenAtNotIn  []*time.Time `json:"lastSeenAtNotIn,omitempty"`
	LastSeenAtGt     *time.Time   `json:"lastSeenAtGT,omitempty"`
	LastSeenAtGte    *time.Time   `json:"lastSeenAtGTE,omitempty"`
	LastSeenAtLt     *time.Time   `json:"lastSeenAtLT,omitempty"`
	LastSeenAtLte    *time.Time   `json:"lastSeenAtLTE,omitempty"`
	LastSeenAtIsNil  *bool        `json:"lastSeenAtIsNil,omitempty"`
	LastSeenAtNotNil *bool        `json:"lastSeenAtNotNil,omitempty"`
	// observed_at field predicates
	ObservedAt      *time.Time   `json:"observedAt,omitempty"`
	ObservedAtNeq   *time.Time   `json:"observedAtNEQ,omitempty"`
	ObservedAtIn    []*time.Time `json:"observedAtIn,omitempty"`
	ObservedAtNotIn []*time.Time `json:"observedAtNotIn,omitempty"`
	ObservedAtGt    *time.Time   `json:"observedAtGT,omitempty"`
	ObservedAtGte   *time.Time   `json:"observedAtGTE,omitempty"`
	ObservedAtLt    *time.Time   `json:"observedAtLT,omitempty"`
	ObservedAtLte   *time.Time   `json:"observedAtLTE,omitempty"`
	// last_confirmed_run_id field predicates
	LastConfirmedRunID             *string  `json:"lastConfirmedRunID,omitempty"`
	LastConfirmedRunIdneq          *string  `json:"lastConfirmedRunIDNEQ,omitempty"`
	LastConfirmedRunIDIn           []string `json:"lastConfirmedRunIDIn,omitempty"`
	LastConfirmedRunIDNotIn        []string `json:"lastConfirmedRunIDNotIn,omitempty"`
	LastConfirmedRunIdgt           *string  `json:"lastConfirmedRunIDGT,omitempty"`
	LastConfirmedRunIdgte          *string  `json:"lastConfirmedRunIDGTE,omitempty"`
	LastConfirmedRunIdlt           *string  `json:"lastConfirmedRunIDLT,omitempty"`
	LastConfirmedRunIdlte          *string  `json:"lastConfirmedRunIDLTE,omitempty"`
	LastConfirmedRunIDContains     *string  `json:"lastConfirmedRunIDContains,omitempty"`
	LastConfirmedRunIDHasPrefix    *string  `json:"lastConfirmedRunIDHasPrefix,omitempty"`
	LastConfirmedRunIDHasSuffix    *string  `json:"lastConfirmedRunIDHasSuffix,omitempty"`
	LastConfirmedRunIDIsNil        *bool    `json:"lastConfirmedRunIDIsNil,omitempty"`
	LastConfirmedRunIDNotNil       *bool    `json:"lastConfirmedRunIDNotNil,omitempty"`
	LastConfirmedRunIDEqualFold    *string  `json:"lastConfirmedRunIDEqualFold,omitempty"`
	LastConfirmedRunIDContainsFold *string  `json:"lastConfirmedRunIDContainsFold,omitempty"`
}

type DirectorySyncRun struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// integration this sync run executed for
	IntegrationID string `json:"integrationID"`
	// current state of the sync run
	Status enums.DirectorySyncRunStatus `json:"status"`
	// time the sync started
	StartedAt time.Time `json:"startedAt"`
	// time the sync finished
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// cursor or checkpoint returned by the provider for the next run
	SourceCursor *string `json:"sourceCursor,omitempty"`
	// total records processed during this run
	FullCount int64 `json:"fullCount"`
	// number of records that changed compared to the prior run
	DeltaCount int64 `json:"deltaCount"`
	// serialized error information when the run failed
	Error *string `json:"error,omitempty"`
	// object storage file identifier for the manifest captured during the run
	RawManifestFileID *string `json:"rawManifestFileID,omitempty"`
	// additional provider-specific stats for the run
	Stats map[string]any `json:"stats,omitempty"`
	Owner *Organization  `json:"owner,omitempty"`
	// integration that executed this sync run
	Integration          *Integration                   `json:"integration"`
	DirectoryAccounts    *DirectoryAccountConnection    `json:"directoryAccounts"`
	DirectoryGroups      *DirectoryGroupConnection      `json:"directoryGroups"`
	DirectoryMemberships *DirectoryMembershipConnection `json:"directoryMemberships"`
}

func (DirectorySyncRun) IsNode() {}

// Return response for createBulkDirectorySyncRun mutation
type DirectorySyncRunBulkCreatePayload struct {
	// Created directorySyncRuns
	DirectorySyncRuns []*DirectorySyncRun `json:"directorySyncRuns,omitempty"`
}

// A connection to a list of items.
type DirectorySyncRunConnection struct {
	// A list of edges.
	Edges []*DirectorySyncRunEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDirectorySyncRun mutation
type DirectorySyncRunCreatePayload struct {
	// Created directorySyncRun
	DirectorySyncRun *DirectorySyncRun `json:"directorySyncRun"`
}

// Return response for deleteDirectorySyncRun mutation
type DirectorySyncRunDeletePayload struct {
	// Deleted directorySyncRun ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DirectorySyncRunEdge struct {
	// The item at the end of the edge.
	Node *DirectorySyncRun `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for DirectorySyncRun connections
type DirectorySyncRunOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DirectorySyncRuns.
	Field DirectorySyncRunOrderField `json:"field"`
}

// Return response for updateDirectorySyncRun mutation
type DirectorySyncRunUpdatePayload struct {
	// Updated directorySyncRun
	DirectorySyncRun *DirectorySyncRun `json:"directorySyncRun"`
}

// DirectorySyncRunWhereInput is used for filtering DirectorySyncRun objects.
// Input was generated by ent.
type DirectorySyncRunWhereInput struct {
	Not *DirectorySyncRunWhereInput   `json:"not,omitempty"`
	And []*DirectorySyncRunWhereInput `json:"and,omitempty"`
	Or  []*DirectorySyncRunWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// integration_id field predicates
	IntegrationID             *string  `json:"integrationID,omitempty"`
	IntegrationIdneq          *string  `json:"integrationIDNEQ,omitempty"`
	IntegrationIDIn           []string `json:"integrationIDIn,omitempty"`
	IntegrationIDNotIn        []string `json:"integrationIDNotIn,omitempty"`
	IntegrationIdgt           *string  `json:"integrationIDGT,omitempty"`
	IntegrationIdgte          *string  `json:"integrationIDGTE,omitempty"`
	IntegrationIdlt           *string  `json:"integrationIDLT,omitempty"`
	IntegrationIdlte          *string  `json:"integrationIDLTE,omitempty"`
	IntegrationIDContains     *string  `json:"integrationIDContains,omitempty"`
	IntegrationIDHasPrefix    *string  `json:"integrationIDHasPrefix,omitempty"`
	IntegrationIDHasSuffix    *string  `json:"integrationIDHasSuffix,omitempty"`
	IntegrationIDEqualFold    *string  `json:"integrationIDEqualFold,omitempty"`
	IntegrationIDContainsFold *string  `json:"integrationIDContainsFold,omitempty"`
	// status field predicates
	Status      *enums.DirectorySyncRunStatus  `json:"status,omitempty"`
	StatusNeq   *enums.DirectorySyncRunStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.DirectorySyncRunStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.DirectorySyncRunStatus `json:"statusNotIn,omitempty"`
	// started_at field predicates
	StartedAt      *time.Time   `json:"startedAt,omitempty"`
	StartedAtNeq   *time.Time   `json:"startedAtNEQ,omitempty"`
	StartedAtIn    []*time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn []*time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGt    *time.Time   `json:"startedAtGT,omitempty"`
	StartedAtGte   *time.Time   `json:"startedAtGTE,omitempty"`
	StartedAtLt    *time.Time   `json:"startedAtLT,omitempty"`
	StartedAtLte   *time.Time   `json:"startedAtLTE,omitempty"`
	// completed_at field predicates
	CompletedAt       *time.Time   `json:"completedAt,omitempty"`
	CompletedAtNeq    *time.Time   `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []*time.Time `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []*time.Time `json:"completedAtNotIn,omitempty"`
	CompletedAtGt     *time.Time   `json:"completedAtGT,omitempty"`
	CompletedAtGte    *time.Time   `json:"completedAtGTE,omitempty"`
	CompletedAtLt     *time.Time   `json:"completedAtLT,omitempty"`
	CompletedAtLte    *time.Time   `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  *bool        `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil *bool        `json:"completedAtNotNil,omitempty"`
	// source_cursor field predicates
	SourceCursor             *string  `json:"sourceCursor,omitempty"`
	SourceCursorNeq          *string  `json:"sourceCursorNEQ,omitempty"`
	SourceCursorIn           []string `json:"sourceCursorIn,omitempty"`
	SourceCursorNotIn        []string `json:"sourceCursorNotIn,omitempty"`
	SourceCursorGt           *string  `json:"sourceCursorGT,omitempty"`
	SourceCursorGte          *string  `json:"sourceCursorGTE,omitempty"`
	SourceCursorLt           *string  `json:"sourceCursorLT,omitempty"`
	SourceCursorLte          *string  `json:"sourceCursorLTE,omitempty"`
	SourceCursorContains     *string  `json:"sourceCursorContains,omitempty"`
	SourceCursorHasPrefix    *string  `json:"sourceCursorHasPrefix,omitempty"`
	SourceCursorHasSuffix    *string  `json:"sourceCursorHasSuffix,omitempty"`
	SourceCursorIsNil        *bool    `json:"sourceCursorIsNil,omitempty"`
	SourceCursorNotNil       *bool    `json:"sourceCursorNotNil,omitempty"`
	SourceCursorEqualFold    *string  `json:"sourceCursorEqualFold,omitempty"`
	SourceCursorContainsFold *string  `json:"sourceCursorContainsFold,omitempty"`
	// full_count field predicates
	FullCount      *int64  `json:"fullCount,omitempty"`
	FullCountNeq   *int64  `json:"fullCountNEQ,omitempty"`
	FullCountIn    []int64 `json:"fullCountIn,omitempty"`
	FullCountNotIn []int64 `json:"fullCountNotIn,omitempty"`
	FullCountGt    *int64  `json:"fullCountGT,omitempty"`
	FullCountGte   *int64  `json:"fullCountGTE,omitempty"`
	FullCountLt    *int64  `json:"fullCountLT,omitempty"`
	FullCountLte   *int64  `json:"fullCountLTE,omitempty"`
	// delta_count field predicates
	DeltaCount      *int64  `json:"deltaCount,omitempty"`
	DeltaCountNeq   *int64  `json:"deltaCountNEQ,omitempty"`
	DeltaCountIn    []int64 `json:"deltaCountIn,omitempty"`
	DeltaCountNotIn []int64 `json:"deltaCountNotIn,omitempty"`
	DeltaCountGt    *int64  `json:"deltaCountGT,omitempty"`
	DeltaCountGte   *int64  `json:"deltaCountGTE,omitempty"`
	DeltaCountLt    *int64  `json:"deltaCountLT,omitempty"`
	DeltaCountLte   *int64  `json:"deltaCountLTE,omitempty"`
	// error field predicates
	Error             *string  `json:"error,omitempty"`
	ErrorNeq          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGt           *string  `json:"errorGT,omitempty"`
	ErrorGte          *string  `json:"errorGTE,omitempty"`
	ErrorLt           *string  `json:"errorLT,omitempty"`
	ErrorLte          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        *bool    `json:"errorIsNil,omitempty"`
	ErrorNotNil       *bool    `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`
	// raw_manifest_file_id field predicates
	RawManifestFileID             *string  `json:"rawManifestFileID,omitempty"`
	RawManifestFileIdneq          *string  `json:"rawManifestFileIDNEQ,omitempty"`
	RawManifestFileIDIn           []string `json:"rawManifestFileIDIn,omitempty"`
	RawManifestFileIDNotIn        []string `json:"rawManifestFileIDNotIn,omitempty"`
	RawManifestFileIdgt           *string  `json:"rawManifestFileIDGT,omitempty"`
	RawManifestFileIdgte          *string  `json:"rawManifestFileIDGTE,omitempty"`
	RawManifestFileIdlt           *string  `json:"rawManifestFileIDLT,omitempty"`
	RawManifestFileIdlte          *string  `json:"rawManifestFileIDLTE,omitempty"`
	RawManifestFileIDContains     *string  `json:"rawManifestFileIDContains,omitempty"`
	RawManifestFileIDHasPrefix    *string  `json:"rawManifestFileIDHasPrefix,omitempty"`
	RawManifestFileIDHasSuffix    *string  `json:"rawManifestFileIDHasSuffix,omitempty"`
	RawManifestFileIDIsNil        *bool    `json:"rawManifestFileIDIsNil,omitempty"`
	RawManifestFileIDNotNil       *bool    `json:"rawManifestFileIDNotNil,omitempty"`
	RawManifestFileIDEqualFold    *string  `json:"rawManifestFileIDEqualFold,omitempty"`
	RawManifestFileIDContainsFold *string  `json:"rawManifestFileIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// integration edge predicates
	HasIntegration     *bool                    `json:"hasIntegration,omitempty"`
	HasIntegrationWith []*IntegrationWhereInput `json:"hasIntegrationWith,omitempty"`
	// directory_accounts edge predicates
	HasDirectoryAccounts     *bool                         `json:"hasDirectoryAccounts,omitempty"`
	HasDirectoryAccountsWith []*DirectoryAccountWhereInput `json:"hasDirectoryAccountsWith,omitempty"`
	// directory_groups edge predicates
	HasDirectoryGroups     *bool                       `json:"hasDirectoryGroups,omitempty"`
	HasDirectoryGroupsWith []*DirectoryGroupWhereInput `json:"hasDirectoryGroupsWith,omitempty"`
	// directory_memberships edge predicates
	HasDirectoryMemberships     *bool                            `json:"hasDirectoryMemberships,omitempty"`
	HasDirectoryMembershipsWith []*DirectoryMembershipWhereInput `json:"hasDirectoryMembershipsWith,omitempty"`
}

type DocumentData struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID *string `json:"templateID,omitempty"`
	// the json data of the document
	Data     map[string]any    `json:"data"`
	Owner    *Organization     `json:"owner,omitempty"`
	Template *Template         `json:"template,omitempty"`
	Entities *EntityConnection `json:"entities"`
	Files    *FileConnection   `json:"files"`
}

func (DocumentData) IsNode() {}

// Return response for createBulkDocumentData mutation
type DocumentDataBulkCreatePayload struct {
	// Created documentData
	DocumentData []*DocumentData `json:"documentData,omitempty"`
}

// Return response for deleteBulkDocumentData mutation
type DocumentDataBulkDeletePayload struct {
	// Deleted documentData IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type DocumentDataConnection struct {
	// A list of edges.
	Edges []*DocumentDataEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDocumentData mutation
type DocumentDataCreatePayload struct {
	// Created documentData
	DocumentData *DocumentData `json:"documentData"`
}

// Return response for deleteDocumentData mutation
type DocumentDataDeletePayload struct {
	// Deleted documentData ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DocumentDataEdge struct {
	// The item at the end of the edge.
	Node *DocumentData `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DocumentDataHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID *string `json:"templateID,omitempty"`
	// the json data of the document
	Data map[string]any `json:"data"`
}

func (DocumentDataHistory) IsNode() {}

// A connection to a list of items.
type DocumentDataHistoryConnection struct {
	// A list of edges.
	Edges []*DocumentDataHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DocumentDataHistoryEdge struct {
	// The item at the end of the edge.
	Node *DocumentDataHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for DocumentDataHistory connections
type DocumentDataHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DocumentDataHistories.
	Field DocumentDataHistoryOrderField `json:"field"`
}

// DocumentDataHistoryWhereInput is used for filtering DocumentDataHistory objects.
// Input was generated by ent.
type DocumentDataHistoryWhereInput struct {
	Not *DocumentDataHistoryWhereInput   `json:"not,omitempty"`
	And []*DocumentDataHistoryWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDIsNil        *bool    `json:"templateIDIsNil,omitempty"`
	TemplateIDNotNil       *bool    `json:"templateIDNotNil,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
}

// Ordering options for DocumentData connections
type DocumentDataOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DocumentDataSlice.
	Field DocumentDataOrderField `json:"field"`
}

// Return response for updateDocumentData mutation
type DocumentDataUpdatePayload struct {
	// Updated documentData
	DocumentData *DocumentData `json:"documentData"`
}

// DocumentDataWhereInput is used for filtering DocumentData objects.
// Input was generated by ent.
type DocumentDataWhereInput struct {
	Not *DocumentDataWhereInput   `json:"not,omitempty"`
	And []*DocumentDataWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDIsNil        *bool    `json:"templateIDIsNil,omitempty"`
	TemplateIDNotNil       *bool    `json:"templateIDNotNil,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Entity struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status        *string                 `json:"status,omitempty"`
	Owner         *Organization           `json:"owner,omitempty"`
	BlockedGroups *GroupConnection        `json:"blockedGroups"`
	Editors       *GroupConnection        `json:"editors"`
	Viewers       *GroupConnection        `json:"viewers"`
	Contacts      *ContactConnection      `json:"contacts"`
	Documents     *DocumentDataConnection `json:"documents"`
	Notes         *NoteConnection         `json:"notes"`
	Files         *FileConnection         `json:"files"`
	Assets        *AssetConnection        `json:"assets"`
	Scans         *ScanConnection         `json:"scans"`
	EntityType    *EntityType             `json:"entityType,omitempty"`
}

func (Entity) IsNode() {}

// Return response for createBulkEntity mutation
type EntityBulkCreatePayload struct {
	// Created entities
	Entities []*Entity `json:"entities,omitempty"`
}

// Return response for deleteBulkEntity mutation
type EntityBulkDeletePayload struct {
	// Deleted entity IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type EntityConnection struct {
	// A list of edges.
	Edges []*EntityEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntity mutation
type EntityCreatePayload struct {
	// Created entity
	Entity *Entity `json:"entity"`
}

// Return response for deleteEntity mutation
type EntityDeletePayload struct {
	// Deleted entity ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityEdge struct {
	// The item at the end of the edge.
	Node *Entity `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status *string `json:"status,omitempty"`
}

func (EntityHistory) IsNode() {}

// A connection to a list of items.
type EntityHistoryConnection struct {
	// A list of edges.
	Edges []*EntityHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityHistory connections
type EntityHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityHistories.
	Field EntityHistoryOrderField `json:"field"`
}

// EntityHistoryWhereInput is used for filtering EntityHistory objects.
// Input was generated by ent.
type EntityHistoryWhereInput struct {
	Not *EntityHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIdneq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIdgt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIdgte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIdlt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIdlte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
}

// Ordering options for Entity connections
type EntityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Entities.
	Field EntityOrderField `json:"field"`
}

type EntityType struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the entity
	Name     string            `json:"name"`
	Owner    *Organization     `json:"owner,omitempty"`
	Entities *EntityConnection `json:"entities"`
}

func (EntityType) IsNode() {}

// Return response for createBulkEntityType mutation
type EntityTypeBulkCreatePayload struct {
	// Created entityTypes
	EntityTypes []*EntityType `json:"entityTypes,omitempty"`
}

// Return response for deleteBulkEntityType mutation
type EntityTypeBulkDeletePayload struct {
	// Deleted entityType IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type EntityTypeConnection struct {
	// A list of edges.
	Edges []*EntityTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntityType mutation
type EntityTypeCreatePayload struct {
	// Created entityType
	EntityType *EntityType `json:"entityType"`
}

// Return response for deleteEntityType mutation
type EntityTypeDeletePayload struct {
	// Deleted entityType ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityTypeEdge struct {
	// The item at the end of the edge.
	Node *EntityType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityTypeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the entity
	Name string `json:"name"`
}

func (EntityTypeHistory) IsNode() {}

// A connection to a list of items.
type EntityTypeHistoryConnection struct {
	// A list of edges.
	Edges []*EntityTypeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityTypeHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityTypeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityTypeHistory connections
type EntityTypeHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypeHistories.
	Field EntityTypeHistoryOrderField `json:"field"`
}

// EntityTypeHistoryWhereInput is used for filtering EntityTypeHistory objects.
// Input was generated by ent.
type EntityTypeHistoryWhereInput struct {
	Not *EntityTypeHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityTypeHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// Ordering options for EntityType connections
type EntityTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypes.
	Field EntityTypeOrderField `json:"field"`
}

// Return response for updateEntityType mutation
type EntityTypeUpdatePayload struct {
	// Updated entityType
	EntityType *EntityType `json:"entityType"`
}

// EntityTypeWhereInput is used for filtering EntityType objects.
// Input was generated by ent.
type EntityTypeWhereInput struct {
	Not *EntityTypeWhereInput   `json:"not,omitempty"`
	And []*EntityTypeWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
}

// Return response for updateEntity mutation
type EntityUpdatePayload struct {
	// Updated entity
	Entity *Entity `json:"entity"`
}

// EntityWhereInput is used for filtering Entity objects.
// Input was generated by ent.
type EntityWhereInput struct {
	Not *EntityWhereInput   `json:"not,omitempty"`
	And []*EntityWhereInput `json:"and,omitempty"`
	Or  []*EntityWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIdneq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIdgt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIdgte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIdlt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIdlte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// scans edge predicates
	HasScans     *bool             `json:"hasScans,omitempty"`
	HasScansWith []*ScanWhereInput `json:"hasScansWith,omitempty"`
	// entity_type edge predicates
	HasEntityType     *bool                   `json:"hasEntityType,omitempty"`
	HasEntityTypeWith []*EntityTypeWhereInput `json:"hasEntityTypeWith,omitempty"`
}

type Event struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags                 []string                       `json:"tags,omitempty"`
	EventID              *string                        `json:"eventID,omitempty"`
	CorrelationID        *string                        `json:"correlationID,omitempty"`
	EventType            string                         `json:"eventType"`
	Metadata             map[string]any                 `json:"metadata,omitempty"`
	Users                *UserConnection                `json:"users"`
	Groups               *GroupConnection               `json:"groups"`
	Integrations         *IntegrationConnection         `json:"integrations"`
	Organizations        *OrganizationConnection        `json:"organizations"`
	Invites              *InviteConnection              `json:"invites"`
	PersonalAccessTokens *PersonalAccessTokenConnection `json:"personalAccessTokens"`
	Secrets              *HushConnection                `json:"secrets"`
	OrgMemberships       *OrgMembershipConnection       `json:"orgMemberships"`
	GroupMemberships     *GroupMembershipConnection     `json:"groupMemberships"`
	Subscribers          *SubscriberConnection          `json:"subscribers"`
	Files                *FileConnection                `json:"files"`
	OrgSubscriptions     *OrgSubscriptionConnection     `json:"orgSubscriptions"`
}

func (Event) IsNode() {}

// Return response for createBulkEvent mutation
type EventBulkCreatePayload struct {
	// Created events
	Events []*Event `json:"events,omitempty"`
}

// Return response for deleteBulkEvent mutation
type EventBulkDeletePayload struct {
	// Deleted event IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type EventConnection struct {
	// A list of edges.
	Edges []*EventEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEvent mutation
type EventCreatePayload struct {
	// Created event
	Event *Event `json:"event"`
}

// Return response for deleteEvent mutation
type EventDeletePayload struct {
	// Deleted event ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EventEdge struct {
	// The item at the end of the edge.
	Node *Event `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Event connections
type EventOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Events.
	Field EventOrderField `json:"field"`
}

// Return response for updateEvent mutation
type EventUpdatePayload struct {
	// Updated event
	Event *Event `json:"event"`
}

// EventWhereInput is used for filtering Event objects.
// Input was generated by ent.
type EventWhereInput struct {
	Not *EventWhereInput   `json:"not,omitempty"`
	And []*EventWhereInput `json:"and,omitempty"`
	Or  []*EventWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIdneq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIdgt           *string  `json:"eventIDGT,omitempty"`
	EventIdgte          *string  `json:"eventIDGTE,omitempty"`
	EventIdlt           *string  `json:"eventIDLT,omitempty"`
	EventIdlte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDIsNil        *bool    `json:"eventIDIsNil,omitempty"`
	EventIDNotNil       *bool    `json:"eventIDNotNil,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIdneq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIdgt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIdgte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIdlt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIdlte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// invites edge predicates
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// org_memberships edge predicates
	HasOrgMemberships     *bool                      `json:"hasOrgMemberships,omitempty"`
	HasOrgMembershipsWith []*OrgMembershipWhereInput `json:"hasOrgMembershipsWith,omitempty"`
	// group_memberships edge predicates
	HasGroupMemberships     *bool                        `json:"hasGroupMemberships,omitempty"`
	HasGroupMembershipsWith []*GroupMembershipWhereInput `json:"hasGroupMembershipsWith,omitempty"`
	// subscribers edge predicates
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// org_subscriptions edge predicates
	HasOrgSubscriptions     *bool                        `json:"hasOrgSubscriptions,omitempty"`
	HasOrgSubscriptionsWith []*OrgSubscriptionWhereInput `json:"hasOrgSubscriptionsWith,omitempty"`
}

type Evidence struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate time.Time `json:"creationDate"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL *string `json:"url,omitempty"`
	// the status of the evidence, ready, approved, needs renewal, missing artifact, rejected
	Status                 *enums.EvidenceStatus            `json:"status,omitempty"`
	Owner                  *Organization                    `json:"owner,omitempty"`
	Controls               *ControlConnection               `json:"controls"`
	Subcontrols            *SubcontrolConnection            `json:"subcontrols"`
	ControlObjectives      *ControlObjectiveConnection      `json:"controlObjectives"`
	ControlImplementations *ControlImplementationConnection `json:"controlImplementations"`
	Files                  *FileConnection                  `json:"files"`
	Programs               *ProgramConnection               `json:"programs"`
	Tasks                  *TaskConnection                  `json:"tasks"`
	Comments               *NoteConnection                  `json:"comments"`
}

func (Evidence) IsNode() {}

// Return response for createBulkEvidence mutation
type EvidenceBulkCreatePayload struct {
	// Created evidences
	Evidences []*Evidence `json:"evidences,omitempty"`
}

// A connection to a list of items.
type EvidenceConnection struct {
	// A list of edges.
	Edges []*EvidenceEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEvidence mutation
type EvidenceCreatePayload struct {
	// Created evidence
	Evidence *Evidence `json:"evidence"`
}

// Return response for deleteEvidence mutation
type EvidenceDeletePayload struct {
	// Deleted evidence ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EvidenceEdge struct {
	// The item at the end of the edge.
	Node *Evidence `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EvidenceHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate time.Time `json:"creationDate"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL *string `json:"url,omitempty"`
	// the status of the evidence, ready, approved, needs renewal, missing artifact, rejected
	Status *enums.EvidenceStatus `json:"status,omitempty"`
}

func (EvidenceHistory) IsNode() {}

// A connection to a list of items.
type EvidenceHistoryConnection struct {
	// A list of edges.
	Edges []*EvidenceHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EvidenceHistoryEdge struct {
	// The item at the end of the edge.
	Node *EvidenceHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EvidenceHistory connections
type EvidenceHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EvidenceHistories.
	Field EvidenceHistoryOrderField `json:"field"`
}

// EvidenceHistoryWhereInput is used for filtering EvidenceHistory objects.
// Input was generated by ent.
type EvidenceHistoryWhereInput struct {
	Not *EvidenceHistoryWhereInput   `json:"not,omitempty"`
	And []*EvidenceHistoryWhereInput `json:"and,omitempty"`
	Or  []*EvidenceHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// collection_procedure field predicates
	CollectionProcedure             *string  `json:"collectionProcedure,omitempty"`
	CollectionProcedureNeq          *string  `json:"collectionProcedureNEQ,omitempty"`
	CollectionProcedureIn           []string `json:"collectionProcedureIn,omitempty"`
	CollectionProcedureNotIn        []string `json:"collectionProcedureNotIn,omitempty"`
	CollectionProcedureGt           *string  `json:"collectionProcedureGT,omitempty"`
	CollectionProcedureGte          *string  `json:"collectionProcedureGTE,omitempty"`
	CollectionProcedureLt           *string  `json:"collectionProcedureLT,omitempty"`
	CollectionProcedureLte          *string  `json:"collectionProcedureLTE,omitempty"`
	CollectionProcedureContains     *string  `json:"collectionProcedureContains,omitempty"`
	CollectionProcedureHasPrefix    *string  `json:"collectionProcedureHasPrefix,omitempty"`
	CollectionProcedureHasSuffix    *string  `json:"collectionProcedureHasSuffix,omitempty"`
	CollectionProcedureIsNil        *bool    `json:"collectionProcedureIsNil,omitempty"`
	CollectionProcedureNotNil       *bool    `json:"collectionProcedureNotNil,omitempty"`
	CollectionProcedureEqualFold    *string  `json:"collectionProcedureEqualFold,omitempty"`
	CollectionProcedureContainsFold *string  `json:"collectionProcedureContainsFold,omitempty"`
	// creation_date field predicates
	CreationDate      *time.Time   `json:"creationDate,omitempty"`
	CreationDateNeq   *time.Time   `json:"creationDateNEQ,omitempty"`
	CreationDateIn    []*time.Time `json:"creationDateIn,omitempty"`
	CreationDateNotIn []*time.Time `json:"creationDateNotIn,omitempty"`
	CreationDateGt    *time.Time   `json:"creationDateGT,omitempty"`
	CreationDateGte   *time.Time   `json:"creationDateGTE,omitempty"`
	CreationDateLt    *time.Time   `json:"creationDateLT,omitempty"`
	CreationDateLte   *time.Time   `json:"creationDateLTE,omitempty"`
	// renewal_date field predicates
	RenewalDate       *time.Time   `json:"renewalDate,omitempty"`
	RenewalDateNeq    *time.Time   `json:"renewalDateNEQ,omitempty"`
	RenewalDateIn     []*time.Time `json:"renewalDateIn,omitempty"`
	RenewalDateNotIn  []*time.Time `json:"renewalDateNotIn,omitempty"`
	RenewalDateGt     *time.Time   `json:"renewalDateGT,omitempty"`
	RenewalDateGte    *time.Time   `json:"renewalDateGTE,omitempty"`
	RenewalDateLt     *time.Time   `json:"renewalDateLT,omitempty"`
	RenewalDateLte    *time.Time   `json:"renewalDateLTE,omitempty"`
	RenewalDateIsNil  *bool        `json:"renewalDateIsNil,omitempty"`
	RenewalDateNotNil *bool        `json:"renewalDateNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// is_automated field predicates
	IsAutomated       *bool `json:"isAutomated,omitempty"`
	IsAutomatedNeq    *bool `json:"isAutomatedNEQ,omitempty"`
	IsAutomatedIsNil  *bool `json:"isAutomatedIsNil,omitempty"`
	IsAutomatedNotNil *bool `json:"isAutomatedNotNil,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// status field predicates
	Status       *enums.EvidenceStatus  `json:"status,omitempty"`
	StatusNeq    *enums.EvidenceStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.EvidenceStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.EvidenceStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
}

// Ordering options for Evidence connections
type EvidenceOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Evidences.
	Field EvidenceOrderField `json:"field"`
}

// Return response for updateEvidence mutation
type EvidenceUpdatePayload struct {
	// Updated evidence
	Evidence *Evidence `json:"evidence"`
}

// EvidenceWhereInput is used for filtering Evidence objects.
// Input was generated by ent.
type EvidenceWhereInput struct {
	Not *EvidenceWhereInput   `json:"not,omitempty"`
	And []*EvidenceWhereInput `json:"and,omitempty"`
	Or  []*EvidenceWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// collection_procedure field predicates
	CollectionProcedure             *string  `json:"collectionProcedure,omitempty"`
	CollectionProcedureNeq          *string  `json:"collectionProcedureNEQ,omitempty"`
	CollectionProcedureIn           []string `json:"collectionProcedureIn,omitempty"`
	CollectionProcedureNotIn        []string `json:"collectionProcedureNotIn,omitempty"`
	CollectionProcedureGt           *string  `json:"collectionProcedureGT,omitempty"`
	CollectionProcedureGte          *string  `json:"collectionProcedureGTE,omitempty"`
	CollectionProcedureLt           *string  `json:"collectionProcedureLT,omitempty"`
	CollectionProcedureLte          *string  `json:"collectionProcedureLTE,omitempty"`
	CollectionProcedureContains     *string  `json:"collectionProcedureContains,omitempty"`
	CollectionProcedureHasPrefix    *string  `json:"collectionProcedureHasPrefix,omitempty"`
	CollectionProcedureHasSuffix    *string  `json:"collectionProcedureHasSuffix,omitempty"`
	CollectionProcedureIsNil        *bool    `json:"collectionProcedureIsNil,omitempty"`
	CollectionProcedureNotNil       *bool    `json:"collectionProcedureNotNil,omitempty"`
	CollectionProcedureEqualFold    *string  `json:"collectionProcedureEqualFold,omitempty"`
	CollectionProcedureContainsFold *string  `json:"collectionProcedureContainsFold,omitempty"`
	// creation_date field predicates
	CreationDate      *time.Time   `json:"creationDate,omitempty"`
	CreationDateNeq   *time.Time   `json:"creationDateNEQ,omitempty"`
	CreationDateIn    []*time.Time `json:"creationDateIn,omitempty"`
	CreationDateNotIn []*time.Time `json:"creationDateNotIn,omitempty"`
	CreationDateGt    *time.Time   `json:"creationDateGT,omitempty"`
	CreationDateGte   *time.Time   `json:"creationDateGTE,omitempty"`
	CreationDateLt    *time.Time   `json:"creationDateLT,omitempty"`
	CreationDateLte   *time.Time   `json:"creationDateLTE,omitempty"`
	// renewal_date field predicates
	RenewalDate       *time.Time   `json:"renewalDate,omitempty"`
	RenewalDateNeq    *time.Time   `json:"renewalDateNEQ,omitempty"`
	RenewalDateIn     []*time.Time `json:"renewalDateIn,omitempty"`
	RenewalDateNotIn  []*time.Time `json:"renewalDateNotIn,omitempty"`
	RenewalDateGt     *time.Time   `json:"renewalDateGT,omitempty"`
	RenewalDateGte    *time.Time   `json:"renewalDateGTE,omitempty"`
	RenewalDateLt     *time.Time   `json:"renewalDateLT,omitempty"`
	RenewalDateLte    *time.Time   `json:"renewalDateLTE,omitempty"`
	RenewalDateIsNil  *bool        `json:"renewalDateIsNil,omitempty"`
	RenewalDateNotNil *bool        `json:"renewalDateNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// is_automated field predicates
	IsAutomated       *bool `json:"isAutomated,omitempty"`
	IsAutomatedNeq    *bool `json:"isAutomatedNEQ,omitempty"`
	IsAutomatedIsNil  *bool `json:"isAutomatedIsNil,omitempty"`
	IsAutomatedNotNil *bool `json:"isAutomatedNotNil,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// status field predicates
	Status       *enums.EvidenceStatus  `json:"status,omitempty"`
	StatusNeq    *enums.EvidenceStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.EvidenceStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.EvidenceStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// control_implementations edge predicates
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
}

type Export struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the type of export, e.g., control, policy, etc.
	ExportType enums.ExportType `json:"exportType"`
	// the format of export, e.g., csv and others
	Format enums.ExportFormat `json:"format"`
	// the status of the export, e.g., pending, ready, failed
	Status enums.ExportStatus `json:"status"`
	// the user who initiated the export
	RequestorID *string `json:"requestorID,omitempty"`
	// the specific fields to include in the export (defaults to only the id if not provided)
	Fields []string `json:"fields,omitempty"`
	// the specific filters to run against the exported data. This should be a well formatted graphql query
	Filters *string `json:"filters,omitempty"`
	// if we try to export and it fails, the error message will be stored here
	ErrorMessage *string          `json:"errorMessage,omitempty"`
	Owner        *Organization    `json:"owner,omitempty"`
	Events       *EventConnection `json:"events"`
	Files        *FileConnection  `json:"files"`
}

func (Export) IsNode() {}

// Return response for createBulkExport mutation
type ExportBulkCreatePayload struct {
	// Created exports
	Exports []*Export `json:"exports,omitempty"`
}

// Return response for deleteBulkExport mutation
type ExportBulkDeletePayload struct {
	// Deleted export IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type ExportConnection struct {
	// A list of edges.
	Edges []*ExportEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createExport mutation
type ExportCreatePayload struct {
	// Created export
	Export *Export `json:"export"`
}

// Return response for deleteExport mutation
type ExportDeletePayload struct {
	// Deleted export ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ExportEdge struct {
	// The item at the end of the edge.
	Node *Export `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Export connections
type ExportOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Exports.
	Field ExportOrderField `json:"field"`
}

// Return response for updateExport mutation
type ExportUpdatePayload struct {
	// Updated export
	Export *Export `json:"export"`
}

// ExportWhereInput is used for filtering Export objects.
// Input was generated by ent.
type ExportWhereInput struct {
	Not *ExportWhereInput   `json:"not,omitempty"`
	And []*ExportWhereInput `json:"and,omitempty"`
	Or  []*ExportWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// export_type field predicates
	ExportType      *enums.ExportType  `json:"exportType,omitempty"`
	ExportTypeNeq   *enums.ExportType  `json:"exportTypeNEQ,omitempty"`
	ExportTypeIn    []enums.ExportType `json:"exportTypeIn,omitempty"`
	ExportTypeNotIn []enums.ExportType `json:"exportTypeNotIn,omitempty"`
	// format field predicates
	Format      *enums.ExportFormat  `json:"format,omitempty"`
	FormatNeq   *enums.ExportFormat  `json:"formatNEQ,omitempty"`
	FormatIn    []enums.ExportFormat `json:"formatIn,omitempty"`
	FormatNotIn []enums.ExportFormat `json:"formatNotIn,omitempty"`
	// status field predicates
	Status      *enums.ExportStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ExportStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ExportStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ExportStatus `json:"statusNotIn,omitempty"`
	// requestor_id field predicates
	RequestorID             *string  `json:"requestorID,omitempty"`
	RequestorIdneq          *string  `json:"requestorIDNEQ,omitempty"`
	RequestorIDIn           []string `json:"requestorIDIn,omitempty"`
	RequestorIDNotIn        []string `json:"requestorIDNotIn,omitempty"`
	RequestorIdgt           *string  `json:"requestorIDGT,omitempty"`
	RequestorIdgte          *string  `json:"requestorIDGTE,omitempty"`
	RequestorIdlt           *string  `json:"requestorIDLT,omitempty"`
	RequestorIdlte          *string  `json:"requestorIDLTE,omitempty"`
	RequestorIDContains     *string  `json:"requestorIDContains,omitempty"`
	RequestorIDHasPrefix    *string  `json:"requestorIDHasPrefix,omitempty"`
	RequestorIDHasSuffix    *string  `json:"requestorIDHasSuffix,omitempty"`
	RequestorIDIsNil        *bool    `json:"requestorIDIsNil,omitempty"`
	RequestorIDNotNil       *bool    `json:"requestorIDNotNil,omitempty"`
	RequestorIDEqualFold    *string  `json:"requestorIDEqualFold,omitempty"`
	RequestorIDContainsFold *string  `json:"requestorIDContainsFold,omitempty"`
	// filters field predicates
	Filters             *string  `json:"filters,omitempty"`
	FiltersNeq          *string  `json:"filtersNEQ,omitempty"`
	FiltersIn           []string `json:"filtersIn,omitempty"`
	FiltersNotIn        []string `json:"filtersNotIn,omitempty"`
	FiltersGt           *string  `json:"filtersGT,omitempty"`
	FiltersGte          *string  `json:"filtersGTE,omitempty"`
	FiltersLt           *string  `json:"filtersLT,omitempty"`
	FiltersLte          *string  `json:"filtersLTE,omitempty"`
	FiltersContains     *string  `json:"filtersContains,omitempty"`
	FiltersHasPrefix    *string  `json:"filtersHasPrefix,omitempty"`
	FiltersHasSuffix    *string  `json:"filtersHasSuffix,omitempty"`
	FiltersIsNil        *bool    `json:"filtersIsNil,omitempty"`
	FiltersNotNil       *bool    `json:"filtersNotNil,omitempty"`
	FiltersEqualFold    *string  `json:"filtersEqualFold,omitempty"`
	FiltersContainsFold *string  `json:"filtersContainsFold,omitempty"`
	// error_message field predicates
	ErrorMessage             *string  `json:"errorMessage,omitempty"`
	ErrorMessageNeq          *string  `json:"errorMessageNEQ,omitempty"`
	ErrorMessageIn           []string `json:"errorMessageIn,omitempty"`
	ErrorMessageNotIn        []string `json:"errorMessageNotIn,omitempty"`
	ErrorMessageGt           *string  `json:"errorMessageGT,omitempty"`
	ErrorMessageGte          *string  `json:"errorMessageGTE,omitempty"`
	ErrorMessageLt           *string  `json:"errorMessageLT,omitempty"`
	ErrorMessageLte          *string  `json:"errorMessageLTE,omitempty"`
	ErrorMessageContains     *string  `json:"errorMessageContains,omitempty"`
	ErrorMessageHasPrefix    *string  `json:"errorMessageHasPrefix,omitempty"`
	ErrorMessageHasSuffix    *string  `json:"errorMessageHasSuffix,omitempty"`
	ErrorMessageIsNil        *bool    `json:"errorMessageIsNil,omitempty"`
	ErrorMessageNotNil       *bool    `json:"errorMessageNotNil,omitempty"`
	ErrorMessageEqualFold    *string  `json:"errorMessageEqualFold,omitempty"`
	ErrorMessageContainsFold *string  `json:"errorMessageContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type File struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath *string `json:"storagePath,omitempty"`
	// additional metadata about the file
	Metadata map[string]any `json:"metadata,omitempty"`
	// the region the file is stored in, if applicable
	StorageRegion *string `json:"storageRegion,omitempty"`
	// the storage provider the file is stored in, if applicable
	StorageProvider     *string                      `json:"storageProvider,omitempty"`
	LastAccessedAt      *time.Time                   `json:"lastAccessedAt,omitempty"`
	Organization        []*Organization              `json:"organization,omitempty"`
	Groups              *GroupConnection             `json:"groups"`
	Contact             []*Contact                   `json:"contact,omitempty"`
	Entity              []*Entity                    `json:"entity,omitempty"`
	OrganizationSetting []*OrganizationSetting       `json:"organizationSetting,omitempty"`
	Template            []*Template                  `json:"template,omitempty"`
	Document            []*DocumentData              `json:"document,omitempty"`
	Program             []*Program                   `json:"program,omitempty"`
	Evidence            []*Evidence                  `json:"evidence,omitempty"`
	Events              *EventConnection             `json:"events"`
	TrustCenterSetting  []*TrustCenterSetting        `json:"trustCenterSetting,omitempty"`
	Integrations        *IntegrationConnection       `json:"integrations"`
	Secrets             *HushConnection              `json:"secrets"`
	TrustcenterEntities *TrustcenterEntityConnection `json:"trustcenterEntities"`
	PresignedURL        *string                      `json:"presignedURL,omitempty"`
}

func (File) IsNode() {}

// A connection to a list of items.
type FileConnection struct {
	// A list of edges.
	Edges []*FileEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for deleteFile mutation
type FileDeletePayload struct {
	// Deleted file ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FileEdge struct {
	// The item at the end of the edge.
	Node *File `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FileHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath *string `json:"storagePath,omitempty"`
	// additional metadata about the file
	Metadata map[string]any `json:"metadata,omitempty"`
	// the region the file is stored in, if applicable
	StorageRegion *string `json:"storageRegion,omitempty"`
	// the storage provider the file is stored in, if applicable
	StorageProvider *string    `json:"storageProvider,omitempty"`
	LastAccessedAt  *time.Time `json:"lastAccessedAt,omitempty"`
}

func (FileHistory) IsNode() {}

// A connection to a list of items.
type FileHistoryConnection struct {
	// A list of edges.
	Edges []*FileHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FileHistoryEdge struct {
	// The item at the end of the edge.
	Node *FileHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for FileHistory connections
type FileHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order FileHistories.
	Field FileHistoryOrderField `json:"field"`
}

// FileHistoryWhereInput is used for filtering FileHistory objects.
// Input was generated by ent.
type FileHistoryWhereInput struct {
	Not *FileHistoryWhereInput   `json:"not,omitempty"`
	And []*FileHistoryWhereInput `json:"and,omitempty"`
	Or  []*FileHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// provided_file_name field predicates
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNeq          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGt           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGte          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLt           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLte          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`
	// provided_file_extension field predicates
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNeq          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGt           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGte          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLt           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLte          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`
	// provided_file_size field predicates
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNeq    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGt     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGte    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLt     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLte    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  *bool   `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil *bool   `json:"providedFileSizeNotNil,omitempty"`
	// persisted_file_size field predicates
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNeq    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGt     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGte    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLt     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLte    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  *bool   `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil *bool   `json:"persistedFileSizeNotNil,omitempty"`
	// detected_mime_type field predicates
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNeq          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGt           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGte          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLt           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLte          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        *bool    `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       *bool    `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`
	// md5_hash field predicates
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNeq          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGt           *string  `json:"md5HashGT,omitempty"`
	Md5HashGte          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLt           *string  `json:"md5HashLT,omitempty"`
	Md5HashLte          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        *bool    `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       *bool    `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`
	// detected_content_type field predicates
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNeq          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGt           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGte          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLt           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLte          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        *bool    `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       *bool    `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category_type field predicates
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNeq          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGt           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGte          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLt           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLte          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        *bool    `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       *bool    `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`
	// uri field predicates
	URI             *string  `json:"uri,omitempty"`
	URINeq          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGt           *string  `json:"uriGT,omitempty"`
	URIGte          *string  `json:"uriGTE,omitempty"`
	URILt           *string  `json:"uriLT,omitempty"`
	URILte          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        *bool    `json:"uriIsNil,omitempty"`
	URINotNil       *bool    `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`
	// storage_scheme field predicates
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNeq          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGt           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGte          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLt           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLte          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        *bool    `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       *bool    `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`
	// storage_volume field predicates
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNeq          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGt           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGte          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLt           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLte          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        *bool    `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       *bool    `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`
	// storage_path field predicates
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNeq          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGt           *string  `json:"storagePathGT,omitempty"`
	StoragePathGte          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLt           *string  `json:"storagePathLT,omitempty"`
	StoragePathLte          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        *bool    `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       *bool    `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
	// storage_region field predicates
	StorageRegion             *string  `json:"storageRegion,omitempty"`
	StorageRegionNeq          *string  `json:"storageRegionNEQ,omitempty"`
	StorageRegionIn           []string `json:"storageRegionIn,omitempty"`
	StorageRegionNotIn        []string `json:"storageRegionNotIn,omitempty"`
	StorageRegionGt           *string  `json:"storageRegionGT,omitempty"`
	StorageRegionGte          *string  `json:"storageRegionGTE,omitempty"`
	StorageRegionLt           *string  `json:"storageRegionLT,omitempty"`
	StorageRegionLte          *string  `json:"storageRegionLTE,omitempty"`
	StorageRegionContains     *string  `json:"storageRegionContains,omitempty"`
	StorageRegionHasPrefix    *string  `json:"storageRegionHasPrefix,omitempty"`
	StorageRegionHasSuffix    *string  `json:"storageRegionHasSuffix,omitempty"`
	StorageRegionIsNil        *bool    `json:"storageRegionIsNil,omitempty"`
	StorageRegionNotNil       *bool    `json:"storageRegionNotNil,omitempty"`
	StorageRegionEqualFold    *string  `json:"storageRegionEqualFold,omitempty"`
	StorageRegionContainsFold *string  `json:"storageRegionContainsFold,omitempty"`
	// storage_provider field predicates
	StorageProvider             *string  `json:"storageProvider,omitempty"`
	StorageProviderNeq          *string  `json:"storageProviderNEQ,omitempty"`
	StorageProviderIn           []string `json:"storageProviderIn,omitempty"`
	StorageProviderNotIn        []string `json:"storageProviderNotIn,omitempty"`
	StorageProviderGt           *string  `json:"storageProviderGT,omitempty"`
	StorageProviderGte          *string  `json:"storageProviderGTE,omitempty"`
	StorageProviderLt           *string  `json:"storageProviderLT,omitempty"`
	StorageProviderLte          *string  `json:"storageProviderLTE,omitempty"`
	StorageProviderContains     *string  `json:"storageProviderContains,omitempty"`
	StorageProviderHasPrefix    *string  `json:"storageProviderHasPrefix,omitempty"`
	StorageProviderHasSuffix    *string  `json:"storageProviderHasSuffix,omitempty"`
	StorageProviderIsNil        *bool    `json:"storageProviderIsNil,omitempty"`
	StorageProviderNotNil       *bool    `json:"storageProviderNotNil,omitempty"`
	StorageProviderEqualFold    *string  `json:"storageProviderEqualFold,omitempty"`
	StorageProviderContainsFold *string  `json:"storageProviderContainsFold,omitempty"`
	// last_accessed_at field predicates
	LastAccessedAt       *time.Time   `json:"lastAccessedAt,omitempty"`
	LastAccessedAtNeq    *time.Time   `json:"lastAccessedAtNEQ,omitempty"`
	LastAccessedAtIn     []*time.Time `json:"lastAccessedAtIn,omitempty"`
	LastAccessedAtNotIn  []*time.Time `json:"lastAccessedAtNotIn,omitempty"`
	LastAccessedAtGt     *time.Time   `json:"lastAccessedAtGT,omitempty"`
	LastAccessedAtGte    *time.Time   `json:"lastAccessedAtGTE,omitempty"`
	LastAccessedAtLt     *time.Time   `json:"lastAccessedAtLT,omitempty"`
	LastAccessedAtLte    *time.Time   `json:"lastAccessedAtLTE,omitempty"`
	LastAccessedAtIsNil  *bool        `json:"lastAccessedAtIsNil,omitempty"`
	LastAccessedAtNotNil *bool        `json:"lastAccessedAtNotNil,omitempty"`
}

// Ordering options for File connections
type FileOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Files.
	Field FileOrderField `json:"field"`
}

// FileWhereInput is used for filtering File objects.
// Input was generated by ent.
type FileWhereInput struct {
	Not *FileWhereInput   `json:"not,omitempty"`
	And []*FileWhereInput `json:"and,omitempty"`
	Or  []*FileWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// provided_file_name field predicates
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNeq          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGt           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGte          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLt           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLte          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`
	// provided_file_extension field predicates
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNeq          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGt           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGte          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLt           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLte          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`
	// provided_file_size field predicates
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNeq    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGt     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGte    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLt     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLte    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  *bool   `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil *bool   `json:"providedFileSizeNotNil,omitempty"`
	// persisted_file_size field predicates
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNeq    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGt     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGte    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLt     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLte    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  *bool   `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil *bool   `json:"persistedFileSizeNotNil,omitempty"`
	// detected_mime_type field predicates
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNeq          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGt           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGte          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLt           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLte          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        *bool    `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       *bool    `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`
	// md5_hash field predicates
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNeq          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGt           *string  `json:"md5HashGT,omitempty"`
	Md5HashGte          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLt           *string  `json:"md5HashLT,omitempty"`
	Md5HashLte          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        *bool    `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       *bool    `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`
	// detected_content_type field predicates
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNeq          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGt           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGte          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLt           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLte          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        *bool    `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       *bool    `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category_type field predicates
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNeq          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGt           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGte          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLt           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLte          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        *bool    `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       *bool    `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`
	// uri field predicates
	URI             *string  `json:"uri,omitempty"`
	URINeq          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGt           *string  `json:"uriGT,omitempty"`
	URIGte          *string  `json:"uriGTE,omitempty"`
	URILt           *string  `json:"uriLT,omitempty"`
	URILte          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        *bool    `json:"uriIsNil,omitempty"`
	URINotNil       *bool    `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`
	// storage_scheme field predicates
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNeq          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGt           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGte          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLt           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLte          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        *bool    `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       *bool    `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`
	// storage_volume field predicates
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNeq          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGt           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGte          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLt           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLte          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        *bool    `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       *bool    `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`
	// storage_path field predicates
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNeq          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGt           *string  `json:"storagePathGT,omitempty"`
	StoragePathGte          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLt           *string  `json:"storagePathLT,omitempty"`
	StoragePathLte          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        *bool    `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       *bool    `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
	// storage_region field predicates
	StorageRegion             *string  `json:"storageRegion,omitempty"`
	StorageRegionNeq          *string  `json:"storageRegionNEQ,omitempty"`
	StorageRegionIn           []string `json:"storageRegionIn,omitempty"`
	StorageRegionNotIn        []string `json:"storageRegionNotIn,omitempty"`
	StorageRegionGt           *string  `json:"storageRegionGT,omitempty"`
	StorageRegionGte          *string  `json:"storageRegionGTE,omitempty"`
	StorageRegionLt           *string  `json:"storageRegionLT,omitempty"`
	StorageRegionLte          *string  `json:"storageRegionLTE,omitempty"`
	StorageRegionContains     *string  `json:"storageRegionContains,omitempty"`
	StorageRegionHasPrefix    *string  `json:"storageRegionHasPrefix,omitempty"`
	StorageRegionHasSuffix    *string  `json:"storageRegionHasSuffix,omitempty"`
	StorageRegionIsNil        *bool    `json:"storageRegionIsNil,omitempty"`
	StorageRegionNotNil       *bool    `json:"storageRegionNotNil,omitempty"`
	StorageRegionEqualFold    *string  `json:"storageRegionEqualFold,omitempty"`
	StorageRegionContainsFold *string  `json:"storageRegionContainsFold,omitempty"`
	// storage_provider field predicates
	StorageProvider             *string  `json:"storageProvider,omitempty"`
	StorageProviderNeq          *string  `json:"storageProviderNEQ,omitempty"`
	StorageProviderIn           []string `json:"storageProviderIn,omitempty"`
	StorageProviderNotIn        []string `json:"storageProviderNotIn,omitempty"`
	StorageProviderGt           *string  `json:"storageProviderGT,omitempty"`
	StorageProviderGte          *string  `json:"storageProviderGTE,omitempty"`
	StorageProviderLt           *string  `json:"storageProviderLT,omitempty"`
	StorageProviderLte          *string  `json:"storageProviderLTE,omitempty"`
	StorageProviderContains     *string  `json:"storageProviderContains,omitempty"`
	StorageProviderHasPrefix    *string  `json:"storageProviderHasPrefix,omitempty"`
	StorageProviderHasSuffix    *string  `json:"storageProviderHasSuffix,omitempty"`
	StorageProviderIsNil        *bool    `json:"storageProviderIsNil,omitempty"`
	StorageProviderNotNil       *bool    `json:"storageProviderNotNil,omitempty"`
	StorageProviderEqualFold    *string  `json:"storageProviderEqualFold,omitempty"`
	StorageProviderContainsFold *string  `json:"storageProviderContainsFold,omitempty"`
	// last_accessed_at field predicates
	LastAccessedAt       *time.Time   `json:"lastAccessedAt,omitempty"`
	LastAccessedAtNeq    *time.Time   `json:"lastAccessedAtNEQ,omitempty"`
	LastAccessedAtIn     []*time.Time `json:"lastAccessedAtIn,omitempty"`
	LastAccessedAtNotIn  []*time.Time `json:"lastAccessedAtNotIn,omitempty"`
	LastAccessedAtGt     *time.Time   `json:"lastAccessedAtGT,omitempty"`
	LastAccessedAtGte    *time.Time   `json:"lastAccessedAtGTE,omitempty"`
	LastAccessedAtLt     *time.Time   `json:"lastAccessedAtLT,omitempty"`
	LastAccessedAtLte    *time.Time   `json:"lastAccessedAtLTE,omitempty"`
	LastAccessedAtIsNil  *bool        `json:"lastAccessedAtIsNil,omitempty"`
	LastAccessedAtNotNil *bool        `json:"lastAccessedAtNotNil,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// contact edge predicates
	HasContact     *bool                `json:"hasContact,omitempty"`
	HasContactWith []*ContactWhereInput `json:"hasContactWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
	// organization_setting edge predicates
	HasOrganizationSetting     *bool                            `json:"hasOrganizationSetting,omitempty"`
	HasOrganizationSettingWith []*OrganizationSettingWhereInput `json:"hasOrganizationSettingWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// document edge predicates
	HasDocument     *bool                     `json:"hasDocument,omitempty"`
	HasDocumentWith []*DocumentDataWhereInput `json:"hasDocumentWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// trust_center_setting edge predicates
	HasTrustCenterSetting     *bool                           `json:"hasTrustCenterSetting,omitempty"`
	HasTrustCenterSettingWith []*TrustCenterSettingWhereInput `json:"hasTrustCenterSettingWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// trustcenter_entities edge predicates
	HasTrustcenterEntities     *bool                          `json:"hasTrustcenterEntities,omitempty"`
	HasTrustcenterEntitiesWith []*TrustcenterEntityWhereInput `json:"hasTrustcenterEntitiesWith,omitempty"`
}

type Finding struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the finding
	ExternalID *string `json:"externalID,omitempty"`
	// the owner of the finding
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// system that produced the finding, e.g. gcp_scc
	Source *string `json:"source,omitempty"`
	// resource identifier provided by the source system
	ResourceName *string `json:"resourceName,omitempty"`
	// display name for the finding when provided by the source
	DisplayName *string `json:"displayName,omitempty"`
	// state reported by the source system, such as ACTIVE or INACTIVE
	State *string `json:"state,omitempty"`
	// primary category of the finding
	Category *string `json:"category,omitempty"`
	// normalized categories for the finding
	Categories []string `json:"categories,omitempty"`
	// classification provided by the source, e.g. MISCONFIGURATION
	FindingClass *string `json:"findingClass,omitempty"`
	// severity label for the finding
	Severity *string `json:"severity,omitempty"`
	// numeric severity score for the finding if provided
	NumericSeverity *float64 `json:"numericSeverity,omitempty"`
	// aggregated score such as CVSS for the finding
	Score *float64 `json:"score,omitempty"`
	// impact score or rating for the finding
	Impact *float64 `json:"impact,omitempty"`
	// exploitability score or rating for the finding
	Exploitability *float64 `json:"exploitability,omitempty"`
	// priority assigned to the finding
	Priority *string `json:"priority,omitempty"`
	// indicates if the finding is still open
	Open *bool `json:"open,omitempty"`
	// true when the finding blocks production changes
	BlocksProduction *bool `json:"blocksProduction,omitempty"`
	// true when the finding affects production systems
	Production *bool `json:"production,omitempty"`
	// true when the finding is publicly disclosed
	Public *bool `json:"public,omitempty"`
	// true when the finding has been validated by the security team
	Validated *bool `json:"validated,omitempty"`
	// identifier for the assessment that generated the finding
	AssessmentID *string `json:"assessmentID,omitempty"`
	// long form description of the finding
	Description *string `json:"description,omitempty"`
	// short recommendation text from the source system (deprecated upstream)
	Recommendation *string `json:"recommendation,omitempty"`
	// markdown formatted remediation guidance for the finding
	RecommendedActions *string `json:"recommendedActions,omitempty"`
	// reference links for the finding
	References []string `json:"references,omitempty"`
	// steps required to reproduce the finding
	StepsToReproduce []string `json:"stepsToReproduce,omitempty"`
	// targets impacted by the finding such as projects or applications
	Targets []string `json:"targets,omitempty"`
	// structured details about the impacted targets
	TargetDetails map[string]any `json:"targetDetails,omitempty"`
	// attack vector string such as a CVSS vector
	Vector *string `json:"vector,omitempty"`
	// remediation service level agreement in days
	RemediationSLA *int64 `json:"remediationSLA,omitempty"`
	// lifecycle status of the finding
	Status *string `json:"status,omitempty"`
	// timestamp when the finding was last observed by the source
	EventTime *models.DateTime `json:"eventTime,omitempty"`
	// timestamp when the finding was first reported by the source
	ReportedAt *models.DateTime `json:"reportedAt,omitempty"`
	// timestamp when the source last updated the finding
	SourceUpdatedAt *models.DateTime `json:"sourceUpdatedAt,omitempty"`
	// link to the finding in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the finding from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload         map[string]any               `json:"rawPayload,omitempty"`
	Owner              *Organization                `json:"owner,omitempty"`
	BlockedGroups      *GroupConnection             `json:"blockedGroups"`
	Editors            *GroupConnection             `json:"editors"`
	Viewers            *GroupConnection             `json:"viewers"`
	Integrations       *IntegrationConnection       `json:"integrations"`
	Vulnerabilities    *VulnerabilityConnection     `json:"vulnerabilities"`
	ActionPlans        *ActionPlanConnection        `json:"actionPlans"`
	Controls           *ControlConnection           `json:"controls"`
	Subcontrols        *SubcontrolConnection        `json:"subcontrols"`
	Risks              *RiskConnection              `json:"risks"`
	Programs           *ProgramConnection           `json:"programs"`
	Assets             *AssetConnection             `json:"assets"`
	Entities           *EntityConnection            `json:"entities"`
	Scans              *ScanConnection              `json:"scans"`
	Tasks              *TaskConnection              `json:"tasks"`
	Remediations       *RemediationConnection       `json:"remediations"`
	Reviews            *ReviewConnection            `json:"reviews"`
	Comments           *NoteConnection              `json:"comments"`
	Files              *FileConnection              `json:"files"`
	WorkflowObjectRefs *WorkflowObjectRefConnection `json:"workflowObjectRefs"`
	ControlMappings    *FindingControlConnection    `json:"controlMappings"`
}

func (Finding) IsNode() {}

// Return response for createBulkFinding mutation
type FindingBulkCreatePayload struct {
	// Created findings
	Findings []*Finding `json:"findings,omitempty"`
}

// A connection to a list of items.
type FindingConnection struct {
	// A list of edges.
	Edges []*FindingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

type FindingControl struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the id of the finding associated with the control
	FindingID string `json:"findingID"`
	// the id of the control mapped to the finding when it exists in the catalog
	ControlID string `json:"controlID"`
	// the id of the standard that the control belongs to when it exists in the catalog
	StandardID *string `json:"standardID,omitempty"`
	// external identifier for the standard provided by the source system such as iso or hipaa
	ExternalStandard *string `json:"externalStandard,omitempty"`
	// version for the external standard provided by the source system
	ExternalStandardVersion *string `json:"externalStandardVersion,omitempty"`
	// control identifier provided by the source system such as A.5.10
	ExternalControlID *string `json:"externalControlID,omitempty"`
	// the integration source that provided the mapping
	Source *string `json:"source,omitempty"`
	// additional metadata about the control mapping from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// timestamp when the mapping was first observed
	DiscoveredAt *models.DateTime `json:"discoveredAt,omitempty"`
	Finding      *Finding         `json:"finding"`
	Control      *Control         `json:"control"`
	Standard     *Standard        `json:"standard,omitempty"`
}

func (FindingControl) IsNode() {}

// Return response for createBulkFindingControl mutation
type FindingControlBulkCreatePayload struct {
	// Created findingControls
	FindingControls []*FindingControl `json:"findingControls,omitempty"`
}

// A connection to a list of items.
type FindingControlConnection struct {
	// A list of edges.
	Edges []*FindingControlEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createFindingControl mutation
type FindingControlCreatePayload struct {
	// Created findingControl
	FindingControl *FindingControl `json:"findingControl"`
}

// Return response for deleteFindingControl mutation
type FindingControlDeletePayload struct {
	// Deleted findingControl ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FindingControlEdge struct {
	// The item at the end of the edge.
	Node *FindingControl `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FindingControlHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// the id of the finding associated with the control
	FindingID string `json:"findingID"`
	// the id of the control mapped to the finding when it exists in the catalog
	ControlID string `json:"controlID"`
	// the id of the standard that the control belongs to when it exists in the catalog
	StandardID *string `json:"standardID,omitempty"`
	// external identifier for the standard provided by the source system such as iso or hipaa
	ExternalStandard *string `json:"externalStandard,omitempty"`
	// version for the external standard provided by the source system
	ExternalStandardVersion *string `json:"externalStandardVersion,omitempty"`
	// control identifier provided by the source system such as A.5.10
	ExternalControlID *string `json:"externalControlID,omitempty"`
	// the integration source that provided the mapping
	Source *string `json:"source,omitempty"`
	// additional metadata about the control mapping from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// timestamp when the mapping was first observed
	DiscoveredAt *models.DateTime `json:"discoveredAt,omitempty"`
}

func (FindingControlHistory) IsNode() {}

// A connection to a list of items.
type FindingControlHistoryConnection struct {
	// A list of edges.
	Edges []*FindingControlHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FindingControlHistoryEdge struct {
	// The item at the end of the edge.
	Node *FindingControlHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for FindingControlHistory connections
type FindingControlHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order FindingControlHistories.
	Field FindingControlHistoryOrderField `json:"field"`
}

// FindingControlHistoryWhereInput is used for filtering FindingControlHistory objects.
// Input was generated by ent.
type FindingControlHistoryWhereInput struct {
	Not *FindingControlHistoryWhereInput   `json:"not,omitempty"`
	And []*FindingControlHistoryWhereInput `json:"and,omitempty"`
	Or  []*FindingControlHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// finding_id field predicates
	FindingID             *string  `json:"findingID,omitempty"`
	FindingIdneq          *string  `json:"findingIDNEQ,omitempty"`
	FindingIDIn           []string `json:"findingIDIn,omitempty"`
	FindingIDNotIn        []string `json:"findingIDNotIn,omitempty"`
	FindingIdgt           *string  `json:"findingIDGT,omitempty"`
	FindingIdgte          *string  `json:"findingIDGTE,omitempty"`
	FindingIdlt           *string  `json:"findingIDLT,omitempty"`
	FindingIdlte          *string  `json:"findingIDLTE,omitempty"`
	FindingIDContains     *string  `json:"findingIDContains,omitempty"`
	FindingIDHasPrefix    *string  `json:"findingIDHasPrefix,omitempty"`
	FindingIDHasSuffix    *string  `json:"findingIDHasSuffix,omitempty"`
	FindingIDEqualFold    *string  `json:"findingIDEqualFold,omitempty"`
	FindingIDContainsFold *string  `json:"findingIDContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
	// external_standard field predicates
	ExternalStandard             *string  `json:"externalStandard,omitempty"`
	ExternalStandardNeq          *string  `json:"externalStandardNEQ,omitempty"`
	ExternalStandardIn           []string `json:"externalStandardIn,omitempty"`
	ExternalStandardNotIn        []string `json:"externalStandardNotIn,omitempty"`
	ExternalStandardGt           *string  `json:"externalStandardGT,omitempty"`
	ExternalStandardGte          *string  `json:"externalStandardGTE,omitempty"`
	ExternalStandardLt           *string  `json:"externalStandardLT,omitempty"`
	ExternalStandardLte          *string  `json:"externalStandardLTE,omitempty"`
	ExternalStandardContains     *string  `json:"externalStandardContains,omitempty"`
	ExternalStandardHasPrefix    *string  `json:"externalStandardHasPrefix,omitempty"`
	ExternalStandardHasSuffix    *string  `json:"externalStandardHasSuffix,omitempty"`
	ExternalStandardIsNil        *bool    `json:"externalStandardIsNil,omitempty"`
	ExternalStandardNotNil       *bool    `json:"externalStandardNotNil,omitempty"`
	ExternalStandardEqualFold    *string  `json:"externalStandardEqualFold,omitempty"`
	ExternalStandardContainsFold *string  `json:"externalStandardContainsFold,omitempty"`
	// external_standard_version field predicates
	ExternalStandardVersion             *string  `json:"externalStandardVersion,omitempty"`
	ExternalStandardVersionNeq          *string  `json:"externalStandardVersionNEQ,omitempty"`
	ExternalStandardVersionIn           []string `json:"externalStandardVersionIn,omitempty"`
	ExternalStandardVersionNotIn        []string `json:"externalStandardVersionNotIn,omitempty"`
	ExternalStandardVersionGt           *string  `json:"externalStandardVersionGT,omitempty"`
	ExternalStandardVersionGte          *string  `json:"externalStandardVersionGTE,omitempty"`
	ExternalStandardVersionLt           *string  `json:"externalStandardVersionLT,omitempty"`
	ExternalStandardVersionLte          *string  `json:"externalStandardVersionLTE,omitempty"`
	ExternalStandardVersionContains     *string  `json:"externalStandardVersionContains,omitempty"`
	ExternalStandardVersionHasPrefix    *string  `json:"externalStandardVersionHasPrefix,omitempty"`
	ExternalStandardVersionHasSuffix    *string  `json:"externalStandardVersionHasSuffix,omitempty"`
	ExternalStandardVersionIsNil        *bool    `json:"externalStandardVersionIsNil,omitempty"`
	ExternalStandardVersionNotNil       *bool    `json:"externalStandardVersionNotNil,omitempty"`
	ExternalStandardVersionEqualFold    *string  `json:"externalStandardVersionEqualFold,omitempty"`
	ExternalStandardVersionContainsFold *string  `json:"externalStandardVersionContainsFold,omitempty"`
	// external_control_id field predicates
	ExternalControlID             *string  `json:"externalControlID,omitempty"`
	ExternalControlIdneq          *string  `json:"externalControlIDNEQ,omitempty"`
	ExternalControlIDIn           []string `json:"externalControlIDIn,omitempty"`
	ExternalControlIDNotIn        []string `json:"externalControlIDNotIn,omitempty"`
	ExternalControlIdgt           *string  `json:"externalControlIDGT,omitempty"`
	ExternalControlIdgte          *string  `json:"externalControlIDGTE,omitempty"`
	ExternalControlIdlt           *string  `json:"externalControlIDLT,omitempty"`
	ExternalControlIdlte          *string  `json:"externalControlIDLTE,omitempty"`
	ExternalControlIDContains     *string  `json:"externalControlIDContains,omitempty"`
	ExternalControlIDHasPrefix    *string  `json:"externalControlIDHasPrefix,omitempty"`
	ExternalControlIDHasSuffix    *string  `json:"externalControlIDHasSuffix,omitempty"`
	ExternalControlIDIsNil        *bool    `json:"externalControlIDIsNil,omitempty"`
	ExternalControlIDNotNil       *bool    `json:"externalControlIDNotNil,omitempty"`
	ExternalControlIDEqualFold    *string  `json:"externalControlIDEqualFold,omitempty"`
	ExternalControlIDContainsFold *string  `json:"externalControlIDContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// discovered_at field predicates
	DiscoveredAt       *models.DateTime   `json:"discoveredAt,omitempty"`
	DiscoveredAtNeq    *models.DateTime   `json:"discoveredAtNEQ,omitempty"`
	DiscoveredAtIn     []*models.DateTime `json:"discoveredAtIn,omitempty"`
	DiscoveredAtNotIn  []*models.DateTime `json:"discoveredAtNotIn,omitempty"`
	DiscoveredAtGt     *models.DateTime   `json:"discoveredAtGT,omitempty"`
	DiscoveredAtGte    *models.DateTime   `json:"discoveredAtGTE,omitempty"`
	DiscoveredAtLt     *models.DateTime   `json:"discoveredAtLT,omitempty"`
	DiscoveredAtLte    *models.DateTime   `json:"discoveredAtLTE,omitempty"`
	DiscoveredAtIsNil  *bool              `json:"discoveredAtIsNil,omitempty"`
	DiscoveredAtNotNil *bool              `json:"discoveredAtNotNil,omitempty"`
}

// Ordering options for FindingControl connections
type FindingControlOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order FindingControls.
	Field FindingControlOrderField `json:"field"`
}

// Return response for updateFindingControl mutation
type FindingControlUpdatePayload struct {
	// Updated findingControl
	FindingControl *FindingControl `json:"findingControl"`
}

// FindingControlWhereInput is used for filtering FindingControl objects.
// Input was generated by ent.
type FindingControlWhereInput struct {
	Not *FindingControlWhereInput   `json:"not,omitempty"`
	And []*FindingControlWhereInput `json:"and,omitempty"`
	Or  []*FindingControlWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// external_standard field predicates
	ExternalStandard             *string  `json:"externalStandard,omitempty"`
	ExternalStandardNeq          *string  `json:"externalStandardNEQ,omitempty"`
	ExternalStandardIn           []string `json:"externalStandardIn,omitempty"`
	ExternalStandardNotIn        []string `json:"externalStandardNotIn,omitempty"`
	ExternalStandardGt           *string  `json:"externalStandardGT,omitempty"`
	ExternalStandardGte          *string  `json:"externalStandardGTE,omitempty"`
	ExternalStandardLt           *string  `json:"externalStandardLT,omitempty"`
	ExternalStandardLte          *string  `json:"externalStandardLTE,omitempty"`
	ExternalStandardContains     *string  `json:"externalStandardContains,omitempty"`
	ExternalStandardHasPrefix    *string  `json:"externalStandardHasPrefix,omitempty"`
	ExternalStandardHasSuffix    *string  `json:"externalStandardHasSuffix,omitempty"`
	ExternalStandardIsNil        *bool    `json:"externalStandardIsNil,omitempty"`
	ExternalStandardNotNil       *bool    `json:"externalStandardNotNil,omitempty"`
	ExternalStandardEqualFold    *string  `json:"externalStandardEqualFold,omitempty"`
	ExternalStandardContainsFold *string  `json:"externalStandardContainsFold,omitempty"`
	// external_standard_version field predicates
	ExternalStandardVersion             *string  `json:"externalStandardVersion,omitempty"`
	ExternalStandardVersionNeq          *string  `json:"externalStandardVersionNEQ,omitempty"`
	ExternalStandardVersionIn           []string `json:"externalStandardVersionIn,omitempty"`
	ExternalStandardVersionNotIn        []string `json:"externalStandardVersionNotIn,omitempty"`
	ExternalStandardVersionGt           *string  `json:"externalStandardVersionGT,omitempty"`
	ExternalStandardVersionGte          *string  `json:"externalStandardVersionGTE,omitempty"`
	ExternalStandardVersionLt           *string  `json:"externalStandardVersionLT,omitempty"`
	ExternalStandardVersionLte          *string  `json:"externalStandardVersionLTE,omitempty"`
	ExternalStandardVersionContains     *string  `json:"externalStandardVersionContains,omitempty"`
	ExternalStandardVersionHasPrefix    *string  `json:"externalStandardVersionHasPrefix,omitempty"`
	ExternalStandardVersionHasSuffix    *string  `json:"externalStandardVersionHasSuffix,omitempty"`
	ExternalStandardVersionIsNil        *bool    `json:"externalStandardVersionIsNil,omitempty"`
	ExternalStandardVersionNotNil       *bool    `json:"externalStandardVersionNotNil,omitempty"`
	ExternalStandardVersionEqualFold    *string  `json:"externalStandardVersionEqualFold,omitempty"`
	ExternalStandardVersionContainsFold *string  `json:"externalStandardVersionContainsFold,omitempty"`
	// external_control_id field predicates
	ExternalControlID             *string  `json:"externalControlID,omitempty"`
	ExternalControlIdneq          *string  `json:"externalControlIDNEQ,omitempty"`
	ExternalControlIDIn           []string `json:"externalControlIDIn,omitempty"`
	ExternalControlIDNotIn        []string `json:"externalControlIDNotIn,omitempty"`
	ExternalControlIdgt           *string  `json:"externalControlIDGT,omitempty"`
	ExternalControlIdgte          *string  `json:"externalControlIDGTE,omitempty"`
	ExternalControlIdlt           *string  `json:"externalControlIDLT,omitempty"`
	ExternalControlIdlte          *string  `json:"externalControlIDLTE,omitempty"`
	ExternalControlIDContains     *string  `json:"externalControlIDContains,omitempty"`
	ExternalControlIDHasPrefix    *string  `json:"externalControlIDHasPrefix,omitempty"`
	ExternalControlIDHasSuffix    *string  `json:"externalControlIDHasSuffix,omitempty"`
	ExternalControlIDIsNil        *bool    `json:"externalControlIDIsNil,omitempty"`
	ExternalControlIDNotNil       *bool    `json:"externalControlIDNotNil,omitempty"`
	ExternalControlIDEqualFold    *string  `json:"externalControlIDEqualFold,omitempty"`
	ExternalControlIDContainsFold *string  `json:"externalControlIDContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// discovered_at field predicates
	DiscoveredAt       *models.DateTime   `json:"discoveredAt,omitempty"`
	DiscoveredAtNeq    *models.DateTime   `json:"discoveredAtNEQ,omitempty"`
	DiscoveredAtIn     []*models.DateTime `json:"discoveredAtIn,omitempty"`
	DiscoveredAtNotIn  []*models.DateTime `json:"discoveredAtNotIn,omitempty"`
	DiscoveredAtGt     *models.DateTime   `json:"discoveredAtGT,omitempty"`
	DiscoveredAtGte    *models.DateTime   `json:"discoveredAtGTE,omitempty"`
	DiscoveredAtLt     *models.DateTime   `json:"discoveredAtLT,omitempty"`
	DiscoveredAtLte    *models.DateTime   `json:"discoveredAtLTE,omitempty"`
	DiscoveredAtIsNil  *bool              `json:"discoveredAtIsNil,omitempty"`
	DiscoveredAtNotNil *bool              `json:"discoveredAtNotNil,omitempty"`
}

// Return response for createFinding mutation
type FindingCreatePayload struct {
	// Created finding
	Finding *Finding `json:"finding"`
}

// Return response for deleteFinding mutation
type FindingDeletePayload struct {
	// Deleted finding ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FindingEdge struct {
	// The item at the end of the edge.
	Node *Finding `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FindingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the finding
	ExternalID *string `json:"externalID,omitempty"`
	// the owner of the finding
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// system that produced the finding, e.g. gcp_scc
	Source *string `json:"source,omitempty"`
	// resource identifier provided by the source system
	ResourceName *string `json:"resourceName,omitempty"`
	// display name for the finding when provided by the source
	DisplayName *string `json:"displayName,omitempty"`
	// state reported by the source system, such as ACTIVE or INACTIVE
	State *string `json:"state,omitempty"`
	// primary category of the finding
	Category *string `json:"category,omitempty"`
	// normalized categories for the finding
	Categories []string `json:"categories,omitempty"`
	// classification provided by the source, e.g. MISCONFIGURATION
	FindingClass *string `json:"findingClass,omitempty"`
	// severity label for the finding
	Severity *string `json:"severity,omitempty"`
	// numeric severity score for the finding if provided
	NumericSeverity *float64 `json:"numericSeverity,omitempty"`
	// aggregated score such as CVSS for the finding
	Score *float64 `json:"score,omitempty"`
	// impact score or rating for the finding
	Impact *float64 `json:"impact,omitempty"`
	// exploitability score or rating for the finding
	Exploitability *float64 `json:"exploitability,omitempty"`
	// priority assigned to the finding
	Priority *string `json:"priority,omitempty"`
	// indicates if the finding is still open
	Open *bool `json:"open,omitempty"`
	// true when the finding blocks production changes
	BlocksProduction *bool `json:"blocksProduction,omitempty"`
	// true when the finding affects production systems
	Production *bool `json:"production,omitempty"`
	// true when the finding is publicly disclosed
	Public *bool `json:"public,omitempty"`
	// true when the finding has been validated by the security team
	Validated *bool `json:"validated,omitempty"`
	// identifier for the assessment that generated the finding
	AssessmentID *string `json:"assessmentID,omitempty"`
	// long form description of the finding
	Description *string `json:"description,omitempty"`
	// short recommendation text from the source system (deprecated upstream)
	Recommendation *string `json:"recommendation,omitempty"`
	// markdown formatted remediation guidance for the finding
	RecommendedActions *string `json:"recommendedActions,omitempty"`
	// reference links for the finding
	References []string `json:"references,omitempty"`
	// steps required to reproduce the finding
	StepsToReproduce []string `json:"stepsToReproduce,omitempty"`
	// targets impacted by the finding such as projects or applications
	Targets []string `json:"targets,omitempty"`
	// structured details about the impacted targets
	TargetDetails map[string]any `json:"targetDetails,omitempty"`
	// attack vector string such as a CVSS vector
	Vector *string `json:"vector,omitempty"`
	// remediation service level agreement in days
	RemediationSLA *int64 `json:"remediationSLA,omitempty"`
	// lifecycle status of the finding
	Status *string `json:"status,omitempty"`
	// timestamp when the finding was last observed by the source
	EventTime *models.DateTime `json:"eventTime,omitempty"`
	// timestamp when the finding was first reported by the source
	ReportedAt *models.DateTime `json:"reportedAt,omitempty"`
	// timestamp when the source last updated the finding
	SourceUpdatedAt *models.DateTime `json:"sourceUpdatedAt,omitempty"`
	// link to the finding in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the finding from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload map[string]any `json:"rawPayload,omitempty"`
}

func (FindingHistory) IsNode() {}

// A connection to a list of items.
type FindingHistoryConnection struct {
	// A list of edges.
	Edges []*FindingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FindingHistoryEdge struct {
	// The item at the end of the edge.
	Node *FindingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for FindingHistory connections
type FindingHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order FindingHistories.
	Field FindingHistoryOrderField `json:"field"`
}

// FindingHistoryWhereInput is used for filtering FindingHistory objects.
// Input was generated by ent.
type FindingHistoryWhereInput struct {
	Not *FindingHistoryWhereInput   `json:"not,omitempty"`
	And []*FindingHistoryWhereInput `json:"and,omitempty"`
	Or  []*FindingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        *bool    `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       *bool    `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// external_owner_id field predicates
	ExternalOwnerID             *string  `json:"externalOwnerID,omitempty"`
	ExternalOwnerIdneq          *string  `json:"externalOwnerIDNEQ,omitempty"`
	ExternalOwnerIDIn           []string `json:"externalOwnerIDIn,omitempty"`
	ExternalOwnerIDNotIn        []string `json:"externalOwnerIDNotIn,omitempty"`
	ExternalOwnerIdgt           *string  `json:"externalOwnerIDGT,omitempty"`
	ExternalOwnerIdgte          *string  `json:"externalOwnerIDGTE,omitempty"`
	ExternalOwnerIdlt           *string  `json:"externalOwnerIDLT,omitempty"`
	ExternalOwnerIdlte          *string  `json:"externalOwnerIDLTE,omitempty"`
	ExternalOwnerIDContains     *string  `json:"externalOwnerIDContains,omitempty"`
	ExternalOwnerIDHasPrefix    *string  `json:"externalOwnerIDHasPrefix,omitempty"`
	ExternalOwnerIDHasSuffix    *string  `json:"externalOwnerIDHasSuffix,omitempty"`
	ExternalOwnerIDIsNil        *bool    `json:"externalOwnerIDIsNil,omitempty"`
	ExternalOwnerIDNotNil       *bool    `json:"externalOwnerIDNotNil,omitempty"`
	ExternalOwnerIDEqualFold    *string  `json:"externalOwnerIDEqualFold,omitempty"`
	ExternalOwnerIDContainsFold *string  `json:"externalOwnerIDContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// resource_name field predicates
	ResourceName             *string  `json:"resourceName,omitempty"`
	ResourceNameNeq          *string  `json:"resourceNameNEQ,omitempty"`
	ResourceNameIn           []string `json:"resourceNameIn,omitempty"`
	ResourceNameNotIn        []string `json:"resourceNameNotIn,omitempty"`
	ResourceNameGt           *string  `json:"resourceNameGT,omitempty"`
	ResourceNameGte          *string  `json:"resourceNameGTE,omitempty"`
	ResourceNameLt           *string  `json:"resourceNameLT,omitempty"`
	ResourceNameLte          *string  `json:"resourceNameLTE,omitempty"`
	ResourceNameContains     *string  `json:"resourceNameContains,omitempty"`
	ResourceNameHasPrefix    *string  `json:"resourceNameHasPrefix,omitempty"`
	ResourceNameHasSuffix    *string  `json:"resourceNameHasSuffix,omitempty"`
	ResourceNameIsNil        *bool    `json:"resourceNameIsNil,omitempty"`
	ResourceNameNotNil       *bool    `json:"resourceNameNotNil,omitempty"`
	ResourceNameEqualFold    *string  `json:"resourceNameEqualFold,omitempty"`
	ResourceNameContainsFold *string  `json:"resourceNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// state field predicates
	State             *string  `json:"state,omitempty"`
	StateNeq          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGt           *string  `json:"stateGT,omitempty"`
	StateGte          *string  `json:"stateGTE,omitempty"`
	StateLt           *string  `json:"stateLT,omitempty"`
	StateLte          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        *bool    `json:"stateIsNil,omitempty"`
	StateNotNil       *bool    `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// finding_class field predicates
	FindingClass             *string  `json:"findingClass,omitempty"`
	FindingClassNeq          *string  `json:"findingClassNEQ,omitempty"`
	FindingClassIn           []string `json:"findingClassIn,omitempty"`
	FindingClassNotIn        []string `json:"findingClassNotIn,omitempty"`
	FindingClassGt           *string  `json:"findingClassGT,omitempty"`
	FindingClassGte          *string  `json:"findingClassGTE,omitempty"`
	FindingClassLt           *string  `json:"findingClassLT,omitempty"`
	FindingClassLte          *string  `json:"findingClassLTE,omitempty"`
	FindingClassContains     *string  `json:"findingClassContains,omitempty"`
	FindingClassHasPrefix    *string  `json:"findingClassHasPrefix,omitempty"`
	FindingClassHasSuffix    *string  `json:"findingClassHasSuffix,omitempty"`
	FindingClassIsNil        *bool    `json:"findingClassIsNil,omitempty"`
	FindingClassNotNil       *bool    `json:"findingClassNotNil,omitempty"`
	FindingClassEqualFold    *string  `json:"findingClassEqualFold,omitempty"`
	FindingClassContainsFold *string  `json:"findingClassContainsFold,omitempty"`
	// severity field predicates
	Severity             *string  `json:"severity,omitempty"`
	SeverityNeq          *string  `json:"severityNEQ,omitempty"`
	SeverityIn           []string `json:"severityIn,omitempty"`
	SeverityNotIn        []string `json:"severityNotIn,omitempty"`
	SeverityGt           *string  `json:"severityGT,omitempty"`
	SeverityGte          *string  `json:"severityGTE,omitempty"`
	SeverityLt           *string  `json:"severityLT,omitempty"`
	SeverityLte          *string  `json:"severityLTE,omitempty"`
	SeverityContains     *string  `json:"severityContains,omitempty"`
	SeverityHasPrefix    *string  `json:"severityHasPrefix,omitempty"`
	SeverityHasSuffix    *string  `json:"severityHasSuffix,omitempty"`
	SeverityIsNil        *bool    `json:"severityIsNil,omitempty"`
	SeverityNotNil       *bool    `json:"severityNotNil,omitempty"`
	SeverityEqualFold    *string  `json:"severityEqualFold,omitempty"`
	SeverityContainsFold *string  `json:"severityContainsFold,omitempty"`
	// numeric_severity field predicates
	NumericSeverity       *float64  `json:"numericSeverity,omitempty"`
	NumericSeverityNeq    *float64  `json:"numericSeverityNEQ,omitempty"`
	NumericSeverityIn     []float64 `json:"numericSeverityIn,omitempty"`
	NumericSeverityNotIn  []float64 `json:"numericSeverityNotIn,omitempty"`
	NumericSeverityGt     *float64  `json:"numericSeverityGT,omitempty"`
	NumericSeverityGte    *float64  `json:"numericSeverityGTE,omitempty"`
	NumericSeverityLt     *float64  `json:"numericSeverityLT,omitempty"`
	NumericSeverityLte    *float64  `json:"numericSeverityLTE,omitempty"`
	NumericSeverityIsNil  *bool     `json:"numericSeverityIsNil,omitempty"`
	NumericSeverityNotNil *bool     `json:"numericSeverityNotNil,omitempty"`
	// score field predicates
	Score       *float64  `json:"score,omitempty"`
	ScoreNeq    *float64  `json:"scoreNEQ,omitempty"`
	ScoreIn     []float64 `json:"scoreIn,omitempty"`
	ScoreNotIn  []float64 `json:"scoreNotIn,omitempty"`
	ScoreGt     *float64  `json:"scoreGT,omitempty"`
	ScoreGte    *float64  `json:"scoreGTE,omitempty"`
	ScoreLt     *float64  `json:"scoreLT,omitempty"`
	ScoreLte    *float64  `json:"scoreLTE,omitempty"`
	ScoreIsNil  *bool     `json:"scoreIsNil,omitempty"`
	ScoreNotNil *bool     `json:"scoreNotNil,omitempty"`
	// impact field predicates
	Impact       *float64  `json:"impact,omitempty"`
	ImpactNeq    *float64  `json:"impactNEQ,omitempty"`
	ImpactIn     []float64 `json:"impactIn,omitempty"`
	ImpactNotIn  []float64 `json:"impactNotIn,omitempty"`
	ImpactGt     *float64  `json:"impactGT,omitempty"`
	ImpactGte    *float64  `json:"impactGTE,omitempty"`
	ImpactLt     *float64  `json:"impactLT,omitempty"`
	ImpactLte    *float64  `json:"impactLTE,omitempty"`
	ImpactIsNil  *bool     `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool     `json:"impactNotNil,omitempty"`
	// exploitability field predicates
	Exploitability       *float64  `json:"exploitability,omitempty"`
	ExploitabilityNeq    *float64  `json:"exploitabilityNEQ,omitempty"`
	ExploitabilityIn     []float64 `json:"exploitabilityIn,omitempty"`
	ExploitabilityNotIn  []float64 `json:"exploitabilityNotIn,omitempty"`
	ExploitabilityGt     *float64  `json:"exploitabilityGT,omitempty"`
	ExploitabilityGte    *float64  `json:"exploitabilityGTE,omitempty"`
	ExploitabilityLt     *float64  `json:"exploitabilityLT,omitempty"`
	ExploitabilityLte    *float64  `json:"exploitabilityLTE,omitempty"`
	ExploitabilityIsNil  *bool     `json:"exploitabilityIsNil,omitempty"`
	ExploitabilityNotNil *bool     `json:"exploitabilityNotNil,omitempty"`
	// priority field predicates
	Priority             *string  `json:"priority,omitempty"`
	PriorityNeq          *string  `json:"priorityNEQ,omitempty"`
	PriorityIn           []string `json:"priorityIn,omitempty"`
	PriorityNotIn        []string `json:"priorityNotIn,omitempty"`
	PriorityGt           *string  `json:"priorityGT,omitempty"`
	PriorityGte          *string  `json:"priorityGTE,omitempty"`
	PriorityLt           *string  `json:"priorityLT,omitempty"`
	PriorityLte          *string  `json:"priorityLTE,omitempty"`
	PriorityContains     *string  `json:"priorityContains,omitempty"`
	PriorityHasPrefix    *string  `json:"priorityHasPrefix,omitempty"`
	PriorityHasSuffix    *string  `json:"priorityHasSuffix,omitempty"`
	PriorityIsNil        *bool    `json:"priorityIsNil,omitempty"`
	PriorityNotNil       *bool    `json:"priorityNotNil,omitempty"`
	PriorityEqualFold    *string  `json:"priorityEqualFold,omitempty"`
	PriorityContainsFold *string  `json:"priorityContainsFold,omitempty"`
	// open field predicates
	Open       *bool `json:"open,omitempty"`
	OpenNeq    *bool `json:"openNEQ,omitempty"`
	OpenIsNil  *bool `json:"openIsNil,omitempty"`
	OpenNotNil *bool `json:"openNotNil,omitempty"`
	// blocks_production field predicates
	BlocksProduction       *bool `json:"blocksProduction,omitempty"`
	BlocksProductionNeq    *bool `json:"blocksProductionNEQ,omitempty"`
	BlocksProductionIsNil  *bool `json:"blocksProductionIsNil,omitempty"`
	BlocksProductionNotNil *bool `json:"blocksProductionNotNil,omitempty"`
	// production field predicates
	Production       *bool `json:"production,omitempty"`
	ProductionNeq    *bool `json:"productionNEQ,omitempty"`
	ProductionIsNil  *bool `json:"productionIsNil,omitempty"`
	ProductionNotNil *bool `json:"productionNotNil,omitempty"`
	// public field predicates
	Public       *bool `json:"public,omitempty"`
	PublicNeq    *bool `json:"publicNEQ,omitempty"`
	PublicIsNil  *bool `json:"publicIsNil,omitempty"`
	PublicNotNil *bool `json:"publicNotNil,omitempty"`
	// validated field predicates
	Validated       *bool `json:"validated,omitempty"`
	ValidatedNeq    *bool `json:"validatedNEQ,omitempty"`
	ValidatedIsNil  *bool `json:"validatedIsNil,omitempty"`
	ValidatedNotNil *bool `json:"validatedNotNil,omitempty"`
	// assessment_id field predicates
	AssessmentID             *string  `json:"assessmentID,omitempty"`
	AssessmentIdneq          *string  `json:"assessmentIDNEQ,omitempty"`
	AssessmentIDIn           []string `json:"assessmentIDIn,omitempty"`
	AssessmentIDNotIn        []string `json:"assessmentIDNotIn,omitempty"`
	AssessmentIdgt           *string  `json:"assessmentIDGT,omitempty"`
	AssessmentIdgte          *string  `json:"assessmentIDGTE,omitempty"`
	AssessmentIdlt           *string  `json:"assessmentIDLT,omitempty"`
	AssessmentIdlte          *string  `json:"assessmentIDLTE,omitempty"`
	AssessmentIDContains     *string  `json:"assessmentIDContains,omitempty"`
	AssessmentIDHasPrefix    *string  `json:"assessmentIDHasPrefix,omitempty"`
	AssessmentIDHasSuffix    *string  `json:"assessmentIDHasSuffix,omitempty"`
	AssessmentIDIsNil        *bool    `json:"assessmentIDIsNil,omitempty"`
	AssessmentIDNotNil       *bool    `json:"assessmentIDNotNil,omitempty"`
	AssessmentIDEqualFold    *string  `json:"assessmentIDEqualFold,omitempty"`
	AssessmentIDContainsFold *string  `json:"assessmentIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// recommendation field predicates
	Recommendation             *string  `json:"recommendation,omitempty"`
	RecommendationNeq          *string  `json:"recommendationNEQ,omitempty"`
	RecommendationIn           []string `json:"recommendationIn,omitempty"`
	RecommendationNotIn        []string `json:"recommendationNotIn,omitempty"`
	RecommendationGt           *string  `json:"recommendationGT,omitempty"`
	RecommendationGte          *string  `json:"recommendationGTE,omitempty"`
	RecommendationLt           *string  `json:"recommendationLT,omitempty"`
	RecommendationLte          *string  `json:"recommendationLTE,omitempty"`
	RecommendationContains     *string  `json:"recommendationContains,omitempty"`
	RecommendationHasPrefix    *string  `json:"recommendationHasPrefix,omitempty"`
	RecommendationHasSuffix    *string  `json:"recommendationHasSuffix,omitempty"`
	RecommendationIsNil        *bool    `json:"recommendationIsNil,omitempty"`
	RecommendationNotNil       *bool    `json:"recommendationNotNil,omitempty"`
	RecommendationEqualFold    *string  `json:"recommendationEqualFold,omitempty"`
	RecommendationContainsFold *string  `json:"recommendationContainsFold,omitempty"`
	// recommended_actions field predicates
	RecommendedActions             *string  `json:"recommendedActions,omitempty"`
	RecommendedActionsNeq          *string  `json:"recommendedActionsNEQ,omitempty"`
	RecommendedActionsIn           []string `json:"recommendedActionsIn,omitempty"`
	RecommendedActionsNotIn        []string `json:"recommendedActionsNotIn,omitempty"`
	RecommendedActionsGt           *string  `json:"recommendedActionsGT,omitempty"`
	RecommendedActionsGte          *string  `json:"recommendedActionsGTE,omitempty"`
	RecommendedActionsLt           *string  `json:"recommendedActionsLT,omitempty"`
	RecommendedActionsLte          *string  `json:"recommendedActionsLTE,omitempty"`
	RecommendedActionsContains     *string  `json:"recommendedActionsContains,omitempty"`
	RecommendedActionsHasPrefix    *string  `json:"recommendedActionsHasPrefix,omitempty"`
	RecommendedActionsHasSuffix    *string  `json:"recommendedActionsHasSuffix,omitempty"`
	RecommendedActionsIsNil        *bool    `json:"recommendedActionsIsNil,omitempty"`
	RecommendedActionsNotNil       *bool    `json:"recommendedActionsNotNil,omitempty"`
	RecommendedActionsEqualFold    *string  `json:"recommendedActionsEqualFold,omitempty"`
	RecommendedActionsContainsFold *string  `json:"recommendedActionsContainsFold,omitempty"`
	// vector field predicates
	Vector             *string  `json:"vector,omitempty"`
	VectorNeq          *string  `json:"vectorNEQ,omitempty"`
	VectorIn           []string `json:"vectorIn,omitempty"`
	VectorNotIn        []string `json:"vectorNotIn,omitempty"`
	VectorGt           *string  `json:"vectorGT,omitempty"`
	VectorGte          *string  `json:"vectorGTE,omitempty"`
	VectorLt           *string  `json:"vectorLT,omitempty"`
	VectorLte          *string  `json:"vectorLTE,omitempty"`
	VectorContains     *string  `json:"vectorContains,omitempty"`
	VectorHasPrefix    *string  `json:"vectorHasPrefix,omitempty"`
	VectorHasSuffix    *string  `json:"vectorHasSuffix,omitempty"`
	VectorIsNil        *bool    `json:"vectorIsNil,omitempty"`
	VectorNotNil       *bool    `json:"vectorNotNil,omitempty"`
	VectorEqualFold    *string  `json:"vectorEqualFold,omitempty"`
	VectorContainsFold *string  `json:"vectorContainsFold,omitempty"`
	// remediation_sla field predicates
	RemediationSLA       *int64  `json:"remediationSLA,omitempty"`
	RemediationSLANeq    *int64  `json:"remediationSLANEQ,omitempty"`
	RemediationSLAIn     []int64 `json:"remediationSLAIn,omitempty"`
	RemediationSLANotIn  []int64 `json:"remediationSLANotIn,omitempty"`
	RemediationSLAGt     *int64  `json:"remediationSLAGT,omitempty"`
	RemediationSLAGte    *int64  `json:"remediationSLAGTE,omitempty"`
	RemediationSLALt     *int64  `json:"remediationSLALT,omitempty"`
	RemediationSLALte    *int64  `json:"remediationSLALTE,omitempty"`
	RemediationSLAIsNil  *bool   `json:"remediationSLAIsNil,omitempty"`
	RemediationSLANotNil *bool   `json:"remediationSLANotNil,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// event_time field predicates
	EventTime       *models.DateTime   `json:"eventTime,omitempty"`
	EventTimeNeq    *models.DateTime   `json:"eventTimeNEQ,omitempty"`
	EventTimeIn     []*models.DateTime `json:"eventTimeIn,omitempty"`
	EventTimeNotIn  []*models.DateTime `json:"eventTimeNotIn,omitempty"`
	EventTimeGt     *models.DateTime   `json:"eventTimeGT,omitempty"`
	EventTimeGte    *models.DateTime   `json:"eventTimeGTE,omitempty"`
	EventTimeLt     *models.DateTime   `json:"eventTimeLT,omitempty"`
	EventTimeLte    *models.DateTime   `json:"eventTimeLTE,omitempty"`
	EventTimeIsNil  *bool              `json:"eventTimeIsNil,omitempty"`
	EventTimeNotNil *bool              `json:"eventTimeNotNil,omitempty"`
	// reported_at field predicates
	ReportedAt       *models.DateTime   `json:"reportedAt,omitempty"`
	ReportedAtNeq    *models.DateTime   `json:"reportedAtNEQ,omitempty"`
	ReportedAtIn     []*models.DateTime `json:"reportedAtIn,omitempty"`
	ReportedAtNotIn  []*models.DateTime `json:"reportedAtNotIn,omitempty"`
	ReportedAtGt     *models.DateTime   `json:"reportedAtGT,omitempty"`
	ReportedAtGte    *models.DateTime   `json:"reportedAtGTE,omitempty"`
	ReportedAtLt     *models.DateTime   `json:"reportedAtLT,omitempty"`
	ReportedAtLte    *models.DateTime   `json:"reportedAtLTE,omitempty"`
	ReportedAtIsNil  *bool              `json:"reportedAtIsNil,omitempty"`
	ReportedAtNotNil *bool              `json:"reportedAtNotNil,omitempty"`
	// source_updated_at field predicates
	SourceUpdatedAt       *models.DateTime   `json:"sourceUpdatedAt,omitempty"`
	SourceUpdatedAtNeq    *models.DateTime   `json:"sourceUpdatedAtNEQ,omitempty"`
	SourceUpdatedAtIn     []*models.DateTime `json:"sourceUpdatedAtIn,omitempty"`
	SourceUpdatedAtNotIn  []*models.DateTime `json:"sourceUpdatedAtNotIn,omitempty"`
	SourceUpdatedAtGt     *models.DateTime   `json:"sourceUpdatedAtGT,omitempty"`
	SourceUpdatedAtGte    *models.DateTime   `json:"sourceUpdatedAtGTE,omitempty"`
	SourceUpdatedAtLt     *models.DateTime   `json:"sourceUpdatedAtLT,omitempty"`
	SourceUpdatedAtLte    *models.DateTime   `json:"sourceUpdatedAtLTE,omitempty"`
	SourceUpdatedAtIsNil  *bool              `json:"sourceUpdatedAtIsNil,omitempty"`
	SourceUpdatedAtNotNil *bool              `json:"sourceUpdatedAtNotNil,omitempty"`
	// external_uri field predicates
	ExternalURI             *string  `json:"externalURI,omitempty"`
	ExternalURINeq          *string  `json:"externalURINEQ,omitempty"`
	ExternalURIIn           []string `json:"externalURIIn,omitempty"`
	ExternalURINotIn        []string `json:"externalURINotIn,omitempty"`
	ExternalURIGt           *string  `json:"externalURIGT,omitempty"`
	ExternalURIGte          *string  `json:"externalURIGTE,omitempty"`
	ExternalURILt           *string  `json:"externalURILT,omitempty"`
	ExternalURILte          *string  `json:"externalURILTE,omitempty"`
	ExternalURIContains     *string  `json:"externalURIContains,omitempty"`
	ExternalURIHasPrefix    *string  `json:"externalURIHasPrefix,omitempty"`
	ExternalURIHasSuffix    *string  `json:"externalURIHasSuffix,omitempty"`
	ExternalURIIsNil        *bool    `json:"externalURIIsNil,omitempty"`
	ExternalURINotNil       *bool    `json:"externalURINotNil,omitempty"`
	ExternalURIEqualFold    *string  `json:"externalURIEqualFold,omitempty"`
	ExternalURIContainsFold *string  `json:"externalURIContainsFold,omitempty"`
}

// Ordering options for Finding connections
type FindingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Findings.
	Field FindingOrderField `json:"field"`
}

// Return response for updateFinding mutation
type FindingUpdatePayload struct {
	// Updated finding
	Finding *Finding `json:"finding"`
}

// FindingWhereInput is used for filtering Finding objects.
// Input was generated by ent.
type FindingWhereInput struct {
	Not *FindingWhereInput   `json:"not,omitempty"`
	And []*FindingWhereInput `json:"and,omitempty"`
	Or  []*FindingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        *bool    `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       *bool    `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// external_owner_id field predicates
	ExternalOwnerID             *string  `json:"externalOwnerID,omitempty"`
	ExternalOwnerIdneq          *string  `json:"externalOwnerIDNEQ,omitempty"`
	ExternalOwnerIDIn           []string `json:"externalOwnerIDIn,omitempty"`
	ExternalOwnerIDNotIn        []string `json:"externalOwnerIDNotIn,omitempty"`
	ExternalOwnerIdgt           *string  `json:"externalOwnerIDGT,omitempty"`
	ExternalOwnerIdgte          *string  `json:"externalOwnerIDGTE,omitempty"`
	ExternalOwnerIdlt           *string  `json:"externalOwnerIDLT,omitempty"`
	ExternalOwnerIdlte          *string  `json:"externalOwnerIDLTE,omitempty"`
	ExternalOwnerIDContains     *string  `json:"externalOwnerIDContains,omitempty"`
	ExternalOwnerIDHasPrefix    *string  `json:"externalOwnerIDHasPrefix,omitempty"`
	ExternalOwnerIDHasSuffix    *string  `json:"externalOwnerIDHasSuffix,omitempty"`
	ExternalOwnerIDIsNil        *bool    `json:"externalOwnerIDIsNil,omitempty"`
	ExternalOwnerIDNotNil       *bool    `json:"externalOwnerIDNotNil,omitempty"`
	ExternalOwnerIDEqualFold    *string  `json:"externalOwnerIDEqualFold,omitempty"`
	ExternalOwnerIDContainsFold *string  `json:"externalOwnerIDContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// resource_name field predicates
	ResourceName             *string  `json:"resourceName,omitempty"`
	ResourceNameNeq          *string  `json:"resourceNameNEQ,omitempty"`
	ResourceNameIn           []string `json:"resourceNameIn,omitempty"`
	ResourceNameNotIn        []string `json:"resourceNameNotIn,omitempty"`
	ResourceNameGt           *string  `json:"resourceNameGT,omitempty"`
	ResourceNameGte          *string  `json:"resourceNameGTE,omitempty"`
	ResourceNameLt           *string  `json:"resourceNameLT,omitempty"`
	ResourceNameLte          *string  `json:"resourceNameLTE,omitempty"`
	ResourceNameContains     *string  `json:"resourceNameContains,omitempty"`
	ResourceNameHasPrefix    *string  `json:"resourceNameHasPrefix,omitempty"`
	ResourceNameHasSuffix    *string  `json:"resourceNameHasSuffix,omitempty"`
	ResourceNameIsNil        *bool    `json:"resourceNameIsNil,omitempty"`
	ResourceNameNotNil       *bool    `json:"resourceNameNotNil,omitempty"`
	ResourceNameEqualFold    *string  `json:"resourceNameEqualFold,omitempty"`
	ResourceNameContainsFold *string  `json:"resourceNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// state field predicates
	State             *string  `json:"state,omitempty"`
	StateNeq          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGt           *string  `json:"stateGT,omitempty"`
	StateGte          *string  `json:"stateGTE,omitempty"`
	StateLt           *string  `json:"stateLT,omitempty"`
	StateLte          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        *bool    `json:"stateIsNil,omitempty"`
	StateNotNil       *bool    `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// finding_class field predicates
	FindingClass             *string  `json:"findingClass,omitempty"`
	FindingClassNeq          *string  `json:"findingClassNEQ,omitempty"`
	FindingClassIn           []string `json:"findingClassIn,omitempty"`
	FindingClassNotIn        []string `json:"findingClassNotIn,omitempty"`
	FindingClassGt           *string  `json:"findingClassGT,omitempty"`
	FindingClassGte          *string  `json:"findingClassGTE,omitempty"`
	FindingClassLt           *string  `json:"findingClassLT,omitempty"`
	FindingClassLte          *string  `json:"findingClassLTE,omitempty"`
	FindingClassContains     *string  `json:"findingClassContains,omitempty"`
	FindingClassHasPrefix    *string  `json:"findingClassHasPrefix,omitempty"`
	FindingClassHasSuffix    *string  `json:"findingClassHasSuffix,omitempty"`
	FindingClassIsNil        *bool    `json:"findingClassIsNil,omitempty"`
	FindingClassNotNil       *bool    `json:"findingClassNotNil,omitempty"`
	FindingClassEqualFold    *string  `json:"findingClassEqualFold,omitempty"`
	FindingClassContainsFold *string  `json:"findingClassContainsFold,omitempty"`
	// severity field predicates
	Severity             *string  `json:"severity,omitempty"`
	SeverityNeq          *string  `json:"severityNEQ,omitempty"`
	SeverityIn           []string `json:"severityIn,omitempty"`
	SeverityNotIn        []string `json:"severityNotIn,omitempty"`
	SeverityGt           *string  `json:"severityGT,omitempty"`
	SeverityGte          *string  `json:"severityGTE,omitempty"`
	SeverityLt           *string  `json:"severityLT,omitempty"`
	SeverityLte          *string  `json:"severityLTE,omitempty"`
	SeverityContains     *string  `json:"severityContains,omitempty"`
	SeverityHasPrefix    *string  `json:"severityHasPrefix,omitempty"`
	SeverityHasSuffix    *string  `json:"severityHasSuffix,omitempty"`
	SeverityIsNil        *bool    `json:"severityIsNil,omitempty"`
	SeverityNotNil       *bool    `json:"severityNotNil,omitempty"`
	SeverityEqualFold    *string  `json:"severityEqualFold,omitempty"`
	SeverityContainsFold *string  `json:"severityContainsFold,omitempty"`
	// numeric_severity field predicates
	NumericSeverity       *float64  `json:"numericSeverity,omitempty"`
	NumericSeverityNeq    *float64  `json:"numericSeverityNEQ,omitempty"`
	NumericSeverityIn     []float64 `json:"numericSeverityIn,omitempty"`
	NumericSeverityNotIn  []float64 `json:"numericSeverityNotIn,omitempty"`
	NumericSeverityGt     *float64  `json:"numericSeverityGT,omitempty"`
	NumericSeverityGte    *float64  `json:"numericSeverityGTE,omitempty"`
	NumericSeverityLt     *float64  `json:"numericSeverityLT,omitempty"`
	NumericSeverityLte    *float64  `json:"numericSeverityLTE,omitempty"`
	NumericSeverityIsNil  *bool     `json:"numericSeverityIsNil,omitempty"`
	NumericSeverityNotNil *bool     `json:"numericSeverityNotNil,omitempty"`
	// score field predicates
	Score       *float64  `json:"score,omitempty"`
	ScoreNeq    *float64  `json:"scoreNEQ,omitempty"`
	ScoreIn     []float64 `json:"scoreIn,omitempty"`
	ScoreNotIn  []float64 `json:"scoreNotIn,omitempty"`
	ScoreGt     *float64  `json:"scoreGT,omitempty"`
	ScoreGte    *float64  `json:"scoreGTE,omitempty"`
	ScoreLt     *float64  `json:"scoreLT,omitempty"`
	ScoreLte    *float64  `json:"scoreLTE,omitempty"`
	ScoreIsNil  *bool     `json:"scoreIsNil,omitempty"`
	ScoreNotNil *bool     `json:"scoreNotNil,omitempty"`
	// impact field predicates
	Impact       *float64  `json:"impact,omitempty"`
	ImpactNeq    *float64  `json:"impactNEQ,omitempty"`
	ImpactIn     []float64 `json:"impactIn,omitempty"`
	ImpactNotIn  []float64 `json:"impactNotIn,omitempty"`
	ImpactGt     *float64  `json:"impactGT,omitempty"`
	ImpactGte    *float64  `json:"impactGTE,omitempty"`
	ImpactLt     *float64  `json:"impactLT,omitempty"`
	ImpactLte    *float64  `json:"impactLTE,omitempty"`
	ImpactIsNil  *bool     `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool     `json:"impactNotNil,omitempty"`
	// exploitability field predicates
	Exploitability       *float64  `json:"exploitability,omitempty"`
	ExploitabilityNeq    *float64  `json:"exploitabilityNEQ,omitempty"`
	ExploitabilityIn     []float64 `json:"exploitabilityIn,omitempty"`
	ExploitabilityNotIn  []float64 `json:"exploitabilityNotIn,omitempty"`
	ExploitabilityGt     *float64  `json:"exploitabilityGT,omitempty"`
	ExploitabilityGte    *float64  `json:"exploitabilityGTE,omitempty"`
	ExploitabilityLt     *float64  `json:"exploitabilityLT,omitempty"`
	ExploitabilityLte    *float64  `json:"exploitabilityLTE,omitempty"`
	ExploitabilityIsNil  *bool     `json:"exploitabilityIsNil,omitempty"`
	ExploitabilityNotNil *bool     `json:"exploitabilityNotNil,omitempty"`
	// priority field predicates
	Priority             *string  `json:"priority,omitempty"`
	PriorityNeq          *string  `json:"priorityNEQ,omitempty"`
	PriorityIn           []string `json:"priorityIn,omitempty"`
	PriorityNotIn        []string `json:"priorityNotIn,omitempty"`
	PriorityGt           *string  `json:"priorityGT,omitempty"`
	PriorityGte          *string  `json:"priorityGTE,omitempty"`
	PriorityLt           *string  `json:"priorityLT,omitempty"`
	PriorityLte          *string  `json:"priorityLTE,omitempty"`
	PriorityContains     *string  `json:"priorityContains,omitempty"`
	PriorityHasPrefix    *string  `json:"priorityHasPrefix,omitempty"`
	PriorityHasSuffix    *string  `json:"priorityHasSuffix,omitempty"`
	PriorityIsNil        *bool    `json:"priorityIsNil,omitempty"`
	PriorityNotNil       *bool    `json:"priorityNotNil,omitempty"`
	PriorityEqualFold    *string  `json:"priorityEqualFold,omitempty"`
	PriorityContainsFold *string  `json:"priorityContainsFold,omitempty"`
	// open field predicates
	Open       *bool `json:"open,omitempty"`
	OpenNeq    *bool `json:"openNEQ,omitempty"`
	OpenIsNil  *bool `json:"openIsNil,omitempty"`
	OpenNotNil *bool `json:"openNotNil,omitempty"`
	// blocks_production field predicates
	BlocksProduction       *bool `json:"blocksProduction,omitempty"`
	BlocksProductionNeq    *bool `json:"blocksProductionNEQ,omitempty"`
	BlocksProductionIsNil  *bool `json:"blocksProductionIsNil,omitempty"`
	BlocksProductionNotNil *bool `json:"blocksProductionNotNil,omitempty"`
	// production field predicates
	Production       *bool `json:"production,omitempty"`
	ProductionNeq    *bool `json:"productionNEQ,omitempty"`
	ProductionIsNil  *bool `json:"productionIsNil,omitempty"`
	ProductionNotNil *bool `json:"productionNotNil,omitempty"`
	// public field predicates
	Public       *bool `json:"public,omitempty"`
	PublicNeq    *bool `json:"publicNEQ,omitempty"`
	PublicIsNil  *bool `json:"publicIsNil,omitempty"`
	PublicNotNil *bool `json:"publicNotNil,omitempty"`
	// validated field predicates
	Validated       *bool `json:"validated,omitempty"`
	ValidatedNeq    *bool `json:"validatedNEQ,omitempty"`
	ValidatedIsNil  *bool `json:"validatedIsNil,omitempty"`
	ValidatedNotNil *bool `json:"validatedNotNil,omitempty"`
	// assessment_id field predicates
	AssessmentID             *string  `json:"assessmentID,omitempty"`
	AssessmentIdneq          *string  `json:"assessmentIDNEQ,omitempty"`
	AssessmentIDIn           []string `json:"assessmentIDIn,omitempty"`
	AssessmentIDNotIn        []string `json:"assessmentIDNotIn,omitempty"`
	AssessmentIdgt           *string  `json:"assessmentIDGT,omitempty"`
	AssessmentIdgte          *string  `json:"assessmentIDGTE,omitempty"`
	AssessmentIdlt           *string  `json:"assessmentIDLT,omitempty"`
	AssessmentIdlte          *string  `json:"assessmentIDLTE,omitempty"`
	AssessmentIDContains     *string  `json:"assessmentIDContains,omitempty"`
	AssessmentIDHasPrefix    *string  `json:"assessmentIDHasPrefix,omitempty"`
	AssessmentIDHasSuffix    *string  `json:"assessmentIDHasSuffix,omitempty"`
	AssessmentIDIsNil        *bool    `json:"assessmentIDIsNil,omitempty"`
	AssessmentIDNotNil       *bool    `json:"assessmentIDNotNil,omitempty"`
	AssessmentIDEqualFold    *string  `json:"assessmentIDEqualFold,omitempty"`
	AssessmentIDContainsFold *string  `json:"assessmentIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// recommendation field predicates
	Recommendation             *string  `json:"recommendation,omitempty"`
	RecommendationNeq          *string  `json:"recommendationNEQ,omitempty"`
	RecommendationIn           []string `json:"recommendationIn,omitempty"`
	RecommendationNotIn        []string `json:"recommendationNotIn,omitempty"`
	RecommendationGt           *string  `json:"recommendationGT,omitempty"`
	RecommendationGte          *string  `json:"recommendationGTE,omitempty"`
	RecommendationLt           *string  `json:"recommendationLT,omitempty"`
	RecommendationLte          *string  `json:"recommendationLTE,omitempty"`
	RecommendationContains     *string  `json:"recommendationContains,omitempty"`
	RecommendationHasPrefix    *string  `json:"recommendationHasPrefix,omitempty"`
	RecommendationHasSuffix    *string  `json:"recommendationHasSuffix,omitempty"`
	RecommendationIsNil        *bool    `json:"recommendationIsNil,omitempty"`
	RecommendationNotNil       *bool    `json:"recommendationNotNil,omitempty"`
	RecommendationEqualFold    *string  `json:"recommendationEqualFold,omitempty"`
	RecommendationContainsFold *string  `json:"recommendationContainsFold,omitempty"`
	// recommended_actions field predicates
	RecommendedActions             *string  `json:"recommendedActions,omitempty"`
	RecommendedActionsNeq          *string  `json:"recommendedActionsNEQ,omitempty"`
	RecommendedActionsIn           []string `json:"recommendedActionsIn,omitempty"`
	RecommendedActionsNotIn        []string `json:"recommendedActionsNotIn,omitempty"`
	RecommendedActionsGt           *string  `json:"recommendedActionsGT,omitempty"`
	RecommendedActionsGte          *string  `json:"recommendedActionsGTE,omitempty"`
	RecommendedActionsLt           *string  `json:"recommendedActionsLT,omitempty"`
	RecommendedActionsLte          *string  `json:"recommendedActionsLTE,omitempty"`
	RecommendedActionsContains     *string  `json:"recommendedActionsContains,omitempty"`
	RecommendedActionsHasPrefix    *string  `json:"recommendedActionsHasPrefix,omitempty"`
	RecommendedActionsHasSuffix    *string  `json:"recommendedActionsHasSuffix,omitempty"`
	RecommendedActionsIsNil        *bool    `json:"recommendedActionsIsNil,omitempty"`
	RecommendedActionsNotNil       *bool    `json:"recommendedActionsNotNil,omitempty"`
	RecommendedActionsEqualFold    *string  `json:"recommendedActionsEqualFold,omitempty"`
	RecommendedActionsContainsFold *string  `json:"recommendedActionsContainsFold,omitempty"`
	// vector field predicates
	Vector             *string  `json:"vector,omitempty"`
	VectorNeq          *string  `json:"vectorNEQ,omitempty"`
	VectorIn           []string `json:"vectorIn,omitempty"`
	VectorNotIn        []string `json:"vectorNotIn,omitempty"`
	VectorGt           *string  `json:"vectorGT,omitempty"`
	VectorGte          *string  `json:"vectorGTE,omitempty"`
	VectorLt           *string  `json:"vectorLT,omitempty"`
	VectorLte          *string  `json:"vectorLTE,omitempty"`
	VectorContains     *string  `json:"vectorContains,omitempty"`
	VectorHasPrefix    *string  `json:"vectorHasPrefix,omitempty"`
	VectorHasSuffix    *string  `json:"vectorHasSuffix,omitempty"`
	VectorIsNil        *bool    `json:"vectorIsNil,omitempty"`
	VectorNotNil       *bool    `json:"vectorNotNil,omitempty"`
	VectorEqualFold    *string  `json:"vectorEqualFold,omitempty"`
	VectorContainsFold *string  `json:"vectorContainsFold,omitempty"`
	// remediation_sla field predicates
	RemediationSLA       *int64  `json:"remediationSLA,omitempty"`
	RemediationSLANeq    *int64  `json:"remediationSLANEQ,omitempty"`
	RemediationSLAIn     []int64 `json:"remediationSLAIn,omitempty"`
	RemediationSLANotIn  []int64 `json:"remediationSLANotIn,omitempty"`
	RemediationSLAGt     *int64  `json:"remediationSLAGT,omitempty"`
	RemediationSLAGte    *int64  `json:"remediationSLAGTE,omitempty"`
	RemediationSLALt     *int64  `json:"remediationSLALT,omitempty"`
	RemediationSLALte    *int64  `json:"remediationSLALTE,omitempty"`
	RemediationSLAIsNil  *bool   `json:"remediationSLAIsNil,omitempty"`
	RemediationSLANotNil *bool   `json:"remediationSLANotNil,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// event_time field predicates
	EventTime       *models.DateTime   `json:"eventTime,omitempty"`
	EventTimeNeq    *models.DateTime   `json:"eventTimeNEQ,omitempty"`
	EventTimeIn     []*models.DateTime `json:"eventTimeIn,omitempty"`
	EventTimeNotIn  []*models.DateTime `json:"eventTimeNotIn,omitempty"`
	EventTimeGt     *models.DateTime   `json:"eventTimeGT,omitempty"`
	EventTimeGte    *models.DateTime   `json:"eventTimeGTE,omitempty"`
	EventTimeLt     *models.DateTime   `json:"eventTimeLT,omitempty"`
	EventTimeLte    *models.DateTime   `json:"eventTimeLTE,omitempty"`
	EventTimeIsNil  *bool              `json:"eventTimeIsNil,omitempty"`
	EventTimeNotNil *bool              `json:"eventTimeNotNil,omitempty"`
	// reported_at field predicates
	ReportedAt       *models.DateTime   `json:"reportedAt,omitempty"`
	ReportedAtNeq    *models.DateTime   `json:"reportedAtNEQ,omitempty"`
	ReportedAtIn     []*models.DateTime `json:"reportedAtIn,omitempty"`
	ReportedAtNotIn  []*models.DateTime `json:"reportedAtNotIn,omitempty"`
	ReportedAtGt     *models.DateTime   `json:"reportedAtGT,omitempty"`
	ReportedAtGte    *models.DateTime   `json:"reportedAtGTE,omitempty"`
	ReportedAtLt     *models.DateTime   `json:"reportedAtLT,omitempty"`
	ReportedAtLte    *models.DateTime   `json:"reportedAtLTE,omitempty"`
	ReportedAtIsNil  *bool              `json:"reportedAtIsNil,omitempty"`
	ReportedAtNotNil *bool              `json:"reportedAtNotNil,omitempty"`
	// source_updated_at field predicates
	SourceUpdatedAt       *models.DateTime   `json:"sourceUpdatedAt,omitempty"`
	SourceUpdatedAtNeq    *models.DateTime   `json:"sourceUpdatedAtNEQ,omitempty"`
	SourceUpdatedAtIn     []*models.DateTime `json:"sourceUpdatedAtIn,omitempty"`
	SourceUpdatedAtNotIn  []*models.DateTime `json:"sourceUpdatedAtNotIn,omitempty"`
	SourceUpdatedAtGt     *models.DateTime   `json:"sourceUpdatedAtGT,omitempty"`
	SourceUpdatedAtGte    *models.DateTime   `json:"sourceUpdatedAtGTE,omitempty"`
	SourceUpdatedAtLt     *models.DateTime   `json:"sourceUpdatedAtLT,omitempty"`
	SourceUpdatedAtLte    *models.DateTime   `json:"sourceUpdatedAtLTE,omitempty"`
	SourceUpdatedAtIsNil  *bool              `json:"sourceUpdatedAtIsNil,omitempty"`
	SourceUpdatedAtNotNil *bool              `json:"sourceUpdatedAtNotNil,omitempty"`
	// external_uri field predicates
	ExternalURI             *string  `json:"externalURI,omitempty"`
	ExternalURINeq          *string  `json:"externalURINEQ,omitempty"`
	ExternalURIIn           []string `json:"externalURIIn,omitempty"`
	ExternalURINotIn        []string `json:"externalURINotIn,omitempty"`
	ExternalURIGt           *string  `json:"externalURIGT,omitempty"`
	ExternalURIGte          *string  `json:"externalURIGTE,omitempty"`
	ExternalURILt           *string  `json:"externalURILT,omitempty"`
	ExternalURILte          *string  `json:"externalURILTE,omitempty"`
	ExternalURIContains     *string  `json:"externalURIContains,omitempty"`
	ExternalURIHasPrefix    *string  `json:"externalURIHasPrefix,omitempty"`
	ExternalURIHasSuffix    *string  `json:"externalURIHasSuffix,omitempty"`
	ExternalURIIsNil        *bool    `json:"externalURIIsNil,omitempty"`
	ExternalURINotNil       *bool    `json:"externalURINotNil,omitempty"`
	ExternalURIEqualFold    *string  `json:"externalURIEqualFold,omitempty"`
	ExternalURIContainsFold *string  `json:"externalURIContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// vulnerabilities edge predicates
	HasVulnerabilities     *bool                      `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*VulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// scans edge predicates
	HasScans     *bool             `json:"hasScans,omitempty"`
	HasScansWith []*ScanWhereInput `json:"hasScansWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// remediations edge predicates
	HasRemediations     *bool                    `json:"hasRemediations,omitempty"`
	HasRemediationsWith []*RemediationWhereInput `json:"hasRemediationsWith,omitempty"`
	// reviews edge predicates
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// workflow_object_refs edge predicates
	HasWorkflowObjectRefs     *bool                          `json:"hasWorkflowObjectRefs,omitempty"`
	HasWorkflowObjectRefsWith []*WorkflowObjectRefWhereInput `json:"hasWorkflowObjectRefsWith,omitempty"`
	// control_mappings edge predicates
	HasControlMappings     *bool                       `json:"hasControlMappings,omitempty"`
	HasControlMappingsWith []*FindingControlWhereInput `json:"hasControlMappingsWith,omitempty"`
}

type Group struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// whether the group is managed by the system
	IsManaged *bool `json:"isManaged,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// the SCIM external ID for the group
	ScimExternalID *string `json:"scimExternalID,omitempty"`
	// the SCIM displayname for the group
	ScimDisplayName *string `json:"scimDisplayName,omitempty"`
	// whether the SCIM group is marked as active
	ScimActive *bool `json:"scimActive,omitempty"`
	// the SCIM group mailing list email
	ScimGroupMailing                   *string                          `json:"scimGroupMailing,omitempty"`
	Owner                              *Organization                    `json:"owner,omitempty"`
	ProgramEditors                     *ProgramConnection               `json:"programEditors"`
	ProgramBlockedGroups               *ProgramConnection               `json:"programBlockedGroups"`
	ProgramViewers                     *ProgramConnection               `json:"programViewers"`
	RiskEditors                        *RiskConnection                  `json:"riskEditors"`
	RiskBlockedGroups                  *RiskConnection                  `json:"riskBlockedGroups"`
	RiskViewers                        *RiskConnection                  `json:"riskViewers"`
	ControlObjectiveEditors            *ControlObjectiveConnection      `json:"controlObjectiveEditors"`
	ControlObjectiveBlockedGroups      *ControlObjectiveConnection      `json:"controlObjectiveBlockedGroups"`
	ControlObjectiveViewers            *ControlObjectiveConnection      `json:"controlObjectiveViewers"`
	NarrativeEditors                   *NarrativeConnection             `json:"narrativeEditors"`
	NarrativeBlockedGroups             *NarrativeConnection             `json:"narrativeBlockedGroups"`
	NarrativeViewers                   *NarrativeConnection             `json:"narrativeViewers"`
	ControlImplementationEditors       *ControlImplementationConnection `json:"controlImplementationEditors"`
	ControlImplementationBlockedGroups *ControlImplementationConnection `json:"controlImplementationBlockedGroups"`
	ControlImplementationViewers       *ControlImplementationConnection `json:"controlImplementationViewers"`
	ScanEditors                        *ScanConnection                  `json:"scanEditors"`
	ScanBlockedGroups                  *ScanConnection                  `json:"scanBlockedGroups"`
	ScanViewers                        *ScanConnection                  `json:"scanViewers"`
	EntityEditors                      *EntityConnection                `json:"entityEditors"`
	EntityBlockedGroups                *EntityConnection                `json:"entityBlockedGroups"`
	EntityViewers                      *EntityConnection                `json:"entityViewers"`
	ProcedureEditors                   *ProcedureConnection             `json:"procedureEditors"`
	ProcedureBlockedGroups             *ProcedureConnection             `json:"procedureBlockedGroups"`
	InternalPolicyEditors              *InternalPolicyConnection        `json:"internalPolicyEditors"`
	InternalPolicyBlockedGroups        *InternalPolicyConnection        `json:"internalPolicyBlockedGroups"`
	ControlEditors                     *ControlConnection               `json:"controlEditors"`
	ControlBlockedGroups               *ControlConnection               `json:"controlBlockedGroups"`
	MappedControlEditors               *MappedControlConnection         `json:"mappedControlEditors"`
	MappedControlBlockedGroups         *MappedControlConnection         `json:"mappedControlBlockedGroups"`
	Setting                            *GroupSetting                    `json:"setting,omitempty"`
	Users                              *UserConnection                  `json:"users"`
	Events                             *EventConnection                 `json:"events"`
	Integrations                       *IntegrationConnection           `json:"integrations"`
	Files                              *FileConnection                  `json:"files"`
	Tasks                              *TaskConnection                  `json:"tasks"`
	Members                            *GroupMembershipConnection       `json:"members"`
	// permissions the group provides
	Permissions *GroupPermissionConnection `json:"permissions"`
}

func (Group) IsNode() {}

// Return response for createBulkGroup mutation
type GroupBulkCreatePayload struct {
	// Created groups
	Groups []*Group `json:"groups,omitempty"`
}

// Return response for deleteBulkGroup mutation
type GroupBulkDeletePayload struct {
	// Deleted group IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type GroupConnection struct {
	// A list of edges.
	Edges []*GroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroup mutation
type GroupCreatePayload struct {
	// Created group
	Group *Group `json:"group"`
}

// Return response for deleteGroup mutation
type GroupDeletePayload struct {
	// Deleted group ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupEdge struct {
	// The item at the end of the edge.
	Node *Group `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// whether the group is managed by the system
	IsManaged *bool `json:"isManaged,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// the SCIM external ID for the group
	ScimExternalID *string `json:"scimExternalID,omitempty"`
	// the SCIM displayname for the group
	ScimDisplayName *string `json:"scimDisplayName,omitempty"`
	// whether the SCIM group is marked as active
	ScimActive *bool `json:"scimActive,omitempty"`
	// the SCIM group mailing list email
	ScimGroupMailing *string `json:"scimGroupMailing,omitempty"`
}

func (GroupHistory) IsNode() {}

// A connection to a list of items.
type GroupHistoryConnection struct {
	// A list of edges.
	Edges []*GroupHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupHistory connections
type GroupHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupHistories.
	Field GroupHistoryOrderField `json:"field"`
}

// GroupHistoryWhereInput is used for filtering GroupHistory objects.
// Input was generated by ent.
type GroupHistoryWhereInput struct {
	Not *GroupHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// is_managed field predicates
	IsManaged       *bool `json:"isManaged,omitempty"`
	IsManagedNeq    *bool `json:"isManagedNEQ,omitempty"`
	IsManagedIsNil  *bool `json:"isManagedIsNil,omitempty"`
	IsManagedNotNil *bool `json:"isManagedNotNil,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// scim_external_id field predicates
	ScimExternalID             *string  `json:"scimExternalID,omitempty"`
	ScimExternalIdneq          *string  `json:"scimExternalIDNEQ,omitempty"`
	ScimExternalIDIn           []string `json:"scimExternalIDIn,omitempty"`
	ScimExternalIDNotIn        []string `json:"scimExternalIDNotIn,omitempty"`
	ScimExternalIdgt           *string  `json:"scimExternalIDGT,omitempty"`
	ScimExternalIdgte          *string  `json:"scimExternalIDGTE,omitempty"`
	ScimExternalIdlt           *string  `json:"scimExternalIDLT,omitempty"`
	ScimExternalIdlte          *string  `json:"scimExternalIDLTE,omitempty"`
	ScimExternalIDContains     *string  `json:"scimExternalIDContains,omitempty"`
	ScimExternalIDHasPrefix    *string  `json:"scimExternalIDHasPrefix,omitempty"`
	ScimExternalIDHasSuffix    *string  `json:"scimExternalIDHasSuffix,omitempty"`
	ScimExternalIDIsNil        *bool    `json:"scimExternalIDIsNil,omitempty"`
	ScimExternalIDNotNil       *bool    `json:"scimExternalIDNotNil,omitempty"`
	ScimExternalIDEqualFold    *string  `json:"scimExternalIDEqualFold,omitempty"`
	ScimExternalIDContainsFold *string  `json:"scimExternalIDContainsFold,omitempty"`
	// scim_display_name field predicates
	ScimDisplayName             *string  `json:"scimDisplayName,omitempty"`
	ScimDisplayNameNeq          *string  `json:"scimDisplayNameNEQ,omitempty"`
	ScimDisplayNameIn           []string `json:"scimDisplayNameIn,omitempty"`
	ScimDisplayNameNotIn        []string `json:"scimDisplayNameNotIn,omitempty"`
	ScimDisplayNameGt           *string  `json:"scimDisplayNameGT,omitempty"`
	ScimDisplayNameGte          *string  `json:"scimDisplayNameGTE,omitempty"`
	ScimDisplayNameLt           *string  `json:"scimDisplayNameLT,omitempty"`
	ScimDisplayNameLte          *string  `json:"scimDisplayNameLTE,omitempty"`
	ScimDisplayNameContains     *string  `json:"scimDisplayNameContains,omitempty"`
	ScimDisplayNameHasPrefix    *string  `json:"scimDisplayNameHasPrefix,omitempty"`
	ScimDisplayNameHasSuffix    *string  `json:"scimDisplayNameHasSuffix,omitempty"`
	ScimDisplayNameIsNil        *bool    `json:"scimDisplayNameIsNil,omitempty"`
	ScimDisplayNameNotNil       *bool    `json:"scimDisplayNameNotNil,omitempty"`
	ScimDisplayNameEqualFold    *string  `json:"scimDisplayNameEqualFold,omitempty"`
	ScimDisplayNameContainsFold *string  `json:"scimDisplayNameContainsFold,omitempty"`
	// scim_active field predicates
	ScimActive       *bool `json:"scimActive,omitempty"`
	ScimActiveNeq    *bool `json:"scimActiveNEQ,omitempty"`
	ScimActiveIsNil  *bool `json:"scimActiveIsNil,omitempty"`
	ScimActiveNotNil *bool `json:"scimActiveNotNil,omitempty"`
	// scim_group_mailing field predicates
	ScimGroupMailing             *string  `json:"scimGroupMailing,omitempty"`
	ScimGroupMailingNeq          *string  `json:"scimGroupMailingNEQ,omitempty"`
	ScimGroupMailingIn           []string `json:"scimGroupMailingIn,omitempty"`
	ScimGroupMailingNotIn        []string `json:"scimGroupMailingNotIn,omitempty"`
	ScimGroupMailingGt           *string  `json:"scimGroupMailingGT,omitempty"`
	ScimGroupMailingGte          *string  `json:"scimGroupMailingGTE,omitempty"`
	ScimGroupMailingLt           *string  `json:"scimGroupMailingLT,omitempty"`
	ScimGroupMailingLte          *string  `json:"scimGroupMailingLTE,omitempty"`
	ScimGroupMailingContains     *string  `json:"scimGroupMailingContains,omitempty"`
	ScimGroupMailingHasPrefix    *string  `json:"scimGroupMailingHasPrefix,omitempty"`
	ScimGroupMailingHasSuffix    *string  `json:"scimGroupMailingHasSuffix,omitempty"`
	ScimGroupMailingIsNil        *bool    `json:"scimGroupMailingIsNil,omitempty"`
	ScimGroupMailingNotNil       *bool    `json:"scimGroupMailingNotNil,omitempty"`
	ScimGroupMailingEqualFold    *string  `json:"scimGroupMailingEqualFold,omitempty"`
	ScimGroupMailingContainsFold *string  `json:"scimGroupMailingContainsFold,omitempty"`
}

// GroupMembersInput is used to create members for a group
// along with the group creation
type GroupMembersInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

type GroupMembership struct {
	ID        string           `json:"id"`
	CreatedAt *time.Time       `json:"createdAt,omitempty"`
	UpdatedAt *time.Time       `json:"updatedAt,omitempty"`
	CreatedBy *string          `json:"createdBy,omitempty"`
	UpdatedBy *string          `json:"updatedBy,omitempty"`
	Role      enums.Role       `json:"role"`
	GroupID   string           `json:"groupID"`
	UserID    string           `json:"userID"`
	Group     *Group           `json:"group"`
	User      *User            `json:"user"`
	Events    *EventConnection `json:"events"`
}

func (GroupMembership) IsNode() {}

// Return response for createBulkGroupMembership mutation
type GroupMembershipBulkCreatePayload struct {
	// Created groupMemberships
	GroupMemberships []*GroupMembership `json:"groupMemberships,omitempty"`
}

// Return response for deleteBulkGroupMembership mutation
type GroupMembershipBulkDeletePayload struct {
	// Deleted groupMembership IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type GroupMembershipConnection struct {
	// A list of edges.
	Edges []*GroupMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupMembership mutation
type GroupMembershipCreatePayload struct {
	// Created groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// Return response for deleteGroupMembership mutation
type GroupMembershipDeletePayload struct {
	// Deleted groupMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupMembershipEdge struct {
	// The item at the end of the edge.
	Node *GroupMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	GroupID     string         `json:"groupID"`
	UserID      string         `json:"userID"`
}

func (GroupMembershipHistory) IsNode() {}

// A connection to a list of items.
type GroupMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*GroupMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupMembershipHistory connections
type GroupMembershipHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupMembershipHistories.
	Field GroupMembershipHistoryOrderField `json:"field"`
}

// GroupMembershipHistoryWhereInput is used for filtering GroupMembershipHistory objects.
// Input was generated by ent.
type GroupMembershipHistoryWhereInput struct {
	Not *GroupMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Ordering options for GroupMembership connections
type GroupMembershipOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupMemberships.
	Field GroupMembershipOrderField `json:"field"`
}

// Return response for updateGroupMembership mutation
type GroupMembershipUpdatePayload struct {
	// Updated groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// GroupMembershipWhereInput is used for filtering GroupMembership objects.
// Input was generated by ent.
type GroupMembershipWhereInput struct {
	Not *GroupMembershipWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	GroupID   *string      `json:"groupID,omitempty"`
	UserID    *string      `json:"userID,omitempty"`
}

// Ordering options for Group connections
type GroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Groups.
	Field GroupOrderField `json:"field"`
}

// GroupPermission contains details for the related object and the permissions
// the group provides (or removes in the case of blocked) to the object within the
// organization
type GroupPermission struct {
	// the type of object the permissions are for, e.g. Program, Control, etc.
	ObjectType string `json:"objectType"`
	// the permissions the group has in relation to the object, e.g. EDITOR, VIEWER, BLOCKED
	Permissions enums.Permission `json:"permissions"`
	// the ID of the object the group was given permissions to
	ID string `json:"id"`
	// the displayID of the object the group was given permissions to
	DisplayID *string `json:"displayID,omitempty"`
	// the  name of the object the group was given permissions to
	Name *string `json:"name,omitempty"`
}

func (GroupPermission) IsNode() {}

// A connection to a list of items.
type GroupPermissionConnection struct {
	// A list of edges.
	Edges []*GroupPermissionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupPermissionEdge struct {
	// The item at the end of the edge.
	Node *GroupPermission `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupPermission connections
type GroupPermissionOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupPermission.
	Field GroupPermissionOrderField `json:"field"`
}

// GroupPermissionWhereInput is used for filtering GroupPermission objects.
type GroupPermissionWhereInput struct {
	Not *GroupPermissionWhereInput   `json:"not,omitempty"`
	And []*GroupPermissionWhereInput `json:"and,omitempty"`
	Or  []*GroupPermissionWhereInput `json:"or,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// objectType field predicates
	ObjectType             *string  `json:"objectType,omitempty"`
	ObjectTypeNeq          *string  `json:"objectTypeNEQ,omitempty"`
	ObjectTypeIn           []string `json:"objectTypeIn,omitempty"`
	ObjectTypeNotIn        []string `json:"objectTypeNotIn,omitempty"`
	ObjectTypeGt           *string  `json:"objectTypeGT,omitempty"`
	ObjectTypeGte          *string  `json:"objectTypeGTE,omitempty"`
	ObjectTypeLt           *string  `json:"objectTypeLT,omitempty"`
	ObjectTypeLte          *string  `json:"objectTypeLTE,omitempty"`
	ObjectTypeContains     *string  `json:"objectTypeContains,omitempty"`
	ObjectTypeHasPrefix    *string  `json:"objectTypeHasPrefix,omitempty"`
	ObjectTypeHasSuffix    *string  `json:"objectTypeHasSuffix,omitempty"`
	ObjectTypeIsNil        *bool    `json:"objectTypeIsNil,omitempty"`
	ObjectTypeNotNil       *bool    `json:"objectTypeNotNil,omitempty"`
	ObjectTypeEqualFold    *string  `json:"objectTypeEqualFold,omitempty"`
	ObjectTypeContainsFold *string  `json:"objectTypeContainsFold,omitempty"`
	// permission field predicates
	Permission             *string  `json:"permission,omitempty"`
	PermissionNeq          *string  `json:"permissionNEQ,omitempty"`
	PermissionIn           []string `json:"permissionIn,omitempty"`
	PermissionNotIn        []string `json:"permissionNotIn,omitempty"`
	PermissionGt           *string  `json:"permissionGT,omitempty"`
	PermissionGte          *string  `json:"permissionGTE,omitempty"`
	PermissionLt           *string  `json:"permissionLT,omitempty"`
	PermissionLte          *string  `json:"permissionLTE,omitempty"`
	PermissionContains     *string  `json:"permissionContains,omitempty"`
	PermissionHasPrefix    *string  `json:"permissionHasPrefix,omitempty"`
	PermissionHasSuffix    *string  `json:"permissionHasSuffix,omitempty"`
	PermissionIsNil        *bool    `json:"permissionIsNil,omitempty"`
	PermissionNotNil       *bool    `json:"permissionNotNil,omitempty"`
	PermissionEqualFold    *string  `json:"permissionEqualFold,omitempty"`
	PermissionContainsFold *string  `json:"permissionContainsFold,omitempty"`
}

type GroupSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
	Group   *Group  `json:"group,omitempty"`
}

func (GroupSetting) IsNode() {}

// Return response for createBulkGroupSetting mutation
type GroupSettingBulkCreatePayload struct {
	// Created groupSettings
	GroupSettings []*GroupSetting `json:"groupSettings,omitempty"`
}

// Return response for deleteBulkGroupSetting mutation
type GroupSettingBulkDeletePayload struct {
	// Deleted groupSetting IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type GroupSettingConnection struct {
	// A list of edges.
	Edges []*GroupSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupSetting mutation
type GroupSettingCreatePayload struct {
	// Created groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// Return response for deleteGroupSetting mutation
type GroupSettingDeletePayload struct {
	// Deleted groupSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupSettingEdge struct {
	// The item at the end of the edge.
	Node *GroupSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
}

func (GroupSettingHistory) IsNode() {}

// A connection to a list of items.
type GroupSettingHistoryConnection struct {
	// A list of edges.
	Edges []*GroupSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupSettingHistory connections
type GroupSettingHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupSettingHistories.
	Field GroupSettingHistoryOrderField `json:"field"`
}

// GroupSettingHistoryWhereInput is used for filtering GroupSettingHistory objects.
// Input was generated by ent.
type GroupSettingHistoryWhereInput struct {
	Not *GroupSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
}

// Ordering options for GroupSetting connections
type GroupSettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupSettings.
	Field GroupSettingOrderField `json:"field"`
}

// Return response for updateGroupSetting mutation
type GroupSettingUpdatePayload struct {
	// Updated groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// GroupSettingWhereInput is used for filtering GroupSetting objects.
// Input was generated by ent.
type GroupSettingWhereInput struct {
	Not *GroupSettingWhereInput   `json:"not,omitempty"`
	And []*GroupSettingWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

// Return response for updateGroup mutation
type GroupUpdatePayload struct {
	// Updated group
	Group *Group `json:"group"`
}

// GroupWhereInput is used for filtering Group objects.
// Input was generated by ent.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// is_managed field predicates
	IsManaged       *bool `json:"isManaged,omitempty"`
	IsManagedNeq    *bool `json:"isManagedNEQ,omitempty"`
	IsManagedIsNil  *bool `json:"isManagedIsNil,omitempty"`
	IsManagedNotNil *bool `json:"isManagedNotNil,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// scim_external_id field predicates
	ScimExternalID             *string  `json:"scimExternalID,omitempty"`
	ScimExternalIdneq          *string  `json:"scimExternalIDNEQ,omitempty"`
	ScimExternalIDIn           []string `json:"scimExternalIDIn,omitempty"`
	ScimExternalIDNotIn        []string `json:"scimExternalIDNotIn,omitempty"`
	ScimExternalIdgt           *string  `json:"scimExternalIDGT,omitempty"`
	ScimExternalIdgte          *string  `json:"scimExternalIDGTE,omitempty"`
	ScimExternalIdlt           *string  `json:"scimExternalIDLT,omitempty"`
	ScimExternalIdlte          *string  `json:"scimExternalIDLTE,omitempty"`
	ScimExternalIDContains     *string  `json:"scimExternalIDContains,omitempty"`
	ScimExternalIDHasPrefix    *string  `json:"scimExternalIDHasPrefix,omitempty"`
	ScimExternalIDHasSuffix    *string  `json:"scimExternalIDHasSuffix,omitempty"`
	ScimExternalIDIsNil        *bool    `json:"scimExternalIDIsNil,omitempty"`
	ScimExternalIDNotNil       *bool    `json:"scimExternalIDNotNil,omitempty"`
	ScimExternalIDEqualFold    *string  `json:"scimExternalIDEqualFold,omitempty"`
	ScimExternalIDContainsFold *string  `json:"scimExternalIDContainsFold,omitempty"`
	// scim_display_name field predicates
	ScimDisplayName             *string  `json:"scimDisplayName,omitempty"`
	ScimDisplayNameNeq          *string  `json:"scimDisplayNameNEQ,omitempty"`
	ScimDisplayNameIn           []string `json:"scimDisplayNameIn,omitempty"`
	ScimDisplayNameNotIn        []string `json:"scimDisplayNameNotIn,omitempty"`
	ScimDisplayNameGt           *string  `json:"scimDisplayNameGT,omitempty"`
	ScimDisplayNameGte          *string  `json:"scimDisplayNameGTE,omitempty"`
	ScimDisplayNameLt           *string  `json:"scimDisplayNameLT,omitempty"`
	ScimDisplayNameLte          *string  `json:"scimDisplayNameLTE,omitempty"`
	ScimDisplayNameContains     *string  `json:"scimDisplayNameContains,omitempty"`
	ScimDisplayNameHasPrefix    *string  `json:"scimDisplayNameHasPrefix,omitempty"`
	ScimDisplayNameHasSuffix    *string  `json:"scimDisplayNameHasSuffix,omitempty"`
	ScimDisplayNameIsNil        *bool    `json:"scimDisplayNameIsNil,omitempty"`
	ScimDisplayNameNotNil       *bool    `json:"scimDisplayNameNotNil,omitempty"`
	ScimDisplayNameEqualFold    *string  `json:"scimDisplayNameEqualFold,omitempty"`
	ScimDisplayNameContainsFold *string  `json:"scimDisplayNameContainsFold,omitempty"`
	// scim_active field predicates
	ScimActive       *bool `json:"scimActive,omitempty"`
	ScimActiveNeq    *bool `json:"scimActiveNEQ,omitempty"`
	ScimActiveIsNil  *bool `json:"scimActiveIsNil,omitempty"`
	ScimActiveNotNil *bool `json:"scimActiveNotNil,omitempty"`
	// scim_group_mailing field predicates
	ScimGroupMailing             *string  `json:"scimGroupMailing,omitempty"`
	ScimGroupMailingNeq          *string  `json:"scimGroupMailingNEQ,omitempty"`
	ScimGroupMailingIn           []string `json:"scimGroupMailingIn,omitempty"`
	ScimGroupMailingNotIn        []string `json:"scimGroupMailingNotIn,omitempty"`
	ScimGroupMailingGt           *string  `json:"scimGroupMailingGT,omitempty"`
	ScimGroupMailingGte          *string  `json:"scimGroupMailingGTE,omitempty"`
	ScimGroupMailingLt           *string  `json:"scimGroupMailingLT,omitempty"`
	ScimGroupMailingLte          *string  `json:"scimGroupMailingLTE,omitempty"`
	ScimGroupMailingContains     *string  `json:"scimGroupMailingContains,omitempty"`
	ScimGroupMailingHasPrefix    *string  `json:"scimGroupMailingHasPrefix,omitempty"`
	ScimGroupMailingHasSuffix    *string  `json:"scimGroupMailingHasSuffix,omitempty"`
	ScimGroupMailingIsNil        *bool    `json:"scimGroupMailingIsNil,omitempty"`
	ScimGroupMailingNotNil       *bool    `json:"scimGroupMailingNotNil,omitempty"`
	ScimGroupMailingEqualFold    *string  `json:"scimGroupMailingEqualFold,omitempty"`
	ScimGroupMailingContainsFold *string  `json:"scimGroupMailingContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// program_editors edge predicates
	HasProgramEditors     *bool                `json:"hasProgramEditors,omitempty"`
	HasProgramEditorsWith []*ProgramWhereInput `json:"hasProgramEditorsWith,omitempty"`
	// program_blocked_groups edge predicates
	HasProgramBlockedGroups     *bool                `json:"hasProgramBlockedGroups,omitempty"`
	HasProgramBlockedGroupsWith []*ProgramWhereInput `json:"hasProgramBlockedGroupsWith,omitempty"`
	// program_viewers edge predicates
	HasProgramViewers     *bool                `json:"hasProgramViewers,omitempty"`
	HasProgramViewersWith []*ProgramWhereInput `json:"hasProgramViewersWith,omitempty"`
	// risk_editors edge predicates
	HasRiskEditors     *bool             `json:"hasRiskEditors,omitempty"`
	HasRiskEditorsWith []*RiskWhereInput `json:"hasRiskEditorsWith,omitempty"`
	// risk_blocked_groups edge predicates
	HasRiskBlockedGroups     *bool             `json:"hasRiskBlockedGroups,omitempty"`
	HasRiskBlockedGroupsWith []*RiskWhereInput `json:"hasRiskBlockedGroupsWith,omitempty"`
	// risk_viewers edge predicates
	HasRiskViewers     *bool             `json:"hasRiskViewers,omitempty"`
	HasRiskViewersWith []*RiskWhereInput `json:"hasRiskViewersWith,omitempty"`
	// control_objective_editors edge predicates
	HasControlObjectiveEditors     *bool                         `json:"hasControlObjectiveEditors,omitempty"`
	HasControlObjectiveEditorsWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveEditorsWith,omitempty"`
	// control_objective_blocked_groups edge predicates
	HasControlObjectiveBlockedGroups     *bool                         `json:"hasControlObjectiveBlockedGroups,omitempty"`
	HasControlObjectiveBlockedGroupsWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveBlockedGroupsWith,omitempty"`
	// control_objective_viewers edge predicates
	HasControlObjectiveViewers     *bool                         `json:"hasControlObjectiveViewers,omitempty"`
	HasControlObjectiveViewersWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveViewersWith,omitempty"`
	// narrative_editors edge predicates
	HasNarrativeEditors     *bool                  `json:"hasNarrativeEditors,omitempty"`
	HasNarrativeEditorsWith []*NarrativeWhereInput `json:"hasNarrativeEditorsWith,omitempty"`
	// narrative_blocked_groups edge predicates
	HasNarrativeBlockedGroups     *bool                  `json:"hasNarrativeBlockedGroups,omitempty"`
	HasNarrativeBlockedGroupsWith []*NarrativeWhereInput `json:"hasNarrativeBlockedGroupsWith,omitempty"`
	// narrative_viewers edge predicates
	HasNarrativeViewers     *bool                  `json:"hasNarrativeViewers,omitempty"`
	HasNarrativeViewersWith []*NarrativeWhereInput `json:"hasNarrativeViewersWith,omitempty"`
	// control_implementation_editors edge predicates
	HasControlImplementationEditors     *bool                              `json:"hasControlImplementationEditors,omitempty"`
	HasControlImplementationEditorsWith []*ControlImplementationWhereInput `json:"hasControlImplementationEditorsWith,omitempty"`
	// control_implementation_blocked_groups edge predicates
	HasControlImplementationBlockedGroups     *bool                              `json:"hasControlImplementationBlockedGroups,omitempty"`
	HasControlImplementationBlockedGroupsWith []*ControlImplementationWhereInput `json:"hasControlImplementationBlockedGroupsWith,omitempty"`
	// control_implementation_viewers edge predicates
	HasControlImplementationViewers     *bool                              `json:"hasControlImplementationViewers,omitempty"`
	HasControlImplementationViewersWith []*ControlImplementationWhereInput `json:"hasControlImplementationViewersWith,omitempty"`
	// scan_editors edge predicates
	HasScanEditors     *bool             `json:"hasScanEditors,omitempty"`
	HasScanEditorsWith []*ScanWhereInput `json:"hasScanEditorsWith,omitempty"`
	// scan_blocked_groups edge predicates
	HasScanBlockedGroups     *bool             `json:"hasScanBlockedGroups,omitempty"`
	HasScanBlockedGroupsWith []*ScanWhereInput `json:"hasScanBlockedGroupsWith,omitempty"`
	// scan_viewers edge predicates
	HasScanViewers     *bool             `json:"hasScanViewers,omitempty"`
	HasScanViewersWith []*ScanWhereInput `json:"hasScanViewersWith,omitempty"`
	// entity_editors edge predicates
	HasEntityEditors     *bool               `json:"hasEntityEditors,omitempty"`
	HasEntityEditorsWith []*EntityWhereInput `json:"hasEntityEditorsWith,omitempty"`
	// entity_blocked_groups edge predicates
	HasEntityBlockedGroups     *bool               `json:"hasEntityBlockedGroups,omitempty"`
	HasEntityBlockedGroupsWith []*EntityWhereInput `json:"hasEntityBlockedGroupsWith,omitempty"`
	// entity_viewers edge predicates
	HasEntityViewers     *bool               `json:"hasEntityViewers,omitempty"`
	HasEntityViewersWith []*EntityWhereInput `json:"hasEntityViewersWith,omitempty"`
	// procedure_editors edge predicates
	HasProcedureEditors     *bool                  `json:"hasProcedureEditors,omitempty"`
	HasProcedureEditorsWith []*ProcedureWhereInput `json:"hasProcedureEditorsWith,omitempty"`
	// procedure_blocked_groups edge predicates
	HasProcedureBlockedGroups     *bool                  `json:"hasProcedureBlockedGroups,omitempty"`
	HasProcedureBlockedGroupsWith []*ProcedureWhereInput `json:"hasProcedureBlockedGroupsWith,omitempty"`
	// internal_policy_editors edge predicates
	HasInternalPolicyEditors     *bool                       `json:"hasInternalPolicyEditors,omitempty"`
	HasInternalPolicyEditorsWith []*InternalPolicyWhereInput `json:"hasInternalPolicyEditorsWith,omitempty"`
	// internal_policy_blocked_groups edge predicates
	HasInternalPolicyBlockedGroups     *bool                       `json:"hasInternalPolicyBlockedGroups,omitempty"`
	HasInternalPolicyBlockedGroupsWith []*InternalPolicyWhereInput `json:"hasInternalPolicyBlockedGroupsWith,omitempty"`
	// control_editors edge predicates
	HasControlEditors     *bool                `json:"hasControlEditors,omitempty"`
	HasControlEditorsWith []*ControlWhereInput `json:"hasControlEditorsWith,omitempty"`
	// control_blocked_groups edge predicates
	HasControlBlockedGroups     *bool                `json:"hasControlBlockedGroups,omitempty"`
	HasControlBlockedGroupsWith []*ControlWhereInput `json:"hasControlBlockedGroupsWith,omitempty"`
	// mapped_control_editors edge predicates
	HasMappedControlEditors     *bool                      `json:"hasMappedControlEditors,omitempty"`
	HasMappedControlEditorsWith []*MappedControlWhereInput `json:"hasMappedControlEditorsWith,omitempty"`
	// mapped_control_blocked_groups edge predicates
	HasMappedControlBlockedGroups     *bool                      `json:"hasMappedControlBlockedGroups,omitempty"`
	HasMappedControlBlockedGroupsWith []*MappedControlWhereInput `json:"hasMappedControlBlockedGroupsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                     `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingWhereInput `json:"hasSettingWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                        `json:"hasMembers,omitempty"`
	HasMembersWith []*GroupMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Hush struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// a credential set, typically where you have multiple tokens or keys that compose one credential such as when accessing s3 and using access key ID, secret key, etc.
	CredentialSet *models.CredentialSet `json:"credentialSet,omitempty"`
	// additional metadata about the credential
	Metadata   map[string]any `json:"metadata,omitempty"`
	LastUsedAt *time.Time     `json:"lastUsedAt,omitempty"`
	// when the token expires
	ExpiresAt    *time.Time             `json:"expiresAt,omitempty"`
	Owner        *Organization          `json:"owner,omitempty"`
	Integrations *IntegrationConnection `json:"integrations"`
	Files        *FileConnection        `json:"files"`
	Events       *EventConnection       `json:"events"`
}

func (Hush) IsNode() {}

// Return response for createBulkHush mutation
type HushBulkCreatePayload struct {
	// Created hushs
	Hushes []*Hush `json:"hushes,omitempty"`
}

// Return response for deleteBulkHush mutation
type HushBulkDeletePayload struct {
	// Deleted hush IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkHush mutation
type HushBulkUpdatePayload struct {
	// Updated hushs
	Hushes []*Hush `json:"hushes,omitempty"`
	// IDs of the updated hushs
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type HushConnection struct {
	// A list of edges.
	Edges []*HushEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createHush mutation
type HushCreatePayload struct {
	// Created hush
	Hush *Hush `json:"hush"`
}

// Return response for deleteHush mutation
type HushDeletePayload struct {
	// Deleted hush ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type HushEdge struct {
	// The item at the end of the edge.
	Node *Hush `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type HushHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// a credential set, typically where you have multiple tokens or keys that compose one credential such as when accessing s3 and using access key ID, secret key, etc.
	CredentialSet *models.CredentialSet `json:"credentialSet,omitempty"`
	// additional metadata about the credential
	Metadata   map[string]any `json:"metadata,omitempty"`
	LastUsedAt *time.Time     `json:"lastUsedAt,omitempty"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
}

func (HushHistory) IsNode() {}

// A connection to a list of items.
type HushHistoryConnection struct {
	// A list of edges.
	Edges []*HushHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type HushHistoryEdge struct {
	// The item at the end of the edge.
	Node *HushHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for HushHistory connections
type HushHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order HushHistories.
	Field HushHistoryOrderField `json:"field"`
}

// HushHistoryWhereInput is used for filtering HushHistory objects.
// Input was generated by ent.
type HushHistoryWhereInput struct {
	Not *HushHistoryWhereInput   `json:"not,omitempty"`
	And []*HushHistoryWhereInput `json:"and,omitempty"`
	Or  []*HushHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
}

// Ordering options for Hush connections
type HushOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Hushes.
	Field HushOrderField `json:"field"`
}

// Return response for updateHush mutation
type HushUpdatePayload struct {
	// Updated hush
	Hush *Hush `json:"hush"`
}

// HushWhereInput is used for filtering Hush objects.
// Input was generated by ent.
type HushWhereInput struct {
	Not *HushWhereInput   `json:"not,omitempty"`
	And []*HushWhereInput `json:"and,omitempty"`
	Or  []*HushWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Integration struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the integration
	Name string `json:"name"`
	// a description of the integration
	Description *string `json:"description,omitempty"`
	// the kind of integration, such as github, slack, s3 etc.
	Kind *string `json:"kind,omitempty"`
	// the type of integration, such as communicattion, storage, SCM, etc.
	IntegrationType *string `json:"integrationType,omitempty"`
	// additional metadata about the integration
	Metadata             map[string]any                 `json:"metadata,omitempty"`
	Owner                *Organization                  `json:"owner,omitempty"`
	Secrets              *HushConnection                `json:"secrets"`
	Files                *FileConnection                `json:"files"`
	Events               *EventConnection               `json:"events"`
	Findings             *FindingConnection             `json:"findings"`
	Vulnerabilities      *VulnerabilityConnection       `json:"vulnerabilities"`
	Reviews              *ReviewConnection              `json:"reviews"`
	Remediations         *RemediationConnection         `json:"remediations"`
	Tasks                *TaskConnection                `json:"tasks"`
	ActionPlans          *ActionPlanConnection          `json:"actionPlans"`
	DirectoryAccounts    *DirectoryAccountConnection    `json:"directoryAccounts"`
	DirectoryGroups      *DirectoryGroupConnection      `json:"directoryGroups"`
	DirectoryMemberships *DirectoryMembershipConnection `json:"directoryMemberships"`
	DirectorySyncRuns    *DirectorySyncRunConnection    `json:"directorySyncRuns"`
}

func (Integration) IsNode() {}

// A connection to a list of items.
type IntegrationConnection struct {
	// A list of edges.
	Edges []*IntegrationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type IntegrationEdge struct {
	// The item at the end of the edge.
	Node *Integration `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type IntegrationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the integration
	Name string `json:"name"`
	// a description of the integration
	Description *string `json:"description,omitempty"`
	// the kind of integration, such as github, slack, s3 etc.
	Kind *string `json:"kind,omitempty"`
	// the type of integration, such as communicattion, storage, SCM, etc.
	IntegrationType *string `json:"integrationType,omitempty"`
	// additional metadata about the integration
	Metadata map[string]any `json:"metadata,omitempty"`
}

func (IntegrationHistory) IsNode() {}

// A connection to a list of items.
type IntegrationHistoryConnection struct {
	// A list of edges.
	Edges []*IntegrationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type IntegrationHistoryEdge struct {
	// The item at the end of the edge.
	Node *IntegrationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for IntegrationHistory connections
type IntegrationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order IntegrationHistories.
	Field IntegrationHistoryOrderField `json:"field"`
}

// IntegrationHistoryWhereInput is used for filtering IntegrationHistory objects.
// Input was generated by ent.
type IntegrationHistoryWhereInput struct {
	Not *IntegrationHistoryWhereInput   `json:"not,omitempty"`
	And []*IntegrationHistoryWhereInput `json:"and,omitempty"`
	Or  []*IntegrationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// integration_type field predicates
	IntegrationType             *string  `json:"integrationType,omitempty"`
	IntegrationTypeNeq          *string  `json:"integrationTypeNEQ,omitempty"`
	IntegrationTypeIn           []string `json:"integrationTypeIn,omitempty"`
	IntegrationTypeNotIn        []string `json:"integrationTypeNotIn,omitempty"`
	IntegrationTypeGt           *string  `json:"integrationTypeGT,omitempty"`
	IntegrationTypeGte          *string  `json:"integrationTypeGTE,omitempty"`
	IntegrationTypeLt           *string  `json:"integrationTypeLT,omitempty"`
	IntegrationTypeLte          *string  `json:"integrationTypeLTE,omitempty"`
	IntegrationTypeContains     *string  `json:"integrationTypeContains,omitempty"`
	IntegrationTypeHasPrefix    *string  `json:"integrationTypeHasPrefix,omitempty"`
	IntegrationTypeHasSuffix    *string  `json:"integrationTypeHasSuffix,omitempty"`
	IntegrationTypeIsNil        *bool    `json:"integrationTypeIsNil,omitempty"`
	IntegrationTypeNotNil       *bool    `json:"integrationTypeNotNil,omitempty"`
	IntegrationTypeEqualFold    *string  `json:"integrationTypeEqualFold,omitempty"`
	IntegrationTypeContainsFold *string  `json:"integrationTypeContainsFold,omitempty"`
}

// Ordering options for Integration connections
type IntegrationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Integrations.
	Field IntegrationOrderField `json:"field"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// integration_type field predicates
	IntegrationType             *string  `json:"integrationType,omitempty"`
	IntegrationTypeNeq          *string  `json:"integrationTypeNEQ,omitempty"`
	IntegrationTypeIn           []string `json:"integrationTypeIn,omitempty"`
	IntegrationTypeNotIn        []string `json:"integrationTypeNotIn,omitempty"`
	IntegrationTypeGt           *string  `json:"integrationTypeGT,omitempty"`
	IntegrationTypeGte          *string  `json:"integrationTypeGTE,omitempty"`
	IntegrationTypeLt           *string  `json:"integrationTypeLT,omitempty"`
	IntegrationTypeLte          *string  `json:"integrationTypeLTE,omitempty"`
	IntegrationTypeContains     *string  `json:"integrationTypeContains,omitempty"`
	IntegrationTypeHasPrefix    *string  `json:"integrationTypeHasPrefix,omitempty"`
	IntegrationTypeHasSuffix    *string  `json:"integrationTypeHasSuffix,omitempty"`
	IntegrationTypeIsNil        *bool    `json:"integrationTypeIsNil,omitempty"`
	IntegrationTypeNotNil       *bool    `json:"integrationTypeNotNil,omitempty"`
	IntegrationTypeEqualFold    *string  `json:"integrationTypeEqualFold,omitempty"`
	IntegrationTypeContainsFold *string  `json:"integrationTypeContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// findings edge predicates
	HasFindings     *bool                `json:"hasFindings,omitempty"`
	HasFindingsWith []*FindingWhereInput `json:"hasFindingsWith,omitempty"`
	// vulnerabilities edge predicates
	HasVulnerabilities     *bool                      `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*VulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`
	// reviews edge predicates
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`
	// remediations edge predicates
	HasRemediations     *bool                    `json:"hasRemediations,omitempty"`
	HasRemediationsWith []*RemediationWhereInput `json:"hasRemediationsWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// directory_accounts edge predicates
	HasDirectoryAccounts     *bool                         `json:"hasDirectoryAccounts,omitempty"`
	HasDirectoryAccountsWith []*DirectoryAccountWhereInput `json:"hasDirectoryAccountsWith,omitempty"`
	// directory_groups edge predicates
	HasDirectoryGroups     *bool                       `json:"hasDirectoryGroups,omitempty"`
	HasDirectoryGroupsWith []*DirectoryGroupWhereInput `json:"hasDirectoryGroupsWith,omitempty"`
	// directory_memberships edge predicates
	HasDirectoryMemberships     *bool                            `json:"hasDirectoryMemberships,omitempty"`
	HasDirectoryMembershipsWith []*DirectoryMembershipWhereInput `json:"hasDirectoryMembershipsWith,omitempty"`
	// directory_sync_runs edge predicates
	HasDirectorySyncRuns     *bool                         `json:"hasDirectorySyncRuns,omitempty"`
	HasDirectorySyncRunsWith []*DirectorySyncRunWhereInput `json:"hasDirectorySyncRunsWith,omitempty"`
}

type InternalPolicy struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// status of the policy, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the policy, e.g. compliance, operational, health and safety, etc.
	PolicyType *string `json:"policyType,omitempty"`
	// details of the policy
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the policy
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the policy should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the policy should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// the id of the group responsible for approving the policy
	ApproverID *string `json:"approverID,omitempty"`
	// the id of the group responsible for approving the policy
	DelegateID *string `json:"delegateID,omitempty"`
	Summary    *string `json:"summary,omitempty"`
	// auto-generated tag suggestions for the policy
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the policy
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the policy
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the policy
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the policy
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the policy
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the policy
	URL *string `json:"url,omitempty"`
	// This will contain the most recent file id if this policy was created from a file
	FileID *string `json:"fileID,omitempty"`
	// the kind of the internal_policy
	InternalPolicyKindName *string `json:"internalPolicyKindName,omitempty"`
	// the kind of the internal_policy
	InternalPolicyKindID *string          `json:"internalPolicyKindID,omitempty"`
	Owner                *Organization    `json:"owner,omitempty"`
	BlockedGroups        *GroupConnection `json:"blockedGroups"`
	Editors              *GroupConnection `json:"editors"`
	// the group of users who are responsible for approving the policy
	Approver *Group `json:"approver,omitempty"`
	// temporary delegates for the policy, used for temporary approval
	Delegate               *Group                           `json:"delegate,omitempty"`
	InternalPolicyKind     *CustomTypeEnum                  `json:"internalPolicyKind,omitempty"`
	ControlObjectives      *ControlObjectiveConnection      `json:"controlObjectives"`
	ControlImplementations *ControlImplementationConnection `json:"controlImplementations"`
	Controls               *ControlConnection               `json:"controls"`
	Subcontrols            *SubcontrolConnection            `json:"subcontrols"`
	Procedures             *ProcedureConnection             `json:"procedures"`
	Narratives             *NarrativeConnection             `json:"narratives"`
	Tasks                  *TaskConnection                  `json:"tasks"`
	Risks                  *RiskConnection                  `json:"risks"`
	Programs               *ProgramConnection               `json:"programs"`
	File                   *File                            `json:"file,omitempty"`
	Comments               *NoteConnection                  `json:"comments"`
	WorkflowObjectRefs     *WorkflowObjectRefConnection     `json:"workflowObjectRefs"`
}

func (InternalPolicy) IsNode() {}

// Return response for createBulkInternalPolicy mutation
type InternalPolicyBulkCreatePayload struct {
	// Created internalPolicys
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
}

// Return response for deleteBulkInternalPolicy mutation
type InternalPolicyBulkDeletePayload struct {
	// Deleted internalPolicy IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkInternalPolicy mutation
type InternalPolicyBulkUpdatePayload struct {
	// Updated internalPolicys
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
	// IDs of the updated internalPolicys
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type InternalPolicyConnection struct {
	// A list of edges.
	Edges []*InternalPolicyEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInternalPolicy mutation
type InternalPolicyCreatePayload struct {
	// Created internalPolicy
	InternalPolicy *InternalPolicy `json:"internalPolicy"`
}

// Return response for deleteInternalPolicy mutation
type InternalPolicyDeletePayload struct {
	// Deleted internalPolicy ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InternalPolicyEdge struct {
	// The item at the end of the edge.
	Node *InternalPolicy `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type InternalPolicyHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// status of the policy, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the policy, e.g. compliance, operational, health and safety, etc.
	PolicyType *string `json:"policyType,omitempty"`
	// details of the policy
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the policy
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the policy should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the policy should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// the id of the group responsible for approving the policy
	ApproverID *string `json:"approverID,omitempty"`
	// the id of the group responsible for approving the policy
	DelegateID *string `json:"delegateID,omitempty"`
	Summary    *string `json:"summary,omitempty"`
	// auto-generated tag suggestions for the policy
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the policy
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the policy
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the policy
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the policy
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the policy
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the policy
	URL *string `json:"url,omitempty"`
	// This will contain the most recent file id if this policy was created from a file
	FileID *string `json:"fileID,omitempty"`
	// the kind of the internal_policy
	InternalPolicyKindName *string `json:"internalPolicyKindName,omitempty"`
	// the kind of the internal_policy
	InternalPolicyKindID *string `json:"internalPolicyKindID,omitempty"`
}

func (InternalPolicyHistory) IsNode() {}

// A connection to a list of items.
type InternalPolicyHistoryConnection struct {
	// A list of edges.
	Edges []*InternalPolicyHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type InternalPolicyHistoryEdge struct {
	// The item at the end of the edge.
	Node *InternalPolicyHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for InternalPolicyHistory connections
type InternalPolicyHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order InternalPolicyHistories.
	Field InternalPolicyHistoryOrderField `json:"field"`
}

// InternalPolicyHistoryWhereInput is used for filtering InternalPolicyHistory objects.
// Input was generated by ent.
type InternalPolicyHistoryWhereInput struct {
	Not *InternalPolicyHistoryWhereInput   `json:"not,omitempty"`
	And []*InternalPolicyHistoryWhereInput `json:"and,omitempty"`
	Or  []*InternalPolicyHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// policy_type field predicates
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNeq          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGt           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGte          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLt           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLte          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        *bool    `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       *bool    `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// approver_id field predicates
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIdneq          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIdgt           *string  `json:"approverIDGT,omitempty"`
	ApproverIdgte          *string  `json:"approverIDGTE,omitempty"`
	ApproverIdlt           *string  `json:"approverIDLT,omitempty"`
	ApproverIdlte          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        *bool    `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       *bool    `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDIsNil        *bool    `json:"fileIDIsNil,omitempty"`
	FileIDNotNil       *bool    `json:"fileIDNotNil,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// internal_policy_kind_name field predicates
	InternalPolicyKindName             *string  `json:"internalPolicyKindName,omitempty"`
	InternalPolicyKindNameNeq          *string  `json:"internalPolicyKindNameNEQ,omitempty"`
	InternalPolicyKindNameIn           []string `json:"internalPolicyKindNameIn,omitempty"`
	InternalPolicyKindNameNotIn        []string `json:"internalPolicyKindNameNotIn,omitempty"`
	InternalPolicyKindNameGt           *string  `json:"internalPolicyKindNameGT,omitempty"`
	InternalPolicyKindNameGte          *string  `json:"internalPolicyKindNameGTE,omitempty"`
	InternalPolicyKindNameLt           *string  `json:"internalPolicyKindNameLT,omitempty"`
	InternalPolicyKindNameLte          *string  `json:"internalPolicyKindNameLTE,omitempty"`
	InternalPolicyKindNameContains     *string  `json:"internalPolicyKindNameContains,omitempty"`
	InternalPolicyKindNameHasPrefix    *string  `json:"internalPolicyKindNameHasPrefix,omitempty"`
	InternalPolicyKindNameHasSuffix    *string  `json:"internalPolicyKindNameHasSuffix,omitempty"`
	InternalPolicyKindNameIsNil        *bool    `json:"internalPolicyKindNameIsNil,omitempty"`
	InternalPolicyKindNameNotNil       *bool    `json:"internalPolicyKindNameNotNil,omitempty"`
	InternalPolicyKindNameEqualFold    *string  `json:"internalPolicyKindNameEqualFold,omitempty"`
	InternalPolicyKindNameContainsFold *string  `json:"internalPolicyKindNameContainsFold,omitempty"`
	// internal_policy_kind_id field predicates
	InternalPolicyKindID             *string  `json:"internalPolicyKindID,omitempty"`
	InternalPolicyKindIdneq          *string  `json:"internalPolicyKindIDNEQ,omitempty"`
	InternalPolicyKindIDIn           []string `json:"internalPolicyKindIDIn,omitempty"`
	InternalPolicyKindIDNotIn        []string `json:"internalPolicyKindIDNotIn,omitempty"`
	InternalPolicyKindIdgt           *string  `json:"internalPolicyKindIDGT,omitempty"`
	InternalPolicyKindIdgte          *string  `json:"internalPolicyKindIDGTE,omitempty"`
	InternalPolicyKindIdlt           *string  `json:"internalPolicyKindIDLT,omitempty"`
	InternalPolicyKindIdlte          *string  `json:"internalPolicyKindIDLTE,omitempty"`
	InternalPolicyKindIDContains     *string  `json:"internalPolicyKindIDContains,omitempty"`
	InternalPolicyKindIDHasPrefix    *string  `json:"internalPolicyKindIDHasPrefix,omitempty"`
	InternalPolicyKindIDHasSuffix    *string  `json:"internalPolicyKindIDHasSuffix,omitempty"`
	InternalPolicyKindIDIsNil        *bool    `json:"internalPolicyKindIDIsNil,omitempty"`
	InternalPolicyKindIDNotNil       *bool    `json:"internalPolicyKindIDNotNil,omitempty"`
	InternalPolicyKindIDEqualFold    *string  `json:"internalPolicyKindIDEqualFold,omitempty"`
	InternalPolicyKindIDContainsFold *string  `json:"internalPolicyKindIDContainsFold,omitempty"`
}

// Ordering options for InternalPolicy connections
type InternalPolicyOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order InternalPolicies.
	Field InternalPolicyOrderField `json:"field"`
}

// Return response for updateInternalPolicy mutation
type InternalPolicyUpdatePayload struct {
	// Updated internalPolicy
	InternalPolicy *InternalPolicy `json:"internalPolicy"`
}

// InternalPolicyWhereInput is used for filtering InternalPolicy objects.
// Input was generated by ent.
type InternalPolicyWhereInput struct {
	Not *InternalPolicyWhereInput   `json:"not,omitempty"`
	And []*InternalPolicyWhereInput `json:"and,omitempty"`
	Or  []*InternalPolicyWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// policy_type field predicates
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNeq          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGt           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGte          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLt           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLte          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        *bool    `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       *bool    `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// approver_id field predicates
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIdneq          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIdgt           *string  `json:"approverIDGT,omitempty"`
	ApproverIdgte          *string  `json:"approverIDGTE,omitempty"`
	ApproverIdlt           *string  `json:"approverIDLT,omitempty"`
	ApproverIdlte          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        *bool    `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       *bool    `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDIsNil        *bool    `json:"fileIDIsNil,omitempty"`
	FileIDNotNil       *bool    `json:"fileIDNotNil,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// internal_policy_kind_name field predicates
	InternalPolicyKindName             *string  `json:"internalPolicyKindName,omitempty"`
	InternalPolicyKindNameNeq          *string  `json:"internalPolicyKindNameNEQ,omitempty"`
	InternalPolicyKindNameIn           []string `json:"internalPolicyKindNameIn,omitempty"`
	InternalPolicyKindNameNotIn        []string `json:"internalPolicyKindNameNotIn,omitempty"`
	InternalPolicyKindNameGt           *string  `json:"internalPolicyKindNameGT,omitempty"`
	InternalPolicyKindNameGte          *string  `json:"internalPolicyKindNameGTE,omitempty"`
	InternalPolicyKindNameLt           *string  `json:"internalPolicyKindNameLT,omitempty"`
	InternalPolicyKindNameLte          *string  `json:"internalPolicyKindNameLTE,omitempty"`
	InternalPolicyKindNameContains     *string  `json:"internalPolicyKindNameContains,omitempty"`
	InternalPolicyKindNameHasPrefix    *string  `json:"internalPolicyKindNameHasPrefix,omitempty"`
	InternalPolicyKindNameHasSuffix    *string  `json:"internalPolicyKindNameHasSuffix,omitempty"`
	InternalPolicyKindNameIsNil        *bool    `json:"internalPolicyKindNameIsNil,omitempty"`
	InternalPolicyKindNameNotNil       *bool    `json:"internalPolicyKindNameNotNil,omitempty"`
	InternalPolicyKindNameEqualFold    *string  `json:"internalPolicyKindNameEqualFold,omitempty"`
	InternalPolicyKindNameContainsFold *string  `json:"internalPolicyKindNameContainsFold,omitempty"`
	// internal_policy_kind_id field predicates
	InternalPolicyKindID             *string  `json:"internalPolicyKindID,omitempty"`
	InternalPolicyKindIdneq          *string  `json:"internalPolicyKindIDNEQ,omitempty"`
	InternalPolicyKindIDIn           []string `json:"internalPolicyKindIDIn,omitempty"`
	InternalPolicyKindIDNotIn        []string `json:"internalPolicyKindIDNotIn,omitempty"`
	InternalPolicyKindIdgt           *string  `json:"internalPolicyKindIDGT,omitempty"`
	InternalPolicyKindIdgte          *string  `json:"internalPolicyKindIDGTE,omitempty"`
	InternalPolicyKindIdlt           *string  `json:"internalPolicyKindIDLT,omitempty"`
	InternalPolicyKindIdlte          *string  `json:"internalPolicyKindIDLTE,omitempty"`
	InternalPolicyKindIDContains     *string  `json:"internalPolicyKindIDContains,omitempty"`
	InternalPolicyKindIDHasPrefix    *string  `json:"internalPolicyKindIDHasPrefix,omitempty"`
	InternalPolicyKindIDHasSuffix    *string  `json:"internalPolicyKindIDHasSuffix,omitempty"`
	InternalPolicyKindIDIsNil        *bool    `json:"internalPolicyKindIDIsNil,omitempty"`
	InternalPolicyKindIDNotNil       *bool    `json:"internalPolicyKindIDNotNil,omitempty"`
	InternalPolicyKindIDEqualFold    *string  `json:"internalPolicyKindIDEqualFold,omitempty"`
	InternalPolicyKindIDContainsFold *string  `json:"internalPolicyKindIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// approver edge predicates
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// internal_policy_kind edge predicates
	HasInternalPolicyKind     *bool                       `json:"hasInternalPolicyKind,omitempty"`
	HasInternalPolicyKindWith []*CustomTypeEnumWhereInput `json:"hasInternalPolicyKindWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// control_implementations edge predicates
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// workflow_object_refs edge predicates
	HasWorkflowObjectRefs     *bool                          `json:"hasWorkflowObjectRefs,omitempty"`
	HasWorkflowObjectRefsWith []*WorkflowObjectRefWhereInput `json:"hasWorkflowObjectRefsWith,omitempty"`
}

type Invite struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status enums.InviteStatus `json:"status"`
	Role   enums.Role         `json:"role"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts int64 `json:"sendAttempts"`
	// the user who initiated the invitation
	RequestorID *string `json:"requestorID,omitempty"`
	// indicates if this invitation is for transferring organization ownership - when accepted, current owner becomes admin and invitee becomes owner
	OwnershipTransfer *bool            `json:"ownershipTransfer,omitempty"`
	Owner             *Organization    `json:"owner,omitempty"`
	Events            *EventConnection `json:"events"`
	Groups            *GroupConnection `json:"groups"`
}

func (Invite) IsNode() {}

// Return response for createBulkInvite mutation
type InviteBulkCreatePayload struct {
	// Created invites
	Invites []*Invite `json:"invites,omitempty"`
}

// Return response for deleteBulkInvite mutation
type InviteBulkDeletePayload struct {
	// Deleted invite IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type InviteConnection struct {
	// A list of edges.
	Edges []*InviteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInvite mutation
type InviteCreatePayload struct {
	// Created invite
	Invite *Invite `json:"invite"`
}

// Return response for deleteInvite mutation
type InviteDeletePayload struct {
	// Deleted invite ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InviteEdge struct {
	// The item at the end of the edge.
	Node *Invite `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Invite connections
type InviteOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Invites.
	Field InviteOrderField `json:"field"`
}

// Return response for updateInvite mutation
type InviteUpdatePayload struct {
	// Updated invite
	Invite *Invite `json:"invite"`
}

// InviteWhereInput is used for filtering Invite objects.
// Input was generated by ent.
type InviteWhereInput struct {
	Not *InviteWhereInput   `json:"not,omitempty"`
	And []*InviteWhereInput `json:"and,omitempty"`
	Or  []*InviteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// expires field predicates
	Expires       *time.Time   `json:"expires,omitempty"`
	ExpiresNeq    *time.Time   `json:"expiresNEQ,omitempty"`
	ExpiresIn     []*time.Time `json:"expiresIn,omitempty"`
	ExpiresNotIn  []*time.Time `json:"expiresNotIn,omitempty"`
	ExpiresGt     *time.Time   `json:"expiresGT,omitempty"`
	ExpiresGte    *time.Time   `json:"expiresGTE,omitempty"`
	ExpiresLt     *time.Time   `json:"expiresLT,omitempty"`
	ExpiresLte    *time.Time   `json:"expiresLTE,omitempty"`
	ExpiresIsNil  *bool        `json:"expiresIsNil,omitempty"`
	ExpiresNotNil *bool        `json:"expiresNotNil,omitempty"`
	// recipient field predicates
	Recipient             *string  `json:"recipient,omitempty"`
	RecipientNeq          *string  `json:"recipientNEQ,omitempty"`
	RecipientIn           []string `json:"recipientIn,omitempty"`
	RecipientNotIn        []string `json:"recipientNotIn,omitempty"`
	RecipientGt           *string  `json:"recipientGT,omitempty"`
	RecipientGte          *string  `json:"recipientGTE,omitempty"`
	RecipientLt           *string  `json:"recipientLT,omitempty"`
	RecipientLte          *string  `json:"recipientLTE,omitempty"`
	RecipientContains     *string  `json:"recipientContains,omitempty"`
	RecipientHasPrefix    *string  `json:"recipientHasPrefix,omitempty"`
	RecipientHasSuffix    *string  `json:"recipientHasSuffix,omitempty"`
	RecipientEqualFold    *string  `json:"recipientEqualFold,omitempty"`
	RecipientContainsFold *string  `json:"recipientContainsFold,omitempty"`
	// status field predicates
	Status      *enums.InviteStatus  `json:"status,omitempty"`
	StatusNeq   *enums.InviteStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.InviteStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.InviteStatus `json:"statusNotIn,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// send_attempts field predicates
	SendAttempts      *int64  `json:"sendAttempts,omitempty"`
	SendAttemptsNeq   *int64  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int64 `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int64 `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGt    *int64  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGte   *int64  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLt    *int64  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLte   *int64  `json:"sendAttemptsLTE,omitempty"`
	// requestor_id field predicates
	RequestorID             *string  `json:"requestorID,omitempty"`
	RequestorIdneq          *string  `json:"requestorIDNEQ,omitempty"`
	RequestorIDIn           []string `json:"requestorIDIn,omitempty"`
	RequestorIDNotIn        []string `json:"requestorIDNotIn,omitempty"`
	RequestorIdgt           *string  `json:"requestorIDGT,omitempty"`
	RequestorIdgte          *string  `json:"requestorIDGTE,omitempty"`
	RequestorIdlt           *string  `json:"requestorIDLT,omitempty"`
	RequestorIdlte          *string  `json:"requestorIDLTE,omitempty"`
	RequestorIDContains     *string  `json:"requestorIDContains,omitempty"`
	RequestorIDHasPrefix    *string  `json:"requestorIDHasPrefix,omitempty"`
	RequestorIDHasSuffix    *string  `json:"requestorIDHasSuffix,omitempty"`
	RequestorIDIsNil        *bool    `json:"requestorIDIsNil,omitempty"`
	RequestorIDNotNil       *bool    `json:"requestorIDNotNil,omitempty"`
	RequestorIDEqualFold    *string  `json:"requestorIDEqualFold,omitempty"`
	RequestorIDContainsFold *string  `json:"requestorIDContainsFold,omitempty"`
	// ownership_transfer field predicates
	OwnershipTransfer       *bool `json:"ownershipTransfer,omitempty"`
	OwnershipTransferNeq    *bool `json:"ownershipTransferNEQ,omitempty"`
	OwnershipTransferIsNil  *bool `json:"ownershipTransferIsNil,omitempty"`
	OwnershipTransferNotNil *bool `json:"ownershipTransferNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
}

type JobResult struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the job this result belongs to
	ScheduledJobID string `json:"scheduledJobID"`
	// the status of this job. did it fail? did it succeed?
	Status enums.JobExecutionStatus `json:"status"`
	// the exit code from the script that was executed
	ExitCode int64 `json:"exitCode"`
	// The time the job finished it's execution. This is different from the db insertion time
	FinishedAt time.Time `json:"finishedAt"`
	// The time the job started it's execution. This is different from the db insertion time
	StartedAt time.Time `json:"startedAt"`
	FileID    string    `json:"fileID"`
	// the log output from the job
	Log          *string       `json:"log,omitempty"`
	Owner        *Organization `json:"owner,omitempty"`
	ScheduledJob *ScheduledJob `json:"scheduledJob"`
	File         *File         `json:"file"`
}

func (JobResult) IsNode() {}

// A connection to a list of items.
type JobResultConnection struct {
	// A list of edges.
	Edges []*JobResultEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createJobResult mutation
type JobResultCreatePayload struct {
	// Created jobResult
	JobResult *JobResult `json:"jobResult"`
}

// Return response for deleteJobResult mutation
type JobResultDeletePayload struct {
	// Deleted jobResult ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type JobResultEdge struct {
	// The item at the end of the edge.
	Node *JobResult `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for JobResult connections
type JobResultOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order JobResults.
	Field JobResultOrderField `json:"field"`
}

// Return response for updateJobResult mutation
type JobResultUpdatePayload struct {
	// Updated jobResult
	JobResult *JobResult `json:"jobResult"`
}

// JobResultWhereInput is used for filtering JobResult objects.
// Input was generated by ent.
type JobResultWhereInput struct {
	Not *JobResultWhereInput   `json:"not,omitempty"`
	And []*JobResultWhereInput `json:"and,omitempty"`
	Or  []*JobResultWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// scheduled_job_id field predicates
	ScheduledJobID             *string  `json:"scheduledJobID,omitempty"`
	ScheduledJobIdneq          *string  `json:"scheduledJobIDNEQ,omitempty"`
	ScheduledJobIDIn           []string `json:"scheduledJobIDIn,omitempty"`
	ScheduledJobIDNotIn        []string `json:"scheduledJobIDNotIn,omitempty"`
	ScheduledJobIdgt           *string  `json:"scheduledJobIDGT,omitempty"`
	ScheduledJobIdgte          *string  `json:"scheduledJobIDGTE,omitempty"`
	ScheduledJobIdlt           *string  `json:"scheduledJobIDLT,omitempty"`
	ScheduledJobIdlte          *string  `json:"scheduledJobIDLTE,omitempty"`
	ScheduledJobIDContains     *string  `json:"scheduledJobIDContains,omitempty"`
	ScheduledJobIDHasPrefix    *string  `json:"scheduledJobIDHasPrefix,omitempty"`
	ScheduledJobIDHasSuffix    *string  `json:"scheduledJobIDHasSuffix,omitempty"`
	ScheduledJobIDEqualFold    *string  `json:"scheduledJobIDEqualFold,omitempty"`
	ScheduledJobIDContainsFold *string  `json:"scheduledJobIDContainsFold,omitempty"`
	// status field predicates
	Status      *enums.JobExecutionStatus  `json:"status,omitempty"`
	StatusNeq   *enums.JobExecutionStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.JobExecutionStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.JobExecutionStatus `json:"statusNotIn,omitempty"`
	// exit_code field predicates
	ExitCode      *int64  `json:"exitCode,omitempty"`
	ExitCodeNeq   *int64  `json:"exitCodeNEQ,omitempty"`
	ExitCodeIn    []int64 `json:"exitCodeIn,omitempty"`
	ExitCodeNotIn []int64 `json:"exitCodeNotIn,omitempty"`
	ExitCodeGt    *int64  `json:"exitCodeGT,omitempty"`
	ExitCodeGte   *int64  `json:"exitCodeGTE,omitempty"`
	ExitCodeLt    *int64  `json:"exitCodeLT,omitempty"`
	ExitCodeLte   *int64  `json:"exitCodeLTE,omitempty"`
	// finished_at field predicates
	FinishedAt      *time.Time   `json:"finishedAt,omitempty"`
	FinishedAtNeq   *time.Time   `json:"finishedAtNEQ,omitempty"`
	FinishedAtIn    []*time.Time `json:"finishedAtIn,omitempty"`
	FinishedAtNotIn []*time.Time `json:"finishedAtNotIn,omitempty"`
	FinishedAtGt    *time.Time   `json:"finishedAtGT,omitempty"`
	FinishedAtGte   *time.Time   `json:"finishedAtGTE,omitempty"`
	FinishedAtLt    *time.Time   `json:"finishedAtLT,omitempty"`
	FinishedAtLte   *time.Time   `json:"finishedAtLTE,omitempty"`
	// started_at field predicates
	StartedAt      *time.Time   `json:"startedAt,omitempty"`
	StartedAtNeq   *time.Time   `json:"startedAtNEQ,omitempty"`
	StartedAtIn    []*time.Time `json:"startedAtIn,omitempty"`
	StartedAtNotIn []*time.Time `json:"startedAtNotIn,omitempty"`
	StartedAtGt    *time.Time   `json:"startedAtGT,omitempty"`
	StartedAtGte   *time.Time   `json:"startedAtGTE,omitempty"`
	StartedAtLt    *time.Time   `json:"startedAtLT,omitempty"`
	StartedAtLte   *time.Time   `json:"startedAtLTE,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// log field predicates
	Log             *string  `json:"log,omitempty"`
	LogNeq          *string  `json:"logNEQ,omitempty"`
	LogIn           []string `json:"logIn,omitempty"`
	LogNotIn        []string `json:"logNotIn,omitempty"`
	LogGt           *string  `json:"logGT,omitempty"`
	LogGte          *string  `json:"logGTE,omitempty"`
	LogLt           *string  `json:"logLT,omitempty"`
	LogLte          *string  `json:"logLTE,omitempty"`
	LogContains     *string  `json:"logContains,omitempty"`
	LogHasPrefix    *string  `json:"logHasPrefix,omitempty"`
	LogHasSuffix    *string  `json:"logHasSuffix,omitempty"`
	LogIsNil        *bool    `json:"logIsNil,omitempty"`
	LogNotNil       *bool    `json:"logNotNil,omitempty"`
	LogEqualFold    *string  `json:"logEqualFold,omitempty"`
	LogContainsFold *string  `json:"logContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// scheduled_job edge predicates
	HasScheduledJob     *bool                     `json:"hasScheduledJob,omitempty"`
	HasScheduledJobWith []*ScheduledJobWhereInput `json:"hasScheduledJobWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

type JobRunner struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the runner
	Name string `json:"name"`
	// the status of this runner
	Status enums.JobRunnerStatus `json:"status"`
	// the IP address of this runner
	IPAddress *string `json:"ipAddress,omitempty"`
	// the last time this runner was seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the version of the runner
	Version *string `json:"version,omitempty"`
	// the operating system of the runner
	Os              *string                   `json:"os,omitempty"`
	Owner           *Organization             `json:"owner,omitempty"`
	JobRunnerTokens *JobRunnerTokenConnection `json:"jobRunnerTokens"`
}

func (JobRunner) IsNode() {}

// A connection to a list of items.
type JobRunnerConnection struct {
	// A list of edges.
	Edges []*JobRunnerEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createJobRunner mutation
type JobRunnerCreatePayload struct {
	// Created jobRunner
	JobRunner *JobRunner `json:"jobRunner"`
}

// Return response for deleteJobRunner mutation
type JobRunnerDeletePayload struct {
	// Deleted jobRunner ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type JobRunnerEdge struct {
	// The item at the end of the edge.
	Node *JobRunner `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for JobRunner connections
type JobRunnerOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order JobRunners.
	Field JobRunnerOrderField `json:"field"`
}

type JobRunnerRegistrationToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	Token   string  `json:"token"`
	// when the token expires
	ExpiresAt  time.Time  `json:"expiresAt"`
	LastUsedAt *time.Time `json:"lastUsedAt,omitempty"`
	// the ID of the runner this token was used to register
	JobRunnerID *string       `json:"jobRunnerID,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	JobRunner   *JobRunner    `json:"jobRunner,omitempty"`
}

func (JobRunnerRegistrationToken) IsNode() {}

// Return response for createBulkJobRunnerRegistrationToken mutation
type JobRunnerRegistrationTokenBulkCreatePayload struct {
	// Created jobRunnerRegistrationTokens
	JobRunnerRegistrationTokens []*JobRunnerRegistrationToken `json:"jobRunnerRegistrationTokens,omitempty"`
}

// A connection to a list of items.
type JobRunnerRegistrationTokenConnection struct {
	// A list of edges.
	Edges []*JobRunnerRegistrationTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createJobRunnerRegistrationToken mutation
type JobRunnerRegistrationTokenCreatePayload struct {
	// Created jobRunnerRegistrationToken
	JobRunnerRegistrationToken *JobRunnerRegistrationToken `json:"jobRunnerRegistrationToken"`
}

// Return response for deleteJobRunnerRegistrationToken mutation
type JobRunnerRegistrationTokenDeletePayload struct {
	// Deleted jobRunnerRegistrationToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type JobRunnerRegistrationTokenEdge struct {
	// The item at the end of the edge.
	Node *JobRunnerRegistrationToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for JobRunnerRegistrationToken connections
type JobRunnerRegistrationTokenOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order JobRunnerRegistrationTokens.
	Field JobRunnerRegistrationTokenOrderField `json:"field"`
}

// JobRunnerRegistrationTokenWhereInput is used for filtering JobRunnerRegistrationToken objects.
// Input was generated by ent.
type JobRunnerRegistrationTokenWhereInput struct {
	Not *JobRunnerRegistrationTokenWhereInput   `json:"not,omitempty"`
	And []*JobRunnerRegistrationTokenWhereInput `json:"and,omitempty"`
	Or  []*JobRunnerRegistrationTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// job_runner_id field predicates
	JobRunnerID             *string  `json:"jobRunnerID,omitempty"`
	JobRunnerIdneq          *string  `json:"jobRunnerIDNEQ,omitempty"`
	JobRunnerIDIn           []string `json:"jobRunnerIDIn,omitempty"`
	JobRunnerIDNotIn        []string `json:"jobRunnerIDNotIn,omitempty"`
	JobRunnerIdgt           *string  `json:"jobRunnerIDGT,omitempty"`
	JobRunnerIdgte          *string  `json:"jobRunnerIDGTE,omitempty"`
	JobRunnerIdlt           *string  `json:"jobRunnerIDLT,omitempty"`
	JobRunnerIdlte          *string  `json:"jobRunnerIDLTE,omitempty"`
	JobRunnerIDContains     *string  `json:"jobRunnerIDContains,omitempty"`
	JobRunnerIDHasPrefix    *string  `json:"jobRunnerIDHasPrefix,omitempty"`
	JobRunnerIDHasSuffix    *string  `json:"jobRunnerIDHasSuffix,omitempty"`
	JobRunnerIDIsNil        *bool    `json:"jobRunnerIDIsNil,omitempty"`
	JobRunnerIDNotNil       *bool    `json:"jobRunnerIDNotNil,omitempty"`
	JobRunnerIDEqualFold    *string  `json:"jobRunnerIDEqualFold,omitempty"`
	JobRunnerIDContainsFold *string  `json:"jobRunnerIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// job_runner edge predicates
	HasJobRunner     *bool                  `json:"hasJobRunner,omitempty"`
	HasJobRunnerWith []*JobRunnerWhereInput `json:"hasJobRunnerWith,omitempty"`
}

type JobRunnerToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	Token   string  `json:"token"`
	// when the token expires
	ExpiresAt  *time.Time `json:"expiresAt,omitempty"`
	LastUsedAt *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt  *time.Time           `json:"revokedAt,omitempty"`
	Owner      *Organization        `json:"owner,omitempty"`
	JobRunners *JobRunnerConnection `json:"jobRunners"`
}

func (JobRunnerToken) IsNode() {}

// A connection to a list of items.
type JobRunnerTokenConnection struct {
	// A list of edges.
	Edges []*JobRunnerTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createJobRunnerToken mutation
type JobRunnerTokenCreatePayload struct {
	// Created jobRunnerToken
	JobRunnerToken *JobRunnerToken `json:"jobRunnerToken"`
}

// Return response for deleteJobRunnerToken mutation
type JobRunnerTokenDeletePayload struct {
	// Deleted jobRunnerToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type JobRunnerTokenEdge struct {
	// The item at the end of the edge.
	Node *JobRunnerToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for JobRunnerToken connections
type JobRunnerTokenOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order JobRunnerTokens.
	Field JobRunnerTokenOrderField `json:"field"`
}

// Return response for updateJobRunnerToken mutation
type JobRunnerTokenUpdatePayload struct {
	// Updated jobRunnerToken
	JobRunnerToken *JobRunnerToken `json:"jobRunnerToken"`
}

// JobRunnerTokenWhereInput is used for filtering JobRunnerToken objects.
// Input was generated by ent.
type JobRunnerTokenWhereInput struct {
	Not *JobRunnerTokenWhereInput   `json:"not,omitempty"`
	And []*JobRunnerTokenWhereInput `json:"and,omitempty"`
	Or  []*JobRunnerTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// is_active field predicates
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNeq    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  *bool `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil *bool `json:"isActiveNotNil,omitempty"`
	// revoked_reason field predicates
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNeq          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGt           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGte          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLt           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLte          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        *bool    `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       *bool    `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`
	// revoked_by field predicates
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNeq          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGt           *string  `json:"revokedByGT,omitempty"`
	RevokedByGte          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLt           *string  `json:"revokedByLT,omitempty"`
	RevokedByLte          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        *bool    `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       *bool    `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`
	// revoked_at field predicates
	RevokedAt       *time.Time   `json:"revokedAt,omitempty"`
	RevokedAtNeq    *time.Time   `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []*time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []*time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGt     *time.Time   `json:"revokedAtGT,omitempty"`
	RevokedAtGte    *time.Time   `json:"revokedAtGTE,omitempty"`
	RevokedAtLt     *time.Time   `json:"revokedAtLT,omitempty"`
	RevokedAtLte    *time.Time   `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  *bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil *bool        `json:"revokedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// job_runners edge predicates
	HasJobRunners     *bool                  `json:"hasJobRunners,omitempty"`
	HasJobRunnersWith []*JobRunnerWhereInput `json:"hasJobRunnersWith,omitempty"`
}

// Return response for updateJobRunner mutation
type JobRunnerUpdatePayload struct {
	// Updated jobRunner
	JobRunner *JobRunner `json:"jobRunner"`
}

// JobRunnerWhereInput is used for filtering JobRunner objects.
// Input was generated by ent.
type JobRunnerWhereInput struct {
	Not *JobRunnerWhereInput   `json:"not,omitempty"`
	And []*JobRunnerWhereInput `json:"and,omitempty"`
	Or  []*JobRunnerWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status      *enums.JobRunnerStatus  `json:"status,omitempty"`
	StatusNeq   *enums.JobRunnerStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.JobRunnerStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.JobRunnerStatus `json:"statusNotIn,omitempty"`
	// ip_address field predicates
	IPAddress             *string  `json:"ipAddress,omitempty"`
	IPAddressNeq          *string  `json:"ipAddressNEQ,omitempty"`
	IPAddressIn           []string `json:"ipAddressIn,omitempty"`
	IPAddressNotIn        []string `json:"ipAddressNotIn,omitempty"`
	IPAddressGt           *string  `json:"ipAddressGT,omitempty"`
	IPAddressGte          *string  `json:"ipAddressGTE,omitempty"`
	IPAddressLt           *string  `json:"ipAddressLT,omitempty"`
	IPAddressLte          *string  `json:"ipAddressLTE,omitempty"`
	IPAddressContains     *string  `json:"ipAddressContains,omitempty"`
	IPAddressHasPrefix    *string  `json:"ipAddressHasPrefix,omitempty"`
	IPAddressHasSuffix    *string  `json:"ipAddressHasSuffix,omitempty"`
	IPAddressIsNil        *bool    `json:"ipAddressIsNil,omitempty"`
	IPAddressNotNil       *bool    `json:"ipAddressNotNil,omitempty"`
	IPAddressEqualFold    *string  `json:"ipAddressEqualFold,omitempty"`
	IPAddressContainsFold *string  `json:"ipAddressContainsFold,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// os field predicates
	Os             *string  `json:"os,omitempty"`
	OsNeq          *string  `json:"osNEQ,omitempty"`
	OsIn           []string `json:"osIn,omitempty"`
	OsNotIn        []string `json:"osNotIn,omitempty"`
	OsGt           *string  `json:"osGT,omitempty"`
	OsGte          *string  `json:"osGTE,omitempty"`
	OsLt           *string  `json:"osLT,omitempty"`
	OsLte          *string  `json:"osLTE,omitempty"`
	OsContains     *string  `json:"osContains,omitempty"`
	OsHasPrefix    *string  `json:"osHasPrefix,omitempty"`
	OsHasSuffix    *string  `json:"osHasSuffix,omitempty"`
	OsIsNil        *bool    `json:"osIsNil,omitempty"`
	OsNotNil       *bool    `json:"osNotNil,omitempty"`
	OsEqualFold    *string  `json:"osEqualFold,omitempty"`
	OsContainsFold *string  `json:"osContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// job_runner_tokens edge predicates
	HasJobRunnerTokens     *bool                       `json:"hasJobRunnerTokens,omitempty"`
	HasJobRunnerTokensWith []*JobRunnerTokenWhereInput `json:"hasJobRunnerTokensWith,omitempty"`
}

type JobTemplate struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the title of the job
	Title string `json:"title"`
	// the short description of the job and what it does
	Description *string `json:"description,omitempty"`
	// the platform to use to execute this job, e.g. golang, typescript, python, etc.
	Platform enums.JobPlatformType `json:"platform"`
	// the url from where to download the script from
	DownloadURL string `json:"downloadURL"`
	// the json configuration to run this job, which could be used to template a job, e.g. { "account_name": "my-account" }
	Configuration models.JobConfiguration `json:"configuration,omitempty"`
	// cron schedule to run the job in cron 6-field syntax, e.g. 0 0 0 * * *
	Cron          *string                 `json:"cron,omitempty"`
	Owner         *Organization           `json:"owner,omitempty"`
	ScheduledJobs *ScheduledJobConnection `json:"scheduledJobs"`
}

func (JobTemplate) IsNode() {}

// Return response for createBulkJobTemplate mutation
type JobTemplateBulkCreatePayload struct {
	// Created jobTemplates
	JobTemplates []*JobTemplate `json:"jobTemplates,omitempty"`
}

// Return response for deleteBulkJobTemplate mutation
type JobTemplateBulkDeletePayload struct {
	// Deleted jobTemplate IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type JobTemplateConnection struct {
	// A list of edges.
	Edges []*JobTemplateEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createJobTemplate mutation
type JobTemplateCreatePayload struct {
	// Created jobTemplate
	JobTemplate *JobTemplate `json:"jobTemplate"`
}

// Return response for deleteJobTemplate mutation
type JobTemplateDeletePayload struct {
	// Deleted jobTemplate ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type JobTemplateEdge struct {
	// The item at the end of the edge.
	Node *JobTemplate `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type JobTemplateHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the title of the job
	Title string `json:"title"`
	// the short description of the job and what it does
	Description *string `json:"description,omitempty"`
	// the platform to use to execute this job, e.g. golang, typescript, python, etc.
	Platform enums.JobPlatformType `json:"platform"`
	// the url from where to download the script from
	DownloadURL string `json:"downloadURL"`
	// the json configuration to run this job, which could be used to template a job, e.g. { "account_name": "my-account" }
	Configuration models.JobConfiguration `json:"configuration,omitempty"`
	// cron schedule to run the job in cron 6-field syntax, e.g. 0 0 0 * * *
	Cron *string `json:"cron,omitempty"`
}

func (JobTemplateHistory) IsNode() {}

// A connection to a list of items.
type JobTemplateHistoryConnection struct {
	// A list of edges.
	Edges []*JobTemplateHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type JobTemplateHistoryEdge struct {
	// The item at the end of the edge.
	Node *JobTemplateHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for JobTemplateHistory connections
type JobTemplateHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order JobTemplateHistories.
	Field JobTemplateHistoryOrderField `json:"field"`
}

// JobTemplateHistoryWhereInput is used for filtering JobTemplateHistory objects.
// Input was generated by ent.
type JobTemplateHistoryWhereInput struct {
	Not *JobTemplateHistoryWhereInput   `json:"not,omitempty"`
	And []*JobTemplateHistoryWhereInput `json:"and,omitempty"`
	Or  []*JobTemplateHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// platform field predicates
	Platform      *enums.JobPlatformType  `json:"platform,omitempty"`
	PlatformNeq   *enums.JobPlatformType  `json:"platformNEQ,omitempty"`
	PlatformIn    []enums.JobPlatformType `json:"platformIn,omitempty"`
	PlatformNotIn []enums.JobPlatformType `json:"platformNotIn,omitempty"`
}

// Ordering options for JobTemplate connections
type JobTemplateOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order JobTemplates.
	Field JobTemplateOrderField `json:"field"`
}

// Return response for updateJobTemplate mutation
type JobTemplateUpdatePayload struct {
	// Updated jobTemplate
	JobTemplate *JobTemplate `json:"jobTemplate"`
}

// JobTemplateWhereInput is used for filtering JobTemplate objects.
// Input was generated by ent.
type JobTemplateWhereInput struct {
	Not *JobTemplateWhereInput   `json:"not,omitempty"`
	And []*JobTemplateWhereInput `json:"and,omitempty"`
	Or  []*JobTemplateWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// platform field predicates
	Platform      *enums.JobPlatformType  `json:"platform,omitempty"`
	PlatformNeq   *enums.JobPlatformType  `json:"platformNEQ,omitempty"`
	PlatformIn    []enums.JobPlatformType `json:"platformIn,omitempty"`
	PlatformNotIn []enums.JobPlatformType `json:"platformNotIn,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// scheduled_jobs edge predicates
	HasScheduledJobs     *bool                     `json:"hasScheduledJobs,omitempty"`
	HasScheduledJobsWith []*ScheduledJobWhereInput `json:"hasScheduledJobsWith,omitempty"`
}

type MappableDomain struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// Name of the mappable domain
	Name string `json:"name"`
	// DNS Zone ID of the mappable domain.
	ZoneID        string                  `json:"zoneID"`
	CustomDomains *CustomDomainConnection `json:"customDomains"`
}

func (MappableDomain) IsNode() {}

// Return response for createBulkMappableDomain mutation
type MappableDomainBulkCreatePayload struct {
	// Created mappableDomains
	MappableDomains []*MappableDomain `json:"mappableDomains,omitempty"`
}

// Return response for deleteBulkMappableDomain mutation
type MappableDomainBulkDeletePayload struct {
	// Deleted mappableDomain IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type MappableDomainConnection struct {
	// A list of edges.
	Edges []*MappableDomainEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createMappableDomain mutation
type MappableDomainCreatePayload struct {
	// Created mappableDomain
	MappableDomain *MappableDomain `json:"mappableDomain"`
}

// Return response for deleteMappableDomain mutation
type MappableDomainDeletePayload struct {
	// Deleted mappableDomain ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type MappableDomainEdge struct {
	// The item at the end of the edge.
	Node *MappableDomain `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type MappableDomainHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// Name of the mappable domain
	Name string `json:"name"`
	// DNS Zone ID of the mappable domain.
	ZoneID string `json:"zoneID"`
}

func (MappableDomainHistory) IsNode() {}

// A connection to a list of items.
type MappableDomainHistoryConnection struct {
	// A list of edges.
	Edges []*MappableDomainHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type MappableDomainHistoryEdge struct {
	// The item at the end of the edge.
	Node *MappableDomainHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for MappableDomainHistory connections
type MappableDomainHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order MappableDomainHistories.
	Field MappableDomainHistoryOrderField `json:"field"`
}

// MappableDomainHistoryWhereInput is used for filtering MappableDomainHistory objects.
// Input was generated by ent.
type MappableDomainHistoryWhereInput struct {
	Not *MappableDomainHistoryWhereInput   `json:"not,omitempty"`
	And []*MappableDomainHistoryWhereInput `json:"and,omitempty"`
	Or  []*MappableDomainHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// zone_id field predicates
	ZoneID             *string  `json:"zoneID,omitempty"`
	ZoneIdneq          *string  `json:"zoneIDNEQ,omitempty"`
	ZoneIDIn           []string `json:"zoneIDIn,omitempty"`
	ZoneIDNotIn        []string `json:"zoneIDNotIn,omitempty"`
	ZoneIdgt           *string  `json:"zoneIDGT,omitempty"`
	ZoneIdgte          *string  `json:"zoneIDGTE,omitempty"`
	ZoneIdlt           *string  `json:"zoneIDLT,omitempty"`
	ZoneIdlte          *string  `json:"zoneIDLTE,omitempty"`
	ZoneIDContains     *string  `json:"zoneIDContains,omitempty"`
	ZoneIDHasPrefix    *string  `json:"zoneIDHasPrefix,omitempty"`
	ZoneIDHasSuffix    *string  `json:"zoneIDHasSuffix,omitempty"`
	ZoneIDEqualFold    *string  `json:"zoneIDEqualFold,omitempty"`
	ZoneIDContainsFold *string  `json:"zoneIDContainsFold,omitempty"`
}

// Ordering options for MappableDomain connections
type MappableDomainOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order MappableDomains.
	Field MappableDomainOrderField `json:"field"`
}

// Return response for updateMappableDomain mutation
type MappableDomainUpdatePayload struct {
	// Updated mappableDomain
	MappableDomain *MappableDomain `json:"mappableDomain"`
}

// MappableDomainWhereInput is used for filtering MappableDomain objects.
// Input was generated by ent.
type MappableDomainWhereInput struct {
	Not *MappableDomainWhereInput   `json:"not,omitempty"`
	And []*MappableDomainWhereInput `json:"and,omitempty"`
	Or  []*MappableDomainWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// zone_id field predicates
	ZoneID             *string  `json:"zoneID,omitempty"`
	ZoneIdneq          *string  `json:"zoneIDNEQ,omitempty"`
	ZoneIDIn           []string `json:"zoneIDIn,omitempty"`
	ZoneIDNotIn        []string `json:"zoneIDNotIn,omitempty"`
	ZoneIdgt           *string  `json:"zoneIDGT,omitempty"`
	ZoneIdgte          *string  `json:"zoneIDGTE,omitempty"`
	ZoneIdlt           *string  `json:"zoneIDLT,omitempty"`
	ZoneIdlte          *string  `json:"zoneIDLTE,omitempty"`
	ZoneIDContains     *string  `json:"zoneIDContains,omitempty"`
	ZoneIDHasPrefix    *string  `json:"zoneIDHasPrefix,omitempty"`
	ZoneIDHasSuffix    *string  `json:"zoneIDHasSuffix,omitempty"`
	ZoneIDEqualFold    *string  `json:"zoneIDEqualFold,omitempty"`
	ZoneIDContainsFold *string  `json:"zoneIDContainsFold,omitempty"`
	// custom_domains edge predicates
	HasCustomDomains     *bool                     `json:"hasCustomDomains,omitempty"`
	HasCustomDomainsWith []*CustomDomainWhereInput `json:"hasCustomDomainsWith,omitempty"`
}

type MappedControl struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType enums.MappingType `json:"mappingType"`
	// description of how the two controls are related
	Relation *string `json:"relation,omitempty"`
	// percentage (0-100) of confidence in the mapping
	Confidence *int64 `json:"confidence,omitempty"`
	// source of the mapping, e.g. manual, suggested, etc.
	Source          *enums.MappingSource  `json:"source,omitempty"`
	Owner           *Organization         `json:"owner,omitempty"`
	BlockedGroups   *GroupConnection      `json:"blockedGroups"`
	Editors         *GroupConnection      `json:"editors"`
	FromControls    *ControlConnection    `json:"fromControls"`
	ToControls      *ControlConnection    `json:"toControls"`
	FromSubcontrols *SubcontrolConnection `json:"fromSubcontrols"`
	ToSubcontrols   *SubcontrolConnection `json:"toSubcontrols"`
}

func (MappedControl) IsNode() {}

// Return response for createBulkMappedControl mutation
type MappedControlBulkCreatePayload struct {
	// Created mappedControls
	MappedControls []*MappedControl `json:"mappedControls,omitempty"`
}

// Return response for deleteBulkMappedControl mutation
type MappedControlBulkDeletePayload struct {
	// Deleted mappedControl IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type MappedControlConnection struct {
	// A list of edges.
	Edges []*MappedControlEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createMappedControl mutation
type MappedControlCreatePayload struct {
	// Created mappedControl
	MappedControl *MappedControl `json:"mappedControl"`
}

// Return response for deleteMappedControl mutation
type MappedControlDeletePayload struct {
	// Deleted mappedControl ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type MappedControlEdge struct {
	// The item at the end of the edge.
	Node *MappedControl `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type MappedControlHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType enums.MappingType `json:"mappingType"`
	// description of how the two controls are related
	Relation *string `json:"relation,omitempty"`
	// percentage (0-100) of confidence in the mapping
	Confidence *int64 `json:"confidence,omitempty"`
	// source of the mapping, e.g. manual, suggested, etc.
	Source *enums.MappingSource `json:"source,omitempty"`
}

func (MappedControlHistory) IsNode() {}

// A connection to a list of items.
type MappedControlHistoryConnection struct {
	// A list of edges.
	Edges []*MappedControlHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type MappedControlHistoryEdge struct {
	// The item at the end of the edge.
	Node *MappedControlHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for MappedControlHistory connections
type MappedControlHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order MappedControlHistories.
	Field MappedControlHistoryOrderField `json:"field"`
}

// MappedControlHistoryWhereInput is used for filtering MappedControlHistory objects.
// Input was generated by ent.
type MappedControlHistoryWhereInput struct {
	Not *MappedControlHistoryWhereInput   `json:"not,omitempty"`
	And []*MappedControlHistoryWhereInput `json:"and,omitempty"`
	Or  []*MappedControlHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// mapping_type field predicates
	MappingType      *enums.MappingType  `json:"mappingType,omitempty"`
	MappingTypeNeq   *enums.MappingType  `json:"mappingTypeNEQ,omitempty"`
	MappingTypeIn    []enums.MappingType `json:"mappingTypeIn,omitempty"`
	MappingTypeNotIn []enums.MappingType `json:"mappingTypeNotIn,omitempty"`
	// relation field predicates
	Relation             *string  `json:"relation,omitempty"`
	RelationNeq          *string  `json:"relationNEQ,omitempty"`
	RelationIn           []string `json:"relationIn,omitempty"`
	RelationNotIn        []string `json:"relationNotIn,omitempty"`
	RelationGt           *string  `json:"relationGT,omitempty"`
	RelationGte          *string  `json:"relationGTE,omitempty"`
	RelationLt           *string  `json:"relationLT,omitempty"`
	RelationLte          *string  `json:"relationLTE,omitempty"`
	RelationContains     *string  `json:"relationContains,omitempty"`
	RelationHasPrefix    *string  `json:"relationHasPrefix,omitempty"`
	RelationHasSuffix    *string  `json:"relationHasSuffix,omitempty"`
	RelationIsNil        *bool    `json:"relationIsNil,omitempty"`
	RelationNotNil       *bool    `json:"relationNotNil,omitempty"`
	RelationEqualFold    *string  `json:"relationEqualFold,omitempty"`
	RelationContainsFold *string  `json:"relationContainsFold,omitempty"`
	// confidence field predicates
	Confidence       *int64  `json:"confidence,omitempty"`
	ConfidenceNeq    *int64  `json:"confidenceNEQ,omitempty"`
	ConfidenceIn     []int64 `json:"confidenceIn,omitempty"`
	ConfidenceNotIn  []int64 `json:"confidenceNotIn,omitempty"`
	ConfidenceGt     *int64  `json:"confidenceGT,omitempty"`
	ConfidenceGte    *int64  `json:"confidenceGTE,omitempty"`
	ConfidenceLt     *int64  `json:"confidenceLT,omitempty"`
	ConfidenceLte    *int64  `json:"confidenceLTE,omitempty"`
	ConfidenceIsNil  *bool   `json:"confidenceIsNil,omitempty"`
	ConfidenceNotNil *bool   `json:"confidenceNotNil,omitempty"`
	// source field predicates
	Source       *enums.MappingSource  `json:"source,omitempty"`
	SourceNeq    *enums.MappingSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.MappingSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.MappingSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
}

// Ordering options for MappedControl connections
type MappedControlOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order MappedControls.
	Field MappedControlOrderField `json:"field"`
}

// Return response for updateMappedControl mutation
type MappedControlUpdatePayload struct {
	// Updated mappedControl
	MappedControl *MappedControl `json:"mappedControl"`
}

// MappedControlWhereInput is used for filtering MappedControl objects.
// Input was generated by ent.
type MappedControlWhereInput struct {
	Not *MappedControlWhereInput   `json:"not,omitempty"`
	And []*MappedControlWhereInput `json:"and,omitempty"`
	Or  []*MappedControlWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// mapping_type field predicates
	MappingType      *enums.MappingType  `json:"mappingType,omitempty"`
	MappingTypeNeq   *enums.MappingType  `json:"mappingTypeNEQ,omitempty"`
	MappingTypeIn    []enums.MappingType `json:"mappingTypeIn,omitempty"`
	MappingTypeNotIn []enums.MappingType `json:"mappingTypeNotIn,omitempty"`
	// relation field predicates
	Relation             *string  `json:"relation,omitempty"`
	RelationNeq          *string  `json:"relationNEQ,omitempty"`
	RelationIn           []string `json:"relationIn,omitempty"`
	RelationNotIn        []string `json:"relationNotIn,omitempty"`
	RelationGt           *string  `json:"relationGT,omitempty"`
	RelationGte          *string  `json:"relationGTE,omitempty"`
	RelationLt           *string  `json:"relationLT,omitempty"`
	RelationLte          *string  `json:"relationLTE,omitempty"`
	RelationContains     *string  `json:"relationContains,omitempty"`
	RelationHasPrefix    *string  `json:"relationHasPrefix,omitempty"`
	RelationHasSuffix    *string  `json:"relationHasSuffix,omitempty"`
	RelationIsNil        *bool    `json:"relationIsNil,omitempty"`
	RelationNotNil       *bool    `json:"relationNotNil,omitempty"`
	RelationEqualFold    *string  `json:"relationEqualFold,omitempty"`
	RelationContainsFold *string  `json:"relationContainsFold,omitempty"`
	// confidence field predicates
	Confidence       *int64  `json:"confidence,omitempty"`
	ConfidenceNeq    *int64  `json:"confidenceNEQ,omitempty"`
	ConfidenceIn     []int64 `json:"confidenceIn,omitempty"`
	ConfidenceNotIn  []int64 `json:"confidenceNotIn,omitempty"`
	ConfidenceGt     *int64  `json:"confidenceGT,omitempty"`
	ConfidenceGte    *int64  `json:"confidenceGTE,omitempty"`
	ConfidenceLt     *int64  `json:"confidenceLT,omitempty"`
	ConfidenceLte    *int64  `json:"confidenceLTE,omitempty"`
	ConfidenceIsNil  *bool   `json:"confidenceIsNil,omitempty"`
	ConfidenceNotNil *bool   `json:"confidenceNotNil,omitempty"`
	// source field predicates
	Source       *enums.MappingSource  `json:"source,omitempty"`
	SourceNeq    *enums.MappingSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.MappingSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.MappingSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// from_controls edge predicates
	HasFromControls     *bool                `json:"hasFromControls,omitempty"`
	HasFromControlsWith []*ControlWhereInput `json:"hasFromControlsWith,omitempty"`
	// to_controls edge predicates
	HasToControls     *bool                `json:"hasToControls,omitempty"`
	HasToControlsWith []*ControlWhereInput `json:"hasToControlsWith,omitempty"`
	// from_subcontrols edge predicates
	HasFromSubcontrols     *bool                   `json:"hasFromSubcontrols,omitempty"`
	HasFromSubcontrolsWith []*SubcontrolWhereInput `json:"hasFromSubcontrolsWith,omitempty"`
	// to_subcontrols edge predicates
	HasToSubcontrols     *bool                   `json:"hasToSubcontrols,omitempty"`
	HasToSubcontrolsWith []*SubcontrolWhereInput `json:"hasToSubcontrolsWith,omitempty"`
}

type Mutation struct {
}

type Narrative struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details          *string                   `json:"details,omitempty"`
	Owner            *Organization             `json:"owner,omitempty"`
	BlockedGroups    *GroupConnection          `json:"blockedGroups"`
	Editors          *GroupConnection          `json:"editors"`
	Viewers          *GroupConnection          `json:"viewers"`
	Satisfies        *ControlConnection        `json:"satisfies"`
	Programs         *ProgramConnection        `json:"programs"`
	InternalPolicies *InternalPolicyConnection `json:"internalPolicies"`
	Procedures       *ProcedureConnection      `json:"procedures"`
}

func (Narrative) IsNode() {}

// Return response for createBulkNarrative mutation
type NarrativeBulkCreatePayload struct {
	// Created narratives
	Narratives []*Narrative `json:"narratives,omitempty"`
}

// Return response for deleteBulkNarrative mutation
type NarrativeBulkDeletePayload struct {
	// Deleted narrative IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type NarrativeConnection struct {
	// A list of edges.
	Edges []*NarrativeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createNarrative mutation
type NarrativeCreatePayload struct {
	// Created narrative
	Narrative *Narrative `json:"narrative"`
}

// Return response for deleteNarrative mutation
type NarrativeDeletePayload struct {
	// Deleted narrative ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type NarrativeEdge struct {
	// The item at the end of the edge.
	Node *Narrative `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NarrativeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details *string `json:"details,omitempty"`
}

func (NarrativeHistory) IsNode() {}

// A connection to a list of items.
type NarrativeHistoryConnection struct {
	// A list of edges.
	Edges []*NarrativeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NarrativeHistoryEdge struct {
	// The item at the end of the edge.
	Node *NarrativeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for NarrativeHistory connections
type NarrativeHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order NarrativeHistories.
	Field NarrativeHistoryOrderField `json:"field"`
}

// NarrativeHistoryWhereInput is used for filtering NarrativeHistory objects.
// Input was generated by ent.
type NarrativeHistoryWhereInput struct {
	Not *NarrativeHistoryWhereInput   `json:"not,omitempty"`
	And []*NarrativeHistoryWhereInput `json:"and,omitempty"`
	Or  []*NarrativeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
}

// Ordering options for Narrative connections
type NarrativeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Narratives.
	Field NarrativeOrderField `json:"field"`
}

// Return response for updateNarrative mutation
type NarrativeUpdatePayload struct {
	// Updated narrative
	Narrative *Narrative `json:"narrative"`
}

// NarrativeWhereInput is used for filtering Narrative objects.
// Input was generated by ent.
type NarrativeWhereInput struct {
	Not *NarrativeWhereInput   `json:"not,omitempty"`
	And []*NarrativeWhereInput `json:"and,omitempty"`
	Or  []*NarrativeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// satisfies edge predicates
	HasSatisfies     *bool                `json:"hasSatisfies,omitempty"`
	HasSatisfiesWith []*ControlWhereInput `json:"hasSatisfiesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
}

type Note struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text           string          `json:"text"`
	Owner          *Organization   `json:"owner,omitempty"`
	Task           *Task           `json:"task,omitempty"`
	Control        *Control        `json:"control,omitempty"`
	Subcontrol     *Subcontrol     `json:"subcontrol,omitempty"`
	Procedure      *Procedure      `json:"procedure,omitempty"`
	Risk           *Risk           `json:"risk,omitempty"`
	InternalPolicy *InternalPolicy `json:"internalPolicy,omitempty"`
	Evidence       *Evidence       `json:"evidence,omitempty"`
	TrustCenter    *TrustCenter    `json:"trustCenter,omitempty"`
	Files          *FileConnection `json:"files"`
}

func (Note) IsNode() {}

// A connection to a list of items.
type NoteConnection struct {
	// A list of edges.
	Edges []*NoteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for deleteComment mutation
type NoteDeletePayload struct {
	// Deleted comment ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type NoteEdge struct {
	// The item at the end of the edge.
	Node *Note `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NoteHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text string `json:"text"`
}

func (NoteHistory) IsNode() {}

// A connection to a list of items.
type NoteHistoryConnection struct {
	// A list of edges.
	Edges []*NoteHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteHistoryEdge struct {
	// The item at the end of the edge.
	Node *NoteHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for NoteHistory connections
type NoteHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order NoteHistories.
	Field NoteHistoryOrderField `json:"field"`
}

// NoteHistoryWhereInput is used for filtering NoteHistory objects.
// Input was generated by ent.
type NoteHistoryWhereInput struct {
	Not *NoteHistoryWhereInput   `json:"not,omitempty"`
	And []*NoteHistoryWhereInput `json:"and,omitempty"`
	Or  []*NoteHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
}

// Ordering options for Note connections
type NoteOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Notes.
	Field NoteOrderField `json:"field"`
}

// NoteWhereInput is used for filtering Note objects.
// Input was generated by ent.
type NoteWhereInput struct {
	Not *NoteWhereInput   `json:"not,omitempty"`
	And []*NoteWhereInput `json:"and,omitempty"`
	Or  []*NoteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// task edge predicates
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// subcontrol edge predicates
	HasSubcontrol     *bool                   `json:"hasSubcontrol,omitempty"`
	HasSubcontrolWith []*SubcontrolWhereInput `json:"hasSubcontrolWith,omitempty"`
	// procedure edge predicates
	HasProcedure     *bool                  `json:"hasProcedure,omitempty"`
	HasProcedureWith []*ProcedureWhereInput `json:"hasProcedureWith,omitempty"`
	// risk edge predicates
	HasRisk     *bool             `json:"hasRisk,omitempty"`
	HasRiskWith []*RiskWhereInput `json:"hasRiskWith,omitempty"`
	// internal_policy edge predicates
	HasInternalPolicy     *bool                       `json:"hasInternalPolicy,omitempty"`
	HasInternalPolicyWith []*InternalPolicyWhereInput `json:"hasInternalPolicyWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// trust_center edge predicates
	HasTrustCenter     *bool                    `json:"hasTrustCenter,omitempty"`
	HasTrustCenterWith []*TrustCenterWhereInput `json:"hasTrustCenterWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Notification struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the user this notification is for
	UserID *string `json:"userID,omitempty"`
	// the type of notification - organization or user
	NotificationType enums.NotificationType `json:"notificationType"`
	// the event type this notification is related to (e.g., task.created, control.updated)
	ObjectType string `json:"objectType"`
	// the title of the notification
	Title string `json:"title"`
	// the body text of the notification
	Body string `json:"body"`
	// structured payload containing IDs, links, and other notification data
	Data map[string]any `json:"data,omitempty"`
	// the time the notification was read
	ReadAt *models.DateTime `json:"readAt,omitempty"`
	// the channels this notification should be sent to (IN_APP, SLACK, EMAIL)
	Channels []string `json:"channels,omitempty"`
	// the topic of the notification
	Topic *string       `json:"topic,omitempty"`
	Owner *Organization `json:"owner,omitempty"`
}

func (Notification) IsNode() {}

type Onboarding struct {
	ID             string  `json:"id"`
	OrganizationID *string `json:"organizationID,omitempty"`
	// name of the company
	CompanyName string `json:"companyName"`
	// domains associated with the company
	Domains []string `json:"domains,omitempty"`
	// details given about the company during the onboarding process, including things such as company size, sector, etc
	CompanyDetails map[string]any `json:"companyDetails,omitempty"`
	// details given about the user during the onboarding process, including things such as name, job title, department, etc
	UserDetails map[string]any `json:"userDetails,omitempty"`
	// details given about the compliance requirements during the onboarding process, such as coming with existing policies, controls, risk assessments, etc
	Compliance   map[string]any `json:"compliance,omitempty"`
	Organization *Organization  `json:"organization,omitempty"`
}

func (Onboarding) IsNode() {}

// Return response for createOnboarding mutation
type OnboardingCreatePayload struct {
	// Created onboarding
	Onboarding *Onboarding `json:"onboarding"`
}

// OnboardingWhereInput is used for filtering Onboarding objects.
// Input was generated by ent.
type OnboardingWhereInput struct {
	Not *OnboardingWhereInput   `json:"not,omitempty"`
	And []*OnboardingWhereInput `json:"and,omitempty"`
	Or  []*OnboardingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// company_name field predicates
	CompanyName             *string  `json:"companyName,omitempty"`
	CompanyNameNeq          *string  `json:"companyNameNEQ,omitempty"`
	CompanyNameIn           []string `json:"companyNameIn,omitempty"`
	CompanyNameNotIn        []string `json:"companyNameNotIn,omitempty"`
	CompanyNameGt           *string  `json:"companyNameGT,omitempty"`
	CompanyNameGte          *string  `json:"companyNameGTE,omitempty"`
	CompanyNameLt           *string  `json:"companyNameLT,omitempty"`
	CompanyNameLte          *string  `json:"companyNameLTE,omitempty"`
	CompanyNameContains     *string  `json:"companyNameContains,omitempty"`
	CompanyNameHasPrefix    *string  `json:"companyNameHasPrefix,omitempty"`
	CompanyNameHasSuffix    *string  `json:"companyNameHasSuffix,omitempty"`
	CompanyNameEqualFold    *string  `json:"companyNameEqualFold,omitempty"`
	CompanyNameContainsFold *string  `json:"companyNameContainsFold,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
}

// OrgMembersInput is used to create members for a organization
// along with the org creation
type OrgMembersInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

type OrgMembership struct {
	ID             string           `json:"id"`
	CreatedAt      *time.Time       `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time       `json:"updatedAt,omitempty"`
	CreatedBy      *string          `json:"createdBy,omitempty"`
	UpdatedBy      *string          `json:"updatedBy,omitempty"`
	Role           enums.Role       `json:"role"`
	OrganizationID string           `json:"organizationID"`
	UserID         string           `json:"userID"`
	Organization   *Organization    `json:"organization"`
	User           *User            `json:"user"`
	Events         *EventConnection `json:"events"`
}

func (OrgMembership) IsNode() {}

// Return response for createBulkOrgMembership mutation
type OrgMembershipBulkCreatePayload struct {
	// Created orgMemberships
	OrgMemberships []*OrgMembership `json:"orgMemberships,omitempty"`
}

// Return response for deleteBulkOrgMembership mutation
type OrgMembershipBulkDeletePayload struct {
	// Deleted orgMembership IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type OrgMembershipConnection struct {
	// A list of edges.
	Edges []*OrgMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrgMembership mutation
type OrgMembershipCreatePayload struct {
	// Created orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// Return response for deleteOrgMembership mutation
type OrgMembershipDeletePayload struct {
	// Deleted orgMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrgMembershipEdge struct {
	// The item at the end of the edge.
	Node *OrgMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrgMembershipHistory struct {
	ID             string         `json:"id"`
	HistoryTime    time.Time      `json:"historyTime"`
	Ref            *string        `json:"ref,omitempty"`
	Operation      history.OpType `json:"operation"`
	CreatedAt      *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy      *string        `json:"createdBy,omitempty"`
	UpdatedBy      *string        `json:"updatedBy,omitempty"`
	Role           enums.Role     `json:"role"`
	OrganizationID string         `json:"organizationID"`
	UserID         string         `json:"userID"`
}

func (OrgMembershipHistory) IsNode() {}

// A connection to a list of items.
type OrgMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*OrgMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrgMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrgMembershipHistory connections
type OrgMembershipHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrgMembershipHistories.
	Field OrgMembershipHistoryOrderField `json:"field"`
}

// OrgMembershipHistoryWhereInput is used for filtering OrgMembershipHistory objects.
// Input was generated by ent.
type OrgMembershipHistoryWhereInput struct {
	Not *OrgMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Ordering options for OrgMembership connections
type OrgMembershipOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrgMemberships.
	Field OrgMembershipOrderField `json:"field"`
}

// Return response for updateOrgMembership mutation
type OrgMembershipUpdatePayload struct {
	// Updated orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// OrgMembershipWhereInput is used for filtering OrgMembership objects.
// Input was generated by ent.
type OrgMembershipWhereInput struct {
	Not *OrgMembershipWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// role field predicates
	Role           *enums.Role       `json:"role,omitempty"`
	RoleNeq        *enums.Role       `json:"roleNEQ,omitempty"`
	RoleIn         []enums.Role      `json:"roleIn,omitempty"`
	RoleNotIn      []enums.Role      `json:"roleNotIn,omitempty"`
	OrganizationID *string           `json:"organizationID,omitempty"`
	UserID         *string           `json:"userID,omitempty"`
	HasUserWith    []*UserWhereInput `json:"hasUserWith,omitempty"`
}

type OrgSubscription struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the stripe subscription id
	StripeSubscriptionID *string `json:"stripeSubscriptionID,omitempty"`
	// the status of the subscription in stripe -- see https://docs.stripe.com/api/subscriptions/object#subscription_object-status
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty"`
	// indicates if the subscription is active
	Active bool `json:"active"`
	// the time the subscription is set to expire; only populated if subscription is cancelled
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// the time the trial is set to expire
	TrialExpiresAt *time.Time `json:"trialExpiresAt,omitempty"`
	// number of days until there is a due payment
	DaysUntilDue         *string          `json:"daysUntilDue,omitempty"`
	Owner                *Organization    `json:"owner,omitempty"`
	Events               *EventConnection `json:"events"`
	ManagePaymentMethods *string          `json:"managePaymentMethods,omitempty"`
}

func (OrgSubscription) IsNode() {}

// A connection to a list of items.
type OrgSubscriptionConnection struct {
	// A list of edges.
	Edges []*OrgSubscriptionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgSubscriptionEdge struct {
	// The item at the end of the edge.
	Node *OrgSubscription `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrgSubscriptionHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the stripe subscription id
	StripeSubscriptionID *string `json:"stripeSubscriptionID,omitempty"`
	// the status of the subscription in stripe -- see https://docs.stripe.com/api/subscriptions/object#subscription_object-status
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty"`
	// indicates if the subscription is active
	Active bool `json:"active"`
	// the time the subscription is set to expire; only populated if subscription is cancelled
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// the time the trial is set to expire
	TrialExpiresAt *time.Time `json:"trialExpiresAt,omitempty"`
	// number of days until there is a due payment
	DaysUntilDue *string `json:"daysUntilDue,omitempty"`
}

func (OrgSubscriptionHistory) IsNode() {}

// A connection to a list of items.
type OrgSubscriptionHistoryConnection struct {
	// A list of edges.
	Edges []*OrgSubscriptionHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgSubscriptionHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrgSubscriptionHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrgSubscriptionHistory connections
type OrgSubscriptionHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrgSubscriptionHistories.
	Field OrgSubscriptionHistoryOrderField `json:"field"`
}

// OrgSubscriptionHistoryWhereInput is used for filtering OrgSubscriptionHistory objects.
// Input was generated by ent.
type OrgSubscriptionHistoryWhereInput struct {
	Not *OrgSubscriptionHistoryWhereInput   `json:"not,omitempty"`
	And []*OrgSubscriptionHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrgSubscriptionHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// stripe_subscription_id field predicates
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIdneq          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIdgt           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIdgte          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIdlt           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIdlte          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        *bool    `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       *bool    `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`
	// stripe_subscription_status field predicates
	StripeSubscriptionStatus             *string  `json:"stripeSubscriptionStatus,omitempty"`
	StripeSubscriptionStatusNeq          *string  `json:"stripeSubscriptionStatusNEQ,omitempty"`
	StripeSubscriptionStatusIn           []string `json:"stripeSubscriptionStatusIn,omitempty"`
	StripeSubscriptionStatusNotIn        []string `json:"stripeSubscriptionStatusNotIn,omitempty"`
	StripeSubscriptionStatusGt           *string  `json:"stripeSubscriptionStatusGT,omitempty"`
	StripeSubscriptionStatusGte          *string  `json:"stripeSubscriptionStatusGTE,omitempty"`
	StripeSubscriptionStatusLt           *string  `json:"stripeSubscriptionStatusLT,omitempty"`
	StripeSubscriptionStatusLte          *string  `json:"stripeSubscriptionStatusLTE,omitempty"`
	StripeSubscriptionStatusContains     *string  `json:"stripeSubscriptionStatusContains,omitempty"`
	StripeSubscriptionStatusHasPrefix    *string  `json:"stripeSubscriptionStatusHasPrefix,omitempty"`
	StripeSubscriptionStatusHasSuffix    *string  `json:"stripeSubscriptionStatusHasSuffix,omitempty"`
	StripeSubscriptionStatusIsNil        *bool    `json:"stripeSubscriptionStatusIsNil,omitempty"`
	StripeSubscriptionStatusNotNil       *bool    `json:"stripeSubscriptionStatusNotNil,omitempty"`
	StripeSubscriptionStatusEqualFold    *string  `json:"stripeSubscriptionStatusEqualFold,omitempty"`
	StripeSubscriptionStatusContainsFold *string  `json:"stripeSubscriptionStatusContainsFold,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// trial_expires_at field predicates
	TrialExpiresAt       *time.Time   `json:"trialExpiresAt,omitempty"`
	TrialExpiresAtNeq    *time.Time   `json:"trialExpiresAtNEQ,omitempty"`
	TrialExpiresAtIn     []*time.Time `json:"trialExpiresAtIn,omitempty"`
	TrialExpiresAtNotIn  []*time.Time `json:"trialExpiresAtNotIn,omitempty"`
	TrialExpiresAtGt     *time.Time   `json:"trialExpiresAtGT,omitempty"`
	TrialExpiresAtGte    *time.Time   `json:"trialExpiresAtGTE,omitempty"`
	TrialExpiresAtLt     *time.Time   `json:"trialExpiresAtLT,omitempty"`
	TrialExpiresAtLte    *time.Time   `json:"trialExpiresAtLTE,omitempty"`
	TrialExpiresAtIsNil  *bool        `json:"trialExpiresAtIsNil,omitempty"`
	TrialExpiresAtNotNil *bool        `json:"trialExpiresAtNotNil,omitempty"`
	// days_until_due field predicates
	DaysUntilDue             *string  `json:"daysUntilDue,omitempty"`
	DaysUntilDueNeq          *string  `json:"daysUntilDueNEQ,omitempty"`
	DaysUntilDueIn           []string `json:"daysUntilDueIn,omitempty"`
	DaysUntilDueNotIn        []string `json:"daysUntilDueNotIn,omitempty"`
	DaysUntilDueGt           *string  `json:"daysUntilDueGT,omitempty"`
	DaysUntilDueGte          *string  `json:"daysUntilDueGTE,omitempty"`
	DaysUntilDueLt           *string  `json:"daysUntilDueLT,omitempty"`
	DaysUntilDueLte          *string  `json:"daysUntilDueLTE,omitempty"`
	DaysUntilDueContains     *string  `json:"daysUntilDueContains,omitempty"`
	DaysUntilDueHasPrefix    *string  `json:"daysUntilDueHasPrefix,omitempty"`
	DaysUntilDueHasSuffix    *string  `json:"daysUntilDueHasSuffix,omitempty"`
	DaysUntilDueIsNil        *bool    `json:"daysUntilDueIsNil,omitempty"`
	DaysUntilDueNotNil       *bool    `json:"daysUntilDueNotNil,omitempty"`
	DaysUntilDueEqualFold    *string  `json:"daysUntilDueEqualFold,omitempty"`
	DaysUntilDueContainsFold *string  `json:"daysUntilDueContainsFold,omitempty"`
}

// Ordering options for OrgSubscription connections
type OrgSubscriptionOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrgSubscriptions.
	Field OrgSubscriptionOrderField `json:"field"`
}

// OrgSubscriptionWhereInput is used for filtering OrgSubscription objects.
// Input was generated by ent.
type OrgSubscriptionWhereInput struct {
	Not *OrgSubscriptionWhereInput   `json:"not,omitempty"`
	And []*OrgSubscriptionWhereInput `json:"and,omitempty"`
	Or  []*OrgSubscriptionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// stripe_subscription_id field predicates
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIdneq          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIdgt           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIdgte          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIdlt           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIdlte          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        *bool    `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       *bool    `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`
	// stripe_subscription_status field predicates
	StripeSubscriptionStatus             *string  `json:"stripeSubscriptionStatus,omitempty"`
	StripeSubscriptionStatusNeq          *string  `json:"stripeSubscriptionStatusNEQ,omitempty"`
	StripeSubscriptionStatusIn           []string `json:"stripeSubscriptionStatusIn,omitempty"`
	StripeSubscriptionStatusNotIn        []string `json:"stripeSubscriptionStatusNotIn,omitempty"`
	StripeSubscriptionStatusGt           *string  `json:"stripeSubscriptionStatusGT,omitempty"`
	StripeSubscriptionStatusGte          *string  `json:"stripeSubscriptionStatusGTE,omitempty"`
	StripeSubscriptionStatusLt           *string  `json:"stripeSubscriptionStatusLT,omitempty"`
	StripeSubscriptionStatusLte          *string  `json:"stripeSubscriptionStatusLTE,omitempty"`
	StripeSubscriptionStatusContains     *string  `json:"stripeSubscriptionStatusContains,omitempty"`
	StripeSubscriptionStatusHasPrefix    *string  `json:"stripeSubscriptionStatusHasPrefix,omitempty"`
	StripeSubscriptionStatusHasSuffix    *string  `json:"stripeSubscriptionStatusHasSuffix,omitempty"`
	StripeSubscriptionStatusIsNil        *bool    `json:"stripeSubscriptionStatusIsNil,omitempty"`
	StripeSubscriptionStatusNotNil       *bool    `json:"stripeSubscriptionStatusNotNil,omitempty"`
	StripeSubscriptionStatusEqualFold    *string  `json:"stripeSubscriptionStatusEqualFold,omitempty"`
	StripeSubscriptionStatusContainsFold *string  `json:"stripeSubscriptionStatusContainsFold,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// trial_expires_at field predicates
	TrialExpiresAt       *time.Time   `json:"trialExpiresAt,omitempty"`
	TrialExpiresAtNeq    *time.Time   `json:"trialExpiresAtNEQ,omitempty"`
	TrialExpiresAtIn     []*time.Time `json:"trialExpiresAtIn,omitempty"`
	TrialExpiresAtNotIn  []*time.Time `json:"trialExpiresAtNotIn,omitempty"`
	TrialExpiresAtGt     *time.Time   `json:"trialExpiresAtGT,omitempty"`
	TrialExpiresAtGte    *time.Time   `json:"trialExpiresAtGTE,omitempty"`
	TrialExpiresAtLt     *time.Time   `json:"trialExpiresAtLT,omitempty"`
	TrialExpiresAtLte    *time.Time   `json:"trialExpiresAtLTE,omitempty"`
	TrialExpiresAtIsNil  *bool        `json:"trialExpiresAtIsNil,omitempty"`
	TrialExpiresAtNotNil *bool        `json:"trialExpiresAtNotNil,omitempty"`
	// days_until_due field predicates
	DaysUntilDue             *string  `json:"daysUntilDue,omitempty"`
	DaysUntilDueNeq          *string  `json:"daysUntilDueNEQ,omitempty"`
	DaysUntilDueIn           []string `json:"daysUntilDueIn,omitempty"`
	DaysUntilDueNotIn        []string `json:"daysUntilDueNotIn,omitempty"`
	DaysUntilDueGt           *string  `json:"daysUntilDueGT,omitempty"`
	DaysUntilDueGte          *string  `json:"daysUntilDueGTE,omitempty"`
	DaysUntilDueLt           *string  `json:"daysUntilDueLT,omitempty"`
	DaysUntilDueLte          *string  `json:"daysUntilDueLTE,omitempty"`
	DaysUntilDueContains     *string  `json:"daysUntilDueContains,omitempty"`
	DaysUntilDueHasPrefix    *string  `json:"daysUntilDueHasPrefix,omitempty"`
	DaysUntilDueHasSuffix    *string  `json:"daysUntilDueHasSuffix,omitempty"`
	DaysUntilDueIsNil        *bool    `json:"daysUntilDueIsNil,omitempty"`
	DaysUntilDueNotNil       *bool    `json:"daysUntilDueNotNil,omitempty"`
	DaysUntilDueEqualFold    *string  `json:"daysUntilDueEqualFold,omitempty"`
	DaysUntilDueContainsFold *string  `json:"daysUntilDueContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Organization struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The organizations's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb bool `json:"dedicatedDb"`
	// the stripe customer ID this organization is associated to
	StripeCustomerID                *string                               `json:"stripeCustomerID,omitempty"`
	ControlCreators                 *GroupConnection                      `json:"controlCreators"`
	ControlImplementationCreators   *GroupConnection                      `json:"controlImplementationCreators"`
	ControlObjectiveCreators        *GroupConnection                      `json:"controlObjectiveCreators"`
	EvidenceCreators                *GroupConnection                      `json:"evidenceCreators"`
	GroupCreators                   *GroupConnection                      `json:"groupCreators"`
	InternalPolicyCreators          *GroupConnection                      `json:"internalPolicyCreators"`
	MappedControlCreators           *GroupConnection                      `json:"mappedControlCreators"`
	NarrativeCreators               *GroupConnection                      `json:"narrativeCreators"`
	ProcedureCreators               *GroupConnection                      `json:"procedureCreators"`
	ProgramCreators                 *GroupConnection                      `json:"programCreators"`
	RiskCreators                    *GroupConnection                      `json:"riskCreators"`
	ScheduledJobCreators            *GroupConnection                      `json:"scheduledJobCreators"`
	StandardCreators                *GroupConnection                      `json:"standardCreators"`
	TemplateCreators                *GroupConnection                      `json:"templateCreators"`
	SubprocessorCreators            *GroupConnection                      `json:"subprocessorCreators"`
	TrustCenterDocCreators          *GroupConnection                      `json:"trustCenterDocCreators"`
	TrustCenterSubprocessorCreators *GroupConnection                      `json:"trustCenterSubprocessorCreators"`
	Parent                          *Organization                         `json:"parent,omitempty"`
	Children                        *OrganizationConnection               `json:"children"`
	Setting                         *OrganizationSetting                  `json:"setting,omitempty"`
	PersonalAccessTokens            *PersonalAccessTokenConnection        `json:"personalAccessTokens"`
	APITokens                       *APITokenConnection                   `json:"apiTokens"`
	Users                           *UserConnection                       `json:"users"`
	Files                           *FileConnection                       `json:"files"`
	Events                          *EventConnection                      `json:"events"`
	Secrets                         *HushConnection                       `json:"secrets"`
	AvatarFile                      *File                                 `json:"avatarFile,omitempty"`
	Groups                          *GroupConnection                      `json:"groups"`
	Templates                       *TemplateConnection                   `json:"templates"`
	Integrations                    *IntegrationConnection                `json:"integrations"`
	Documents                       *DocumentDataConnection               `json:"documents"`
	OrgSubscriptions                []*OrgSubscription                    `json:"orgSubscriptions,omitempty"`
	Invites                         *InviteConnection                     `json:"invites"`
	Subscribers                     *SubscriberConnection                 `json:"subscribers"`
	Entities                        *EntityConnection                     `json:"entities"`
	EntityTypes                     *EntityTypeConnection                 `json:"entityTypes"`
	Contacts                        *ContactConnection                    `json:"contacts"`
	Notes                           *NoteConnection                       `json:"notes"`
	Tasks                           *TaskConnection                       `json:"tasks"`
	Programs                        *ProgramConnection                    `json:"programs"`
	Procedures                      *ProcedureConnection                  `json:"procedures"`
	InternalPolicies                *InternalPolicyConnection             `json:"internalPolicies"`
	Risks                           *RiskConnection                       `json:"risks"`
	ControlObjectives               *ControlObjectiveConnection           `json:"controlObjectives"`
	Narratives                      *NarrativeConnection                  `json:"narratives"`
	Controls                        *ControlConnection                    `json:"controls"`
	Subcontrols                     *SubcontrolConnection                 `json:"subcontrols"`
	ControlImplementations          *ControlImplementationConnection      `json:"controlImplementations"`
	MappedControls                  *MappedControlConnection              `json:"mappedControls"`
	Evidence                        *EvidenceConnection                   `json:"evidence"`
	Standards                       *StandardConnection                   `json:"standards"`
	ActionPlans                     *ActionPlanConnection                 `json:"actionPlans"`
	CustomDomains                   *CustomDomainConnection               `json:"customDomains"`
	JobRunners                      *JobRunnerConnection                  `json:"jobRunners"`
	JobRunnerTokens                 *JobRunnerTokenConnection             `json:"jobRunnerTokens"`
	JobRunnerRegistrationTokens     *JobRunnerRegistrationTokenConnection `json:"jobRunnerRegistrationTokens"`
	DNSVerifications                *DNSVerificationConnection            `json:"dnsVerifications"`
	JobTemplates                    *JobTemplateConnection                `json:"jobTemplates"`
	ScheduledJobs                   *ScheduledJobConnection               `json:"scheduledJobs"`
	JobResults                      *JobResultConnection                  `json:"jobResults"`
	ScheduledJobRuns                *ScheduledJobRunConnection            `json:"scheduledJobRuns"`
	TrustCenters                    *TrustCenterConnection                `json:"trustCenters"`
	Assets                          *AssetConnection                      `json:"assets"`
	Scans                           *ScanConnection                       `json:"scans"`
	Subprocessors                   *SubprocessorConnection               `json:"subprocessors"`
	Exports                         *ExportConnection                     `json:"exports"`
	TrustCenterWatermarkConfigs     *TrustCenterWatermarkConfigConnection `json:"trustCenterWatermarkConfigs"`
	Assessments                     *AssessmentConnection                 `json:"assessments"`
	AssessmentResponses             *AssessmentResponseConnection         `json:"assessmentResponses"`
	CustomTypeEnums                 *CustomTypeEnumConnection             `json:"customTypeEnums"`
	TagDefinitions                  *TagDefinitionConnection              `json:"tagDefinitions"`
	Remediations                    *RemediationConnection                `json:"remediations"`
	Findings                        *FindingConnection                    `json:"findings"`
	Reviews                         *ReviewConnection                     `json:"reviews"`
	Vulnerabilities                 *VulnerabilityConnection              `json:"vulnerabilities"`
	WorkflowDefinitions             *WorkflowDefinitionConnection         `json:"workflowDefinitions"`
	WorkflowInstances               *WorkflowInstanceConnection           `json:"workflowInstances"`
	WorkflowEvents                  *WorkflowEventConnection              `json:"workflowEvents"`
	WorkflowAssignments             *WorkflowAssignmentConnection         `json:"workflowAssignments"`
	WorkflowAssignmentTargets       *WorkflowAssignmentTargetConnection   `json:"workflowAssignmentTargets"`
	WorkflowObjectRefs              *WorkflowObjectRefConnection          `json:"workflowObjectRefs"`
	DirectoryAccounts               *DirectoryAccountConnection           `json:"directoryAccounts"`
	DirectoryGroups                 *DirectoryGroupConnection             `json:"directoryGroups"`
	DirectoryMemberships            *DirectoryMembershipConnection        `json:"directoryMemberships"`
	DirectorySyncRuns               *DirectorySyncRunConnection           `json:"directorySyncRuns"`
	Members                         *OrgMembershipConnection              `json:"members"`
}

func (Organization) IsNode() {}

// Return response for createBulkOrganization mutation
type OrganizationBulkCreatePayload struct {
	// Created organizations
	Organizations []*Organization `json:"organizations,omitempty"`
}

// A connection to a list of items.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization *Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The organizations's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb bool `json:"dedicatedDb"`
	// the stripe customer ID this organization is associated to
	StripeCustomerID *string `json:"stripeCustomerID,omitempty"`
}

func (OrganizationHistory) IsNode() {}

// A connection to a list of items.
type OrganizationHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrganizationHistory connections
type OrganizationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationHistories.
	Field OrganizationHistoryOrderField `json:"field"`
}

// OrganizationHistoryWhereInput is used for filtering OrganizationHistory objects.
// Input was generated by ent.
type OrganizationHistoryWhereInput struct {
	Not *OrganizationHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIdneq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIdgt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIdgte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIdlt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIdlte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
}

// Ordering options for Organization connections
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Organizations.
	Field OrganizationOrderField `json:"field"`
}

type OrganizationSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string `json:"organizationID,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled bool `json:"billingNotificationsEnabled"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string `json:"allowedEmailDomains,omitempty"`
	// allow users who can successfully confirm their email or who login via social providers with an email that matches the organizations configured allowed domain to auto-join the organization
	AllowMatchingDomainsAutojoin *bool `json:"allowMatchingDomainsAutojoin,omitempty"`
	// SSO provider type for the organization
	IdentityProvider *enums.SSOProvider `json:"identityProvider,omitempty"`
	// client ID for SSO integration
	IdentityProviderClientID *string `json:"identityProviderClientID,omitempty"`
	// client secret for SSO integration
	IdentityProviderClientSecret *string `json:"identityProviderClientSecret,omitempty"`
	// metadata URL for the SSO provider
	IdentityProviderMetadataEndpoint *string `json:"identityProviderMetadataEndpoint,omitempty"`
	// has this sso configuration been tested to verify it works? SSO cannot be enforced unless this is done
	IdentityProviderAuthTested bool `json:"identityProviderAuthTested"`
	// SAML entity ID for the SSO provider
	IdentityProviderEntityID *string `json:"identityProviderEntityID,omitempty"`
	// OIDC discovery URL for the SSO provider
	OidcDiscoveryEndpoint *string `json:"oidcDiscoveryEndpoint,omitempty"`
	// the sign in URL to be used for SAML-based authentication
	SamlSigninURL *string `json:"samlSigninURL,omitempty"`
	// the SAML issuer
	SamlIssuer *string `json:"samlIssuer,omitempty"`
	// the x509 certificate used to validate SAML responses
	SamlCert *string `json:"samlCert,omitempty"`
	// enforce SSO authentication for organization members
	IdentityProviderLoginEnforced bool `json:"identityProviderLoginEnforced"`
	// enforce 2fa / multifactor authentication for organization members
	MultifactorAuthEnforced *bool `json:"multifactorAuthEnforced,omitempty"`
	// unique token used to receive compliance webhook events
	ComplianceWebhookToken *string `json:"complianceWebhookToken,omitempty"`
	// whether or not a payment method has been added to the account
	PaymentMethodAdded bool            `json:"paymentMethodAdded"`
	Organization       *Organization   `json:"organization,omitempty"`
	Files              *FileConnection `json:"files"`
}

func (OrganizationSetting) IsNode() {}

// Return response for createBulkOrganizationSetting mutation
type OrganizationSettingBulkCreatePayload struct {
	// Created organizationSettings
	OrganizationSettings []*OrganizationSetting `json:"organizationSettings,omitempty"`
}

// Return response for deleteBulkOrganizationSetting mutation
type OrganizationSettingBulkDeletePayload struct {
	// Deleted organizationSetting IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type OrganizationSettingConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganizationSetting mutation
type OrganizationSettingCreatePayload struct {
	// Created organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// Return response for deleteOrganizationSetting mutation
type OrganizationSettingDeletePayload struct {
	// Deleted organizationSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationSettingEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string `json:"organizationID,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled bool `json:"billingNotificationsEnabled"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string `json:"allowedEmailDomains,omitempty"`
	// allow users who can successfully confirm their email or who login via social providers with an email that matches the organizations configured allowed domain to auto-join the organization
	AllowMatchingDomainsAutojoin *bool `json:"allowMatchingDomainsAutojoin,omitempty"`
	// SSO provider type for the organization
	IdentityProvider *enums.SSOProvider `json:"identityProvider,omitempty"`
	// client ID for SSO integration
	IdentityProviderClientID *string `json:"identityProviderClientID,omitempty"`
	// client secret for SSO integration
	IdentityProviderClientSecret *string `json:"identityProviderClientSecret,omitempty"`
	// metadata URL for the SSO provider
	IdentityProviderMetadataEndpoint *string `json:"identityProviderMetadataEndpoint,omitempty"`
	// has this sso configuration been tested to verify it works? SSO cannot be enforced unless this is done
	IdentityProviderAuthTested bool `json:"identityProviderAuthTested"`
	// SAML entity ID for the SSO provider
	IdentityProviderEntityID *string `json:"identityProviderEntityID,omitempty"`
	// OIDC discovery URL for the SSO provider
	OidcDiscoveryEndpoint *string `json:"oidcDiscoveryEndpoint,omitempty"`
	// the sign in URL to be used for SAML-based authentication
	SamlSigninURL *string `json:"samlSigninURL,omitempty"`
	// the SAML issuer
	SamlIssuer *string `json:"samlIssuer,omitempty"`
	// the x509 certificate used to validate SAML responses
	SamlCert *string `json:"samlCert,omitempty"`
	// enforce SSO authentication for organization members
	IdentityProviderLoginEnforced bool `json:"identityProviderLoginEnforced"`
	// enforce 2fa / multifactor authentication for organization members
	MultifactorAuthEnforced *bool `json:"multifactorAuthEnforced,omitempty"`
	// unique token used to receive compliance webhook events
	ComplianceWebhookToken *string `json:"complianceWebhookToken,omitempty"`
	// whether or not a payment method has been added to the account
	PaymentMethodAdded bool `json:"paymentMethodAdded"`
}

func (OrganizationSettingHistory) IsNode() {}

// A connection to a list of items.
type OrganizationSettingHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrganizationSettingHistory connections
type OrganizationSettingHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationSettingHistories.
	Field OrganizationSettingHistoryOrderField `json:"field"`
}

// OrganizationSettingHistoryWhereInput is used for filtering OrganizationSettingHistory objects.
// Input was generated by ent.
type OrganizationSettingHistoryWhereInput struct {
	Not *OrganizationSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// billing_notifications_enabled field predicates
	BillingNotificationsEnabled    *bool `json:"billingNotificationsEnabled,omitempty"`
	BillingNotificationsEnabledNeq *bool `json:"billingNotificationsEnabledNEQ,omitempty"`
	// allow_matching_domains_autojoin field predicates
	AllowMatchingDomainsAutojoin       *bool `json:"allowMatchingDomainsAutojoin,omitempty"`
	AllowMatchingDomainsAutojoinNeq    *bool `json:"allowMatchingDomainsAutojoinNEQ,omitempty"`
	AllowMatchingDomainsAutojoinIsNil  *bool `json:"allowMatchingDomainsAutojoinIsNil,omitempty"`
	AllowMatchingDomainsAutojoinNotNil *bool `json:"allowMatchingDomainsAutojoinNotNil,omitempty"`
	// identity_provider field predicates
	IdentityProvider       *enums.SSOProvider  `json:"identityProvider,omitempty"`
	IdentityProviderNeq    *enums.SSOProvider  `json:"identityProviderNEQ,omitempty"`
	IdentityProviderIn     []enums.SSOProvider `json:"identityProviderIn,omitempty"`
	IdentityProviderNotIn  []enums.SSOProvider `json:"identityProviderNotIn,omitempty"`
	IdentityProviderIsNil  *bool               `json:"identityProviderIsNil,omitempty"`
	IdentityProviderNotNil *bool               `json:"identityProviderNotNil,omitempty"`
	// identity_provider_client_id field predicates
	IdentityProviderClientID             *string  `json:"identityProviderClientID,omitempty"`
	IdentityProviderClientIdneq          *string  `json:"identityProviderClientIDNEQ,omitempty"`
	IdentityProviderClientIDIn           []string `json:"identityProviderClientIDIn,omitempty"`
	IdentityProviderClientIDNotIn        []string `json:"identityProviderClientIDNotIn,omitempty"`
	IdentityProviderClientIdgt           *string  `json:"identityProviderClientIDGT,omitempty"`
	IdentityProviderClientIdgte          *string  `json:"identityProviderClientIDGTE,omitempty"`
	IdentityProviderClientIdlt           *string  `json:"identityProviderClientIDLT,omitempty"`
	IdentityProviderClientIdlte          *string  `json:"identityProviderClientIDLTE,omitempty"`
	IdentityProviderClientIDContains     *string  `json:"identityProviderClientIDContains,omitempty"`
	IdentityProviderClientIDHasPrefix    *string  `json:"identityProviderClientIDHasPrefix,omitempty"`
	IdentityProviderClientIDHasSuffix    *string  `json:"identityProviderClientIDHasSuffix,omitempty"`
	IdentityProviderClientIDIsNil        *bool    `json:"identityProviderClientIDIsNil,omitempty"`
	IdentityProviderClientIDNotNil       *bool    `json:"identityProviderClientIDNotNil,omitempty"`
	IdentityProviderClientIDEqualFold    *string  `json:"identityProviderClientIDEqualFold,omitempty"`
	IdentityProviderClientIDContainsFold *string  `json:"identityProviderClientIDContainsFold,omitempty"`
	// identity_provider_client_secret field predicates
	IdentityProviderClientSecret             *string  `json:"identityProviderClientSecret,omitempty"`
	IdentityProviderClientSecretNeq          *string  `json:"identityProviderClientSecretNEQ,omitempty"`
	IdentityProviderClientSecretIn           []string `json:"identityProviderClientSecretIn,omitempty"`
	IdentityProviderClientSecretNotIn        []string `json:"identityProviderClientSecretNotIn,omitempty"`
	IdentityProviderClientSecretGt           *string  `json:"identityProviderClientSecretGT,omitempty"`
	IdentityProviderClientSecretGte          *string  `json:"identityProviderClientSecretGTE,omitempty"`
	IdentityProviderClientSecretLt           *string  `json:"identityProviderClientSecretLT,omitempty"`
	IdentityProviderClientSecretLte          *string  `json:"identityProviderClientSecretLTE,omitempty"`
	IdentityProviderClientSecretContains     *string  `json:"identityProviderClientSecretContains,omitempty"`
	IdentityProviderClientSecretHasPrefix    *string  `json:"identityProviderClientSecretHasPrefix,omitempty"`
	IdentityProviderClientSecretHasSuffix    *string  `json:"identityProviderClientSecretHasSuffix,omitempty"`
	IdentityProviderClientSecretIsNil        *bool    `json:"identityProviderClientSecretIsNil,omitempty"`
	IdentityProviderClientSecretNotNil       *bool    `json:"identityProviderClientSecretNotNil,omitempty"`
	IdentityProviderClientSecretEqualFold    *string  `json:"identityProviderClientSecretEqualFold,omitempty"`
	IdentityProviderClientSecretContainsFold *string  `json:"identityProviderClientSecretContainsFold,omitempty"`
	// identity_provider_metadata_endpoint field predicates
	IdentityProviderMetadataEndpoint             *string  `json:"identityProviderMetadataEndpoint,omitempty"`
	IdentityProviderMetadataEndpointNeq          *string  `json:"identityProviderMetadataEndpointNEQ,omitempty"`
	IdentityProviderMetadataEndpointIn           []string `json:"identityProviderMetadataEndpointIn,omitempty"`
	IdentityProviderMetadataEndpointNotIn        []string `json:"identityProviderMetadataEndpointNotIn,omitempty"`
	IdentityProviderMetadataEndpointGt           *string  `json:"identityProviderMetadataEndpointGT,omitempty"`
	IdentityProviderMetadataEndpointGte          *string  `json:"identityProviderMetadataEndpointGTE,omitempty"`
	IdentityProviderMetadataEndpointLt           *string  `json:"identityProviderMetadataEndpointLT,omitempty"`
	IdentityProviderMetadataEndpointLte          *string  `json:"identityProviderMetadataEndpointLTE,omitempty"`
	IdentityProviderMetadataEndpointContains     *string  `json:"identityProviderMetadataEndpointContains,omitempty"`
	IdentityProviderMetadataEndpointHasPrefix    *string  `json:"identityProviderMetadataEndpointHasPrefix,omitempty"`
	IdentityProviderMetadataEndpointHasSuffix    *string  `json:"identityProviderMetadataEndpointHasSuffix,omitempty"`
	IdentityProviderMetadataEndpointIsNil        *bool    `json:"identityProviderMetadataEndpointIsNil,omitempty"`
	IdentityProviderMetadataEndpointNotNil       *bool    `json:"identityProviderMetadataEndpointNotNil,omitempty"`
	IdentityProviderMetadataEndpointEqualFold    *string  `json:"identityProviderMetadataEndpointEqualFold,omitempty"`
	IdentityProviderMetadataEndpointContainsFold *string  `json:"identityProviderMetadataEndpointContainsFold,omitempty"`
	// identity_provider_auth_tested field predicates
	IdentityProviderAuthTested    *bool `json:"identityProviderAuthTested,omitempty"`
	IdentityProviderAuthTestedNeq *bool `json:"identityProviderAuthTestedNEQ,omitempty"`
	// identity_provider_entity_id field predicates
	IdentityProviderEntityID             *string  `json:"identityProviderEntityID,omitempty"`
	IdentityProviderEntityIdneq          *string  `json:"identityProviderEntityIDNEQ,omitempty"`
	IdentityProviderEntityIDIn           []string `json:"identityProviderEntityIDIn,omitempty"`
	IdentityProviderEntityIDNotIn        []string `json:"identityProviderEntityIDNotIn,omitempty"`
	IdentityProviderEntityIdgt           *string  `json:"identityProviderEntityIDGT,omitempty"`
	IdentityProviderEntityIdgte          *string  `json:"identityProviderEntityIDGTE,omitempty"`
	IdentityProviderEntityIdlt           *string  `json:"identityProviderEntityIDLT,omitempty"`
	IdentityProviderEntityIdlte          *string  `json:"identityProviderEntityIDLTE,omitempty"`
	IdentityProviderEntityIDContains     *string  `json:"identityProviderEntityIDContains,omitempty"`
	IdentityProviderEntityIDHasPrefix    *string  `json:"identityProviderEntityIDHasPrefix,omitempty"`
	IdentityProviderEntityIDHasSuffix    *string  `json:"identityProviderEntityIDHasSuffix,omitempty"`
	IdentityProviderEntityIDIsNil        *bool    `json:"identityProviderEntityIDIsNil,omitempty"`
	IdentityProviderEntityIDNotNil       *bool    `json:"identityProviderEntityIDNotNil,omitempty"`
	IdentityProviderEntityIDEqualFold    *string  `json:"identityProviderEntityIDEqualFold,omitempty"`
	IdentityProviderEntityIDContainsFold *string  `json:"identityProviderEntityIDContainsFold,omitempty"`
	// oidc_discovery_endpoint field predicates
	OidcDiscoveryEndpoint             *string  `json:"oidcDiscoveryEndpoint,omitempty"`
	OidcDiscoveryEndpointNeq          *string  `json:"oidcDiscoveryEndpointNEQ,omitempty"`
	OidcDiscoveryEndpointIn           []string `json:"oidcDiscoveryEndpointIn,omitempty"`
	OidcDiscoveryEndpointNotIn        []string `json:"oidcDiscoveryEndpointNotIn,omitempty"`
	OidcDiscoveryEndpointGt           *string  `json:"oidcDiscoveryEndpointGT,omitempty"`
	OidcDiscoveryEndpointGte          *string  `json:"oidcDiscoveryEndpointGTE,omitempty"`
	OidcDiscoveryEndpointLt           *string  `json:"oidcDiscoveryEndpointLT,omitempty"`
	OidcDiscoveryEndpointLte          *string  `json:"oidcDiscoveryEndpointLTE,omitempty"`
	OidcDiscoveryEndpointContains     *string  `json:"oidcDiscoveryEndpointContains,omitempty"`
	OidcDiscoveryEndpointHasPrefix    *string  `json:"oidcDiscoveryEndpointHasPrefix,omitempty"`
	OidcDiscoveryEndpointHasSuffix    *string  `json:"oidcDiscoveryEndpointHasSuffix,omitempty"`
	OidcDiscoveryEndpointIsNil        *bool    `json:"oidcDiscoveryEndpointIsNil,omitempty"`
	OidcDiscoveryEndpointNotNil       *bool    `json:"oidcDiscoveryEndpointNotNil,omitempty"`
	OidcDiscoveryEndpointEqualFold    *string  `json:"oidcDiscoveryEndpointEqualFold,omitempty"`
	OidcDiscoveryEndpointContainsFold *string  `json:"oidcDiscoveryEndpointContainsFold,omitempty"`
	// saml_signin_url field predicates
	SamlSigninURL             *string  `json:"samlSigninURL,omitempty"`
	SamlSigninURLNeq          *string  `json:"samlSigninURLNEQ,omitempty"`
	SamlSigninURLIn           []string `json:"samlSigninURLIn,omitempty"`
	SamlSigninURLNotIn        []string `json:"samlSigninURLNotIn,omitempty"`
	SamlSigninURLGt           *string  `json:"samlSigninURLGT,omitempty"`
	SamlSigninURLGte          *string  `json:"samlSigninURLGTE,omitempty"`
	SamlSigninURLLt           *string  `json:"samlSigninURLLT,omitempty"`
	SamlSigninURLLte          *string  `json:"samlSigninURLLTE,omitempty"`
	SamlSigninURLContains     *string  `json:"samlSigninURLContains,omitempty"`
	SamlSigninURLHasPrefix    *string  `json:"samlSigninURLHasPrefix,omitempty"`
	SamlSigninURLHasSuffix    *string  `json:"samlSigninURLHasSuffix,omitempty"`
	SamlSigninURLIsNil        *bool    `json:"samlSigninURLIsNil,omitempty"`
	SamlSigninURLNotNil       *bool    `json:"samlSigninURLNotNil,omitempty"`
	SamlSigninURLEqualFold    *string  `json:"samlSigninURLEqualFold,omitempty"`
	SamlSigninURLContainsFold *string  `json:"samlSigninURLContainsFold,omitempty"`
	// saml_issuer field predicates
	SamlIssuer             *string  `json:"samlIssuer,omitempty"`
	SamlIssuerNeq          *string  `json:"samlIssuerNEQ,omitempty"`
	SamlIssuerIn           []string `json:"samlIssuerIn,omitempty"`
	SamlIssuerNotIn        []string `json:"samlIssuerNotIn,omitempty"`
	SamlIssuerGt           *string  `json:"samlIssuerGT,omitempty"`
	SamlIssuerGte          *string  `json:"samlIssuerGTE,omitempty"`
	SamlIssuerLt           *string  `json:"samlIssuerLT,omitempty"`
	SamlIssuerLte          *string  `json:"samlIssuerLTE,omitempty"`
	SamlIssuerContains     *string  `json:"samlIssuerContains,omitempty"`
	SamlIssuerHasPrefix    *string  `json:"samlIssuerHasPrefix,omitempty"`
	SamlIssuerHasSuffix    *string  `json:"samlIssuerHasSuffix,omitempty"`
	SamlIssuerIsNil        *bool    `json:"samlIssuerIsNil,omitempty"`
	SamlIssuerNotNil       *bool    `json:"samlIssuerNotNil,omitempty"`
	SamlIssuerEqualFold    *string  `json:"samlIssuerEqualFold,omitempty"`
	SamlIssuerContainsFold *string  `json:"samlIssuerContainsFold,omitempty"`
	// saml_cert field predicates
	SamlCert             *string  `json:"samlCert,omitempty"`
	SamlCertNeq          *string  `json:"samlCertNEQ,omitempty"`
	SamlCertIn           []string `json:"samlCertIn,omitempty"`
	SamlCertNotIn        []string `json:"samlCertNotIn,omitempty"`
	SamlCertGt           *string  `json:"samlCertGT,omitempty"`
	SamlCertGte          *string  `json:"samlCertGTE,omitempty"`
	SamlCertLt           *string  `json:"samlCertLT,omitempty"`
	SamlCertLte          *string  `json:"samlCertLTE,omitempty"`
	SamlCertContains     *string  `json:"samlCertContains,omitempty"`
	SamlCertHasPrefix    *string  `json:"samlCertHasPrefix,omitempty"`
	SamlCertHasSuffix    *string  `json:"samlCertHasSuffix,omitempty"`
	SamlCertIsNil        *bool    `json:"samlCertIsNil,omitempty"`
	SamlCertNotNil       *bool    `json:"samlCertNotNil,omitempty"`
	SamlCertEqualFold    *string  `json:"samlCertEqualFold,omitempty"`
	SamlCertContainsFold *string  `json:"samlCertContainsFold,omitempty"`
	// identity_provider_login_enforced field predicates
	IdentityProviderLoginEnforced    *bool `json:"identityProviderLoginEnforced,omitempty"`
	IdentityProviderLoginEnforcedNeq *bool `json:"identityProviderLoginEnforcedNEQ,omitempty"`
	// multifactor_auth_enforced field predicates
	MultifactorAuthEnforced       *bool `json:"multifactorAuthEnforced,omitempty"`
	MultifactorAuthEnforcedNeq    *bool `json:"multifactorAuthEnforcedNEQ,omitempty"`
	MultifactorAuthEnforcedIsNil  *bool `json:"multifactorAuthEnforcedIsNil,omitempty"`
	MultifactorAuthEnforcedNotNil *bool `json:"multifactorAuthEnforcedNotNil,omitempty"`
	// compliance_webhook_token field predicates
	ComplianceWebhookToken             *string  `json:"complianceWebhookToken,omitempty"`
	ComplianceWebhookTokenNeq          *string  `json:"complianceWebhookTokenNEQ,omitempty"`
	ComplianceWebhookTokenIn           []string `json:"complianceWebhookTokenIn,omitempty"`
	ComplianceWebhookTokenNotIn        []string `json:"complianceWebhookTokenNotIn,omitempty"`
	ComplianceWebhookTokenGt           *string  `json:"complianceWebhookTokenGT,omitempty"`
	ComplianceWebhookTokenGte          *string  `json:"complianceWebhookTokenGTE,omitempty"`
	ComplianceWebhookTokenLt           *string  `json:"complianceWebhookTokenLT,omitempty"`
	ComplianceWebhookTokenLte          *string  `json:"complianceWebhookTokenLTE,omitempty"`
	ComplianceWebhookTokenContains     *string  `json:"complianceWebhookTokenContains,omitempty"`
	ComplianceWebhookTokenHasPrefix    *string  `json:"complianceWebhookTokenHasPrefix,omitempty"`
	ComplianceWebhookTokenHasSuffix    *string  `json:"complianceWebhookTokenHasSuffix,omitempty"`
	ComplianceWebhookTokenIsNil        *bool    `json:"complianceWebhookTokenIsNil,omitempty"`
	ComplianceWebhookTokenNotNil       *bool    `json:"complianceWebhookTokenNotNil,omitempty"`
	ComplianceWebhookTokenEqualFold    *string  `json:"complianceWebhookTokenEqualFold,omitempty"`
	ComplianceWebhookTokenContainsFold *string  `json:"complianceWebhookTokenContainsFold,omitempty"`
}

// Ordering options for OrganizationSetting connections
type OrganizationSettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationSettings.
	Field OrganizationSettingOrderField `json:"field"`
}

// Return response for updateOrganizationSetting mutation
type OrganizationSettingUpdatePayload struct {
	// Updated organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// OrganizationSettingWhereInput is used for filtering OrganizationSetting objects.
// Input was generated by ent.
type OrganizationSettingWhereInput struct {
	Not *OrganizationSettingWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// billing_notifications_enabled field predicates
	BillingNotificationsEnabled    *bool `json:"billingNotificationsEnabled,omitempty"`
	BillingNotificationsEnabledNeq *bool `json:"billingNotificationsEnabledNEQ,omitempty"`
	// allow_matching_domains_autojoin field predicates
	AllowMatchingDomainsAutojoin       *bool `json:"allowMatchingDomainsAutojoin,omitempty"`
	AllowMatchingDomainsAutojoinNeq    *bool `json:"allowMatchingDomainsAutojoinNEQ,omitempty"`
	AllowMatchingDomainsAutojoinIsNil  *bool `json:"allowMatchingDomainsAutojoinIsNil,omitempty"`
	AllowMatchingDomainsAutojoinNotNil *bool `json:"allowMatchingDomainsAutojoinNotNil,omitempty"`
	// identity_provider field predicates
	IdentityProvider       *enums.SSOProvider  `json:"identityProvider,omitempty"`
	IdentityProviderNeq    *enums.SSOProvider  `json:"identityProviderNEQ,omitempty"`
	IdentityProviderIn     []enums.SSOProvider `json:"identityProviderIn,omitempty"`
	IdentityProviderNotIn  []enums.SSOProvider `json:"identityProviderNotIn,omitempty"`
	IdentityProviderIsNil  *bool               `json:"identityProviderIsNil,omitempty"`
	IdentityProviderNotNil *bool               `json:"identityProviderNotNil,omitempty"`
	// identity_provider_client_id field predicates
	IdentityProviderClientID             *string  `json:"identityProviderClientID,omitempty"`
	IdentityProviderClientIdneq          *string  `json:"identityProviderClientIDNEQ,omitempty"`
	IdentityProviderClientIDIn           []string `json:"identityProviderClientIDIn,omitempty"`
	IdentityProviderClientIDNotIn        []string `json:"identityProviderClientIDNotIn,omitempty"`
	IdentityProviderClientIdgt           *string  `json:"identityProviderClientIDGT,omitempty"`
	IdentityProviderClientIdgte          *string  `json:"identityProviderClientIDGTE,omitempty"`
	IdentityProviderClientIdlt           *string  `json:"identityProviderClientIDLT,omitempty"`
	IdentityProviderClientIdlte          *string  `json:"identityProviderClientIDLTE,omitempty"`
	IdentityProviderClientIDContains     *string  `json:"identityProviderClientIDContains,omitempty"`
	IdentityProviderClientIDHasPrefix    *string  `json:"identityProviderClientIDHasPrefix,omitempty"`
	IdentityProviderClientIDHasSuffix    *string  `json:"identityProviderClientIDHasSuffix,omitempty"`
	IdentityProviderClientIDIsNil        *bool    `json:"identityProviderClientIDIsNil,omitempty"`
	IdentityProviderClientIDNotNil       *bool    `json:"identityProviderClientIDNotNil,omitempty"`
	IdentityProviderClientIDEqualFold    *string  `json:"identityProviderClientIDEqualFold,omitempty"`
	IdentityProviderClientIDContainsFold *string  `json:"identityProviderClientIDContainsFold,omitempty"`
	// identity_provider_client_secret field predicates
	IdentityProviderClientSecret             *string  `json:"identityProviderClientSecret,omitempty"`
	IdentityProviderClientSecretNeq          *string  `json:"identityProviderClientSecretNEQ,omitempty"`
	IdentityProviderClientSecretIn           []string `json:"identityProviderClientSecretIn,omitempty"`
	IdentityProviderClientSecretNotIn        []string `json:"identityProviderClientSecretNotIn,omitempty"`
	IdentityProviderClientSecretGt           *string  `json:"identityProviderClientSecretGT,omitempty"`
	IdentityProviderClientSecretGte          *string  `json:"identityProviderClientSecretGTE,omitempty"`
	IdentityProviderClientSecretLt           *string  `json:"identityProviderClientSecretLT,omitempty"`
	IdentityProviderClientSecretLte          *string  `json:"identityProviderClientSecretLTE,omitempty"`
	IdentityProviderClientSecretContains     *string  `json:"identityProviderClientSecretContains,omitempty"`
	IdentityProviderClientSecretHasPrefix    *string  `json:"identityProviderClientSecretHasPrefix,omitempty"`
	IdentityProviderClientSecretHasSuffix    *string  `json:"identityProviderClientSecretHasSuffix,omitempty"`
	IdentityProviderClientSecretIsNil        *bool    `json:"identityProviderClientSecretIsNil,omitempty"`
	IdentityProviderClientSecretNotNil       *bool    `json:"identityProviderClientSecretNotNil,omitempty"`
	IdentityProviderClientSecretEqualFold    *string  `json:"identityProviderClientSecretEqualFold,omitempty"`
	IdentityProviderClientSecretContainsFold *string  `json:"identityProviderClientSecretContainsFold,omitempty"`
	// identity_provider_metadata_endpoint field predicates
	IdentityProviderMetadataEndpoint             *string  `json:"identityProviderMetadataEndpoint,omitempty"`
	IdentityProviderMetadataEndpointNeq          *string  `json:"identityProviderMetadataEndpointNEQ,omitempty"`
	IdentityProviderMetadataEndpointIn           []string `json:"identityProviderMetadataEndpointIn,omitempty"`
	IdentityProviderMetadataEndpointNotIn        []string `json:"identityProviderMetadataEndpointNotIn,omitempty"`
	IdentityProviderMetadataEndpointGt           *string  `json:"identityProviderMetadataEndpointGT,omitempty"`
	IdentityProviderMetadataEndpointGte          *string  `json:"identityProviderMetadataEndpointGTE,omitempty"`
	IdentityProviderMetadataEndpointLt           *string  `json:"identityProviderMetadataEndpointLT,omitempty"`
	IdentityProviderMetadataEndpointLte          *string  `json:"identityProviderMetadataEndpointLTE,omitempty"`
	IdentityProviderMetadataEndpointContains     *string  `json:"identityProviderMetadataEndpointContains,omitempty"`
	IdentityProviderMetadataEndpointHasPrefix    *string  `json:"identityProviderMetadataEndpointHasPrefix,omitempty"`
	IdentityProviderMetadataEndpointHasSuffix    *string  `json:"identityProviderMetadataEndpointHasSuffix,omitempty"`
	IdentityProviderMetadataEndpointIsNil        *bool    `json:"identityProviderMetadataEndpointIsNil,omitempty"`
	IdentityProviderMetadataEndpointNotNil       *bool    `json:"identityProviderMetadataEndpointNotNil,omitempty"`
	IdentityProviderMetadataEndpointEqualFold    *string  `json:"identityProviderMetadataEndpointEqualFold,omitempty"`
	IdentityProviderMetadataEndpointContainsFold *string  `json:"identityProviderMetadataEndpointContainsFold,omitempty"`
	// identity_provider_auth_tested field predicates
	IdentityProviderAuthTested    *bool `json:"identityProviderAuthTested,omitempty"`
	IdentityProviderAuthTestedNeq *bool `json:"identityProviderAuthTestedNEQ,omitempty"`
	// identity_provider_entity_id field predicates
	IdentityProviderEntityID             *string  `json:"identityProviderEntityID,omitempty"`
	IdentityProviderEntityIdneq          *string  `json:"identityProviderEntityIDNEQ,omitempty"`
	IdentityProviderEntityIDIn           []string `json:"identityProviderEntityIDIn,omitempty"`
	IdentityProviderEntityIDNotIn        []string `json:"identityProviderEntityIDNotIn,omitempty"`
	IdentityProviderEntityIdgt           *string  `json:"identityProviderEntityIDGT,omitempty"`
	IdentityProviderEntityIdgte          *string  `json:"identityProviderEntityIDGTE,omitempty"`
	IdentityProviderEntityIdlt           *string  `json:"identityProviderEntityIDLT,omitempty"`
	IdentityProviderEntityIdlte          *string  `json:"identityProviderEntityIDLTE,omitempty"`
	IdentityProviderEntityIDContains     *string  `json:"identityProviderEntityIDContains,omitempty"`
	IdentityProviderEntityIDHasPrefix    *string  `json:"identityProviderEntityIDHasPrefix,omitempty"`
	IdentityProviderEntityIDHasSuffix    *string  `json:"identityProviderEntityIDHasSuffix,omitempty"`
	IdentityProviderEntityIDIsNil        *bool    `json:"identityProviderEntityIDIsNil,omitempty"`
	IdentityProviderEntityIDNotNil       *bool    `json:"identityProviderEntityIDNotNil,omitempty"`
	IdentityProviderEntityIDEqualFold    *string  `json:"identityProviderEntityIDEqualFold,omitempty"`
	IdentityProviderEntityIDContainsFold *string  `json:"identityProviderEntityIDContainsFold,omitempty"`
	// oidc_discovery_endpoint field predicates
	OidcDiscoveryEndpoint             *string  `json:"oidcDiscoveryEndpoint,omitempty"`
	OidcDiscoveryEndpointNeq          *string  `json:"oidcDiscoveryEndpointNEQ,omitempty"`
	OidcDiscoveryEndpointIn           []string `json:"oidcDiscoveryEndpointIn,omitempty"`
	OidcDiscoveryEndpointNotIn        []string `json:"oidcDiscoveryEndpointNotIn,omitempty"`
	OidcDiscoveryEndpointGt           *string  `json:"oidcDiscoveryEndpointGT,omitempty"`
	OidcDiscoveryEndpointGte          *string  `json:"oidcDiscoveryEndpointGTE,omitempty"`
	OidcDiscoveryEndpointLt           *string  `json:"oidcDiscoveryEndpointLT,omitempty"`
	OidcDiscoveryEndpointLte          *string  `json:"oidcDiscoveryEndpointLTE,omitempty"`
	OidcDiscoveryEndpointContains     *string  `json:"oidcDiscoveryEndpointContains,omitempty"`
	OidcDiscoveryEndpointHasPrefix    *string  `json:"oidcDiscoveryEndpointHasPrefix,omitempty"`
	OidcDiscoveryEndpointHasSuffix    *string  `json:"oidcDiscoveryEndpointHasSuffix,omitempty"`
	OidcDiscoveryEndpointIsNil        *bool    `json:"oidcDiscoveryEndpointIsNil,omitempty"`
	OidcDiscoveryEndpointNotNil       *bool    `json:"oidcDiscoveryEndpointNotNil,omitempty"`
	OidcDiscoveryEndpointEqualFold    *string  `json:"oidcDiscoveryEndpointEqualFold,omitempty"`
	OidcDiscoveryEndpointContainsFold *string  `json:"oidcDiscoveryEndpointContainsFold,omitempty"`
	// saml_signin_url field predicates
	SamlSigninURL             *string  `json:"samlSigninURL,omitempty"`
	SamlSigninURLNeq          *string  `json:"samlSigninURLNEQ,omitempty"`
	SamlSigninURLIn           []string `json:"samlSigninURLIn,omitempty"`
	SamlSigninURLNotIn        []string `json:"samlSigninURLNotIn,omitempty"`
	SamlSigninURLGt           *string  `json:"samlSigninURLGT,omitempty"`
	SamlSigninURLGte          *string  `json:"samlSigninURLGTE,omitempty"`
	SamlSigninURLLt           *string  `json:"samlSigninURLLT,omitempty"`
	SamlSigninURLLte          *string  `json:"samlSigninURLLTE,omitempty"`
	SamlSigninURLContains     *string  `json:"samlSigninURLContains,omitempty"`
	SamlSigninURLHasPrefix    *string  `json:"samlSigninURLHasPrefix,omitempty"`
	SamlSigninURLHasSuffix    *string  `json:"samlSigninURLHasSuffix,omitempty"`
	SamlSigninURLIsNil        *bool    `json:"samlSigninURLIsNil,omitempty"`
	SamlSigninURLNotNil       *bool    `json:"samlSigninURLNotNil,omitempty"`
	SamlSigninURLEqualFold    *string  `json:"samlSigninURLEqualFold,omitempty"`
	SamlSigninURLContainsFold *string  `json:"samlSigninURLContainsFold,omitempty"`
	// saml_issuer field predicates
	SamlIssuer             *string  `json:"samlIssuer,omitempty"`
	SamlIssuerNeq          *string  `json:"samlIssuerNEQ,omitempty"`
	SamlIssuerIn           []string `json:"samlIssuerIn,omitempty"`
	SamlIssuerNotIn        []string `json:"samlIssuerNotIn,omitempty"`
	SamlIssuerGt           *string  `json:"samlIssuerGT,omitempty"`
	SamlIssuerGte          *string  `json:"samlIssuerGTE,omitempty"`
	SamlIssuerLt           *string  `json:"samlIssuerLT,omitempty"`
	SamlIssuerLte          *string  `json:"samlIssuerLTE,omitempty"`
	SamlIssuerContains     *string  `json:"samlIssuerContains,omitempty"`
	SamlIssuerHasPrefix    *string  `json:"samlIssuerHasPrefix,omitempty"`
	SamlIssuerHasSuffix    *string  `json:"samlIssuerHasSuffix,omitempty"`
	SamlIssuerIsNil        *bool    `json:"samlIssuerIsNil,omitempty"`
	SamlIssuerNotNil       *bool    `json:"samlIssuerNotNil,omitempty"`
	SamlIssuerEqualFold    *string  `json:"samlIssuerEqualFold,omitempty"`
	SamlIssuerContainsFold *string  `json:"samlIssuerContainsFold,omitempty"`
	// saml_cert field predicates
	SamlCert             *string  `json:"samlCert,omitempty"`
	SamlCertNeq          *string  `json:"samlCertNEQ,omitempty"`
	SamlCertIn           []string `json:"samlCertIn,omitempty"`
	SamlCertNotIn        []string `json:"samlCertNotIn,omitempty"`
	SamlCertGt           *string  `json:"samlCertGT,omitempty"`
	SamlCertGte          *string  `json:"samlCertGTE,omitempty"`
	SamlCertLt           *string  `json:"samlCertLT,omitempty"`
	SamlCertLte          *string  `json:"samlCertLTE,omitempty"`
	SamlCertContains     *string  `json:"samlCertContains,omitempty"`
	SamlCertHasPrefix    *string  `json:"samlCertHasPrefix,omitempty"`
	SamlCertHasSuffix    *string  `json:"samlCertHasSuffix,omitempty"`
	SamlCertIsNil        *bool    `json:"samlCertIsNil,omitempty"`
	SamlCertNotNil       *bool    `json:"samlCertNotNil,omitempty"`
	SamlCertEqualFold    *string  `json:"samlCertEqualFold,omitempty"`
	SamlCertContainsFold *string  `json:"samlCertContainsFold,omitempty"`
	// identity_provider_login_enforced field predicates
	IdentityProviderLoginEnforced    *bool `json:"identityProviderLoginEnforced,omitempty"`
	IdentityProviderLoginEnforcedNeq *bool `json:"identityProviderLoginEnforcedNEQ,omitempty"`
	// multifactor_auth_enforced field predicates
	MultifactorAuthEnforced       *bool `json:"multifactorAuthEnforced,omitempty"`
	MultifactorAuthEnforcedNeq    *bool `json:"multifactorAuthEnforcedNEQ,omitempty"`
	MultifactorAuthEnforcedIsNil  *bool `json:"multifactorAuthEnforcedIsNil,omitempty"`
	MultifactorAuthEnforcedNotNil *bool `json:"multifactorAuthEnforcedNotNil,omitempty"`
	// compliance_webhook_token field predicates
	ComplianceWebhookToken             *string  `json:"complianceWebhookToken,omitempty"`
	ComplianceWebhookTokenNeq          *string  `json:"complianceWebhookTokenNEQ,omitempty"`
	ComplianceWebhookTokenIn           []string `json:"complianceWebhookTokenIn,omitempty"`
	ComplianceWebhookTokenNotIn        []string `json:"complianceWebhookTokenNotIn,omitempty"`
	ComplianceWebhookTokenGt           *string  `json:"complianceWebhookTokenGT,omitempty"`
	ComplianceWebhookTokenGte          *string  `json:"complianceWebhookTokenGTE,omitempty"`
	ComplianceWebhookTokenLt           *string  `json:"complianceWebhookTokenLT,omitempty"`
	ComplianceWebhookTokenLte          *string  `json:"complianceWebhookTokenLTE,omitempty"`
	ComplianceWebhookTokenContains     *string  `json:"complianceWebhookTokenContains,omitempty"`
	ComplianceWebhookTokenHasPrefix    *string  `json:"complianceWebhookTokenHasPrefix,omitempty"`
	ComplianceWebhookTokenHasSuffix    *string  `json:"complianceWebhookTokenHasSuffix,omitempty"`
	ComplianceWebhookTokenIsNil        *bool    `json:"complianceWebhookTokenIsNil,omitempty"`
	ComplianceWebhookTokenNotNil       *bool    `json:"complianceWebhookTokenNotNil,omitempty"`
	ComplianceWebhookTokenEqualFold    *string  `json:"complianceWebhookTokenEqualFold,omitempty"`
	ComplianceWebhookTokenContainsFold *string  `json:"complianceWebhookTokenContainsFold,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// Return response for transferOrganizationOwnership mutation
type OrganizationTransferOwnershipPayload struct {
	// Updated organization
	Organization *Organization `json:"organization"`
	// Whether an invitation was sent (true if new owner wasn't a member)
	InvitationSent bool `json:"invitationSent"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization *Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIdneq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIdgt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIdgte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIdlt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIdlte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// control_creators edge predicates
	HasControlCreators     *bool              `json:"hasControlCreators,omitempty"`
	HasControlCreatorsWith []*GroupWhereInput `json:"hasControlCreatorsWith,omitempty"`
	// control_implementation_creators edge predicates
	HasControlImplementationCreators     *bool              `json:"hasControlImplementationCreators,omitempty"`
	HasControlImplementationCreatorsWith []*GroupWhereInput `json:"hasControlImplementationCreatorsWith,omitempty"`
	// control_objective_creators edge predicates
	HasControlObjectiveCreators     *bool              `json:"hasControlObjectiveCreators,omitempty"`
	HasControlObjectiveCreatorsWith []*GroupWhereInput `json:"hasControlObjectiveCreatorsWith,omitempty"`
	// evidence_creators edge predicates
	HasEvidenceCreators     *bool              `json:"hasEvidenceCreators,omitempty"`
	HasEvidenceCreatorsWith []*GroupWhereInput `json:"hasEvidenceCreatorsWith,omitempty"`
	// group_creators edge predicates
	HasGroupCreators     *bool              `json:"hasGroupCreators,omitempty"`
	HasGroupCreatorsWith []*GroupWhereInput `json:"hasGroupCreatorsWith,omitempty"`
	// internal_policy_creators edge predicates
	HasInternalPolicyCreators     *bool              `json:"hasInternalPolicyCreators,omitempty"`
	HasInternalPolicyCreatorsWith []*GroupWhereInput `json:"hasInternalPolicyCreatorsWith,omitempty"`
	// mapped_control_creators edge predicates
	HasMappedControlCreators     *bool              `json:"hasMappedControlCreators,omitempty"`
	HasMappedControlCreatorsWith []*GroupWhereInput `json:"hasMappedControlCreatorsWith,omitempty"`
	// narrative_creators edge predicates
	HasNarrativeCreators     *bool              `json:"hasNarrativeCreators,omitempty"`
	HasNarrativeCreatorsWith []*GroupWhereInput `json:"hasNarrativeCreatorsWith,omitempty"`
	// procedure_creators edge predicates
	HasProcedureCreators     *bool              `json:"hasProcedureCreators,omitempty"`
	HasProcedureCreatorsWith []*GroupWhereInput `json:"hasProcedureCreatorsWith,omitempty"`
	// program_creators edge predicates
	HasProgramCreators     *bool              `json:"hasProgramCreators,omitempty"`
	HasProgramCreatorsWith []*GroupWhereInput `json:"hasProgramCreatorsWith,omitempty"`
	// risk_creators edge predicates
	HasRiskCreators     *bool              `json:"hasRiskCreators,omitempty"`
	HasRiskCreatorsWith []*GroupWhereInput `json:"hasRiskCreatorsWith,omitempty"`
	// scheduled_job_creators edge predicates
	HasScheduledJobCreators     *bool              `json:"hasScheduledJobCreators,omitempty"`
	HasScheduledJobCreatorsWith []*GroupWhereInput `json:"hasScheduledJobCreatorsWith,omitempty"`
	// standard_creators edge predicates
	HasStandardCreators     *bool              `json:"hasStandardCreators,omitempty"`
	HasStandardCreatorsWith []*GroupWhereInput `json:"hasStandardCreatorsWith,omitempty"`
	// template_creators edge predicates
	HasTemplateCreators     *bool              `json:"hasTemplateCreators,omitempty"`
	HasTemplateCreatorsWith []*GroupWhereInput `json:"hasTemplateCreatorsWith,omitempty"`
	// subprocessor_creators edge predicates
	HasSubprocessorCreators     *bool              `json:"hasSubprocessorCreators,omitempty"`
	HasSubprocessorCreatorsWith []*GroupWhereInput `json:"hasSubprocessorCreatorsWith,omitempty"`
	// trust_center_doc_creators edge predicates
	HasTrustCenterDocCreators     *bool              `json:"hasTrustCenterDocCreators,omitempty"`
	HasTrustCenterDocCreatorsWith []*GroupWhereInput `json:"hasTrustCenterDocCreatorsWith,omitempty"`
	// trust_center_subprocessor_creators edge predicates
	HasTrustCenterSubprocessorCreators     *bool              `json:"hasTrustCenterSubprocessorCreators,omitempty"`
	HasTrustCenterSubprocessorCreatorsWith []*GroupWhereInput `json:"hasTrustCenterSubprocessorCreatorsWith,omitempty"`
	// parent edge predicates
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                            `json:"hasSetting,omitempty"`
	HasSettingWith []*OrganizationSettingWhereInput `json:"hasSettingWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// api_tokens edge predicates
	HasAPITokens     *bool                 `json:"hasAPITokens,omitempty"`
	HasAPITokensWith []*APITokenWhereInput `json:"hasAPITokensWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// avatar_file edge predicates
	HasAvatarFile     *bool             `json:"hasAvatarFile,omitempty"`
	HasAvatarFileWith []*FileWhereInput `json:"hasAvatarFileWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// templates edge predicates
	HasTemplates     *bool                 `json:"hasTemplates,omitempty"`
	HasTemplatesWith []*TemplateWhereInput `json:"hasTemplatesWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// org_subscriptions edge predicates
	HasOrgSubscriptions     *bool                        `json:"hasOrgSubscriptions,omitempty"`
	HasOrgSubscriptionsWith []*OrgSubscriptionWhereInput `json:"hasOrgSubscriptionsWith,omitempty"`
	// invites edge predicates
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`
	// subscribers edge predicates
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// entity_types edge predicates
	HasEntityTypes     *bool                   `json:"hasEntityTypes,omitempty"`
	HasEntityTypesWith []*EntityTypeWhereInput `json:"hasEntityTypesWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// control_implementations edge predicates
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`
	// mapped_controls edge predicates
	HasMappedControls     *bool                      `json:"hasMappedControls,omitempty"`
	HasMappedControlsWith []*MappedControlWhereInput `json:"hasMappedControlsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// standards edge predicates
	HasStandards     *bool                 `json:"hasStandards,omitempty"`
	HasStandardsWith []*StandardWhereInput `json:"hasStandardsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// custom_domains edge predicates
	HasCustomDomains     *bool                     `json:"hasCustomDomains,omitempty"`
	HasCustomDomainsWith []*CustomDomainWhereInput `json:"hasCustomDomainsWith,omitempty"`
	// job_runners edge predicates
	HasJobRunners     *bool                  `json:"hasJobRunners,omitempty"`
	HasJobRunnersWith []*JobRunnerWhereInput `json:"hasJobRunnersWith,omitempty"`
	// job_runner_tokens edge predicates
	HasJobRunnerTokens     *bool                       `json:"hasJobRunnerTokens,omitempty"`
	HasJobRunnerTokensWith []*JobRunnerTokenWhereInput `json:"hasJobRunnerTokensWith,omitempty"`
	// job_runner_registration_tokens edge predicates
	HasJobRunnerRegistrationTokens     *bool                                   `json:"hasJobRunnerRegistrationTokens,omitempty"`
	HasJobRunnerRegistrationTokensWith []*JobRunnerRegistrationTokenWhereInput `json:"hasJobRunnerRegistrationTokensWith,omitempty"`
	// dns_verifications edge predicates
	HasDNSVerifications     *bool                        `json:"hasDNSVerifications,omitempty"`
	HasDNSVerificationsWith []*DNSVerificationWhereInput `json:"hasDNSVerificationsWith,omitempty"`
	// job_templates edge predicates
	HasJobTemplates     *bool                    `json:"hasJobTemplates,omitempty"`
	HasJobTemplatesWith []*JobTemplateWhereInput `json:"hasJobTemplatesWith,omitempty"`
	// scheduled_jobs edge predicates
	HasScheduledJobs     *bool                     `json:"hasScheduledJobs,omitempty"`
	HasScheduledJobsWith []*ScheduledJobWhereInput `json:"hasScheduledJobsWith,omitempty"`
	// job_results edge predicates
	HasJobResults     *bool                  `json:"hasJobResults,omitempty"`
	HasJobResultsWith []*JobResultWhereInput `json:"hasJobResultsWith,omitempty"`
	// scheduled_job_runs edge predicates
	HasScheduledJobRuns     *bool                        `json:"hasScheduledJobRuns,omitempty"`
	HasScheduledJobRunsWith []*ScheduledJobRunWhereInput `json:"hasScheduledJobRunsWith,omitempty"`
	// trust_centers edge predicates
	HasTrustCenters     *bool                    `json:"hasTrustCenters,omitempty"`
	HasTrustCentersWith []*TrustCenterWhereInput `json:"hasTrustCentersWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// scans edge predicates
	HasScans     *bool             `json:"hasScans,omitempty"`
	HasScansWith []*ScanWhereInput `json:"hasScansWith,omitempty"`
	// subprocessors edge predicates
	HasSubprocessors     *bool                     `json:"hasSubprocessors,omitempty"`
	HasSubprocessorsWith []*SubprocessorWhereInput `json:"hasSubprocessorsWith,omitempty"`
	// exports edge predicates
	HasExports     *bool               `json:"hasExports,omitempty"`
	HasExportsWith []*ExportWhereInput `json:"hasExportsWith,omitempty"`
	// trust_center_watermark_configs edge predicates
	HasTrustCenterWatermarkConfigs     *bool                                   `json:"hasTrustCenterWatermarkConfigs,omitempty"`
	HasTrustCenterWatermarkConfigsWith []*TrustCenterWatermarkConfigWhereInput `json:"hasTrustCenterWatermarkConfigsWith,omitempty"`
	// assessments edge predicates
	HasAssessments     *bool                   `json:"hasAssessments,omitempty"`
	HasAssessmentsWith []*AssessmentWhereInput `json:"hasAssessmentsWith,omitempty"`
	// assessment_responses edge predicates
	HasAssessmentResponses     *bool                           `json:"hasAssessmentResponses,omitempty"`
	HasAssessmentResponsesWith []*AssessmentResponseWhereInput `json:"hasAssessmentResponsesWith,omitempty"`
	// custom_type_enums edge predicates
	HasCustomTypeEnums     *bool                       `json:"hasCustomTypeEnums,omitempty"`
	HasCustomTypeEnumsWith []*CustomTypeEnumWhereInput `json:"hasCustomTypeEnumsWith,omitempty"`
	// tag_definitions edge predicates
	HasTagDefinitions     *bool                      `json:"hasTagDefinitions,omitempty"`
	HasTagDefinitionsWith []*TagDefinitionWhereInput `json:"hasTagDefinitionsWith,omitempty"`
	// remediations edge predicates
	HasRemediations     *bool                    `json:"hasRemediations,omitempty"`
	HasRemediationsWith []*RemediationWhereInput `json:"hasRemediationsWith,omitempty"`
	// findings edge predicates
	HasFindings     *bool                `json:"hasFindings,omitempty"`
	HasFindingsWith []*FindingWhereInput `json:"hasFindingsWith,omitempty"`
	// reviews edge predicates
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`
	// vulnerabilities edge predicates
	HasVulnerabilities     *bool                      `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*VulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`
	// workflow_definitions edge predicates
	HasWorkflowDefinitions     *bool                           `json:"hasWorkflowDefinitions,omitempty"`
	HasWorkflowDefinitionsWith []*WorkflowDefinitionWhereInput `json:"hasWorkflowDefinitionsWith,omitempty"`
	// workflow_instances edge predicates
	HasWorkflowInstances     *bool                         `json:"hasWorkflowInstances,omitempty"`
	HasWorkflowInstancesWith []*WorkflowInstanceWhereInput `json:"hasWorkflowInstancesWith,omitempty"`
	// workflow_events edge predicates
	HasWorkflowEvents     *bool                      `json:"hasWorkflowEvents,omitempty"`
	HasWorkflowEventsWith []*WorkflowEventWhereInput `json:"hasWorkflowEventsWith,omitempty"`
	// workflow_assignments edge predicates
	HasWorkflowAssignments     *bool                           `json:"hasWorkflowAssignments,omitempty"`
	HasWorkflowAssignmentsWith []*WorkflowAssignmentWhereInput `json:"hasWorkflowAssignmentsWith,omitempty"`
	// workflow_assignment_targets edge predicates
	HasWorkflowAssignmentTargets     *bool                                 `json:"hasWorkflowAssignmentTargets,omitempty"`
	HasWorkflowAssignmentTargetsWith []*WorkflowAssignmentTargetWhereInput `json:"hasWorkflowAssignmentTargetsWith,omitempty"`
	// workflow_object_refs edge predicates
	HasWorkflowObjectRefs     *bool                          `json:"hasWorkflowObjectRefs,omitempty"`
	HasWorkflowObjectRefsWith []*WorkflowObjectRefWhereInput `json:"hasWorkflowObjectRefsWith,omitempty"`
	// directory_accounts edge predicates
	HasDirectoryAccounts     *bool                         `json:"hasDirectoryAccounts,omitempty"`
	HasDirectoryAccountsWith []*DirectoryAccountWhereInput `json:"hasDirectoryAccountsWith,omitempty"`
	// directory_groups edge predicates
	HasDirectoryGroups     *bool                       `json:"hasDirectoryGroups,omitempty"`
	HasDirectoryGroupsWith []*DirectoryGroupWhereInput `json:"hasDirectoryGroupsWith,omitempty"`
	// directory_memberships edge predicates
	HasDirectoryMemberships     *bool                            `json:"hasDirectoryMemberships,omitempty"`
	HasDirectoryMembershipsWith []*DirectoryMembershipWhereInput `json:"hasDirectoryMembershipsWith,omitempty"`
	// directory_sync_runs edge predicates
	HasDirectorySyncRuns     *bool                         `json:"hasDirectorySyncRuns,omitempty"`
	HasDirectorySyncRunsWith []*DirectorySyncRunWhereInput `json:"hasDirectorySyncRunsWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                      `json:"hasMembers,omitempty"`
	HasMembersWith []*OrgMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PersonalAccessToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string  `json:"description,omitempty"`
	Scopes      []string `json:"scopes,omitempty"`
	// SSO authorization timestamps by organization id
	SsoAuthorizations *string    `json:"ssoAuthorizations,omitempty"`
	LastUsedAt        *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt     *time.Time              `json:"revokedAt,omitempty"`
	Owner         *User                   `json:"owner"`
	Organizations *OrganizationConnection `json:"organizations"`
	Events        *EventConnection        `json:"events"`
}

func (PersonalAccessToken) IsNode() {}

// Return response for createBulkPersonalAccessToken mutation
type PersonalAccessTokenBulkCreatePayload struct {
	// Created personalAccessTokens
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
}

// A connection to a list of items.
type PersonalAccessTokenConnection struct {
	// A list of edges.
	Edges []*PersonalAccessTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPersonalAccessToken mutation
type PersonalAccessTokenCreatePayload struct {
	// Created personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// Return response for deletePersonalAccessToken mutation
type PersonalAccessTokenDeletePayload struct {
	// Deleted personalAccessToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type PersonalAccessTokenEdge struct {
	// The item at the end of the edge.
	Node *PersonalAccessToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for PersonalAccessToken connections
type PersonalAccessTokenOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order PersonalAccessTokens.
	Field PersonalAccessTokenOrderField `json:"field"`
}

// Return response for updatePersonalAccessToken mutation
type PersonalAccessTokenUpdatePayload struct {
	// Updated personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
// Input was generated by ent.
type PersonalAccessTokenWhereInput struct {
	Not *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	And []*PersonalAccessTokenWhereInput `json:"and,omitempty"`
	Or  []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// is_active field predicates
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNeq    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  *bool `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil *bool `json:"isActiveNotNil,omitempty"`
	// revoked_reason field predicates
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNeq          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGt           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGte          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLt           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLte          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        *bool    `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       *bool    `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`
	// revoked_by field predicates
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNeq          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGt           *string  `json:"revokedByGT,omitempty"`
	RevokedByGte          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLt           *string  `json:"revokedByLT,omitempty"`
	RevokedByLte          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        *bool    `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       *bool    `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`
	// revoked_at field predicates
	RevokedAt       *time.Time   `json:"revokedAt,omitempty"`
	RevokedAtNeq    *time.Time   `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []*time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []*time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGt     *time.Time   `json:"revokedAtGT,omitempty"`
	RevokedAtGte    *time.Time   `json:"revokedAtGTE,omitempty"`
	RevokedAtLt     *time.Time   `json:"revokedAtLT,omitempty"`
	RevokedAtLte    *time.Time   `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  *bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil *bool        `json:"revokedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Procedure struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// status of the procedure, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the procedure, e.g. compliance, operational, health and safety, etc.
	ProcedureType *string `json:"procedureType,omitempty"`
	// details of the procedure
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the procedure
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the procedure should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the procedure should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// the id of the group responsible for approving the procedure
	ApproverID *string `json:"approverID,omitempty"`
	// the id of the group responsible for approving the procedure
	DelegateID *string `json:"delegateID,omitempty"`
	Summary    *string `json:"summary,omitempty"`
	// auto-generated tag suggestions for the procedure
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the procedure
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the procedure
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the procedure
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the procedure
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the procedure
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the procedure
	URL *string `json:"url,omitempty"`
	// This will contain the most recent file id if this procedure was created from a file
	FileID *string `json:"fileID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the procedure
	ProcedureKindName *string `json:"procedureKindName,omitempty"`
	// the kind of the procedure
	ProcedureKindID *string          `json:"procedureKindID,omitempty"`
	Owner           *Organization    `json:"owner,omitempty"`
	BlockedGroups   *GroupConnection `json:"blockedGroups"`
	Editors         *GroupConnection `json:"editors"`
	// the group of users who are responsible for approving the procedure
	Approver *Group `json:"approver,omitempty"`
	// temporary delegates for the procedure, used for temporary approval
	Delegate         *Group                    `json:"delegate,omitempty"`
	ProcedureKind    *CustomTypeEnum           `json:"procedureKind,omitempty"`
	Controls         *ControlConnection        `json:"controls"`
	Subcontrols      *SubcontrolConnection     `json:"subcontrols"`
	InternalPolicies *InternalPolicyConnection `json:"internalPolicies"`
	Programs         *ProgramConnection        `json:"programs"`
	Narratives       *NarrativeConnection      `json:"narratives"`
	Risks            *RiskConnection           `json:"risks"`
	Tasks            *TaskConnection           `json:"tasks"`
	Comments         *NoteConnection           `json:"comments"`
	File             *File                     `json:"file,omitempty"`
}

func (Procedure) IsNode() {}

// Return response for createBulkProcedure mutation
type ProcedureBulkCreatePayload struct {
	// Created procedures
	Procedures []*Procedure `json:"procedures,omitempty"`
}

// Return response for deleteBulkProcedure mutation
type ProcedureBulkDeletePayload struct {
	// Deleted export IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkProcedure mutation
type ProcedureBulkUpdatePayload struct {
	// Updated procedures
	Procedures []*Procedure `json:"procedures,omitempty"`
	// IDs of the updated procedures
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type ProcedureConnection struct {
	// A list of edges.
	Edges []*ProcedureEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProcedure mutation
type ProcedureCreatePayload struct {
	// Created procedure
	Procedure *Procedure `json:"procedure"`
}

// Return response for deleteProcedure mutation
type ProcedureDeletePayload struct {
	// Deleted procedure ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProcedureEdge struct {
	// The item at the end of the edge.
	Node *Procedure `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProcedureHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// status of the procedure, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the procedure, e.g. compliance, operational, health and safety, etc.
	ProcedureType *string `json:"procedureType,omitempty"`
	// details of the procedure
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the procedure
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the procedure should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the procedure should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// the id of the group responsible for approving the procedure
	ApproverID *string `json:"approverID,omitempty"`
	// the id of the group responsible for approving the procedure
	DelegateID *string `json:"delegateID,omitempty"`
	Summary    *string `json:"summary,omitempty"`
	// auto-generated tag suggestions for the procedure
	TagSuggestions []string `json:"tagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the procedure
	DismissedTagSuggestions []string `json:"dismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the procedure
	ControlSuggestions []string `json:"controlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the procedure
	DismissedControlSuggestions []string `json:"dismissedControlSuggestions,omitempty"`
	// suggested improvements for the procedure
	ImprovementSuggestions []string `json:"improvementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the procedure
	DismissedImprovementSuggestions []string `json:"dismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the procedure
	URL *string `json:"url,omitempty"`
	// This will contain the most recent file id if this procedure was created from a file
	FileID *string `json:"fileID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the procedure
	ProcedureKindName *string `json:"procedureKindName,omitempty"`
	// the kind of the procedure
	ProcedureKindID *string `json:"procedureKindID,omitempty"`
}

func (ProcedureHistory) IsNode() {}

// A connection to a list of items.
type ProcedureHistoryConnection struct {
	// A list of edges.
	Edges []*ProcedureHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProcedureHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProcedureHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ProcedureHistory connections
type ProcedureHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ProcedureHistories.
	Field ProcedureHistoryOrderField `json:"field"`
}

// ProcedureHistoryWhereInput is used for filtering ProcedureHistory objects.
// Input was generated by ent.
type ProcedureHistoryWhereInput struct {
	Not *ProcedureHistoryWhereInput   `json:"not,omitempty"`
	And []*ProcedureHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProcedureHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// procedure_type field predicates
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNeq          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGt           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGte          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLt           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLte          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        *bool    `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       *bool    `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// approver_id field predicates
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIdneq          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIdgt           *string  `json:"approverIDGT,omitempty"`
	ApproverIdgte          *string  `json:"approverIDGTE,omitempty"`
	ApproverIdlt           *string  `json:"approverIDLT,omitempty"`
	ApproverIdlte          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        *bool    `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       *bool    `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDIsNil        *bool    `json:"fileIDIsNil,omitempty"`
	FileIDNotNil       *bool    `json:"fileIDNotNil,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// procedure_kind_name field predicates
	ProcedureKindName             *string  `json:"procedureKindName,omitempty"`
	ProcedureKindNameNeq          *string  `json:"procedureKindNameNEQ,omitempty"`
	ProcedureKindNameIn           []string `json:"procedureKindNameIn,omitempty"`
	ProcedureKindNameNotIn        []string `json:"procedureKindNameNotIn,omitempty"`
	ProcedureKindNameGt           *string  `json:"procedureKindNameGT,omitempty"`
	ProcedureKindNameGte          *string  `json:"procedureKindNameGTE,omitempty"`
	ProcedureKindNameLt           *string  `json:"procedureKindNameLT,omitempty"`
	ProcedureKindNameLte          *string  `json:"procedureKindNameLTE,omitempty"`
	ProcedureKindNameContains     *string  `json:"procedureKindNameContains,omitempty"`
	ProcedureKindNameHasPrefix    *string  `json:"procedureKindNameHasPrefix,omitempty"`
	ProcedureKindNameHasSuffix    *string  `json:"procedureKindNameHasSuffix,omitempty"`
	ProcedureKindNameIsNil        *bool    `json:"procedureKindNameIsNil,omitempty"`
	ProcedureKindNameNotNil       *bool    `json:"procedureKindNameNotNil,omitempty"`
	ProcedureKindNameEqualFold    *string  `json:"procedureKindNameEqualFold,omitempty"`
	ProcedureKindNameContainsFold *string  `json:"procedureKindNameContainsFold,omitempty"`
	// procedure_kind_id field predicates
	ProcedureKindID             *string  `json:"procedureKindID,omitempty"`
	ProcedureKindIdneq          *string  `json:"procedureKindIDNEQ,omitempty"`
	ProcedureKindIDIn           []string `json:"procedureKindIDIn,omitempty"`
	ProcedureKindIDNotIn        []string `json:"procedureKindIDNotIn,omitempty"`
	ProcedureKindIdgt           *string  `json:"procedureKindIDGT,omitempty"`
	ProcedureKindIdgte          *string  `json:"procedureKindIDGTE,omitempty"`
	ProcedureKindIdlt           *string  `json:"procedureKindIDLT,omitempty"`
	ProcedureKindIdlte          *string  `json:"procedureKindIDLTE,omitempty"`
	ProcedureKindIDContains     *string  `json:"procedureKindIDContains,omitempty"`
	ProcedureKindIDHasPrefix    *string  `json:"procedureKindIDHasPrefix,omitempty"`
	ProcedureKindIDHasSuffix    *string  `json:"procedureKindIDHasSuffix,omitempty"`
	ProcedureKindIDIsNil        *bool    `json:"procedureKindIDIsNil,omitempty"`
	ProcedureKindIDNotNil       *bool    `json:"procedureKindIDNotNil,omitempty"`
	ProcedureKindIDEqualFold    *string  `json:"procedureKindIDEqualFold,omitempty"`
	ProcedureKindIDContainsFold *string  `json:"procedureKindIDContainsFold,omitempty"`
}

// Ordering options for Procedure connections
type ProcedureOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Procedures.
	Field ProcedureOrderField `json:"field"`
}

// Return response for updateProcedure mutation
type ProcedureUpdatePayload struct {
	// Updated procedure
	Procedure *Procedure `json:"procedure"`
}

// ProcedureWhereInput is used for filtering Procedure objects.
// Input was generated by ent.
type ProcedureWhereInput struct {
	Not *ProcedureWhereInput   `json:"not,omitempty"`
	And []*ProcedureWhereInput `json:"and,omitempty"`
	Or  []*ProcedureWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// procedure_type field predicates
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNeq          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGt           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGte          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLt           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLte          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        *bool    `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       *bool    `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// approver_id field predicates
	ApproverID             *string  `json:"approverID,omitempty"`
	ApproverIdneq          *string  `json:"approverIDNEQ,omitempty"`
	ApproverIDIn           []string `json:"approverIDIn,omitempty"`
	ApproverIDNotIn        []string `json:"approverIDNotIn,omitempty"`
	ApproverIdgt           *string  `json:"approverIDGT,omitempty"`
	ApproverIdgte          *string  `json:"approverIDGTE,omitempty"`
	ApproverIdlt           *string  `json:"approverIDLT,omitempty"`
	ApproverIdlte          *string  `json:"approverIDLTE,omitempty"`
	ApproverIDContains     *string  `json:"approverIDContains,omitempty"`
	ApproverIDHasPrefix    *string  `json:"approverIDHasPrefix,omitempty"`
	ApproverIDHasSuffix    *string  `json:"approverIDHasSuffix,omitempty"`
	ApproverIDIsNil        *bool    `json:"approverIDIsNil,omitempty"`
	ApproverIDNotNil       *bool    `json:"approverIDNotNil,omitempty"`
	ApproverIDEqualFold    *string  `json:"approverIDEqualFold,omitempty"`
	ApproverIDContainsFold *string  `json:"approverIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDIsNil        *bool    `json:"fileIDIsNil,omitempty"`
	FileIDNotNil       *bool    `json:"fileIDNotNil,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// procedure_kind_name field predicates
	ProcedureKindName             *string  `json:"procedureKindName,omitempty"`
	ProcedureKindNameNeq          *string  `json:"procedureKindNameNEQ,omitempty"`
	ProcedureKindNameIn           []string `json:"procedureKindNameIn,omitempty"`
	ProcedureKindNameNotIn        []string `json:"procedureKindNameNotIn,omitempty"`
	ProcedureKindNameGt           *string  `json:"procedureKindNameGT,omitempty"`
	ProcedureKindNameGte          *string  `json:"procedureKindNameGTE,omitempty"`
	ProcedureKindNameLt           *string  `json:"procedureKindNameLT,omitempty"`
	ProcedureKindNameLte          *string  `json:"procedureKindNameLTE,omitempty"`
	ProcedureKindNameContains     *string  `json:"procedureKindNameContains,omitempty"`
	ProcedureKindNameHasPrefix    *string  `json:"procedureKindNameHasPrefix,omitempty"`
	ProcedureKindNameHasSuffix    *string  `json:"procedureKindNameHasSuffix,omitempty"`
	ProcedureKindNameIsNil        *bool    `json:"procedureKindNameIsNil,omitempty"`
	ProcedureKindNameNotNil       *bool    `json:"procedureKindNameNotNil,omitempty"`
	ProcedureKindNameEqualFold    *string  `json:"procedureKindNameEqualFold,omitempty"`
	ProcedureKindNameContainsFold *string  `json:"procedureKindNameContainsFold,omitempty"`
	// procedure_kind_id field predicates
	ProcedureKindID             *string  `json:"procedureKindID,omitempty"`
	ProcedureKindIdneq          *string  `json:"procedureKindIDNEQ,omitempty"`
	ProcedureKindIDIn           []string `json:"procedureKindIDIn,omitempty"`
	ProcedureKindIDNotIn        []string `json:"procedureKindIDNotIn,omitempty"`
	ProcedureKindIdgt           *string  `json:"procedureKindIDGT,omitempty"`
	ProcedureKindIdgte          *string  `json:"procedureKindIDGTE,omitempty"`
	ProcedureKindIdlt           *string  `json:"procedureKindIDLT,omitempty"`
	ProcedureKindIdlte          *string  `json:"procedureKindIDLTE,omitempty"`
	ProcedureKindIDContains     *string  `json:"procedureKindIDContains,omitempty"`
	ProcedureKindIDHasPrefix    *string  `json:"procedureKindIDHasPrefix,omitempty"`
	ProcedureKindIDHasSuffix    *string  `json:"procedureKindIDHasSuffix,omitempty"`
	ProcedureKindIDIsNil        *bool    `json:"procedureKindIDIsNil,omitempty"`
	ProcedureKindIDNotNil       *bool    `json:"procedureKindIDNotNil,omitempty"`
	ProcedureKindIDEqualFold    *string  `json:"procedureKindIDEqualFold,omitempty"`
	ProcedureKindIDContainsFold *string  `json:"procedureKindIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// approver edge predicates
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// procedure_kind edge predicates
	HasProcedureKind     *bool                       `json:"hasProcedureKind,omitempty"`
	HasProcedureKindWith []*CustomTypeEnumWhereInput `json:"hasProcedureKindWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

type Program struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the kind of the program
	ProgramKindName *string `json:"programKindName,omitempty"`
	// the kind of the program
	ProgramKindID *string `json:"programKindID,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status enums.ProgramStatus `json:"status"`
	// the type of the program
	ProgramType enums.ProgramType `json:"programType"`
	// the short name of the compliance standard the program is based on, only used for framework type programs
	FrameworkName *string `json:"frameworkName,omitempty"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady bool `json:"auditorReady"`
	// can the auditor write comments
	AuditorWriteComments bool `json:"auditorWriteComments"`
	// can the auditor read comments
	AuditorReadComments bool `json:"auditorReadComments"`
	// the name of the audit firm conducting the audit
	AuditFirm *string `json:"auditFirm,omitempty"`
	// the full name of the auditor conducting the audit
	Auditor *string `json:"auditor,omitempty"`
	// the email of the auditor conducting the audit
	AuditorEmail *string `json:"auditorEmail,omitempty"`
	// the id of the user who is responsible for this program
	ProgramOwnerID    *string                      `json:"programOwnerID,omitempty"`
	Owner             *Organization                `json:"owner,omitempty"`
	BlockedGroups     *GroupConnection             `json:"blockedGroups"`
	Editors           *GroupConnection             `json:"editors"`
	Viewers           *GroupConnection             `json:"viewers"`
	ProgramKind       *CustomTypeEnum              `json:"programKind,omitempty"`
	Controls          *ControlConnection           `json:"controls"`
	Subcontrols       *SubcontrolConnection        `json:"subcontrols"`
	ControlObjectives *ControlObjectiveConnection  `json:"controlObjectives"`
	InternalPolicies  *InternalPolicyConnection    `json:"internalPolicies"`
	Procedures        *ProcedureConnection         `json:"procedures"`
	Risks             *RiskConnection              `json:"risks"`
	Tasks             *TaskConnection              `json:"tasks"`
	Notes             *NoteConnection              `json:"notes"`
	Files             *FileConnection              `json:"files"`
	Evidence          *EvidenceConnection          `json:"evidence"`
	Narratives        *NarrativeConnection         `json:"narratives"`
	ActionPlans       *ActionPlanConnection        `json:"actionPlans"`
	Users             *UserConnection              `json:"users"`
	ProgramOwner      *User                        `json:"programOwner,omitempty"`
	Members           *ProgramMembershipConnection `json:"members"`
}

func (Program) IsNode() {}

// Return response for createBulkProgram mutation
type ProgramBulkCreatePayload struct {
	// Created programs
	Programs []*Program `json:"programs,omitempty"`
}

// Return response for deleteBulkProgram mutation
type ProgramBulkDeletePayload struct {
	// Deleted program IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type ProgramConnection struct {
	// A list of edges.
	Edges []*ProgramEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProgram mutation
type ProgramCreatePayload struct {
	// Created program
	Program *Program `json:"program"`
}

// Return response for deleteProgram mutation
type ProgramDeletePayload struct {
	// Deleted program ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProgramEdge struct {
	// The item at the end of the edge.
	Node *Program `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProgramHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the kind of the program
	ProgramKindName *string `json:"programKindName,omitempty"`
	// the kind of the program
	ProgramKindID *string `json:"programKindID,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status enums.ProgramStatus `json:"status"`
	// the type of the program
	ProgramType enums.ProgramType `json:"programType"`
	// the short name of the compliance standard the program is based on, only used for framework type programs
	FrameworkName *string `json:"frameworkName,omitempty"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady bool `json:"auditorReady"`
	// can the auditor write comments
	AuditorWriteComments bool `json:"auditorWriteComments"`
	// can the auditor read comments
	AuditorReadComments bool `json:"auditorReadComments"`
	// the name of the audit firm conducting the audit
	AuditFirm *string `json:"auditFirm,omitempty"`
	// the full name of the auditor conducting the audit
	Auditor *string `json:"auditor,omitempty"`
	// the email of the auditor conducting the audit
	AuditorEmail *string `json:"auditorEmail,omitempty"`
	// the id of the user who is responsible for this program
	ProgramOwnerID *string `json:"programOwnerID,omitempty"`
}

func (ProgramHistory) IsNode() {}

// A connection to a list of items.
type ProgramHistoryConnection struct {
	// A list of edges.
	Edges []*ProgramHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProgramHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProgramHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ProgramHistory connections
type ProgramHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ProgramHistories.
	Field ProgramHistoryOrderField `json:"field"`
}

// ProgramHistoryWhereInput is used for filtering ProgramHistory objects.
// Input was generated by ent.
type ProgramHistoryWhereInput struct {
	Not *ProgramHistoryWhereInput   `json:"not,omitempty"`
	And []*ProgramHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProgramHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// program_kind_name field predicates
	ProgramKindName             *string  `json:"programKindName,omitempty"`
	ProgramKindNameNeq          *string  `json:"programKindNameNEQ,omitempty"`
	ProgramKindNameIn           []string `json:"programKindNameIn,omitempty"`
	ProgramKindNameNotIn        []string `json:"programKindNameNotIn,omitempty"`
	ProgramKindNameGt           *string  `json:"programKindNameGT,omitempty"`
	ProgramKindNameGte          *string  `json:"programKindNameGTE,omitempty"`
	ProgramKindNameLt           *string  `json:"programKindNameLT,omitempty"`
	ProgramKindNameLte          *string  `json:"programKindNameLTE,omitempty"`
	ProgramKindNameContains     *string  `json:"programKindNameContains,omitempty"`
	ProgramKindNameHasPrefix    *string  `json:"programKindNameHasPrefix,omitempty"`
	ProgramKindNameHasSuffix    *string  `json:"programKindNameHasSuffix,omitempty"`
	ProgramKindNameIsNil        *bool    `json:"programKindNameIsNil,omitempty"`
	ProgramKindNameNotNil       *bool    `json:"programKindNameNotNil,omitempty"`
	ProgramKindNameEqualFold    *string  `json:"programKindNameEqualFold,omitempty"`
	ProgramKindNameContainsFold *string  `json:"programKindNameContainsFold,omitempty"`
	// program_kind_id field predicates
	ProgramKindID             *string  `json:"programKindID,omitempty"`
	ProgramKindIdneq          *string  `json:"programKindIDNEQ,omitempty"`
	ProgramKindIDIn           []string `json:"programKindIDIn,omitempty"`
	ProgramKindIDNotIn        []string `json:"programKindIDNotIn,omitempty"`
	ProgramKindIdgt           *string  `json:"programKindIDGT,omitempty"`
	ProgramKindIdgte          *string  `json:"programKindIDGTE,omitempty"`
	ProgramKindIdlt           *string  `json:"programKindIDLT,omitempty"`
	ProgramKindIdlte          *string  `json:"programKindIDLTE,omitempty"`
	ProgramKindIDContains     *string  `json:"programKindIDContains,omitempty"`
	ProgramKindIDHasPrefix    *string  `json:"programKindIDHasPrefix,omitempty"`
	ProgramKindIDHasSuffix    *string  `json:"programKindIDHasSuffix,omitempty"`
	ProgramKindIDIsNil        *bool    `json:"programKindIDIsNil,omitempty"`
	ProgramKindIDNotNil       *bool    `json:"programKindIDNotNil,omitempty"`
	ProgramKindIDEqualFold    *string  `json:"programKindIDEqualFold,omitempty"`
	ProgramKindIDContainsFold *string  `json:"programKindIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`
	// program_type field predicates
	ProgramType      *enums.ProgramType  `json:"programType,omitempty"`
	ProgramTypeNeq   *enums.ProgramType  `json:"programTypeNEQ,omitempty"`
	ProgramTypeIn    []enums.ProgramType `json:"programTypeIn,omitempty"`
	ProgramTypeNotIn []enums.ProgramType `json:"programTypeNotIn,omitempty"`
	// framework_name field predicates
	FrameworkName             *string  `json:"frameworkName,omitempty"`
	FrameworkNameNeq          *string  `json:"frameworkNameNEQ,omitempty"`
	FrameworkNameIn           []string `json:"frameworkNameIn,omitempty"`
	FrameworkNameNotIn        []string `json:"frameworkNameNotIn,omitempty"`
	FrameworkNameGt           *string  `json:"frameworkNameGT,omitempty"`
	FrameworkNameGte          *string  `json:"frameworkNameGTE,omitempty"`
	FrameworkNameLt           *string  `json:"frameworkNameLT,omitempty"`
	FrameworkNameLte          *string  `json:"frameworkNameLTE,omitempty"`
	FrameworkNameContains     *string  `json:"frameworkNameContains,omitempty"`
	FrameworkNameHasPrefix    *string  `json:"frameworkNameHasPrefix,omitempty"`
	FrameworkNameHasSuffix    *string  `json:"frameworkNameHasSuffix,omitempty"`
	FrameworkNameIsNil        *bool    `json:"frameworkNameIsNil,omitempty"`
	FrameworkNameNotNil       *bool    `json:"frameworkNameNotNil,omitempty"`
	FrameworkNameEqualFold    *string  `json:"frameworkNameEqualFold,omitempty"`
	FrameworkNameContainsFold *string  `json:"frameworkNameContainsFold,omitempty"`
	// start_date field predicates
	StartDate       *time.Time   `json:"startDate,omitempty"`
	StartDateNeq    *time.Time   `json:"startDateNEQ,omitempty"`
	StartDateIn     []*time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []*time.Time `json:"startDateNotIn,omitempty"`
	StartDateGt     *time.Time   `json:"startDateGT,omitempty"`
	StartDateGte    *time.Time   `json:"startDateGTE,omitempty"`
	StartDateLt     *time.Time   `json:"startDateLT,omitempty"`
	StartDateLte    *time.Time   `json:"startDateLTE,omitempty"`
	StartDateIsNil  *bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil *bool        `json:"startDateNotNil,omitempty"`
	// end_date field predicates
	EndDate       *time.Time   `json:"endDate,omitempty"`
	EndDateNeq    *time.Time   `json:"endDateNEQ,omitempty"`
	EndDateIn     []*time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []*time.Time `json:"endDateNotIn,omitempty"`
	EndDateGt     *time.Time   `json:"endDateGT,omitempty"`
	EndDateGte    *time.Time   `json:"endDateGTE,omitempty"`
	EndDateLt     *time.Time   `json:"endDateLT,omitempty"`
	EndDateLte    *time.Time   `json:"endDateLTE,omitempty"`
	EndDateIsNil  *bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil *bool        `json:"endDateNotNil,omitempty"`
	// auditor_ready field predicates
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNeq *bool `json:"auditorReadyNEQ,omitempty"`
	// auditor_write_comments field predicates
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNeq *bool `json:"auditorWriteCommentsNEQ,omitempty"`
	// auditor_read_comments field predicates
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNeq *bool `json:"auditorReadCommentsNEQ,omitempty"`
	// audit_firm field predicates
	AuditFirm             *string  `json:"auditFirm,omitempty"`
	AuditFirmNeq          *string  `json:"auditFirmNEQ,omitempty"`
	AuditFirmIn           []string `json:"auditFirmIn,omitempty"`
	AuditFirmNotIn        []string `json:"auditFirmNotIn,omitempty"`
	AuditFirmGt           *string  `json:"auditFirmGT,omitempty"`
	AuditFirmGte          *string  `json:"auditFirmGTE,omitempty"`
	AuditFirmLt           *string  `json:"auditFirmLT,omitempty"`
	AuditFirmLte          *string  `json:"auditFirmLTE,omitempty"`
	AuditFirmContains     *string  `json:"auditFirmContains,omitempty"`
	AuditFirmHasPrefix    *string  `json:"auditFirmHasPrefix,omitempty"`
	AuditFirmHasSuffix    *string  `json:"auditFirmHasSuffix,omitempty"`
	AuditFirmIsNil        *bool    `json:"auditFirmIsNil,omitempty"`
	AuditFirmNotNil       *bool    `json:"auditFirmNotNil,omitempty"`
	AuditFirmEqualFold    *string  `json:"auditFirmEqualFold,omitempty"`
	AuditFirmContainsFold *string  `json:"auditFirmContainsFold,omitempty"`
	// auditor field predicates
	Auditor             *string  `json:"auditor,omitempty"`
	AuditorNeq          *string  `json:"auditorNEQ,omitempty"`
	AuditorIn           []string `json:"auditorIn,omitempty"`
	AuditorNotIn        []string `json:"auditorNotIn,omitempty"`
	AuditorGt           *string  `json:"auditorGT,omitempty"`
	AuditorGte          *string  `json:"auditorGTE,omitempty"`
	AuditorLt           *string  `json:"auditorLT,omitempty"`
	AuditorLte          *string  `json:"auditorLTE,omitempty"`
	AuditorContains     *string  `json:"auditorContains,omitempty"`
	AuditorHasPrefix    *string  `json:"auditorHasPrefix,omitempty"`
	AuditorHasSuffix    *string  `json:"auditorHasSuffix,omitempty"`
	AuditorIsNil        *bool    `json:"auditorIsNil,omitempty"`
	AuditorNotNil       *bool    `json:"auditorNotNil,omitempty"`
	AuditorEqualFold    *string  `json:"auditorEqualFold,omitempty"`
	AuditorContainsFold *string  `json:"auditorContainsFold,omitempty"`
	// auditor_email field predicates
	AuditorEmail             *string  `json:"auditorEmail,omitempty"`
	AuditorEmailNeq          *string  `json:"auditorEmailNEQ,omitempty"`
	AuditorEmailIn           []string `json:"auditorEmailIn,omitempty"`
	AuditorEmailNotIn        []string `json:"auditorEmailNotIn,omitempty"`
	AuditorEmailGt           *string  `json:"auditorEmailGT,omitempty"`
	AuditorEmailGte          *string  `json:"auditorEmailGTE,omitempty"`
	AuditorEmailLt           *string  `json:"auditorEmailLT,omitempty"`
	AuditorEmailLte          *string  `json:"auditorEmailLTE,omitempty"`
	AuditorEmailContains     *string  `json:"auditorEmailContains,omitempty"`
	AuditorEmailHasPrefix    *string  `json:"auditorEmailHasPrefix,omitempty"`
	AuditorEmailHasSuffix    *string  `json:"auditorEmailHasSuffix,omitempty"`
	AuditorEmailIsNil        *bool    `json:"auditorEmailIsNil,omitempty"`
	AuditorEmailNotNil       *bool    `json:"auditorEmailNotNil,omitempty"`
	AuditorEmailEqualFold    *string  `json:"auditorEmailEqualFold,omitempty"`
	AuditorEmailContainsFold *string  `json:"auditorEmailContainsFold,omitempty"`
	// program_owner_id field predicates
	ProgramOwnerID             *string  `json:"programOwnerID,omitempty"`
	ProgramOwnerIdneq          *string  `json:"programOwnerIDNEQ,omitempty"`
	ProgramOwnerIDIn           []string `json:"programOwnerIDIn,omitempty"`
	ProgramOwnerIDNotIn        []string `json:"programOwnerIDNotIn,omitempty"`
	ProgramOwnerIdgt           *string  `json:"programOwnerIDGT,omitempty"`
	ProgramOwnerIdgte          *string  `json:"programOwnerIDGTE,omitempty"`
	ProgramOwnerIdlt           *string  `json:"programOwnerIDLT,omitempty"`
	ProgramOwnerIdlte          *string  `json:"programOwnerIDLTE,omitempty"`
	ProgramOwnerIDContains     *string  `json:"programOwnerIDContains,omitempty"`
	ProgramOwnerIDHasPrefix    *string  `json:"programOwnerIDHasPrefix,omitempty"`
	ProgramOwnerIDHasSuffix    *string  `json:"programOwnerIDHasSuffix,omitempty"`
	ProgramOwnerIDIsNil        *bool    `json:"programOwnerIDIsNil,omitempty"`
	ProgramOwnerIDNotNil       *bool    `json:"programOwnerIDNotNil,omitempty"`
	ProgramOwnerIDEqualFold    *string  `json:"programOwnerIDEqualFold,omitempty"`
	ProgramOwnerIDContainsFold *string  `json:"programOwnerIDContainsFold,omitempty"`
}

type ProgramMembership struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Role      enums.Role `json:"role"`
	ProgramID string     `json:"programID"`
	UserID    string     `json:"userID"`
	Program   *Program   `json:"program"`
	User      *User      `json:"user"`
}

func (ProgramMembership) IsNode() {}

// Return response for createBulkProgramMembership mutation
type ProgramMembershipBulkCreatePayload struct {
	// Created programMemberships
	ProgramMemberships []*ProgramMembership `json:"programMemberships,omitempty"`
}

// Return response for deleteBulkProgramMembership mutation
type ProgramMembershipBulkDeletePayload struct {
	// Deleted programMembership IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type ProgramMembershipConnection struct {
	// A list of edges.
	Edges []*ProgramMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProgramMembership mutation
type ProgramMembershipCreatePayload struct {
	// Created programMembership
	ProgramMembership *ProgramMembership `json:"programMembership"`
}

// Return response for deleteProgramMembership mutation
type ProgramMembershipDeletePayload struct {
	// Deleted programMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProgramMembershipEdge struct {
	// The item at the end of the edge.
	Node *ProgramMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProgramMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	ProgramID   string         `json:"programID"`
	UserID      string         `json:"userID"`
}

func (ProgramMembershipHistory) IsNode() {}

// A connection to a list of items.
type ProgramMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*ProgramMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProgramMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProgramMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ProgramMembershipHistory connections
type ProgramMembershipHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ProgramMembershipHistories.
	Field ProgramMembershipHistoryOrderField `json:"field"`
}

// ProgramMembershipHistoryWhereInput is used for filtering ProgramMembershipHistory objects.
// Input was generated by ent.
type ProgramMembershipHistoryWhereInput struct {
	Not *ProgramMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*ProgramMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProgramMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// program_id field predicates
	ProgramID             *string  `json:"programID,omitempty"`
	ProgramIdneq          *string  `json:"programIDNEQ,omitempty"`
	ProgramIDIn           []string `json:"programIDIn,omitempty"`
	ProgramIDNotIn        []string `json:"programIDNotIn,omitempty"`
	ProgramIdgt           *string  `json:"programIDGT,omitempty"`
	ProgramIdgte          *string  `json:"programIDGTE,omitempty"`
	ProgramIdlt           *string  `json:"programIDLT,omitempty"`
	ProgramIdlte          *string  `json:"programIDLTE,omitempty"`
	ProgramIDContains     *string  `json:"programIDContains,omitempty"`
	ProgramIDHasPrefix    *string  `json:"programIDHasPrefix,omitempty"`
	ProgramIDHasSuffix    *string  `json:"programIDHasSuffix,omitempty"`
	ProgramIDEqualFold    *string  `json:"programIDEqualFold,omitempty"`
	ProgramIDContainsFold *string  `json:"programIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Ordering options for ProgramMembership connections
type ProgramMembershipOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ProgramMemberships.
	Field ProgramMembershipOrderField `json:"field"`
}

// Return response for updateProgramMembership mutation
type ProgramMembershipUpdatePayload struct {
	// Updated programMembership
	ProgramMembership *ProgramMembership `json:"programMembership"`
}

// ProgramMembershipWhereInput is used for filtering ProgramMembership objects.
// Input was generated by ent.
type ProgramMembershipWhereInput struct {
	Not *ProgramMembershipWhereInput   `json:"not,omitempty"`
	And []*ProgramMembershipWhereInput `json:"and,omitempty"`
	Or  []*ProgramMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	ProgramID *string      `json:"programID,omitempty"`
	UserID    *string      `json:"userID,omitempty"`
}

// Ordering options for Program connections
type ProgramOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Programs.
	Field ProgramOrderField `json:"field"`
}

// Return response for updateProgram mutation
type ProgramUpdatePayload struct {
	// Updated program
	Program *Program `json:"program"`
}

// ProgramWhereInput is used for filtering Program objects.
// Input was generated by ent.
type ProgramWhereInput struct {
	Not *ProgramWhereInput   `json:"not,omitempty"`
	And []*ProgramWhereInput `json:"and,omitempty"`
	Or  []*ProgramWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// program_kind_name field predicates
	ProgramKindName             *string  `json:"programKindName,omitempty"`
	ProgramKindNameNeq          *string  `json:"programKindNameNEQ,omitempty"`
	ProgramKindNameIn           []string `json:"programKindNameIn,omitempty"`
	ProgramKindNameNotIn        []string `json:"programKindNameNotIn,omitempty"`
	ProgramKindNameGt           *string  `json:"programKindNameGT,omitempty"`
	ProgramKindNameGte          *string  `json:"programKindNameGTE,omitempty"`
	ProgramKindNameLt           *string  `json:"programKindNameLT,omitempty"`
	ProgramKindNameLte          *string  `json:"programKindNameLTE,omitempty"`
	ProgramKindNameContains     *string  `json:"programKindNameContains,omitempty"`
	ProgramKindNameHasPrefix    *string  `json:"programKindNameHasPrefix,omitempty"`
	ProgramKindNameHasSuffix    *string  `json:"programKindNameHasSuffix,omitempty"`
	ProgramKindNameIsNil        *bool    `json:"programKindNameIsNil,omitempty"`
	ProgramKindNameNotNil       *bool    `json:"programKindNameNotNil,omitempty"`
	ProgramKindNameEqualFold    *string  `json:"programKindNameEqualFold,omitempty"`
	ProgramKindNameContainsFold *string  `json:"programKindNameContainsFold,omitempty"`
	// program_kind_id field predicates
	ProgramKindID             *string  `json:"programKindID,omitempty"`
	ProgramKindIdneq          *string  `json:"programKindIDNEQ,omitempty"`
	ProgramKindIDIn           []string `json:"programKindIDIn,omitempty"`
	ProgramKindIDNotIn        []string `json:"programKindIDNotIn,omitempty"`
	ProgramKindIdgt           *string  `json:"programKindIDGT,omitempty"`
	ProgramKindIdgte          *string  `json:"programKindIDGTE,omitempty"`
	ProgramKindIdlt           *string  `json:"programKindIDLT,omitempty"`
	ProgramKindIdlte          *string  `json:"programKindIDLTE,omitempty"`
	ProgramKindIDContains     *string  `json:"programKindIDContains,omitempty"`
	ProgramKindIDHasPrefix    *string  `json:"programKindIDHasPrefix,omitempty"`
	ProgramKindIDHasSuffix    *string  `json:"programKindIDHasSuffix,omitempty"`
	ProgramKindIDIsNil        *bool    `json:"programKindIDIsNil,omitempty"`
	ProgramKindIDNotNil       *bool    `json:"programKindIDNotNil,omitempty"`
	ProgramKindIDEqualFold    *string  `json:"programKindIDEqualFold,omitempty"`
	ProgramKindIDContainsFold *string  `json:"programKindIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`
	// program_type field predicates
	ProgramType      *enums.ProgramType  `json:"programType,omitempty"`
	ProgramTypeNeq   *enums.ProgramType  `json:"programTypeNEQ,omitempty"`
	ProgramTypeIn    []enums.ProgramType `json:"programTypeIn,omitempty"`
	ProgramTypeNotIn []enums.ProgramType `json:"programTypeNotIn,omitempty"`
	// framework_name field predicates
	FrameworkName             *string  `json:"frameworkName,omitempty"`
	FrameworkNameNeq          *string  `json:"frameworkNameNEQ,omitempty"`
	FrameworkNameIn           []string `json:"frameworkNameIn,omitempty"`
	FrameworkNameNotIn        []string `json:"frameworkNameNotIn,omitempty"`
	FrameworkNameGt           *string  `json:"frameworkNameGT,omitempty"`
	FrameworkNameGte          *string  `json:"frameworkNameGTE,omitempty"`
	FrameworkNameLt           *string  `json:"frameworkNameLT,omitempty"`
	FrameworkNameLte          *string  `json:"frameworkNameLTE,omitempty"`
	FrameworkNameContains     *string  `json:"frameworkNameContains,omitempty"`
	FrameworkNameHasPrefix    *string  `json:"frameworkNameHasPrefix,omitempty"`
	FrameworkNameHasSuffix    *string  `json:"frameworkNameHasSuffix,omitempty"`
	FrameworkNameIsNil        *bool    `json:"frameworkNameIsNil,omitempty"`
	FrameworkNameNotNil       *bool    `json:"frameworkNameNotNil,omitempty"`
	FrameworkNameEqualFold    *string  `json:"frameworkNameEqualFold,omitempty"`
	FrameworkNameContainsFold *string  `json:"frameworkNameContainsFold,omitempty"`
	// start_date field predicates
	StartDate       *time.Time   `json:"startDate,omitempty"`
	StartDateNeq    *time.Time   `json:"startDateNEQ,omitempty"`
	StartDateIn     []*time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []*time.Time `json:"startDateNotIn,omitempty"`
	StartDateGt     *time.Time   `json:"startDateGT,omitempty"`
	StartDateGte    *time.Time   `json:"startDateGTE,omitempty"`
	StartDateLt     *time.Time   `json:"startDateLT,omitempty"`
	StartDateLte    *time.Time   `json:"startDateLTE,omitempty"`
	StartDateIsNil  *bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil *bool        `json:"startDateNotNil,omitempty"`
	// end_date field predicates
	EndDate       *time.Time   `json:"endDate,omitempty"`
	EndDateNeq    *time.Time   `json:"endDateNEQ,omitempty"`
	EndDateIn     []*time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []*time.Time `json:"endDateNotIn,omitempty"`
	EndDateGt     *time.Time   `json:"endDateGT,omitempty"`
	EndDateGte    *time.Time   `json:"endDateGTE,omitempty"`
	EndDateLt     *time.Time   `json:"endDateLT,omitempty"`
	EndDateLte    *time.Time   `json:"endDateLTE,omitempty"`
	EndDateIsNil  *bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil *bool        `json:"endDateNotNil,omitempty"`
	// auditor_ready field predicates
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNeq *bool `json:"auditorReadyNEQ,omitempty"`
	// auditor_write_comments field predicates
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNeq *bool `json:"auditorWriteCommentsNEQ,omitempty"`
	// auditor_read_comments field predicates
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNeq *bool `json:"auditorReadCommentsNEQ,omitempty"`
	// audit_firm field predicates
	AuditFirm             *string  `json:"auditFirm,omitempty"`
	AuditFirmNeq          *string  `json:"auditFirmNEQ,omitempty"`
	AuditFirmIn           []string `json:"auditFirmIn,omitempty"`
	AuditFirmNotIn        []string `json:"auditFirmNotIn,omitempty"`
	AuditFirmGt           *string  `json:"auditFirmGT,omitempty"`
	AuditFirmGte          *string  `json:"auditFirmGTE,omitempty"`
	AuditFirmLt           *string  `json:"auditFirmLT,omitempty"`
	AuditFirmLte          *string  `json:"auditFirmLTE,omitempty"`
	AuditFirmContains     *string  `json:"auditFirmContains,omitempty"`
	AuditFirmHasPrefix    *string  `json:"auditFirmHasPrefix,omitempty"`
	AuditFirmHasSuffix    *string  `json:"auditFirmHasSuffix,omitempty"`
	AuditFirmIsNil        *bool    `json:"auditFirmIsNil,omitempty"`
	AuditFirmNotNil       *bool    `json:"auditFirmNotNil,omitempty"`
	AuditFirmEqualFold    *string  `json:"auditFirmEqualFold,omitempty"`
	AuditFirmContainsFold *string  `json:"auditFirmContainsFold,omitempty"`
	// auditor field predicates
	Auditor             *string  `json:"auditor,omitempty"`
	AuditorNeq          *string  `json:"auditorNEQ,omitempty"`
	AuditorIn           []string `json:"auditorIn,omitempty"`
	AuditorNotIn        []string `json:"auditorNotIn,omitempty"`
	AuditorGt           *string  `json:"auditorGT,omitempty"`
	AuditorGte          *string  `json:"auditorGTE,omitempty"`
	AuditorLt           *string  `json:"auditorLT,omitempty"`
	AuditorLte          *string  `json:"auditorLTE,omitempty"`
	AuditorContains     *string  `json:"auditorContains,omitempty"`
	AuditorHasPrefix    *string  `json:"auditorHasPrefix,omitempty"`
	AuditorHasSuffix    *string  `json:"auditorHasSuffix,omitempty"`
	AuditorIsNil        *bool    `json:"auditorIsNil,omitempty"`
	AuditorNotNil       *bool    `json:"auditorNotNil,omitempty"`
	AuditorEqualFold    *string  `json:"auditorEqualFold,omitempty"`
	AuditorContainsFold *string  `json:"auditorContainsFold,omitempty"`
	// auditor_email field predicates
	AuditorEmail             *string  `json:"auditorEmail,omitempty"`
	AuditorEmailNeq          *string  `json:"auditorEmailNEQ,omitempty"`
	AuditorEmailIn           []string `json:"auditorEmailIn,omitempty"`
	AuditorEmailNotIn        []string `json:"auditorEmailNotIn,omitempty"`
	AuditorEmailGt           *string  `json:"auditorEmailGT,omitempty"`
	AuditorEmailGte          *string  `json:"auditorEmailGTE,omitempty"`
	AuditorEmailLt           *string  `json:"auditorEmailLT,omitempty"`
	AuditorEmailLte          *string  `json:"auditorEmailLTE,omitempty"`
	AuditorEmailContains     *string  `json:"auditorEmailContains,omitempty"`
	AuditorEmailHasPrefix    *string  `json:"auditorEmailHasPrefix,omitempty"`
	AuditorEmailHasSuffix    *string  `json:"auditorEmailHasSuffix,omitempty"`
	AuditorEmailIsNil        *bool    `json:"auditorEmailIsNil,omitempty"`
	AuditorEmailNotNil       *bool    `json:"auditorEmailNotNil,omitempty"`
	AuditorEmailEqualFold    *string  `json:"auditorEmailEqualFold,omitempty"`
	AuditorEmailContainsFold *string  `json:"auditorEmailContainsFold,omitempty"`
	// program_owner_id field predicates
	ProgramOwnerID             *string  `json:"programOwnerID,omitempty"`
	ProgramOwnerIdneq          *string  `json:"programOwnerIDNEQ,omitempty"`
	ProgramOwnerIDIn           []string `json:"programOwnerIDIn,omitempty"`
	ProgramOwnerIDNotIn        []string `json:"programOwnerIDNotIn,omitempty"`
	ProgramOwnerIdgt           *string  `json:"programOwnerIDGT,omitempty"`
	ProgramOwnerIdgte          *string  `json:"programOwnerIDGTE,omitempty"`
	ProgramOwnerIdlt           *string  `json:"programOwnerIDLT,omitempty"`
	ProgramOwnerIdlte          *string  `json:"programOwnerIDLTE,omitempty"`
	ProgramOwnerIDContains     *string  `json:"programOwnerIDContains,omitempty"`
	ProgramOwnerIDHasPrefix    *string  `json:"programOwnerIDHasPrefix,omitempty"`
	ProgramOwnerIDHasSuffix    *string  `json:"programOwnerIDHasSuffix,omitempty"`
	ProgramOwnerIDIsNil        *bool    `json:"programOwnerIDIsNil,omitempty"`
	ProgramOwnerIDNotNil       *bool    `json:"programOwnerIDNotNil,omitempty"`
	ProgramOwnerIDEqualFold    *string  `json:"programOwnerIDEqualFold,omitempty"`
	ProgramOwnerIDContainsFold *string  `json:"programOwnerIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// program_kind edge predicates
	HasProgramKind     *bool                       `json:"hasProgramKind,omitempty"`
	HasProgramKindWith []*CustomTypeEnumWhereInput `json:"hasProgramKindWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// program_owner edge predicates
	HasProgramOwner     *bool             `json:"hasProgramOwner,omitempty"`
	HasProgramOwnerWith []*UserWhereInput `json:"hasProgramOwnerWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                          `json:"hasMembers,omitempty"`
	HasMembersWith []*ProgramMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Query struct {
}

type Remediation struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the remediation
	ExternalID *string `json:"externalID,omitempty"`
	// external identifier from the integration source for the remediation
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// title or short description of the remediation effort
	Title *string `json:"title,omitempty"`
	// state of the remediation, such as pending or completed
	State *string `json:"state,omitempty"`
	// intent or goal of the remediation effort
	Intent *string `json:"intent,omitempty"`
	// summary of the remediation approach
	Summary *string `json:"summary,omitempty"`
	// detailed explanation of the remediation steps
	Explanation *string `json:"explanation,omitempty"`
	// specific instructions or steps to implement the remediation
	Instructions *string `json:"instructions,omitempty"`
	// reference to the owner responsible for remediation
	OwnerReference *string `json:"ownerReference,omitempty"`
	// source code repository URI associated with the remediation
	RepositoryURI *string `json:"repositoryURI,omitempty"`
	// pull request URI associated with the remediation
	PullRequestURI *string `json:"pullRequestURI,omitempty"`
	// reference to a tracking ticket for the remediation
	TicketReference *string `json:"ticketReference,omitempty"`
	// timestamp when the remediation is due
	DueAt *models.DateTime `json:"dueAt,omitempty"`
	// timestamp when the remediation was completed
	CompletedAt *models.DateTime `json:"completedAt,omitempty"`
	// timestamp when an automated pull request was generated
	PrGeneratedAt *models.DateTime `json:"prGeneratedAt,omitempty"`
	// details about any errors encountered during remediation automation
	Error *string `json:"error,omitempty"`
	// system that produced the remediation record
	Source *string `json:"source,omitempty"`
	// link to the remediation in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the remediation from the source system
	Metadata        map[string]any           `json:"metadata,omitempty"`
	Owner           *Organization            `json:"owner,omitempty"`
	BlockedGroups   *GroupConnection         `json:"blockedGroups"`
	Editors         *GroupConnection         `json:"editors"`
	Viewers         *GroupConnection         `json:"viewers"`
	Integrations    *IntegrationConnection   `json:"integrations"`
	Findings        *FindingConnection       `json:"findings"`
	Vulnerabilities *VulnerabilityConnection `json:"vulnerabilities"`
	ActionPlans     *ActionPlanConnection    `json:"actionPlans"`
	Tasks           *TaskConnection          `json:"tasks"`
	Controls        *ControlConnection       `json:"controls"`
	Subcontrols     *SubcontrolConnection    `json:"subcontrols"`
	Risks           *RiskConnection          `json:"risks"`
	Programs        *ProgramConnection       `json:"programs"`
	Assets          *AssetConnection         `json:"assets"`
	Entities        *EntityConnection        `json:"entities"`
	Reviews         *ReviewConnection        `json:"reviews"`
	Comments        *NoteConnection          `json:"comments"`
	Files           *FileConnection          `json:"files"`
}

func (Remediation) IsNode() {}

// Return response for createBulkRemediation mutation
type RemediationBulkCreatePayload struct {
	// Created remediations
	Remediations []*Remediation `json:"remediations,omitempty"`
}

// A connection to a list of items.
type RemediationConnection struct {
	// A list of edges.
	Edges []*RemediationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createRemediation mutation
type RemediationCreatePayload struct {
	// Created remediation
	Remediation *Remediation `json:"remediation"`
}

// Return response for deleteRemediation mutation
type RemediationDeletePayload struct {
	// Deleted remediation ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type RemediationEdge struct {
	// The item at the end of the edge.
	Node *Remediation `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type RemediationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the remediation
	ExternalID *string `json:"externalID,omitempty"`
	// external identifier from the integration source for the remediation
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// title or short description of the remediation effort
	Title *string `json:"title,omitempty"`
	// state of the remediation, such as pending or completed
	State *string `json:"state,omitempty"`
	// intent or goal of the remediation effort
	Intent *string `json:"intent,omitempty"`
	// summary of the remediation approach
	Summary *string `json:"summary,omitempty"`
	// detailed explanation of the remediation steps
	Explanation *string `json:"explanation,omitempty"`
	// specific instructions or steps to implement the remediation
	Instructions *string `json:"instructions,omitempty"`
	// reference to the owner responsible for remediation
	OwnerReference *string `json:"ownerReference,omitempty"`
	// source code repository URI associated with the remediation
	RepositoryURI *string `json:"repositoryURI,omitempty"`
	// pull request URI associated with the remediation
	PullRequestURI *string `json:"pullRequestURI,omitempty"`
	// reference to a tracking ticket for the remediation
	TicketReference *string `json:"ticketReference,omitempty"`
	// timestamp when the remediation is due
	DueAt *models.DateTime `json:"dueAt,omitempty"`
	// timestamp when the remediation was completed
	CompletedAt *models.DateTime `json:"completedAt,omitempty"`
	// timestamp when an automated pull request was generated
	PrGeneratedAt *models.DateTime `json:"prGeneratedAt,omitempty"`
	// details about any errors encountered during remediation automation
	Error *string `json:"error,omitempty"`
	// system that produced the remediation record
	Source *string `json:"source,omitempty"`
	// link to the remediation in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the remediation from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
}

func (RemediationHistory) IsNode() {}

// A connection to a list of items.
type RemediationHistoryConnection struct {
	// A list of edges.
	Edges []*RemediationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type RemediationHistoryEdge struct {
	// The item at the end of the edge.
	Node *RemediationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for RemediationHistory connections
type RemediationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order RemediationHistories.
	Field RemediationHistoryOrderField `json:"field"`
}

// RemediationHistoryWhereInput is used for filtering RemediationHistory objects.
// Input was generated by ent.
type RemediationHistoryWhereInput struct {
	Not *RemediationHistoryWhereInput   `json:"not,omitempty"`
	And []*RemediationHistoryWhereInput `json:"and,omitempty"`
	Or  []*RemediationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        *bool    `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       *bool    `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// external_owner_id field predicates
	ExternalOwnerID             *string  `json:"externalOwnerID,omitempty"`
	ExternalOwnerIdneq          *string  `json:"externalOwnerIDNEQ,omitempty"`
	ExternalOwnerIDIn           []string `json:"externalOwnerIDIn,omitempty"`
	ExternalOwnerIDNotIn        []string `json:"externalOwnerIDNotIn,omitempty"`
	ExternalOwnerIdgt           *string  `json:"externalOwnerIDGT,omitempty"`
	ExternalOwnerIdgte          *string  `json:"externalOwnerIDGTE,omitempty"`
	ExternalOwnerIdlt           *string  `json:"externalOwnerIDLT,omitempty"`
	ExternalOwnerIdlte          *string  `json:"externalOwnerIDLTE,omitempty"`
	ExternalOwnerIDContains     *string  `json:"externalOwnerIDContains,omitempty"`
	ExternalOwnerIDHasPrefix    *string  `json:"externalOwnerIDHasPrefix,omitempty"`
	ExternalOwnerIDHasSuffix    *string  `json:"externalOwnerIDHasSuffix,omitempty"`
	ExternalOwnerIDIsNil        *bool    `json:"externalOwnerIDIsNil,omitempty"`
	ExternalOwnerIDNotNil       *bool    `json:"externalOwnerIDNotNil,omitempty"`
	ExternalOwnerIDEqualFold    *string  `json:"externalOwnerIDEqualFold,omitempty"`
	ExternalOwnerIDContainsFold *string  `json:"externalOwnerIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// state field predicates
	State             *string  `json:"state,omitempty"`
	StateNeq          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGt           *string  `json:"stateGT,omitempty"`
	StateGte          *string  `json:"stateGTE,omitempty"`
	StateLt           *string  `json:"stateLT,omitempty"`
	StateLte          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        *bool    `json:"stateIsNil,omitempty"`
	StateNotNil       *bool    `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`
	// intent field predicates
	Intent             *string  `json:"intent,omitempty"`
	IntentNeq          *string  `json:"intentNEQ,omitempty"`
	IntentIn           []string `json:"intentIn,omitempty"`
	IntentNotIn        []string `json:"intentNotIn,omitempty"`
	IntentGt           *string  `json:"intentGT,omitempty"`
	IntentGte          *string  `json:"intentGTE,omitempty"`
	IntentLt           *string  `json:"intentLT,omitempty"`
	IntentLte          *string  `json:"intentLTE,omitempty"`
	IntentContains     *string  `json:"intentContains,omitempty"`
	IntentHasPrefix    *string  `json:"intentHasPrefix,omitempty"`
	IntentHasSuffix    *string  `json:"intentHasSuffix,omitempty"`
	IntentIsNil        *bool    `json:"intentIsNil,omitempty"`
	IntentNotNil       *bool    `json:"intentNotNil,omitempty"`
	IntentEqualFold    *string  `json:"intentEqualFold,omitempty"`
	IntentContainsFold *string  `json:"intentContainsFold,omitempty"`
	// summary field predicates
	Summary             *string  `json:"summary,omitempty"`
	SummaryNeq          *string  `json:"summaryNEQ,omitempty"`
	SummaryIn           []string `json:"summaryIn,omitempty"`
	SummaryNotIn        []string `json:"summaryNotIn,omitempty"`
	SummaryGt           *string  `json:"summaryGT,omitempty"`
	SummaryGte          *string  `json:"summaryGTE,omitempty"`
	SummaryLt           *string  `json:"summaryLT,omitempty"`
	SummaryLte          *string  `json:"summaryLTE,omitempty"`
	SummaryContains     *string  `json:"summaryContains,omitempty"`
	SummaryHasPrefix    *string  `json:"summaryHasPrefix,omitempty"`
	SummaryHasSuffix    *string  `json:"summaryHasSuffix,omitempty"`
	SummaryIsNil        *bool    `json:"summaryIsNil,omitempty"`
	SummaryNotNil       *bool    `json:"summaryNotNil,omitempty"`
	SummaryEqualFold    *string  `json:"summaryEqualFold,omitempty"`
	SummaryContainsFold *string  `json:"summaryContainsFold,omitempty"`
	// explanation field predicates
	Explanation             *string  `json:"explanation,omitempty"`
	ExplanationNeq          *string  `json:"explanationNEQ,omitempty"`
	ExplanationIn           []string `json:"explanationIn,omitempty"`
	ExplanationNotIn        []string `json:"explanationNotIn,omitempty"`
	ExplanationGt           *string  `json:"explanationGT,omitempty"`
	ExplanationGte          *string  `json:"explanationGTE,omitempty"`
	ExplanationLt           *string  `json:"explanationLT,omitempty"`
	ExplanationLte          *string  `json:"explanationLTE,omitempty"`
	ExplanationContains     *string  `json:"explanationContains,omitempty"`
	ExplanationHasPrefix    *string  `json:"explanationHasPrefix,omitempty"`
	ExplanationHasSuffix    *string  `json:"explanationHasSuffix,omitempty"`
	ExplanationIsNil        *bool    `json:"explanationIsNil,omitempty"`
	ExplanationNotNil       *bool    `json:"explanationNotNil,omitempty"`
	ExplanationEqualFold    *string  `json:"explanationEqualFold,omitempty"`
	ExplanationContainsFold *string  `json:"explanationContainsFold,omitempty"`
	// instructions field predicates
	Instructions             *string  `json:"instructions,omitempty"`
	InstructionsNeq          *string  `json:"instructionsNEQ,omitempty"`
	InstructionsIn           []string `json:"instructionsIn,omitempty"`
	InstructionsNotIn        []string `json:"instructionsNotIn,omitempty"`
	InstructionsGt           *string  `json:"instructionsGT,omitempty"`
	InstructionsGte          *string  `json:"instructionsGTE,omitempty"`
	InstructionsLt           *string  `json:"instructionsLT,omitempty"`
	InstructionsLte          *string  `json:"instructionsLTE,omitempty"`
	InstructionsContains     *string  `json:"instructionsContains,omitempty"`
	InstructionsHasPrefix    *string  `json:"instructionsHasPrefix,omitempty"`
	InstructionsHasSuffix    *string  `json:"instructionsHasSuffix,omitempty"`
	InstructionsIsNil        *bool    `json:"instructionsIsNil,omitempty"`
	InstructionsNotNil       *bool    `json:"instructionsNotNil,omitempty"`
	InstructionsEqualFold    *string  `json:"instructionsEqualFold,omitempty"`
	InstructionsContainsFold *string  `json:"instructionsContainsFold,omitempty"`
	// owner_reference field predicates
	OwnerReference             *string  `json:"ownerReference,omitempty"`
	OwnerReferenceNeq          *string  `json:"ownerReferenceNEQ,omitempty"`
	OwnerReferenceIn           []string `json:"ownerReferenceIn,omitempty"`
	OwnerReferenceNotIn        []string `json:"ownerReferenceNotIn,omitempty"`
	OwnerReferenceGt           *string  `json:"ownerReferenceGT,omitempty"`
	OwnerReferenceGte          *string  `json:"ownerReferenceGTE,omitempty"`
	OwnerReferenceLt           *string  `json:"ownerReferenceLT,omitempty"`
	OwnerReferenceLte          *string  `json:"ownerReferenceLTE,omitempty"`
	OwnerReferenceContains     *string  `json:"ownerReferenceContains,omitempty"`
	OwnerReferenceHasPrefix    *string  `json:"ownerReferenceHasPrefix,omitempty"`
	OwnerReferenceHasSuffix    *string  `json:"ownerReferenceHasSuffix,omitempty"`
	OwnerReferenceIsNil        *bool    `json:"ownerReferenceIsNil,omitempty"`
	OwnerReferenceNotNil       *bool    `json:"ownerReferenceNotNil,omitempty"`
	OwnerReferenceEqualFold    *string  `json:"ownerReferenceEqualFold,omitempty"`
	OwnerReferenceContainsFold *string  `json:"ownerReferenceContainsFold,omitempty"`
	// repository_uri field predicates
	RepositoryURI             *string  `json:"repositoryURI,omitempty"`
	RepositoryURINeq          *string  `json:"repositoryURINEQ,omitempty"`
	RepositoryURIIn           []string `json:"repositoryURIIn,omitempty"`
	RepositoryURINotIn        []string `json:"repositoryURINotIn,omitempty"`
	RepositoryURIGt           *string  `json:"repositoryURIGT,omitempty"`
	RepositoryURIGte          *string  `json:"repositoryURIGTE,omitempty"`
	RepositoryURILt           *string  `json:"repositoryURILT,omitempty"`
	RepositoryURILte          *string  `json:"repositoryURILTE,omitempty"`
	RepositoryURIContains     *string  `json:"repositoryURIContains,omitempty"`
	RepositoryURIHasPrefix    *string  `json:"repositoryURIHasPrefix,omitempty"`
	RepositoryURIHasSuffix    *string  `json:"repositoryURIHasSuffix,omitempty"`
	RepositoryURIIsNil        *bool    `json:"repositoryURIIsNil,omitempty"`
	RepositoryURINotNil       *bool    `json:"repositoryURINotNil,omitempty"`
	RepositoryURIEqualFold    *string  `json:"repositoryURIEqualFold,omitempty"`
	RepositoryURIContainsFold *string  `json:"repositoryURIContainsFold,omitempty"`
	// pull_request_uri field predicates
	PullRequestURI             *string  `json:"pullRequestURI,omitempty"`
	PullRequestURINeq          *string  `json:"pullRequestURINEQ,omitempty"`
	PullRequestURIIn           []string `json:"pullRequestURIIn,omitempty"`
	PullRequestURINotIn        []string `json:"pullRequestURINotIn,omitempty"`
	PullRequestURIGt           *string  `json:"pullRequestURIGT,omitempty"`
	PullRequestURIGte          *string  `json:"pullRequestURIGTE,omitempty"`
	PullRequestURILt           *string  `json:"pullRequestURILT,omitempty"`
	PullRequestURILte          *string  `json:"pullRequestURILTE,omitempty"`
	PullRequestURIContains     *string  `json:"pullRequestURIContains,omitempty"`
	PullRequestURIHasPrefix    *string  `json:"pullRequestURIHasPrefix,omitempty"`
	PullRequestURIHasSuffix    *string  `json:"pullRequestURIHasSuffix,omitempty"`
	PullRequestURIIsNil        *bool    `json:"pullRequestURIIsNil,omitempty"`
	PullRequestURINotNil       *bool    `json:"pullRequestURINotNil,omitempty"`
	PullRequestURIEqualFold    *string  `json:"pullRequestURIEqualFold,omitempty"`
	PullRequestURIContainsFold *string  `json:"pullRequestURIContainsFold,omitempty"`
	// ticket_reference field predicates
	TicketReference             *string  `json:"ticketReference,omitempty"`
	TicketReferenceNeq          *string  `json:"ticketReferenceNEQ,omitempty"`
	TicketReferenceIn           []string `json:"ticketReferenceIn,omitempty"`
	TicketReferenceNotIn        []string `json:"ticketReferenceNotIn,omitempty"`
	TicketReferenceGt           *string  `json:"ticketReferenceGT,omitempty"`
	TicketReferenceGte          *string  `json:"ticketReferenceGTE,omitempty"`
	TicketReferenceLt           *string  `json:"ticketReferenceLT,omitempty"`
	TicketReferenceLte          *string  `json:"ticketReferenceLTE,omitempty"`
	TicketReferenceContains     *string  `json:"ticketReferenceContains,omitempty"`
	TicketReferenceHasPrefix    *string  `json:"ticketReferenceHasPrefix,omitempty"`
	TicketReferenceHasSuffix    *string  `json:"ticketReferenceHasSuffix,omitempty"`
	TicketReferenceIsNil        *bool    `json:"ticketReferenceIsNil,omitempty"`
	TicketReferenceNotNil       *bool    `json:"ticketReferenceNotNil,omitempty"`
	TicketReferenceEqualFold    *string  `json:"ticketReferenceEqualFold,omitempty"`
	TicketReferenceContainsFold *string  `json:"ticketReferenceContainsFold,omitempty"`
	// due_at field predicates
	DueAt       *models.DateTime   `json:"dueAt,omitempty"`
	DueAtNeq    *models.DateTime   `json:"dueAtNEQ,omitempty"`
	DueAtIn     []*models.DateTime `json:"dueAtIn,omitempty"`
	DueAtNotIn  []*models.DateTime `json:"dueAtNotIn,omitempty"`
	DueAtGt     *models.DateTime   `json:"dueAtGT,omitempty"`
	DueAtGte    *models.DateTime   `json:"dueAtGTE,omitempty"`
	DueAtLt     *models.DateTime   `json:"dueAtLT,omitempty"`
	DueAtLte    *models.DateTime   `json:"dueAtLTE,omitempty"`
	DueAtIsNil  *bool              `json:"dueAtIsNil,omitempty"`
	DueAtNotNil *bool              `json:"dueAtNotNil,omitempty"`
	// completed_at field predicates
	CompletedAt       *models.DateTime   `json:"completedAt,omitempty"`
	CompletedAtNeq    *models.DateTime   `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []*models.DateTime `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []*models.DateTime `json:"completedAtNotIn,omitempty"`
	CompletedAtGt     *models.DateTime   `json:"completedAtGT,omitempty"`
	CompletedAtGte    *models.DateTime   `json:"completedAtGTE,omitempty"`
	CompletedAtLt     *models.DateTime   `json:"completedAtLT,omitempty"`
	CompletedAtLte    *models.DateTime   `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  *bool              `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil *bool              `json:"completedAtNotNil,omitempty"`
	// pr_generated_at field predicates
	PrGeneratedAt       *models.DateTime   `json:"prGeneratedAt,omitempty"`
	PrGeneratedAtNeq    *models.DateTime   `json:"prGeneratedAtNEQ,omitempty"`
	PrGeneratedAtIn     []*models.DateTime `json:"prGeneratedAtIn,omitempty"`
	PrGeneratedAtNotIn  []*models.DateTime `json:"prGeneratedAtNotIn,omitempty"`
	PrGeneratedAtGt     *models.DateTime   `json:"prGeneratedAtGT,omitempty"`
	PrGeneratedAtGte    *models.DateTime   `json:"prGeneratedAtGTE,omitempty"`
	PrGeneratedAtLt     *models.DateTime   `json:"prGeneratedAtLT,omitempty"`
	PrGeneratedAtLte    *models.DateTime   `json:"prGeneratedAtLTE,omitempty"`
	PrGeneratedAtIsNil  *bool              `json:"prGeneratedAtIsNil,omitempty"`
	PrGeneratedAtNotNil *bool              `json:"prGeneratedAtNotNil,omitempty"`
	// error field predicates
	Error             *string  `json:"error,omitempty"`
	ErrorNeq          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGt           *string  `json:"errorGT,omitempty"`
	ErrorGte          *string  `json:"errorGTE,omitempty"`
	ErrorLt           *string  `json:"errorLT,omitempty"`
	ErrorLte          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        *bool    `json:"errorIsNil,omitempty"`
	ErrorNotNil       *bool    `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// external_uri field predicates
	ExternalURI             *string  `json:"externalURI,omitempty"`
	ExternalURINeq          *string  `json:"externalURINEQ,omitempty"`
	ExternalURIIn           []string `json:"externalURIIn,omitempty"`
	ExternalURINotIn        []string `json:"externalURINotIn,omitempty"`
	ExternalURIGt           *string  `json:"externalURIGT,omitempty"`
	ExternalURIGte          *string  `json:"externalURIGTE,omitempty"`
	ExternalURILt           *string  `json:"externalURILT,omitempty"`
	ExternalURILte          *string  `json:"externalURILTE,omitempty"`
	ExternalURIContains     *string  `json:"externalURIContains,omitempty"`
	ExternalURIHasPrefix    *string  `json:"externalURIHasPrefix,omitempty"`
	ExternalURIHasSuffix    *string  `json:"externalURIHasSuffix,omitempty"`
	ExternalURIIsNil        *bool    `json:"externalURIIsNil,omitempty"`
	ExternalURINotNil       *bool    `json:"externalURINotNil,omitempty"`
	ExternalURIEqualFold    *string  `json:"externalURIEqualFold,omitempty"`
	ExternalURIContainsFold *string  `json:"externalURIContainsFold,omitempty"`
}

// Ordering options for Remediation connections
type RemediationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Remediations.
	Field RemediationOrderField `json:"field"`
}

// Return response for updateRemediation mutation
type RemediationUpdatePayload struct {
	// Updated remediation
	Remediation *Remediation `json:"remediation"`
}

// RemediationWhereInput is used for filtering Remediation objects.
// Input was generated by ent.
type RemediationWhereInput struct {
	Not *RemediationWhereInput   `json:"not,omitempty"`
	And []*RemediationWhereInput `json:"and,omitempty"`
	Or  []*RemediationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        *bool    `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       *bool    `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// external_owner_id field predicates
	ExternalOwnerID             *string  `json:"externalOwnerID,omitempty"`
	ExternalOwnerIdneq          *string  `json:"externalOwnerIDNEQ,omitempty"`
	ExternalOwnerIDIn           []string `json:"externalOwnerIDIn,omitempty"`
	ExternalOwnerIDNotIn        []string `json:"externalOwnerIDNotIn,omitempty"`
	ExternalOwnerIdgt           *string  `json:"externalOwnerIDGT,omitempty"`
	ExternalOwnerIdgte          *string  `json:"externalOwnerIDGTE,omitempty"`
	ExternalOwnerIdlt           *string  `json:"externalOwnerIDLT,omitempty"`
	ExternalOwnerIdlte          *string  `json:"externalOwnerIDLTE,omitempty"`
	ExternalOwnerIDContains     *string  `json:"externalOwnerIDContains,omitempty"`
	ExternalOwnerIDHasPrefix    *string  `json:"externalOwnerIDHasPrefix,omitempty"`
	ExternalOwnerIDHasSuffix    *string  `json:"externalOwnerIDHasSuffix,omitempty"`
	ExternalOwnerIDIsNil        *bool    `json:"externalOwnerIDIsNil,omitempty"`
	ExternalOwnerIDNotNil       *bool    `json:"externalOwnerIDNotNil,omitempty"`
	ExternalOwnerIDEqualFold    *string  `json:"externalOwnerIDEqualFold,omitempty"`
	ExternalOwnerIDContainsFold *string  `json:"externalOwnerIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// state field predicates
	State             *string  `json:"state,omitempty"`
	StateNeq          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGt           *string  `json:"stateGT,omitempty"`
	StateGte          *string  `json:"stateGTE,omitempty"`
	StateLt           *string  `json:"stateLT,omitempty"`
	StateLte          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        *bool    `json:"stateIsNil,omitempty"`
	StateNotNil       *bool    `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`
	// intent field predicates
	Intent             *string  `json:"intent,omitempty"`
	IntentNeq          *string  `json:"intentNEQ,omitempty"`
	IntentIn           []string `json:"intentIn,omitempty"`
	IntentNotIn        []string `json:"intentNotIn,omitempty"`
	IntentGt           *string  `json:"intentGT,omitempty"`
	IntentGte          *string  `json:"intentGTE,omitempty"`
	IntentLt           *string  `json:"intentLT,omitempty"`
	IntentLte          *string  `json:"intentLTE,omitempty"`
	IntentContains     *string  `json:"intentContains,omitempty"`
	IntentHasPrefix    *string  `json:"intentHasPrefix,omitempty"`
	IntentHasSuffix    *string  `json:"intentHasSuffix,omitempty"`
	IntentIsNil        *bool    `json:"intentIsNil,omitempty"`
	IntentNotNil       *bool    `json:"intentNotNil,omitempty"`
	IntentEqualFold    *string  `json:"intentEqualFold,omitempty"`
	IntentContainsFold *string  `json:"intentContainsFold,omitempty"`
	// summary field predicates
	Summary             *string  `json:"summary,omitempty"`
	SummaryNeq          *string  `json:"summaryNEQ,omitempty"`
	SummaryIn           []string `json:"summaryIn,omitempty"`
	SummaryNotIn        []string `json:"summaryNotIn,omitempty"`
	SummaryGt           *string  `json:"summaryGT,omitempty"`
	SummaryGte          *string  `json:"summaryGTE,omitempty"`
	SummaryLt           *string  `json:"summaryLT,omitempty"`
	SummaryLte          *string  `json:"summaryLTE,omitempty"`
	SummaryContains     *string  `json:"summaryContains,omitempty"`
	SummaryHasPrefix    *string  `json:"summaryHasPrefix,omitempty"`
	SummaryHasSuffix    *string  `json:"summaryHasSuffix,omitempty"`
	SummaryIsNil        *bool    `json:"summaryIsNil,omitempty"`
	SummaryNotNil       *bool    `json:"summaryNotNil,omitempty"`
	SummaryEqualFold    *string  `json:"summaryEqualFold,omitempty"`
	SummaryContainsFold *string  `json:"summaryContainsFold,omitempty"`
	// explanation field predicates
	Explanation             *string  `json:"explanation,omitempty"`
	ExplanationNeq          *string  `json:"explanationNEQ,omitempty"`
	ExplanationIn           []string `json:"explanationIn,omitempty"`
	ExplanationNotIn        []string `json:"explanationNotIn,omitempty"`
	ExplanationGt           *string  `json:"explanationGT,omitempty"`
	ExplanationGte          *string  `json:"explanationGTE,omitempty"`
	ExplanationLt           *string  `json:"explanationLT,omitempty"`
	ExplanationLte          *string  `json:"explanationLTE,omitempty"`
	ExplanationContains     *string  `json:"explanationContains,omitempty"`
	ExplanationHasPrefix    *string  `json:"explanationHasPrefix,omitempty"`
	ExplanationHasSuffix    *string  `json:"explanationHasSuffix,omitempty"`
	ExplanationIsNil        *bool    `json:"explanationIsNil,omitempty"`
	ExplanationNotNil       *bool    `json:"explanationNotNil,omitempty"`
	ExplanationEqualFold    *string  `json:"explanationEqualFold,omitempty"`
	ExplanationContainsFold *string  `json:"explanationContainsFold,omitempty"`
	// instructions field predicates
	Instructions             *string  `json:"instructions,omitempty"`
	InstructionsNeq          *string  `json:"instructionsNEQ,omitempty"`
	InstructionsIn           []string `json:"instructionsIn,omitempty"`
	InstructionsNotIn        []string `json:"instructionsNotIn,omitempty"`
	InstructionsGt           *string  `json:"instructionsGT,omitempty"`
	InstructionsGte          *string  `json:"instructionsGTE,omitempty"`
	InstructionsLt           *string  `json:"instructionsLT,omitempty"`
	InstructionsLte          *string  `json:"instructionsLTE,omitempty"`
	InstructionsContains     *string  `json:"instructionsContains,omitempty"`
	InstructionsHasPrefix    *string  `json:"instructionsHasPrefix,omitempty"`
	InstructionsHasSuffix    *string  `json:"instructionsHasSuffix,omitempty"`
	InstructionsIsNil        *bool    `json:"instructionsIsNil,omitempty"`
	InstructionsNotNil       *bool    `json:"instructionsNotNil,omitempty"`
	InstructionsEqualFold    *string  `json:"instructionsEqualFold,omitempty"`
	InstructionsContainsFold *string  `json:"instructionsContainsFold,omitempty"`
	// owner_reference field predicates
	OwnerReference             *string  `json:"ownerReference,omitempty"`
	OwnerReferenceNeq          *string  `json:"ownerReferenceNEQ,omitempty"`
	OwnerReferenceIn           []string `json:"ownerReferenceIn,omitempty"`
	OwnerReferenceNotIn        []string `json:"ownerReferenceNotIn,omitempty"`
	OwnerReferenceGt           *string  `json:"ownerReferenceGT,omitempty"`
	OwnerReferenceGte          *string  `json:"ownerReferenceGTE,omitempty"`
	OwnerReferenceLt           *string  `json:"ownerReferenceLT,omitempty"`
	OwnerReferenceLte          *string  `json:"ownerReferenceLTE,omitempty"`
	OwnerReferenceContains     *string  `json:"ownerReferenceContains,omitempty"`
	OwnerReferenceHasPrefix    *string  `json:"ownerReferenceHasPrefix,omitempty"`
	OwnerReferenceHasSuffix    *string  `json:"ownerReferenceHasSuffix,omitempty"`
	OwnerReferenceIsNil        *bool    `json:"ownerReferenceIsNil,omitempty"`
	OwnerReferenceNotNil       *bool    `json:"ownerReferenceNotNil,omitempty"`
	OwnerReferenceEqualFold    *string  `json:"ownerReferenceEqualFold,omitempty"`
	OwnerReferenceContainsFold *string  `json:"ownerReferenceContainsFold,omitempty"`
	// repository_uri field predicates
	RepositoryURI             *string  `json:"repositoryURI,omitempty"`
	RepositoryURINeq          *string  `json:"repositoryURINEQ,omitempty"`
	RepositoryURIIn           []string `json:"repositoryURIIn,omitempty"`
	RepositoryURINotIn        []string `json:"repositoryURINotIn,omitempty"`
	RepositoryURIGt           *string  `json:"repositoryURIGT,omitempty"`
	RepositoryURIGte          *string  `json:"repositoryURIGTE,omitempty"`
	RepositoryURILt           *string  `json:"repositoryURILT,omitempty"`
	RepositoryURILte          *string  `json:"repositoryURILTE,omitempty"`
	RepositoryURIContains     *string  `json:"repositoryURIContains,omitempty"`
	RepositoryURIHasPrefix    *string  `json:"repositoryURIHasPrefix,omitempty"`
	RepositoryURIHasSuffix    *string  `json:"repositoryURIHasSuffix,omitempty"`
	RepositoryURIIsNil        *bool    `json:"repositoryURIIsNil,omitempty"`
	RepositoryURINotNil       *bool    `json:"repositoryURINotNil,omitempty"`
	RepositoryURIEqualFold    *string  `json:"repositoryURIEqualFold,omitempty"`
	RepositoryURIContainsFold *string  `json:"repositoryURIContainsFold,omitempty"`
	// pull_request_uri field predicates
	PullRequestURI             *string  `json:"pullRequestURI,omitempty"`
	PullRequestURINeq          *string  `json:"pullRequestURINEQ,omitempty"`
	PullRequestURIIn           []string `json:"pullRequestURIIn,omitempty"`
	PullRequestURINotIn        []string `json:"pullRequestURINotIn,omitempty"`
	PullRequestURIGt           *string  `json:"pullRequestURIGT,omitempty"`
	PullRequestURIGte          *string  `json:"pullRequestURIGTE,omitempty"`
	PullRequestURILt           *string  `json:"pullRequestURILT,omitempty"`
	PullRequestURILte          *string  `json:"pullRequestURILTE,omitempty"`
	PullRequestURIContains     *string  `json:"pullRequestURIContains,omitempty"`
	PullRequestURIHasPrefix    *string  `json:"pullRequestURIHasPrefix,omitempty"`
	PullRequestURIHasSuffix    *string  `json:"pullRequestURIHasSuffix,omitempty"`
	PullRequestURIIsNil        *bool    `json:"pullRequestURIIsNil,omitempty"`
	PullRequestURINotNil       *bool    `json:"pullRequestURINotNil,omitempty"`
	PullRequestURIEqualFold    *string  `json:"pullRequestURIEqualFold,omitempty"`
	PullRequestURIContainsFold *string  `json:"pullRequestURIContainsFold,omitempty"`
	// ticket_reference field predicates
	TicketReference             *string  `json:"ticketReference,omitempty"`
	TicketReferenceNeq          *string  `json:"ticketReferenceNEQ,omitempty"`
	TicketReferenceIn           []string `json:"ticketReferenceIn,omitempty"`
	TicketReferenceNotIn        []string `json:"ticketReferenceNotIn,omitempty"`
	TicketReferenceGt           *string  `json:"ticketReferenceGT,omitempty"`
	TicketReferenceGte          *string  `json:"ticketReferenceGTE,omitempty"`
	TicketReferenceLt           *string  `json:"ticketReferenceLT,omitempty"`
	TicketReferenceLte          *string  `json:"ticketReferenceLTE,omitempty"`
	TicketReferenceContains     *string  `json:"ticketReferenceContains,omitempty"`
	TicketReferenceHasPrefix    *string  `json:"ticketReferenceHasPrefix,omitempty"`
	TicketReferenceHasSuffix    *string  `json:"ticketReferenceHasSuffix,omitempty"`
	TicketReferenceIsNil        *bool    `json:"ticketReferenceIsNil,omitempty"`
	TicketReferenceNotNil       *bool    `json:"ticketReferenceNotNil,omitempty"`
	TicketReferenceEqualFold    *string  `json:"ticketReferenceEqualFold,omitempty"`
	TicketReferenceContainsFold *string  `json:"ticketReferenceContainsFold,omitempty"`
	// due_at field predicates
	DueAt       *models.DateTime   `json:"dueAt,omitempty"`
	DueAtNeq    *models.DateTime   `json:"dueAtNEQ,omitempty"`
	DueAtIn     []*models.DateTime `json:"dueAtIn,omitempty"`
	DueAtNotIn  []*models.DateTime `json:"dueAtNotIn,omitempty"`
	DueAtGt     *models.DateTime   `json:"dueAtGT,omitempty"`
	DueAtGte    *models.DateTime   `json:"dueAtGTE,omitempty"`
	DueAtLt     *models.DateTime   `json:"dueAtLT,omitempty"`
	DueAtLte    *models.DateTime   `json:"dueAtLTE,omitempty"`
	DueAtIsNil  *bool              `json:"dueAtIsNil,omitempty"`
	DueAtNotNil *bool              `json:"dueAtNotNil,omitempty"`
	// completed_at field predicates
	CompletedAt       *models.DateTime   `json:"completedAt,omitempty"`
	CompletedAtNeq    *models.DateTime   `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []*models.DateTime `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []*models.DateTime `json:"completedAtNotIn,omitempty"`
	CompletedAtGt     *models.DateTime   `json:"completedAtGT,omitempty"`
	CompletedAtGte    *models.DateTime   `json:"completedAtGTE,omitempty"`
	CompletedAtLt     *models.DateTime   `json:"completedAtLT,omitempty"`
	CompletedAtLte    *models.DateTime   `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  *bool              `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil *bool              `json:"completedAtNotNil,omitempty"`
	// pr_generated_at field predicates
	PrGeneratedAt       *models.DateTime   `json:"prGeneratedAt,omitempty"`
	PrGeneratedAtNeq    *models.DateTime   `json:"prGeneratedAtNEQ,omitempty"`
	PrGeneratedAtIn     []*models.DateTime `json:"prGeneratedAtIn,omitempty"`
	PrGeneratedAtNotIn  []*models.DateTime `json:"prGeneratedAtNotIn,omitempty"`
	PrGeneratedAtGt     *models.DateTime   `json:"prGeneratedAtGT,omitempty"`
	PrGeneratedAtGte    *models.DateTime   `json:"prGeneratedAtGTE,omitempty"`
	PrGeneratedAtLt     *models.DateTime   `json:"prGeneratedAtLT,omitempty"`
	PrGeneratedAtLte    *models.DateTime   `json:"prGeneratedAtLTE,omitempty"`
	PrGeneratedAtIsNil  *bool              `json:"prGeneratedAtIsNil,omitempty"`
	PrGeneratedAtNotNil *bool              `json:"prGeneratedAtNotNil,omitempty"`
	// error field predicates
	Error             *string  `json:"error,omitempty"`
	ErrorNeq          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGt           *string  `json:"errorGT,omitempty"`
	ErrorGte          *string  `json:"errorGTE,omitempty"`
	ErrorLt           *string  `json:"errorLT,omitempty"`
	ErrorLte          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        *bool    `json:"errorIsNil,omitempty"`
	ErrorNotNil       *bool    `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// external_uri field predicates
	ExternalURI             *string  `json:"externalURI,omitempty"`
	ExternalURINeq          *string  `json:"externalURINEQ,omitempty"`
	ExternalURIIn           []string `json:"externalURIIn,omitempty"`
	ExternalURINotIn        []string `json:"externalURINotIn,omitempty"`
	ExternalURIGt           *string  `json:"externalURIGT,omitempty"`
	ExternalURIGte          *string  `json:"externalURIGTE,omitempty"`
	ExternalURILt           *string  `json:"externalURILT,omitempty"`
	ExternalURILte          *string  `json:"externalURILTE,omitempty"`
	ExternalURIContains     *string  `json:"externalURIContains,omitempty"`
	ExternalURIHasPrefix    *string  `json:"externalURIHasPrefix,omitempty"`
	ExternalURIHasSuffix    *string  `json:"externalURIHasSuffix,omitempty"`
	ExternalURIIsNil        *bool    `json:"externalURIIsNil,omitempty"`
	ExternalURINotNil       *bool    `json:"externalURINotNil,omitempty"`
	ExternalURIEqualFold    *string  `json:"externalURIEqualFold,omitempty"`
	ExternalURIContainsFold *string  `json:"externalURIContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// findings edge predicates
	HasFindings     *bool                `json:"hasFindings,omitempty"`
	HasFindingsWith []*FindingWhereInput `json:"hasFindingsWith,omitempty"`
	// vulnerabilities edge predicates
	HasVulnerabilities     *bool                      `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*VulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// reviews edge predicates
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Review struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the review
	ExternalID *string `json:"externalID,omitempty"`
	// external identifier from the integration source for the review
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// title of the review
	Title string `json:"title"`
	// state of the review
	State *string `json:"state,omitempty"`
	// category for the review record
	Category *string `json:"category,omitempty"`
	// classification or sensitivity of the review record
	Classification *string `json:"classification,omitempty"`
	// summary text for the review
	Summary *string `json:"summary,omitempty"`
	// detailed notes captured during the review
	Details *string `json:"details,omitempty"`
	// person or system that created the review
	Reporter *string `json:"reporter,omitempty"`
	// true when the review has been approved
	Approved *bool `json:"approved,omitempty"`
	// timestamp when the review was completed
	ReviewedAt *models.DateTime `json:"reviewedAt,omitempty"`
	// timestamp when the review was reported or opened
	ReportedAt *models.DateTime `json:"reportedAt,omitempty"`
	// timestamp when the review was approved
	ApprovedAt *models.DateTime `json:"approvedAt,omitempty"`
	// identifier for the user primarily responsible for the review
	ReviewerID *string `json:"reviewerID,omitempty"`
	// system that produced the review record
	Source *string `json:"source,omitempty"`
	// link to the review in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the review from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload      map[string]any           `json:"rawPayload,omitempty"`
	Owner           *Organization            `json:"owner,omitempty"`
	BlockedGroups   *GroupConnection         `json:"blockedGroups"`
	Editors         *GroupConnection         `json:"editors"`
	Viewers         *GroupConnection         `json:"viewers"`
	Integrations    *IntegrationConnection   `json:"integrations"`
	Findings        *FindingConnection       `json:"findings"`
	Vulnerabilities *VulnerabilityConnection `json:"vulnerabilities"`
	ActionPlans     *ActionPlanConnection    `json:"actionPlans"`
	Remediations    *RemediationConnection   `json:"remediations"`
	Controls        *ControlConnection       `json:"controls"`
	Subcontrols     *SubcontrolConnection    `json:"subcontrols"`
	Risks           *RiskConnection          `json:"risks"`
	Programs        *ProgramConnection       `json:"programs"`
	Assets          *AssetConnection         `json:"assets"`
	Entities        *EntityConnection        `json:"entities"`
	Tasks           *TaskConnection          `json:"tasks"`
	// primary reviewer responsible for the record
	Reviewer *User           `json:"reviewer,omitempty"`
	Comments *NoteConnection `json:"comments"`
	Files    *FileConnection `json:"files"`
}

func (Review) IsNode() {}

// Return response for createBulkReview mutation
type ReviewBulkCreatePayload struct {
	// Created reviews
	Reviews []*Review `json:"reviews,omitempty"`
}

// A connection to a list of items.
type ReviewConnection struct {
	// A list of edges.
	Edges []*ReviewEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createReview mutation
type ReviewCreatePayload struct {
	// Created review
	Review *Review `json:"review"`
}

// Return response for deleteReview mutation
type ReviewDeletePayload struct {
	// Deleted review ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ReviewEdge struct {
	// The item at the end of the edge.
	Node *Review `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ReviewHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// external identifier from the integration source for the review
	ExternalID *string `json:"externalID,omitempty"`
	// external identifier from the integration source for the review
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// title of the review
	Title string `json:"title"`
	// state of the review
	State *string `json:"state,omitempty"`
	// category for the review record
	Category *string `json:"category,omitempty"`
	// classification or sensitivity of the review record
	Classification *string `json:"classification,omitempty"`
	// summary text for the review
	Summary *string `json:"summary,omitempty"`
	// detailed notes captured during the review
	Details *string `json:"details,omitempty"`
	// person or system that created the review
	Reporter *string `json:"reporter,omitempty"`
	// true when the review has been approved
	Approved *bool `json:"approved,omitempty"`
	// timestamp when the review was completed
	ReviewedAt *models.DateTime `json:"reviewedAt,omitempty"`
	// timestamp when the review was reported or opened
	ReportedAt *models.DateTime `json:"reportedAt,omitempty"`
	// timestamp when the review was approved
	ApprovedAt *models.DateTime `json:"approvedAt,omitempty"`
	// identifier for the user primarily responsible for the review
	ReviewerID *string `json:"reviewerID,omitempty"`
	// system that produced the review record
	Source *string `json:"source,omitempty"`
	// link to the review in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the review from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload map[string]any `json:"rawPayload,omitempty"`
}

func (ReviewHistory) IsNode() {}

// A connection to a list of items.
type ReviewHistoryConnection struct {
	// A list of edges.
	Edges []*ReviewHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ReviewHistoryEdge struct {
	// The item at the end of the edge.
	Node *ReviewHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ReviewHistory connections
type ReviewHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ReviewHistories.
	Field ReviewHistoryOrderField `json:"field"`
}

// ReviewHistoryWhereInput is used for filtering ReviewHistory objects.
// Input was generated by ent.
type ReviewHistoryWhereInput struct {
	Not *ReviewHistoryWhereInput   `json:"not,omitempty"`
	And []*ReviewHistoryWhereInput `json:"and,omitempty"`
	Or  []*ReviewHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        *bool    `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       *bool    `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// external_owner_id field predicates
	ExternalOwnerID             *string  `json:"externalOwnerID,omitempty"`
	ExternalOwnerIdneq          *string  `json:"externalOwnerIDNEQ,omitempty"`
	ExternalOwnerIDIn           []string `json:"externalOwnerIDIn,omitempty"`
	ExternalOwnerIDNotIn        []string `json:"externalOwnerIDNotIn,omitempty"`
	ExternalOwnerIdgt           *string  `json:"externalOwnerIDGT,omitempty"`
	ExternalOwnerIdgte          *string  `json:"externalOwnerIDGTE,omitempty"`
	ExternalOwnerIdlt           *string  `json:"externalOwnerIDLT,omitempty"`
	ExternalOwnerIdlte          *string  `json:"externalOwnerIDLTE,omitempty"`
	ExternalOwnerIDContains     *string  `json:"externalOwnerIDContains,omitempty"`
	ExternalOwnerIDHasPrefix    *string  `json:"externalOwnerIDHasPrefix,omitempty"`
	ExternalOwnerIDHasSuffix    *string  `json:"externalOwnerIDHasSuffix,omitempty"`
	ExternalOwnerIDIsNil        *bool    `json:"externalOwnerIDIsNil,omitempty"`
	ExternalOwnerIDNotNil       *bool    `json:"externalOwnerIDNotNil,omitempty"`
	ExternalOwnerIDEqualFold    *string  `json:"externalOwnerIDEqualFold,omitempty"`
	ExternalOwnerIDContainsFold *string  `json:"externalOwnerIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// state field predicates
	State             *string  `json:"state,omitempty"`
	StateNeq          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGt           *string  `json:"stateGT,omitempty"`
	StateGte          *string  `json:"stateGTE,omitempty"`
	StateLt           *string  `json:"stateLT,omitempty"`
	StateLte          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        *bool    `json:"stateIsNil,omitempty"`
	StateNotNil       *bool    `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// classification field predicates
	Classification             *string  `json:"classification,omitempty"`
	ClassificationNeq          *string  `json:"classificationNEQ,omitempty"`
	ClassificationIn           []string `json:"classificationIn,omitempty"`
	ClassificationNotIn        []string `json:"classificationNotIn,omitempty"`
	ClassificationGt           *string  `json:"classificationGT,omitempty"`
	ClassificationGte          *string  `json:"classificationGTE,omitempty"`
	ClassificationLt           *string  `json:"classificationLT,omitempty"`
	ClassificationLte          *string  `json:"classificationLTE,omitempty"`
	ClassificationContains     *string  `json:"classificationContains,omitempty"`
	ClassificationHasPrefix    *string  `json:"classificationHasPrefix,omitempty"`
	ClassificationHasSuffix    *string  `json:"classificationHasSuffix,omitempty"`
	ClassificationIsNil        *bool    `json:"classificationIsNil,omitempty"`
	ClassificationNotNil       *bool    `json:"classificationNotNil,omitempty"`
	ClassificationEqualFold    *string  `json:"classificationEqualFold,omitempty"`
	ClassificationContainsFold *string  `json:"classificationContainsFold,omitempty"`
	// summary field predicates
	Summary             *string  `json:"summary,omitempty"`
	SummaryNeq          *string  `json:"summaryNEQ,omitempty"`
	SummaryIn           []string `json:"summaryIn,omitempty"`
	SummaryNotIn        []string `json:"summaryNotIn,omitempty"`
	SummaryGt           *string  `json:"summaryGT,omitempty"`
	SummaryGte          *string  `json:"summaryGTE,omitempty"`
	SummaryLt           *string  `json:"summaryLT,omitempty"`
	SummaryLte          *string  `json:"summaryLTE,omitempty"`
	SummaryContains     *string  `json:"summaryContains,omitempty"`
	SummaryHasPrefix    *string  `json:"summaryHasPrefix,omitempty"`
	SummaryHasSuffix    *string  `json:"summaryHasSuffix,omitempty"`
	SummaryIsNil        *bool    `json:"summaryIsNil,omitempty"`
	SummaryNotNil       *bool    `json:"summaryNotNil,omitempty"`
	SummaryEqualFold    *string  `json:"summaryEqualFold,omitempty"`
	SummaryContainsFold *string  `json:"summaryContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// reporter field predicates
	Reporter             *string  `json:"reporter,omitempty"`
	ReporterNeq          *string  `json:"reporterNEQ,omitempty"`
	ReporterIn           []string `json:"reporterIn,omitempty"`
	ReporterNotIn        []string `json:"reporterNotIn,omitempty"`
	ReporterGt           *string  `json:"reporterGT,omitempty"`
	ReporterGte          *string  `json:"reporterGTE,omitempty"`
	ReporterLt           *string  `json:"reporterLT,omitempty"`
	ReporterLte          *string  `json:"reporterLTE,omitempty"`
	ReporterContains     *string  `json:"reporterContains,omitempty"`
	ReporterHasPrefix    *string  `json:"reporterHasPrefix,omitempty"`
	ReporterHasSuffix    *string  `json:"reporterHasSuffix,omitempty"`
	ReporterIsNil        *bool    `json:"reporterIsNil,omitempty"`
	ReporterNotNil       *bool    `json:"reporterNotNil,omitempty"`
	ReporterEqualFold    *string  `json:"reporterEqualFold,omitempty"`
	ReporterContainsFold *string  `json:"reporterContainsFold,omitempty"`
	// approved field predicates
	Approved       *bool `json:"approved,omitempty"`
	ApprovedNeq    *bool `json:"approvedNEQ,omitempty"`
	ApprovedIsNil  *bool `json:"approvedIsNil,omitempty"`
	ApprovedNotNil *bool `json:"approvedNotNil,omitempty"`
	// reviewed_at field predicates
	ReviewedAt       *models.DateTime   `json:"reviewedAt,omitempty"`
	ReviewedAtNeq    *models.DateTime   `json:"reviewedAtNEQ,omitempty"`
	ReviewedAtIn     []*models.DateTime `json:"reviewedAtIn,omitempty"`
	ReviewedAtNotIn  []*models.DateTime `json:"reviewedAtNotIn,omitempty"`
	ReviewedAtGt     *models.DateTime   `json:"reviewedAtGT,omitempty"`
	ReviewedAtGte    *models.DateTime   `json:"reviewedAtGTE,omitempty"`
	ReviewedAtLt     *models.DateTime   `json:"reviewedAtLT,omitempty"`
	ReviewedAtLte    *models.DateTime   `json:"reviewedAtLTE,omitempty"`
	ReviewedAtIsNil  *bool              `json:"reviewedAtIsNil,omitempty"`
	ReviewedAtNotNil *bool              `json:"reviewedAtNotNil,omitempty"`
	// reported_at field predicates
	ReportedAt       *models.DateTime   `json:"reportedAt,omitempty"`
	ReportedAtNeq    *models.DateTime   `json:"reportedAtNEQ,omitempty"`
	ReportedAtIn     []*models.DateTime `json:"reportedAtIn,omitempty"`
	ReportedAtNotIn  []*models.DateTime `json:"reportedAtNotIn,omitempty"`
	ReportedAtGt     *models.DateTime   `json:"reportedAtGT,omitempty"`
	ReportedAtGte    *models.DateTime   `json:"reportedAtGTE,omitempty"`
	ReportedAtLt     *models.DateTime   `json:"reportedAtLT,omitempty"`
	ReportedAtLte    *models.DateTime   `json:"reportedAtLTE,omitempty"`
	ReportedAtIsNil  *bool              `json:"reportedAtIsNil,omitempty"`
	ReportedAtNotNil *bool              `json:"reportedAtNotNil,omitempty"`
	// approved_at field predicates
	ApprovedAt       *models.DateTime   `json:"approvedAt,omitempty"`
	ApprovedAtNeq    *models.DateTime   `json:"approvedAtNEQ,omitempty"`
	ApprovedAtIn     []*models.DateTime `json:"approvedAtIn,omitempty"`
	ApprovedAtNotIn  []*models.DateTime `json:"approvedAtNotIn,omitempty"`
	ApprovedAtGt     *models.DateTime   `json:"approvedAtGT,omitempty"`
	ApprovedAtGte    *models.DateTime   `json:"approvedAtGTE,omitempty"`
	ApprovedAtLt     *models.DateTime   `json:"approvedAtLT,omitempty"`
	ApprovedAtLte    *models.DateTime   `json:"approvedAtLTE,omitempty"`
	ApprovedAtIsNil  *bool              `json:"approvedAtIsNil,omitempty"`
	ApprovedAtNotNil *bool              `json:"approvedAtNotNil,omitempty"`
	// reviewer_id field predicates
	ReviewerID             *string  `json:"reviewerID,omitempty"`
	ReviewerIdneq          *string  `json:"reviewerIDNEQ,omitempty"`
	ReviewerIDIn           []string `json:"reviewerIDIn,omitempty"`
	ReviewerIDNotIn        []string `json:"reviewerIDNotIn,omitempty"`
	ReviewerIdgt           *string  `json:"reviewerIDGT,omitempty"`
	ReviewerIdgte          *string  `json:"reviewerIDGTE,omitempty"`
	ReviewerIdlt           *string  `json:"reviewerIDLT,omitempty"`
	ReviewerIdlte          *string  `json:"reviewerIDLTE,omitempty"`
	ReviewerIDContains     *string  `json:"reviewerIDContains,omitempty"`
	ReviewerIDHasPrefix    *string  `json:"reviewerIDHasPrefix,omitempty"`
	ReviewerIDHasSuffix    *string  `json:"reviewerIDHasSuffix,omitempty"`
	ReviewerIDIsNil        *bool    `json:"reviewerIDIsNil,omitempty"`
	ReviewerIDNotNil       *bool    `json:"reviewerIDNotNil,omitempty"`
	ReviewerIDEqualFold    *string  `json:"reviewerIDEqualFold,omitempty"`
	ReviewerIDContainsFold *string  `json:"reviewerIDContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// external_uri field predicates
	ExternalURI             *string  `json:"externalURI,omitempty"`
	ExternalURINeq          *string  `json:"externalURINEQ,omitempty"`
	ExternalURIIn           []string `json:"externalURIIn,omitempty"`
	ExternalURINotIn        []string `json:"externalURINotIn,omitempty"`
	ExternalURIGt           *string  `json:"externalURIGT,omitempty"`
	ExternalURIGte          *string  `json:"externalURIGTE,omitempty"`
	ExternalURILt           *string  `json:"externalURILT,omitempty"`
	ExternalURILte          *string  `json:"externalURILTE,omitempty"`
	ExternalURIContains     *string  `json:"externalURIContains,omitempty"`
	ExternalURIHasPrefix    *string  `json:"externalURIHasPrefix,omitempty"`
	ExternalURIHasSuffix    *string  `json:"externalURIHasSuffix,omitempty"`
	ExternalURIIsNil        *bool    `json:"externalURIIsNil,omitempty"`
	ExternalURINotNil       *bool    `json:"externalURINotNil,omitempty"`
	ExternalURIEqualFold    *string  `json:"externalURIEqualFold,omitempty"`
	ExternalURIContainsFold *string  `json:"externalURIContainsFold,omitempty"`
}

// Ordering options for Review connections
type ReviewOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Reviews.
	Field ReviewOrderField `json:"field"`
}

// Return response for updateReview mutation
type ReviewUpdatePayload struct {
	// Updated review
	Review *Review `json:"review"`
}

// ReviewWhereInput is used for filtering Review objects.
// Input was generated by ent.
type ReviewWhereInput struct {
	Not *ReviewWhereInput   `json:"not,omitempty"`
	And []*ReviewWhereInput `json:"and,omitempty"`
	Or  []*ReviewWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        *bool    `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       *bool    `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// external_owner_id field predicates
	ExternalOwnerID             *string  `json:"externalOwnerID,omitempty"`
	ExternalOwnerIdneq          *string  `json:"externalOwnerIDNEQ,omitempty"`
	ExternalOwnerIDIn           []string `json:"externalOwnerIDIn,omitempty"`
	ExternalOwnerIDNotIn        []string `json:"externalOwnerIDNotIn,omitempty"`
	ExternalOwnerIdgt           *string  `json:"externalOwnerIDGT,omitempty"`
	ExternalOwnerIdgte          *string  `json:"externalOwnerIDGTE,omitempty"`
	ExternalOwnerIdlt           *string  `json:"externalOwnerIDLT,omitempty"`
	ExternalOwnerIdlte          *string  `json:"externalOwnerIDLTE,omitempty"`
	ExternalOwnerIDContains     *string  `json:"externalOwnerIDContains,omitempty"`
	ExternalOwnerIDHasPrefix    *string  `json:"externalOwnerIDHasPrefix,omitempty"`
	ExternalOwnerIDHasSuffix    *string  `json:"externalOwnerIDHasSuffix,omitempty"`
	ExternalOwnerIDIsNil        *bool    `json:"externalOwnerIDIsNil,omitempty"`
	ExternalOwnerIDNotNil       *bool    `json:"externalOwnerIDNotNil,omitempty"`
	ExternalOwnerIDEqualFold    *string  `json:"externalOwnerIDEqualFold,omitempty"`
	ExternalOwnerIDContainsFold *string  `json:"externalOwnerIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// state field predicates
	State             *string  `json:"state,omitempty"`
	StateNeq          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGt           *string  `json:"stateGT,omitempty"`
	StateGte          *string  `json:"stateGTE,omitempty"`
	StateLt           *string  `json:"stateLT,omitempty"`
	StateLte          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        *bool    `json:"stateIsNil,omitempty"`
	StateNotNil       *bool    `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// classification field predicates
	Classification             *string  `json:"classification,omitempty"`
	ClassificationNeq          *string  `json:"classificationNEQ,omitempty"`
	ClassificationIn           []string `json:"classificationIn,omitempty"`
	ClassificationNotIn        []string `json:"classificationNotIn,omitempty"`
	ClassificationGt           *string  `json:"classificationGT,omitempty"`
	ClassificationGte          *string  `json:"classificationGTE,omitempty"`
	ClassificationLt           *string  `json:"classificationLT,omitempty"`
	ClassificationLte          *string  `json:"classificationLTE,omitempty"`
	ClassificationContains     *string  `json:"classificationContains,omitempty"`
	ClassificationHasPrefix    *string  `json:"classificationHasPrefix,omitempty"`
	ClassificationHasSuffix    *string  `json:"classificationHasSuffix,omitempty"`
	ClassificationIsNil        *bool    `json:"classificationIsNil,omitempty"`
	ClassificationNotNil       *bool    `json:"classificationNotNil,omitempty"`
	ClassificationEqualFold    *string  `json:"classificationEqualFold,omitempty"`
	ClassificationContainsFold *string  `json:"classificationContainsFold,omitempty"`
	// summary field predicates
	Summary             *string  `json:"summary,omitempty"`
	SummaryNeq          *string  `json:"summaryNEQ,omitempty"`
	SummaryIn           []string `json:"summaryIn,omitempty"`
	SummaryNotIn        []string `json:"summaryNotIn,omitempty"`
	SummaryGt           *string  `json:"summaryGT,omitempty"`
	SummaryGte          *string  `json:"summaryGTE,omitempty"`
	SummaryLt           *string  `json:"summaryLT,omitempty"`
	SummaryLte          *string  `json:"summaryLTE,omitempty"`
	SummaryContains     *string  `json:"summaryContains,omitempty"`
	SummaryHasPrefix    *string  `json:"summaryHasPrefix,omitempty"`
	SummaryHasSuffix    *string  `json:"summaryHasSuffix,omitempty"`
	SummaryIsNil        *bool    `json:"summaryIsNil,omitempty"`
	SummaryNotNil       *bool    `json:"summaryNotNil,omitempty"`
	SummaryEqualFold    *string  `json:"summaryEqualFold,omitempty"`
	SummaryContainsFold *string  `json:"summaryContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// reporter field predicates
	Reporter             *string  `json:"reporter,omitempty"`
	ReporterNeq          *string  `json:"reporterNEQ,omitempty"`
	ReporterIn           []string `json:"reporterIn,omitempty"`
	ReporterNotIn        []string `json:"reporterNotIn,omitempty"`
	ReporterGt           *string  `json:"reporterGT,omitempty"`
	ReporterGte          *string  `json:"reporterGTE,omitempty"`
	ReporterLt           *string  `json:"reporterLT,omitempty"`
	ReporterLte          *string  `json:"reporterLTE,omitempty"`
	ReporterContains     *string  `json:"reporterContains,omitempty"`
	ReporterHasPrefix    *string  `json:"reporterHasPrefix,omitempty"`
	ReporterHasSuffix    *string  `json:"reporterHasSuffix,omitempty"`
	ReporterIsNil        *bool    `json:"reporterIsNil,omitempty"`
	ReporterNotNil       *bool    `json:"reporterNotNil,omitempty"`
	ReporterEqualFold    *string  `json:"reporterEqualFold,omitempty"`
	ReporterContainsFold *string  `json:"reporterContainsFold,omitempty"`
	// approved field predicates
	Approved       *bool `json:"approved,omitempty"`
	ApprovedNeq    *bool `json:"approvedNEQ,omitempty"`
	ApprovedIsNil  *bool `json:"approvedIsNil,omitempty"`
	ApprovedNotNil *bool `json:"approvedNotNil,omitempty"`
	// reviewed_at field predicates
	ReviewedAt       *models.DateTime   `json:"reviewedAt,omitempty"`
	ReviewedAtNeq    *models.DateTime   `json:"reviewedAtNEQ,omitempty"`
	ReviewedAtIn     []*models.DateTime `json:"reviewedAtIn,omitempty"`
	ReviewedAtNotIn  []*models.DateTime `json:"reviewedAtNotIn,omitempty"`
	ReviewedAtGt     *models.DateTime   `json:"reviewedAtGT,omitempty"`
	ReviewedAtGte    *models.DateTime   `json:"reviewedAtGTE,omitempty"`
	ReviewedAtLt     *models.DateTime   `json:"reviewedAtLT,omitempty"`
	ReviewedAtLte    *models.DateTime   `json:"reviewedAtLTE,omitempty"`
	ReviewedAtIsNil  *bool              `json:"reviewedAtIsNil,omitempty"`
	ReviewedAtNotNil *bool              `json:"reviewedAtNotNil,omitempty"`
	// reported_at field predicates
	ReportedAt       *models.DateTime   `json:"reportedAt,omitempty"`
	ReportedAtNeq    *models.DateTime   `json:"reportedAtNEQ,omitempty"`
	ReportedAtIn     []*models.DateTime `json:"reportedAtIn,omitempty"`
	ReportedAtNotIn  []*models.DateTime `json:"reportedAtNotIn,omitempty"`
	ReportedAtGt     *models.DateTime   `json:"reportedAtGT,omitempty"`
	ReportedAtGte    *models.DateTime   `json:"reportedAtGTE,omitempty"`
	ReportedAtLt     *models.DateTime   `json:"reportedAtLT,omitempty"`
	ReportedAtLte    *models.DateTime   `json:"reportedAtLTE,omitempty"`
	ReportedAtIsNil  *bool              `json:"reportedAtIsNil,omitempty"`
	ReportedAtNotNil *bool              `json:"reportedAtNotNil,omitempty"`
	// approved_at field predicates
	ApprovedAt       *models.DateTime   `json:"approvedAt,omitempty"`
	ApprovedAtNeq    *models.DateTime   `json:"approvedAtNEQ,omitempty"`
	ApprovedAtIn     []*models.DateTime `json:"approvedAtIn,omitempty"`
	ApprovedAtNotIn  []*models.DateTime `json:"approvedAtNotIn,omitempty"`
	ApprovedAtGt     *models.DateTime   `json:"approvedAtGT,omitempty"`
	ApprovedAtGte    *models.DateTime   `json:"approvedAtGTE,omitempty"`
	ApprovedAtLt     *models.DateTime   `json:"approvedAtLT,omitempty"`
	ApprovedAtLte    *models.DateTime   `json:"approvedAtLTE,omitempty"`
	ApprovedAtIsNil  *bool              `json:"approvedAtIsNil,omitempty"`
	ApprovedAtNotNil *bool              `json:"approvedAtNotNil,omitempty"`
	// reviewer_id field predicates
	ReviewerID             *string  `json:"reviewerID,omitempty"`
	ReviewerIdneq          *string  `json:"reviewerIDNEQ,omitempty"`
	ReviewerIDIn           []string `json:"reviewerIDIn,omitempty"`
	ReviewerIDNotIn        []string `json:"reviewerIDNotIn,omitempty"`
	ReviewerIdgt           *string  `json:"reviewerIDGT,omitempty"`
	ReviewerIdgte          *string  `json:"reviewerIDGTE,omitempty"`
	ReviewerIdlt           *string  `json:"reviewerIDLT,omitempty"`
	ReviewerIdlte          *string  `json:"reviewerIDLTE,omitempty"`
	ReviewerIDContains     *string  `json:"reviewerIDContains,omitempty"`
	ReviewerIDHasPrefix    *string  `json:"reviewerIDHasPrefix,omitempty"`
	ReviewerIDHasSuffix    *string  `json:"reviewerIDHasSuffix,omitempty"`
	ReviewerIDIsNil        *bool    `json:"reviewerIDIsNil,omitempty"`
	ReviewerIDNotNil       *bool    `json:"reviewerIDNotNil,omitempty"`
	ReviewerIDEqualFold    *string  `json:"reviewerIDEqualFold,omitempty"`
	ReviewerIDContainsFold *string  `json:"reviewerIDContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// external_uri field predicates
	ExternalURI             *string  `json:"externalURI,omitempty"`
	ExternalURINeq          *string  `json:"externalURINEQ,omitempty"`
	ExternalURIIn           []string `json:"externalURIIn,omitempty"`
	ExternalURINotIn        []string `json:"externalURINotIn,omitempty"`
	ExternalURIGt           *string  `json:"externalURIGT,omitempty"`
	ExternalURIGte          *string  `json:"externalURIGTE,omitempty"`
	ExternalURILt           *string  `json:"externalURILT,omitempty"`
	ExternalURILte          *string  `json:"externalURILTE,omitempty"`
	ExternalURIContains     *string  `json:"externalURIContains,omitempty"`
	ExternalURIHasPrefix    *string  `json:"externalURIHasPrefix,omitempty"`
	ExternalURIHasSuffix    *string  `json:"externalURIHasSuffix,omitempty"`
	ExternalURIIsNil        *bool    `json:"externalURIIsNil,omitempty"`
	ExternalURINotNil       *bool    `json:"externalURINotNil,omitempty"`
	ExternalURIEqualFold    *string  `json:"externalURIEqualFold,omitempty"`
	ExternalURIContainsFold *string  `json:"externalURIContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// findings edge predicates
	HasFindings     *bool                `json:"hasFindings,omitempty"`
	HasFindingsWith []*FindingWhereInput `json:"hasFindingsWith,omitempty"`
	// vulnerabilities edge predicates
	HasVulnerabilities     *bool                      `json:"hasVulnerabilities,omitempty"`
	HasVulnerabilitiesWith []*VulnerabilityWhereInput `json:"hasVulnerabilitiesWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// remediations edge predicates
	HasRemediations     *bool                    `json:"hasRemediations,omitempty"`
	HasRemediationsWith []*RemediationWhereInput `json:"hasRemediationsWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// reviewer edge predicates
	HasReviewer     *bool             `json:"hasReviewer,omitempty"`
	HasReviewerWith []*UserWhereInput `json:"hasReviewerWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Risk struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the kind of the risk
	RiskKindName *string `json:"riskKindName,omitempty"`
	// the kind of the risk
	RiskKindID *string `json:"riskKindID,omitempty"`
	// the category of the risk
	RiskCategoryName *string `json:"riskCategoryName,omitempty"`
	// the category of the risk
	RiskCategoryID *string `json:"riskCategoryID,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// status of the risk - identified, mitigated, accepted, closed, transferred, and archived.
	Status *enums.RiskStatus `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// category of the risk, e.g. human resources, operations, IT, etc.
	Category *string `json:"category,omitempty"`
	// impact of the risk -critical, high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// score of the risk based on impact and likelihood (1-4 unlikely, 5-9 likely, 10-16 highly likely, 17-20 critical)
	Score *int64 `json:"score,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// details of the risk
	Details *string `json:"details,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
	// the id of the group responsible for risk oversight
	StakeholderID *string `json:"stakeholderID,omitempty"`
	// the id of the group responsible for risk oversight on behalf of the stakeholder
	DelegateID       *string                   `json:"delegateID,omitempty"`
	Owner            *Organization             `json:"owner,omitempty"`
	BlockedGroups    *GroupConnection          `json:"blockedGroups"`
	Editors          *GroupConnection          `json:"editors"`
	Viewers          *GroupConnection          `json:"viewers"`
	RiskKind         *CustomTypeEnum           `json:"riskKind,omitempty"`
	RiskCategory     *CustomTypeEnum           `json:"riskCategory,omitempty"`
	Controls         *ControlConnection        `json:"controls"`
	Subcontrols      *SubcontrolConnection     `json:"subcontrols"`
	Procedures       *ProcedureConnection      `json:"procedures"`
	InternalPolicies *InternalPolicyConnection `json:"internalPolicies"`
	Programs         *ProgramConnection        `json:"programs"`
	ActionPlans      *ActionPlanConnection     `json:"actionPlans"`
	Tasks            *TaskConnection           `json:"tasks"`
	Assets           *AssetConnection          `json:"assets"`
	Entities         *EntityConnection         `json:"entities"`
	Scans            *ScanConnection           `json:"scans"`
	// the group of users who are responsible for risk oversight
	Stakeholder *Group `json:"stakeholder,omitempty"`
	// temporary delegates for the risk, used for temporary ownership
	Delegate *Group          `json:"delegate,omitempty"`
	Comments *NoteConnection `json:"comments"`
}

func (Risk) IsNode() {}

// Return response for createBulkRisk mutation
type RiskBulkCreatePayload struct {
	// Created risks
	Risks []*Risk `json:"risks,omitempty"`
}

// Return response for deleteBulkRisk mutation
type RiskBulkDeletePayload struct {
	// Deleted risk IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkRisk mutation
type RiskBulkUpdatePayload struct {
	// Updated risks
	Risks []*Risk `json:"risks,omitempty"`
	// IDs of the updated risks
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type RiskConnection struct {
	// A list of edges.
	Edges []*RiskEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createRisk mutation
type RiskCreatePayload struct {
	// Created risk
	Risk *Risk `json:"risk"`
}

// Return response for deleteRisk mutation
type RiskDeletePayload struct {
	// Deleted risk ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type RiskEdge struct {
	// The item at the end of the edge.
	Node *Risk `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type RiskHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the kind of the risk
	RiskKindName *string `json:"riskKindName,omitempty"`
	// the kind of the risk
	RiskKindID *string `json:"riskKindID,omitempty"`
	// the category of the risk
	RiskCategoryName *string `json:"riskCategoryName,omitempty"`
	// the category of the risk
	RiskCategoryID *string `json:"riskCategoryID,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// status of the risk - identified, mitigated, accepted, closed, transferred, and archived.
	Status *enums.RiskStatus `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// category of the risk, e.g. human resources, operations, IT, etc.
	Category *string `json:"category,omitempty"`
	// impact of the risk -critical, high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// score of the risk based on impact and likelihood (1-4 unlikely, 5-9 likely, 10-16 highly likely, 17-20 critical)
	Score *int64 `json:"score,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// details of the risk
	Details *string `json:"details,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
	// the id of the group responsible for risk oversight
	StakeholderID *string `json:"stakeholderID,omitempty"`
	// the id of the group responsible for risk oversight on behalf of the stakeholder
	DelegateID *string `json:"delegateID,omitempty"`
}

func (RiskHistory) IsNode() {}

// A connection to a list of items.
type RiskHistoryConnection struct {
	// A list of edges.
	Edges []*RiskHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type RiskHistoryEdge struct {
	// The item at the end of the edge.
	Node *RiskHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for RiskHistory connections
type RiskHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order RiskHistories.
	Field RiskHistoryOrderField `json:"field"`
}

// RiskHistoryWhereInput is used for filtering RiskHistory objects.
// Input was generated by ent.
type RiskHistoryWhereInput struct {
	Not *RiskHistoryWhereInput   `json:"not,omitempty"`
	And []*RiskHistoryWhereInput `json:"and,omitempty"`
	Or  []*RiskHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// risk_kind_name field predicates
	RiskKindName             *string  `json:"riskKindName,omitempty"`
	RiskKindNameNeq          *string  `json:"riskKindNameNEQ,omitempty"`
	RiskKindNameIn           []string `json:"riskKindNameIn,omitempty"`
	RiskKindNameNotIn        []string `json:"riskKindNameNotIn,omitempty"`
	RiskKindNameGt           *string  `json:"riskKindNameGT,omitempty"`
	RiskKindNameGte          *string  `json:"riskKindNameGTE,omitempty"`
	RiskKindNameLt           *string  `json:"riskKindNameLT,omitempty"`
	RiskKindNameLte          *string  `json:"riskKindNameLTE,omitempty"`
	RiskKindNameContains     *string  `json:"riskKindNameContains,omitempty"`
	RiskKindNameHasPrefix    *string  `json:"riskKindNameHasPrefix,omitempty"`
	RiskKindNameHasSuffix    *string  `json:"riskKindNameHasSuffix,omitempty"`
	RiskKindNameIsNil        *bool    `json:"riskKindNameIsNil,omitempty"`
	RiskKindNameNotNil       *bool    `json:"riskKindNameNotNil,omitempty"`
	RiskKindNameEqualFold    *string  `json:"riskKindNameEqualFold,omitempty"`
	RiskKindNameContainsFold *string  `json:"riskKindNameContainsFold,omitempty"`
	// risk_kind_id field predicates
	RiskKindID             *string  `json:"riskKindID,omitempty"`
	RiskKindIdneq          *string  `json:"riskKindIDNEQ,omitempty"`
	RiskKindIDIn           []string `json:"riskKindIDIn,omitempty"`
	RiskKindIDNotIn        []string `json:"riskKindIDNotIn,omitempty"`
	RiskKindIdgt           *string  `json:"riskKindIDGT,omitempty"`
	RiskKindIdgte          *string  `json:"riskKindIDGTE,omitempty"`
	RiskKindIdlt           *string  `json:"riskKindIDLT,omitempty"`
	RiskKindIdlte          *string  `json:"riskKindIDLTE,omitempty"`
	RiskKindIDContains     *string  `json:"riskKindIDContains,omitempty"`
	RiskKindIDHasPrefix    *string  `json:"riskKindIDHasPrefix,omitempty"`
	RiskKindIDHasSuffix    *string  `json:"riskKindIDHasSuffix,omitempty"`
	RiskKindIDIsNil        *bool    `json:"riskKindIDIsNil,omitempty"`
	RiskKindIDNotNil       *bool    `json:"riskKindIDNotNil,omitempty"`
	RiskKindIDEqualFold    *string  `json:"riskKindIDEqualFold,omitempty"`
	RiskKindIDContainsFold *string  `json:"riskKindIDContainsFold,omitempty"`
	// risk_category_name field predicates
	RiskCategoryName             *string  `json:"riskCategoryName,omitempty"`
	RiskCategoryNameNeq          *string  `json:"riskCategoryNameNEQ,omitempty"`
	RiskCategoryNameIn           []string `json:"riskCategoryNameIn,omitempty"`
	RiskCategoryNameNotIn        []string `json:"riskCategoryNameNotIn,omitempty"`
	RiskCategoryNameGt           *string  `json:"riskCategoryNameGT,omitempty"`
	RiskCategoryNameGte          *string  `json:"riskCategoryNameGTE,omitempty"`
	RiskCategoryNameLt           *string  `json:"riskCategoryNameLT,omitempty"`
	RiskCategoryNameLte          *string  `json:"riskCategoryNameLTE,omitempty"`
	RiskCategoryNameContains     *string  `json:"riskCategoryNameContains,omitempty"`
	RiskCategoryNameHasPrefix    *string  `json:"riskCategoryNameHasPrefix,omitempty"`
	RiskCategoryNameHasSuffix    *string  `json:"riskCategoryNameHasSuffix,omitempty"`
	RiskCategoryNameIsNil        *bool    `json:"riskCategoryNameIsNil,omitempty"`
	RiskCategoryNameNotNil       *bool    `json:"riskCategoryNameNotNil,omitempty"`
	RiskCategoryNameEqualFold    *string  `json:"riskCategoryNameEqualFold,omitempty"`
	RiskCategoryNameContainsFold *string  `json:"riskCategoryNameContainsFold,omitempty"`
	// risk_category_id field predicates
	RiskCategoryID             *string  `json:"riskCategoryID,omitempty"`
	RiskCategoryIdneq          *string  `json:"riskCategoryIDNEQ,omitempty"`
	RiskCategoryIDIn           []string `json:"riskCategoryIDIn,omitempty"`
	RiskCategoryIDNotIn        []string `json:"riskCategoryIDNotIn,omitempty"`
	RiskCategoryIdgt           *string  `json:"riskCategoryIDGT,omitempty"`
	RiskCategoryIdgte          *string  `json:"riskCategoryIDGTE,omitempty"`
	RiskCategoryIdlt           *string  `json:"riskCategoryIDLT,omitempty"`
	RiskCategoryIdlte          *string  `json:"riskCategoryIDLTE,omitempty"`
	RiskCategoryIDContains     *string  `json:"riskCategoryIDContains,omitempty"`
	RiskCategoryIDHasPrefix    *string  `json:"riskCategoryIDHasPrefix,omitempty"`
	RiskCategoryIDHasSuffix    *string  `json:"riskCategoryIDHasSuffix,omitempty"`
	RiskCategoryIDIsNil        *bool    `json:"riskCategoryIDIsNil,omitempty"`
	RiskCategoryIDNotNil       *bool    `json:"riskCategoryIDNotNil,omitempty"`
	RiskCategoryIDEqualFold    *string  `json:"riskCategoryIDEqualFold,omitempty"`
	RiskCategoryIDContainsFold *string  `json:"riskCategoryIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.RiskStatus  `json:"status,omitempty"`
	StatusNeq    *enums.RiskStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.RiskStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.RiskStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool              `json:"statusIsNil,omitempty"`
	StatusNotNil *bool              `json:"statusNotNil,omitempty"`
	// risk_type field predicates
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNeq          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGt           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGte          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLt           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLte          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        *bool    `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       *bool    `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// impact field predicates
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNeq    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  *bool              `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool              `json:"impactNotNil,omitempty"`
	// likelihood field predicates
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNeq    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  *bool                  `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil *bool                  `json:"likelihoodNotNil,omitempty"`
	// score field predicates
	Score       *int64  `json:"score,omitempty"`
	ScoreNeq    *int64  `json:"scoreNEQ,omitempty"`
	ScoreIn     []int64 `json:"scoreIn,omitempty"`
	ScoreNotIn  []int64 `json:"scoreNotIn,omitempty"`
	ScoreGt     *int64  `json:"scoreGT,omitempty"`
	ScoreGte    *int64  `json:"scoreGTE,omitempty"`
	ScoreLt     *int64  `json:"scoreLT,omitempty"`
	ScoreLte    *int64  `json:"scoreLTE,omitempty"`
	ScoreIsNil  *bool   `json:"scoreIsNil,omitempty"`
	ScoreNotNil *bool   `json:"scoreNotNil,omitempty"`
	// mitigation field predicates
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNeq          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGt           *string  `json:"mitigationGT,omitempty"`
	MitigationGte          *string  `json:"mitigationGTE,omitempty"`
	MitigationLt           *string  `json:"mitigationLT,omitempty"`
	MitigationLte          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        *bool    `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       *bool    `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// business_costs field predicates
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNeq          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGt           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGte          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLt           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLte          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        *bool    `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       *bool    `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`
	// stakeholder_id field predicates
	StakeholderID             *string  `json:"stakeholderID,omitempty"`
	StakeholderIdneq          *string  `json:"stakeholderIDNEQ,omitempty"`
	StakeholderIDIn           []string `json:"stakeholderIDIn,omitempty"`
	StakeholderIDNotIn        []string `json:"stakeholderIDNotIn,omitempty"`
	StakeholderIdgt           *string  `json:"stakeholderIDGT,omitempty"`
	StakeholderIdgte          *string  `json:"stakeholderIDGTE,omitempty"`
	StakeholderIdlt           *string  `json:"stakeholderIDLT,omitempty"`
	StakeholderIdlte          *string  `json:"stakeholderIDLTE,omitempty"`
	StakeholderIDContains     *string  `json:"stakeholderIDContains,omitempty"`
	StakeholderIDHasPrefix    *string  `json:"stakeholderIDHasPrefix,omitempty"`
	StakeholderIDHasSuffix    *string  `json:"stakeholderIDHasSuffix,omitempty"`
	StakeholderIDIsNil        *bool    `json:"stakeholderIDIsNil,omitempty"`
	StakeholderIDNotNil       *bool    `json:"stakeholderIDNotNil,omitempty"`
	StakeholderIDEqualFold    *string  `json:"stakeholderIDEqualFold,omitempty"`
	StakeholderIDContainsFold *string  `json:"stakeholderIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
}

// Ordering options for Risk connections
type RiskOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Risks.
	Field RiskOrderField `json:"field"`
}

// Return response for updateRisk mutation
type RiskUpdatePayload struct {
	// Updated risk
	Risk *Risk `json:"risk"`
}

// RiskWhereInput is used for filtering Risk objects.
// Input was generated by ent.
type RiskWhereInput struct {
	Not *RiskWhereInput   `json:"not,omitempty"`
	And []*RiskWhereInput `json:"and,omitempty"`
	Or  []*RiskWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// risk_kind_name field predicates
	RiskKindName             *string  `json:"riskKindName,omitempty"`
	RiskKindNameNeq          *string  `json:"riskKindNameNEQ,omitempty"`
	RiskKindNameIn           []string `json:"riskKindNameIn,omitempty"`
	RiskKindNameNotIn        []string `json:"riskKindNameNotIn,omitempty"`
	RiskKindNameGt           *string  `json:"riskKindNameGT,omitempty"`
	RiskKindNameGte          *string  `json:"riskKindNameGTE,omitempty"`
	RiskKindNameLt           *string  `json:"riskKindNameLT,omitempty"`
	RiskKindNameLte          *string  `json:"riskKindNameLTE,omitempty"`
	RiskKindNameContains     *string  `json:"riskKindNameContains,omitempty"`
	RiskKindNameHasPrefix    *string  `json:"riskKindNameHasPrefix,omitempty"`
	RiskKindNameHasSuffix    *string  `json:"riskKindNameHasSuffix,omitempty"`
	RiskKindNameIsNil        *bool    `json:"riskKindNameIsNil,omitempty"`
	RiskKindNameNotNil       *bool    `json:"riskKindNameNotNil,omitempty"`
	RiskKindNameEqualFold    *string  `json:"riskKindNameEqualFold,omitempty"`
	RiskKindNameContainsFold *string  `json:"riskKindNameContainsFold,omitempty"`
	// risk_kind_id field predicates
	RiskKindID             *string  `json:"riskKindID,omitempty"`
	RiskKindIdneq          *string  `json:"riskKindIDNEQ,omitempty"`
	RiskKindIDIn           []string `json:"riskKindIDIn,omitempty"`
	RiskKindIDNotIn        []string `json:"riskKindIDNotIn,omitempty"`
	RiskKindIdgt           *string  `json:"riskKindIDGT,omitempty"`
	RiskKindIdgte          *string  `json:"riskKindIDGTE,omitempty"`
	RiskKindIdlt           *string  `json:"riskKindIDLT,omitempty"`
	RiskKindIdlte          *string  `json:"riskKindIDLTE,omitempty"`
	RiskKindIDContains     *string  `json:"riskKindIDContains,omitempty"`
	RiskKindIDHasPrefix    *string  `json:"riskKindIDHasPrefix,omitempty"`
	RiskKindIDHasSuffix    *string  `json:"riskKindIDHasSuffix,omitempty"`
	RiskKindIDIsNil        *bool    `json:"riskKindIDIsNil,omitempty"`
	RiskKindIDNotNil       *bool    `json:"riskKindIDNotNil,omitempty"`
	RiskKindIDEqualFold    *string  `json:"riskKindIDEqualFold,omitempty"`
	RiskKindIDContainsFold *string  `json:"riskKindIDContainsFold,omitempty"`
	// risk_category_name field predicates
	RiskCategoryName             *string  `json:"riskCategoryName,omitempty"`
	RiskCategoryNameNeq          *string  `json:"riskCategoryNameNEQ,omitempty"`
	RiskCategoryNameIn           []string `json:"riskCategoryNameIn,omitempty"`
	RiskCategoryNameNotIn        []string `json:"riskCategoryNameNotIn,omitempty"`
	RiskCategoryNameGt           *string  `json:"riskCategoryNameGT,omitempty"`
	RiskCategoryNameGte          *string  `json:"riskCategoryNameGTE,omitempty"`
	RiskCategoryNameLt           *string  `json:"riskCategoryNameLT,omitempty"`
	RiskCategoryNameLte          *string  `json:"riskCategoryNameLTE,omitempty"`
	RiskCategoryNameContains     *string  `json:"riskCategoryNameContains,omitempty"`
	RiskCategoryNameHasPrefix    *string  `json:"riskCategoryNameHasPrefix,omitempty"`
	RiskCategoryNameHasSuffix    *string  `json:"riskCategoryNameHasSuffix,omitempty"`
	RiskCategoryNameIsNil        *bool    `json:"riskCategoryNameIsNil,omitempty"`
	RiskCategoryNameNotNil       *bool    `json:"riskCategoryNameNotNil,omitempty"`
	RiskCategoryNameEqualFold    *string  `json:"riskCategoryNameEqualFold,omitempty"`
	RiskCategoryNameContainsFold *string  `json:"riskCategoryNameContainsFold,omitempty"`
	// risk_category_id field predicates
	RiskCategoryID             *string  `json:"riskCategoryID,omitempty"`
	RiskCategoryIdneq          *string  `json:"riskCategoryIDNEQ,omitempty"`
	RiskCategoryIDIn           []string `json:"riskCategoryIDIn,omitempty"`
	RiskCategoryIDNotIn        []string `json:"riskCategoryIDNotIn,omitempty"`
	RiskCategoryIdgt           *string  `json:"riskCategoryIDGT,omitempty"`
	RiskCategoryIdgte          *string  `json:"riskCategoryIDGTE,omitempty"`
	RiskCategoryIdlt           *string  `json:"riskCategoryIDLT,omitempty"`
	RiskCategoryIdlte          *string  `json:"riskCategoryIDLTE,omitempty"`
	RiskCategoryIDContains     *string  `json:"riskCategoryIDContains,omitempty"`
	RiskCategoryIDHasPrefix    *string  `json:"riskCategoryIDHasPrefix,omitempty"`
	RiskCategoryIDHasSuffix    *string  `json:"riskCategoryIDHasSuffix,omitempty"`
	RiskCategoryIDIsNil        *bool    `json:"riskCategoryIDIsNil,omitempty"`
	RiskCategoryIDNotNil       *bool    `json:"riskCategoryIDNotNil,omitempty"`
	RiskCategoryIDEqualFold    *string  `json:"riskCategoryIDEqualFold,omitempty"`
	RiskCategoryIDContainsFold *string  `json:"riskCategoryIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.RiskStatus  `json:"status,omitempty"`
	StatusNeq    *enums.RiskStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.RiskStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.RiskStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool              `json:"statusIsNil,omitempty"`
	StatusNotNil *bool              `json:"statusNotNil,omitempty"`
	// risk_type field predicates
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNeq          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGt           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGte          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLt           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLte          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        *bool    `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       *bool    `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// impact field predicates
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNeq    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  *bool              `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool              `json:"impactNotNil,omitempty"`
	// likelihood field predicates
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNeq    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  *bool                  `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil *bool                  `json:"likelihoodNotNil,omitempty"`
	// score field predicates
	Score       *int64  `json:"score,omitempty"`
	ScoreNeq    *int64  `json:"scoreNEQ,omitempty"`
	ScoreIn     []int64 `json:"scoreIn,omitempty"`
	ScoreNotIn  []int64 `json:"scoreNotIn,omitempty"`
	ScoreGt     *int64  `json:"scoreGT,omitempty"`
	ScoreGte    *int64  `json:"scoreGTE,omitempty"`
	ScoreLt     *int64  `json:"scoreLT,omitempty"`
	ScoreLte    *int64  `json:"scoreLTE,omitempty"`
	ScoreIsNil  *bool   `json:"scoreIsNil,omitempty"`
	ScoreNotNil *bool   `json:"scoreNotNil,omitempty"`
	// mitigation field predicates
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNeq          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGt           *string  `json:"mitigationGT,omitempty"`
	MitigationGte          *string  `json:"mitigationGTE,omitempty"`
	MitigationLt           *string  `json:"mitigationLT,omitempty"`
	MitigationLte          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        *bool    `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       *bool    `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// business_costs field predicates
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNeq          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGt           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGte          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLt           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLte          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        *bool    `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       *bool    `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`
	// stakeholder_id field predicates
	StakeholderID             *string  `json:"stakeholderID,omitempty"`
	StakeholderIdneq          *string  `json:"stakeholderIDNEQ,omitempty"`
	StakeholderIDIn           []string `json:"stakeholderIDIn,omitempty"`
	StakeholderIDNotIn        []string `json:"stakeholderIDNotIn,omitempty"`
	StakeholderIdgt           *string  `json:"stakeholderIDGT,omitempty"`
	StakeholderIdgte          *string  `json:"stakeholderIDGTE,omitempty"`
	StakeholderIdlt           *string  `json:"stakeholderIDLT,omitempty"`
	StakeholderIdlte          *string  `json:"stakeholderIDLTE,omitempty"`
	StakeholderIDContains     *string  `json:"stakeholderIDContains,omitempty"`
	StakeholderIDHasPrefix    *string  `json:"stakeholderIDHasPrefix,omitempty"`
	StakeholderIDHasSuffix    *string  `json:"stakeholderIDHasSuffix,omitempty"`
	StakeholderIDIsNil        *bool    `json:"stakeholderIDIsNil,omitempty"`
	StakeholderIDNotNil       *bool    `json:"stakeholderIDNotNil,omitempty"`
	StakeholderIDEqualFold    *string  `json:"stakeholderIDEqualFold,omitempty"`
	StakeholderIDContainsFold *string  `json:"stakeholderIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// risk_kind edge predicates
	HasRiskKind     *bool                       `json:"hasRiskKind,omitempty"`
	HasRiskKindWith []*CustomTypeEnumWhereInput `json:"hasRiskKindWith,omitempty"`
	// risk_category edge predicates
	HasRiskCategory     *bool                       `json:"hasRiskCategory,omitempty"`
	HasRiskCategoryWith []*CustomTypeEnumWhereInput `json:"hasRiskCategoryWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// scans edge predicates
	HasScans     *bool             `json:"hasScans,omitempty"`
	HasScansWith []*ScanWhereInput `json:"hasScansWith,omitempty"`
	// stakeholder edge predicates
	HasStakeholder     *bool              `json:"hasStakeholder,omitempty"`
	HasStakeholderWith []*GroupWhereInput `json:"hasStakeholderWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
}

type Scan struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the target of the scan, e.g., a domain name or IP address, codebase
	Target string `json:"target"`
	// the type of scan, e.g., domain scan, vulnerability scan, provider scan
	ScanType enums.ScanType `json:"scanType"`
	// additional metadata for the scan, e.g., scan configuration, options, etc
	Metadata map[string]any `json:"metadata,omitempty"`
	// the status of the scan, e.g., processing, completed, failed
	Status        enums.ScanStatus  `json:"status"`
	Owner         *Organization     `json:"owner,omitempty"`
	BlockedGroups *GroupConnection  `json:"blockedGroups"`
	Editors       *GroupConnection  `json:"editors"`
	Viewers       *GroupConnection  `json:"viewers"`
	Assets        *AssetConnection  `json:"assets"`
	Entities      *EntityConnection `json:"entities"`
}

func (Scan) IsNode() {}

// Return response for createBulkScan mutation
type ScanBulkCreatePayload struct {
	// Created scans
	Scans []*Scan `json:"scans,omitempty"`
}

// Return response for deleteBulkScan mutation
type ScanBulkDeletePayload struct {
	// Deleted scan IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkScan mutation
type ScanBulkUpdatePayload struct {
	// Updated scans
	Scans []*Scan `json:"scans,omitempty"`
	// IDs of the updated scans
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type ScanConnection struct {
	// A list of edges.
	Edges []*ScanEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createScan mutation
type ScanCreatePayload struct {
	// Created scan
	Scan *Scan `json:"scan"`
}

// Return response for deleteScan mutation
type ScanDeletePayload struct {
	// Deleted scan ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ScanEdge struct {
	// The item at the end of the edge.
	Node *Scan `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ScanHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the target of the scan, e.g., a domain name or IP address, codebase
	Target string `json:"target"`
	// the type of scan, e.g., domain scan, vulnerability scan, provider scan
	ScanType enums.ScanType `json:"scanType"`
	// additional metadata for the scan, e.g., scan configuration, options, etc
	Metadata map[string]any `json:"metadata,omitempty"`
	// the status of the scan, e.g., processing, completed, failed
	Status enums.ScanStatus `json:"status"`
}

func (ScanHistory) IsNode() {}

// A connection to a list of items.
type ScanHistoryConnection struct {
	// A list of edges.
	Edges []*ScanHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ScanHistoryEdge struct {
	// The item at the end of the edge.
	Node *ScanHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ScanHistory connections
type ScanHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ScanHistories.
	Field ScanHistoryOrderField `json:"field"`
}

// ScanHistoryWhereInput is used for filtering ScanHistory objects.
// Input was generated by ent.
type ScanHistoryWhereInput struct {
	Not *ScanHistoryWhereInput   `json:"not,omitempty"`
	And []*ScanHistoryWhereInput `json:"and,omitempty"`
	Or  []*ScanHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// target field predicates
	Target             *string  `json:"target,omitempty"`
	TargetNeq          *string  `json:"targetNEQ,omitempty"`
	TargetIn           []string `json:"targetIn,omitempty"`
	TargetNotIn        []string `json:"targetNotIn,omitempty"`
	TargetGt           *string  `json:"targetGT,omitempty"`
	TargetGte          *string  `json:"targetGTE,omitempty"`
	TargetLt           *string  `json:"targetLT,omitempty"`
	TargetLte          *string  `json:"targetLTE,omitempty"`
	TargetContains     *string  `json:"targetContains,omitempty"`
	TargetHasPrefix    *string  `json:"targetHasPrefix,omitempty"`
	TargetHasSuffix    *string  `json:"targetHasSuffix,omitempty"`
	TargetEqualFold    *string  `json:"targetEqualFold,omitempty"`
	TargetContainsFold *string  `json:"targetContainsFold,omitempty"`
	// scan_type field predicates
	ScanType      *enums.ScanType  `json:"scanType,omitempty"`
	ScanTypeNeq   *enums.ScanType  `json:"scanTypeNEQ,omitempty"`
	ScanTypeIn    []enums.ScanType `json:"scanTypeIn,omitempty"`
	ScanTypeNotIn []enums.ScanType `json:"scanTypeNotIn,omitempty"`
	// status field predicates
	Status      *enums.ScanStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ScanStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ScanStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ScanStatus `json:"statusNotIn,omitempty"`
}

// Ordering options for Scan connections
type ScanOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Scans.
	Field ScanOrderField `json:"field"`
}

// Return response for updateScan mutation
type ScanUpdatePayload struct {
	// Updated scan
	Scan *Scan `json:"scan"`
}

// ScanWhereInput is used for filtering Scan objects.
// Input was generated by ent.
type ScanWhereInput struct {
	Not *ScanWhereInput   `json:"not,omitempty"`
	And []*ScanWhereInput `json:"and,omitempty"`
	Or  []*ScanWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// target field predicates
	Target             *string  `json:"target,omitempty"`
	TargetNeq          *string  `json:"targetNEQ,omitempty"`
	TargetIn           []string `json:"targetIn,omitempty"`
	TargetNotIn        []string `json:"targetNotIn,omitempty"`
	TargetGt           *string  `json:"targetGT,omitempty"`
	TargetGte          *string  `json:"targetGTE,omitempty"`
	TargetLt           *string  `json:"targetLT,omitempty"`
	TargetLte          *string  `json:"targetLTE,omitempty"`
	TargetContains     *string  `json:"targetContains,omitempty"`
	TargetHasPrefix    *string  `json:"targetHasPrefix,omitempty"`
	TargetHasSuffix    *string  `json:"targetHasSuffix,omitempty"`
	TargetEqualFold    *string  `json:"targetEqualFold,omitempty"`
	TargetContainsFold *string  `json:"targetContainsFold,omitempty"`
	// scan_type field predicates
	ScanType      *enums.ScanType  `json:"scanType,omitempty"`
	ScanTypeNeq   *enums.ScanType  `json:"scanTypeNEQ,omitempty"`
	ScanTypeIn    []enums.ScanType `json:"scanTypeIn,omitempty"`
	ScanTypeNotIn []enums.ScanType `json:"scanTypeNotIn,omitempty"`
	// status field predicates
	Status      *enums.ScanStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ScanStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ScanStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ScanStatus `json:"statusNotIn,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
}

type ScheduledJob struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the scheduled_job id to take the script to run from
	JobID string `json:"jobID"`
	// whether the scheduled job is active
	Active bool `json:"active"`
	// the json configuration to run this job, which could be used to template a job, e.g. { "account_name": "my-account" }
	Configuration models.JobConfiguration `json:"configuration,omitempty"`
	// cron 6-field syntax, defaults to the job template's cron if not provided
	Cron *string `json:"cron,omitempty"`
	// the runner that this job will run on. If not set, it will scheduled on a general runner instead
	JobRunnerID *string               `json:"jobRunnerID,omitempty"`
	Owner       *Organization         `json:"owner,omitempty"`
	JobTemplate *JobTemplate          `json:"jobTemplate"`
	Controls    *ControlConnection    `json:"controls"`
	Subcontrols *SubcontrolConnection `json:"subcontrols"`
	JobRunner   *JobRunner            `json:"jobRunner,omitempty"`
}

func (ScheduledJob) IsNode() {}

// Return response for createBulkScheduledJob mutation
type ScheduledJobBulkCreatePayload struct {
	// Created scheduledJobs
	ScheduledJobs []*ScheduledJob `json:"scheduledJobs,omitempty"`
}

// Return response for deleteBulkScheduledJob mutation
type ScheduledJobBulkDeletePayload struct {
	// Deleted scheduledJob IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type ScheduledJobConnection struct {
	// A list of edges.
	Edges []*ScheduledJobEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createScheduledJob mutation
type ScheduledJobCreatePayload struct {
	// Created scheduledJob
	ScheduledJob *ScheduledJob `json:"scheduledJob"`
}

// Return response for deleteScheduledJob mutation
type ScheduledJobDeletePayload struct {
	// Deleted scheduledJob ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ScheduledJobEdge struct {
	// The item at the end of the edge.
	Node *ScheduledJob `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ScheduledJobHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the scheduled_job id to take the script to run from
	JobID string `json:"jobID"`
	// whether the scheduled job is active
	Active bool `json:"active"`
	// the json configuration to run this job, which could be used to template a job, e.g. { "account_name": "my-account" }
	Configuration models.JobConfiguration `json:"configuration,omitempty"`
	// cron 6-field syntax, defaults to the job template's cron if not provided
	Cron *string `json:"cron,omitempty"`
	// the runner that this job will run on. If not set, it will scheduled on a general runner instead
	JobRunnerID *string `json:"jobRunnerID,omitempty"`
}

func (ScheduledJobHistory) IsNode() {}

// A connection to a list of items.
type ScheduledJobHistoryConnection struct {
	// A list of edges.
	Edges []*ScheduledJobHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ScheduledJobHistoryEdge struct {
	// The item at the end of the edge.
	Node *ScheduledJobHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ScheduledJobHistory connections
type ScheduledJobHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ScheduledJobHistories.
	Field ScheduledJobHistoryOrderField `json:"field"`
}

// ScheduledJobHistoryWhereInput is used for filtering ScheduledJobHistory objects.
// Input was generated by ent.
type ScheduledJobHistoryWhereInput struct {
	Not *ScheduledJobHistoryWhereInput   `json:"not,omitempty"`
	And []*ScheduledJobHistoryWhereInput `json:"and,omitempty"`
	Or  []*ScheduledJobHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// job_id field predicates
	JobID             *string  `json:"jobID,omitempty"`
	JobIdneq          *string  `json:"jobIDNEQ,omitempty"`
	JobIDIn           []string `json:"jobIDIn,omitempty"`
	JobIDNotIn        []string `json:"jobIDNotIn,omitempty"`
	JobIdgt           *string  `json:"jobIDGT,omitempty"`
	JobIdgte          *string  `json:"jobIDGTE,omitempty"`
	JobIdlt           *string  `json:"jobIDLT,omitempty"`
	JobIdlte          *string  `json:"jobIDLTE,omitempty"`
	JobIDContains     *string  `json:"jobIDContains,omitempty"`
	JobIDHasPrefix    *string  `json:"jobIDHasPrefix,omitempty"`
	JobIDHasSuffix    *string  `json:"jobIDHasSuffix,omitempty"`
	JobIDEqualFold    *string  `json:"jobIDEqualFold,omitempty"`
	JobIDContainsFold *string  `json:"jobIDContainsFold,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// job_runner_id field predicates
	JobRunnerID             *string  `json:"jobRunnerID,omitempty"`
	JobRunnerIdneq          *string  `json:"jobRunnerIDNEQ,omitempty"`
	JobRunnerIDIn           []string `json:"jobRunnerIDIn,omitempty"`
	JobRunnerIDNotIn        []string `json:"jobRunnerIDNotIn,omitempty"`
	JobRunnerIdgt           *string  `json:"jobRunnerIDGT,omitempty"`
	JobRunnerIdgte          *string  `json:"jobRunnerIDGTE,omitempty"`
	JobRunnerIdlt           *string  `json:"jobRunnerIDLT,omitempty"`
	JobRunnerIdlte          *string  `json:"jobRunnerIDLTE,omitempty"`
	JobRunnerIDContains     *string  `json:"jobRunnerIDContains,omitempty"`
	JobRunnerIDHasPrefix    *string  `json:"jobRunnerIDHasPrefix,omitempty"`
	JobRunnerIDHasSuffix    *string  `json:"jobRunnerIDHasSuffix,omitempty"`
	JobRunnerIDIsNil        *bool    `json:"jobRunnerIDIsNil,omitempty"`
	JobRunnerIDNotNil       *bool    `json:"jobRunnerIDNotNil,omitempty"`
	JobRunnerIDEqualFold    *string  `json:"jobRunnerIDEqualFold,omitempty"`
	JobRunnerIDContainsFold *string  `json:"jobRunnerIDContainsFold,omitempty"`
}

// Ordering options for ScheduledJob connections
type ScheduledJobOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ScheduledJobs.
	Field ScheduledJobOrderField `json:"field"`
}

type ScheduledJobRun struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// The runner that this job will be executed on. Useful to know because of self hosted runners
	JobRunnerID string `json:"jobRunnerID"`
	// The status of the job to be executed. By default will be pending but when
	// 			scheduled on a runner, this will change to acquired.
	Status enums.ScheduledJobRunStatus `json:"status"`
	// the parent job for this run
	ScheduledJobID string `json:"scheduledJobID"`
	// When should this job execute on the agent. Since we might potentially schedule a few minutes before
	ExpectedExecutionTime time.Time `json:"expectedExecutionTime"`
	// the script that will be executed by the agent.
	// This script will be templated with the values from the configuration on the job
	Script       string        `json:"script"`
	Owner        *Organization `json:"owner,omitempty"`
	ScheduledJob *ScheduledJob `json:"scheduledJob"`
	JobRunner    *JobRunner    `json:"jobRunner"`
}

func (ScheduledJobRun) IsNode() {}

// A connection to a list of items.
type ScheduledJobRunConnection struct {
	// A list of edges.
	Edges []*ScheduledJobRunEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createScheduledJobRun mutation
type ScheduledJobRunCreatePayload struct {
	// Created scheduledJobRun
	ScheduledJobRun *ScheduledJobRun `json:"scheduledJobRun"`
}

// Return response for deleteScheduledJobRun mutation
type ScheduledJobRunDeletePayload struct {
	// Deleted scheduledJobRun ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ScheduledJobRunEdge struct {
	// The item at the end of the edge.
	Node *ScheduledJobRun `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ScheduledJobRun connections
type ScheduledJobRunOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ScheduledJobRuns.
	Field ScheduledJobRunOrderField `json:"field"`
}

// Return response for updateScheduledJobRun mutation
type ScheduledJobRunUpdatePayload struct {
	// Updated scheduledJobRun
	ScheduledJobRun *ScheduledJobRun `json:"scheduledJobRun"`
}

// ScheduledJobRunWhereInput is used for filtering ScheduledJobRun objects.
// Input was generated by ent.
type ScheduledJobRunWhereInput struct {
	Not *ScheduledJobRunWhereInput   `json:"not,omitempty"`
	And []*ScheduledJobRunWhereInput `json:"and,omitempty"`
	Or  []*ScheduledJobRunWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// job_runner_id field predicates
	JobRunnerID             *string  `json:"jobRunnerID,omitempty"`
	JobRunnerIdneq          *string  `json:"jobRunnerIDNEQ,omitempty"`
	JobRunnerIDIn           []string `json:"jobRunnerIDIn,omitempty"`
	JobRunnerIDNotIn        []string `json:"jobRunnerIDNotIn,omitempty"`
	JobRunnerIdgt           *string  `json:"jobRunnerIDGT,omitempty"`
	JobRunnerIdgte          *string  `json:"jobRunnerIDGTE,omitempty"`
	JobRunnerIdlt           *string  `json:"jobRunnerIDLT,omitempty"`
	JobRunnerIdlte          *string  `json:"jobRunnerIDLTE,omitempty"`
	JobRunnerIDContains     *string  `json:"jobRunnerIDContains,omitempty"`
	JobRunnerIDHasPrefix    *string  `json:"jobRunnerIDHasPrefix,omitempty"`
	JobRunnerIDHasSuffix    *string  `json:"jobRunnerIDHasSuffix,omitempty"`
	JobRunnerIDEqualFold    *string  `json:"jobRunnerIDEqualFold,omitempty"`
	JobRunnerIDContainsFold *string  `json:"jobRunnerIDContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ScheduledJobRunStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ScheduledJobRunStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ScheduledJobRunStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ScheduledJobRunStatus `json:"statusNotIn,omitempty"`
	// scheduled_job_id field predicates
	ScheduledJobID             *string  `json:"scheduledJobID,omitempty"`
	ScheduledJobIdneq          *string  `json:"scheduledJobIDNEQ,omitempty"`
	ScheduledJobIDIn           []string `json:"scheduledJobIDIn,omitempty"`
	ScheduledJobIDNotIn        []string `json:"scheduledJobIDNotIn,omitempty"`
	ScheduledJobIdgt           *string  `json:"scheduledJobIDGT,omitempty"`
	ScheduledJobIdgte          *string  `json:"scheduledJobIDGTE,omitempty"`
	ScheduledJobIdlt           *string  `json:"scheduledJobIDLT,omitempty"`
	ScheduledJobIdlte          *string  `json:"scheduledJobIDLTE,omitempty"`
	ScheduledJobIDContains     *string  `json:"scheduledJobIDContains,omitempty"`
	ScheduledJobIDHasPrefix    *string  `json:"scheduledJobIDHasPrefix,omitempty"`
	ScheduledJobIDHasSuffix    *string  `json:"scheduledJobIDHasSuffix,omitempty"`
	ScheduledJobIDEqualFold    *string  `json:"scheduledJobIDEqualFold,omitempty"`
	ScheduledJobIDContainsFold *string  `json:"scheduledJobIDContainsFold,omitempty"`
	// expected_execution_time field predicates
	ExpectedExecutionTime      *time.Time   `json:"expectedExecutionTime,omitempty"`
	ExpectedExecutionTimeNeq   *time.Time   `json:"expectedExecutionTimeNEQ,omitempty"`
	ExpectedExecutionTimeIn    []*time.Time `json:"expectedExecutionTimeIn,omitempty"`
	ExpectedExecutionTimeNotIn []*time.Time `json:"expectedExecutionTimeNotIn,omitempty"`
	ExpectedExecutionTimeGt    *time.Time   `json:"expectedExecutionTimeGT,omitempty"`
	ExpectedExecutionTimeGte   *time.Time   `json:"expectedExecutionTimeGTE,omitempty"`
	ExpectedExecutionTimeLt    *time.Time   `json:"expectedExecutionTimeLT,omitempty"`
	ExpectedExecutionTimeLte   *time.Time   `json:"expectedExecutionTimeLTE,omitempty"`
	// script field predicates
	Script             *string  `json:"script,omitempty"`
	ScriptNeq          *string  `json:"scriptNEQ,omitempty"`
	ScriptIn           []string `json:"scriptIn,omitempty"`
	ScriptNotIn        []string `json:"scriptNotIn,omitempty"`
	ScriptGt           *string  `json:"scriptGT,omitempty"`
	ScriptGte          *string  `json:"scriptGTE,omitempty"`
	ScriptLt           *string  `json:"scriptLT,omitempty"`
	ScriptLte          *string  `json:"scriptLTE,omitempty"`
	ScriptContains     *string  `json:"scriptContains,omitempty"`
	ScriptHasPrefix    *string  `json:"scriptHasPrefix,omitempty"`
	ScriptHasSuffix    *string  `json:"scriptHasSuffix,omitempty"`
	ScriptEqualFold    *string  `json:"scriptEqualFold,omitempty"`
	ScriptContainsFold *string  `json:"scriptContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// scheduled_job edge predicates
	HasScheduledJob     *bool                     `json:"hasScheduledJob,omitempty"`
	HasScheduledJobWith []*ScheduledJobWhereInput `json:"hasScheduledJobWith,omitempty"`
	// job_runner edge predicates
	HasJobRunner     *bool                  `json:"hasJobRunner,omitempty"`
	HasJobRunnerWith []*JobRunnerWhereInput `json:"hasJobRunnerWith,omitempty"`
}

// Return response for updateScheduledJob mutation
type ScheduledJobUpdatePayload struct {
	// Updated scheduledJob
	ScheduledJob *ScheduledJob `json:"scheduledJob"`
}

// ScheduledJobWhereInput is used for filtering ScheduledJob objects.
// Input was generated by ent.
type ScheduledJobWhereInput struct {
	Not *ScheduledJobWhereInput   `json:"not,omitempty"`
	And []*ScheduledJobWhereInput `json:"and,omitempty"`
	Or  []*ScheduledJobWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// job_id field predicates
	JobID             *string  `json:"jobID,omitempty"`
	JobIdneq          *string  `json:"jobIDNEQ,omitempty"`
	JobIDIn           []string `json:"jobIDIn,omitempty"`
	JobIDNotIn        []string `json:"jobIDNotIn,omitempty"`
	JobIdgt           *string  `json:"jobIDGT,omitempty"`
	JobIdgte          *string  `json:"jobIDGTE,omitempty"`
	JobIdlt           *string  `json:"jobIDLT,omitempty"`
	JobIdlte          *string  `json:"jobIDLTE,omitempty"`
	JobIDContains     *string  `json:"jobIDContains,omitempty"`
	JobIDHasPrefix    *string  `json:"jobIDHasPrefix,omitempty"`
	JobIDHasSuffix    *string  `json:"jobIDHasSuffix,omitempty"`
	JobIDEqualFold    *string  `json:"jobIDEqualFold,omitempty"`
	JobIDContainsFold *string  `json:"jobIDContainsFold,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// job_runner_id field predicates
	JobRunnerID             *string  `json:"jobRunnerID,omitempty"`
	JobRunnerIdneq          *string  `json:"jobRunnerIDNEQ,omitempty"`
	JobRunnerIDIn           []string `json:"jobRunnerIDIn,omitempty"`
	JobRunnerIDNotIn        []string `json:"jobRunnerIDNotIn,omitempty"`
	JobRunnerIdgt           *string  `json:"jobRunnerIDGT,omitempty"`
	JobRunnerIdgte          *string  `json:"jobRunnerIDGTE,omitempty"`
	JobRunnerIdlt           *string  `json:"jobRunnerIDLT,omitempty"`
	JobRunnerIdlte          *string  `json:"jobRunnerIDLTE,omitempty"`
	JobRunnerIDContains     *string  `json:"jobRunnerIDContains,omitempty"`
	JobRunnerIDHasPrefix    *string  `json:"jobRunnerIDHasPrefix,omitempty"`
	JobRunnerIDHasSuffix    *string  `json:"jobRunnerIDHasSuffix,omitempty"`
	JobRunnerIDIsNil        *bool    `json:"jobRunnerIDIsNil,omitempty"`
	JobRunnerIDNotNil       *bool    `json:"jobRunnerIDNotNil,omitempty"`
	JobRunnerIDEqualFold    *string  `json:"jobRunnerIDEqualFold,omitempty"`
	JobRunnerIDContainsFold *string  `json:"jobRunnerIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// job_template edge predicates
	HasJobTemplate     *bool                    `json:"hasJobTemplate,omitempty"`
	HasJobTemplateWith []*JobTemplateWhereInput `json:"hasJobTemplateWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// job_runner edge predicates
	HasJobRunner     *bool                  `json:"hasJobRunner,omitempty"`
	HasJobRunnerWith []*JobRunnerWhereInput `json:"hasJobRunnerWith,omitempty"`
}

type SearchResults struct {
	// Information to aid in pagination.
	Page *PageInfo `json:"page"`
	// Identifies the total count of items in the connection.
	TotalCount          int64                         `json:"totalCount"`
	ActionPlans         *ActionPlanConnection         `json:"actionPlans,omitempty"`
	Assessments         *AssessmentConnection         `json:"assessments,omitempty"`
	AssessmentResponses *AssessmentResponseConnection `json:"assessmentResponses,omitempty"`
	Assets              *AssetConnection              `json:"assets,omitempty"`
	Contacts            *ContactConnection            `json:"contacts,omitempty"`
	Controls            *ControlConnection            `json:"controls,omitempty"`
	ControlObjectives   *ControlObjectiveConnection   `json:"controlObjectives,omitempty"`
	CustomTypeEnums     *CustomTypeEnumConnection     `json:"customTypeEnums,omitempty"`
	Entities            *EntityConnection             `json:"entities,omitempty"`
	Evidences           *EvidenceConnection           `json:"evidences,omitempty"`
	Findings            *FindingConnection            `json:"findings,omitempty"`
	Groups              *GroupConnection              `json:"groups,omitempty"`
	InternalPolicies    *InternalPolicyConnection     `json:"internalPolicies,omitempty"`
	Invites             *InviteConnection             `json:"invites,omitempty"`
	JobRunners          *JobRunnerConnection          `json:"jobRunners,omitempty"`
	JobTemplates        *JobTemplateConnection        `json:"jobTemplates,omitempty"`
	Narratives          *NarrativeConnection          `json:"narratives,omitempty"`
	Organizations       *OrganizationConnection       `json:"organizations,omitempty"`
	Procedures          *ProcedureConnection          `json:"procedures,omitempty"`
	Programs            *ProgramConnection            `json:"programs,omitempty"`
	Remediations        *RemediationConnection        `json:"remediations,omitempty"`
	Reviews             *ReviewConnection             `json:"reviews,omitempty"`
	Risks               *RiskConnection               `json:"risks,omitempty"`
	Scans               *ScanConnection               `json:"scans,omitempty"`
	Standards           *StandardConnection           `json:"standards,omitempty"`
	Subcontrols         *SubcontrolConnection         `json:"subcontrols,omitempty"`
	Subprocessors       *SubprocessorConnection       `json:"subprocessors,omitempty"`
	Subscribers         *SubscriberConnection         `json:"subscribers,omitempty"`
	TagDefinitions      *TagDefinitionConnection      `json:"tagDefinitions,omitempty"`
	Tasks               *TaskConnection               `json:"tasks,omitempty"`
	Templates           *TemplateConnection           `json:"templates,omitempty"`
	TrustcenterEntities *TrustcenterEntityConnection  `json:"trustcenterEntities,omitempty"`
	Vulnerabilities     *VulnerabilityConnection      `json:"vulnerabilities,omitempty"`
	SearchContext       []*models.SearchContext       `json:"searchContext,omitempty"`
}

type SendTrustCenterNDAEmailPayload struct {
	Success bool `json:"success"`
}

type SendTrustCenterNDAInput struct {
	// trust center id
	TrustCenterID string `json:"trustCenterID"`
	// email address
	Email string `json:"email"`
}

type Standard struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// long description of the standard with details of what is covered
	Description *string `json:"description,omitempty"`
	// URL to the logo of the governing body
	GoverningBodyLogoURL *string `json:"governingBodyLogoURL,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, draft, and archived
	Status *enums.StandardStatus `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for system owned standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for system owned standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// type of the standard - cybersecurity, healthcare , financial, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
	// URL of the logo
	LogoFileID             *string                          `json:"logoFileID,omitempty"`
	Owner                  *Organization                    `json:"owner,omitempty"`
	Controls               *ControlConnection               `json:"controls"`
	TrustCenterCompliances *TrustCenterComplianceConnection `json:"trustCenterCompliances"`
	TrustCenterDocs        *TrustCenterDocConnection        `json:"trustCenterDocs"`
	LogoFile               *File                            `json:"logoFile,omitempty"`
}

func (Standard) IsNode() {}

// Return response for createBulkStandard mutation
type StandardBulkCreatePayload struct {
	// Created standards
	Standards []*Standard `json:"standards,omitempty"`
}

// A connection to a list of items.
type StandardConnection struct {
	// A list of edges.
	Edges []*StandardEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createStandard mutation
type StandardCreatePayload struct {
	// Created standard
	Standard *Standard `json:"standard"`
}

// Return response for deleteStandard mutation
type StandardDeletePayload struct {
	// Deleted standard ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type StandardEdge struct {
	// The item at the end of the edge.
	Node *Standard `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type StandardHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// long description of the standard with details of what is covered
	Description *string `json:"description,omitempty"`
	// URL to the logo of the governing body
	GoverningBodyLogoURL *string `json:"governingBodyLogoURL,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, draft, and archived
	Status *enums.StandardStatus `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for system owned standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for system owned standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// type of the standard - cybersecurity, healthcare , financial, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
	// URL of the logo
	LogoFileID *string `json:"logoFileID,omitempty"`
}

func (StandardHistory) IsNode() {}

// A connection to a list of items.
type StandardHistoryConnection struct {
	// A list of edges.
	Edges []*StandardHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type StandardHistoryEdge struct {
	// The item at the end of the edge.
	Node *StandardHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for StandardHistory connections
type StandardHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order StandardHistories.
	Field StandardHistoryOrderField `json:"field"`
}

// StandardHistoryWhereInput is used for filtering StandardHistory objects.
// Input was generated by ent.
type StandardHistoryWhereInput struct {
	Not *StandardHistoryWhereInput   `json:"not,omitempty"`
	And []*StandardHistoryWhereInput `json:"and,omitempty"`
	Or  []*StandardHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// short_name field predicates
	ShortName             *string  `json:"shortName,omitempty"`
	ShortNameNeq          *string  `json:"shortNameNEQ,omitempty"`
	ShortNameIn           []string `json:"shortNameIn,omitempty"`
	ShortNameNotIn        []string `json:"shortNameNotIn,omitempty"`
	ShortNameGt           *string  `json:"shortNameGT,omitempty"`
	ShortNameGte          *string  `json:"shortNameGTE,omitempty"`
	ShortNameLt           *string  `json:"shortNameLT,omitempty"`
	ShortNameLte          *string  `json:"shortNameLTE,omitempty"`
	ShortNameContains     *string  `json:"shortNameContains,omitempty"`
	ShortNameHasPrefix    *string  `json:"shortNameHasPrefix,omitempty"`
	ShortNameHasSuffix    *string  `json:"shortNameHasSuffix,omitempty"`
	ShortNameIsNil        *bool    `json:"shortNameIsNil,omitempty"`
	ShortNameNotNil       *bool    `json:"shortNameNotNil,omitempty"`
	ShortNameEqualFold    *string  `json:"shortNameEqualFold,omitempty"`
	ShortNameContainsFold *string  `json:"shortNameContainsFold,omitempty"`
	// framework field predicates
	Framework             *string  `json:"framework,omitempty"`
	FrameworkNeq          *string  `json:"frameworkNEQ,omitempty"`
	FrameworkIn           []string `json:"frameworkIn,omitempty"`
	FrameworkNotIn        []string `json:"frameworkNotIn,omitempty"`
	FrameworkGt           *string  `json:"frameworkGT,omitempty"`
	FrameworkGte          *string  `json:"frameworkGTE,omitempty"`
	FrameworkLt           *string  `json:"frameworkLT,omitempty"`
	FrameworkLte          *string  `json:"frameworkLTE,omitempty"`
	FrameworkContains     *string  `json:"frameworkContains,omitempty"`
	FrameworkHasPrefix    *string  `json:"frameworkHasPrefix,omitempty"`
	FrameworkHasSuffix    *string  `json:"frameworkHasSuffix,omitempty"`
	FrameworkIsNil        *bool    `json:"frameworkIsNil,omitempty"`
	FrameworkNotNil       *bool    `json:"frameworkNotNil,omitempty"`
	FrameworkEqualFold    *string  `json:"frameworkEqualFold,omitempty"`
	FrameworkContainsFold *string  `json:"frameworkContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// governing_body_logo_url field predicates
	GoverningBodyLogoURL             *string  `json:"governingBodyLogoURL,omitempty"`
	GoverningBodyLogoURLNeq          *string  `json:"governingBodyLogoURLNEQ,omitempty"`
	GoverningBodyLogoURLIn           []string `json:"governingBodyLogoURLIn,omitempty"`
	GoverningBodyLogoURLNotIn        []string `json:"governingBodyLogoURLNotIn,omitempty"`
	GoverningBodyLogoURLGt           *string  `json:"governingBodyLogoURLGT,omitempty"`
	GoverningBodyLogoURLGte          *string  `json:"governingBodyLogoURLGTE,omitempty"`
	GoverningBodyLogoURLLt           *string  `json:"governingBodyLogoURLLT,omitempty"`
	GoverningBodyLogoURLLte          *string  `json:"governingBodyLogoURLLTE,omitempty"`
	GoverningBodyLogoURLContains     *string  `json:"governingBodyLogoURLContains,omitempty"`
	GoverningBodyLogoURLHasPrefix    *string  `json:"governingBodyLogoURLHasPrefix,omitempty"`
	GoverningBodyLogoURLHasSuffix    *string  `json:"governingBodyLogoURLHasSuffix,omitempty"`
	GoverningBodyLogoURLIsNil        *bool    `json:"governingBodyLogoURLIsNil,omitempty"`
	GoverningBodyLogoURLNotNil       *bool    `json:"governingBodyLogoURLNotNil,omitempty"`
	GoverningBodyLogoURLEqualFold    *string  `json:"governingBodyLogoURLEqualFold,omitempty"`
	GoverningBodyLogoURLContainsFold *string  `json:"governingBodyLogoURLContainsFold,omitempty"`
	// governing_body field predicates
	GoverningBody             *string  `json:"governingBody,omitempty"`
	GoverningBodyNeq          *string  `json:"governingBodyNEQ,omitempty"`
	GoverningBodyIn           []string `json:"governingBodyIn,omitempty"`
	GoverningBodyNotIn        []string `json:"governingBodyNotIn,omitempty"`
	GoverningBodyGt           *string  `json:"governingBodyGT,omitempty"`
	GoverningBodyGte          *string  `json:"governingBodyGTE,omitempty"`
	GoverningBodyLt           *string  `json:"governingBodyLT,omitempty"`
	GoverningBodyLte          *string  `json:"governingBodyLTE,omitempty"`
	GoverningBodyContains     *string  `json:"governingBodyContains,omitempty"`
	GoverningBodyHasPrefix    *string  `json:"governingBodyHasPrefix,omitempty"`
	GoverningBodyHasSuffix    *string  `json:"governingBodyHasSuffix,omitempty"`
	GoverningBodyIsNil        *bool    `json:"governingBodyIsNil,omitempty"`
	GoverningBodyNotNil       *bool    `json:"governingBodyNotNil,omitempty"`
	GoverningBodyEqualFold    *string  `json:"governingBodyEqualFold,omitempty"`
	GoverningBodyContainsFold *string  `json:"governingBodyContainsFold,omitempty"`
	// link field predicates
	Link             *string  `json:"link,omitempty"`
	LinkNeq          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGt           *string  `json:"linkGT,omitempty"`
	LinkGte          *string  `json:"linkGTE,omitempty"`
	LinkLt           *string  `json:"linkLT,omitempty"`
	LinkLte          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        *bool    `json:"linkIsNil,omitempty"`
	LinkNotNil       *bool    `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`
	// status field predicates
	Status       *enums.StandardStatus  `json:"status,omitempty"`
	StatusNeq    *enums.StandardStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.StandardStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.StandardStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// is_public field predicates
	IsPublic       *bool `json:"isPublic,omitempty"`
	IsPublicNeq    *bool `json:"isPublicNEQ,omitempty"`
	IsPublicIsNil  *bool `json:"isPublicIsNil,omitempty"`
	IsPublicNotNil *bool `json:"isPublicNotNil,omitempty"`
	// free_to_use field predicates
	FreeToUse       *bool `json:"freeToUse,omitempty"`
	FreeToUseNeq    *bool `json:"freeToUseNEQ,omitempty"`
	FreeToUseIsNil  *bool `json:"freeToUseIsNil,omitempty"`
	FreeToUseNotNil *bool `json:"freeToUseNotNil,omitempty"`
	// standard_type field predicates
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNeq          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGt           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGte          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLt           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLte          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        *bool    `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       *bool    `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// logo_file_id field predicates
	LogoFileID             *string  `json:"logoFileID,omitempty"`
	LogoFileIdneq          *string  `json:"logoFileIDNEQ,omitempty"`
	LogoFileIDIn           []string `json:"logoFileIDIn,omitempty"`
	LogoFileIDNotIn        []string `json:"logoFileIDNotIn,omitempty"`
	LogoFileIdgt           *string  `json:"logoFileIDGT,omitempty"`
	LogoFileIdgte          *string  `json:"logoFileIDGTE,omitempty"`
	LogoFileIdlt           *string  `json:"logoFileIDLT,omitempty"`
	LogoFileIdlte          *string  `json:"logoFileIDLTE,omitempty"`
	LogoFileIDContains     *string  `json:"logoFileIDContains,omitempty"`
	LogoFileIDHasPrefix    *string  `json:"logoFileIDHasPrefix,omitempty"`
	LogoFileIDHasSuffix    *string  `json:"logoFileIDHasSuffix,omitempty"`
	LogoFileIDIsNil        *bool    `json:"logoFileIDIsNil,omitempty"`
	LogoFileIDNotNil       *bool    `json:"logoFileIDNotNil,omitempty"`
	LogoFileIDEqualFold    *string  `json:"logoFileIDEqualFold,omitempty"`
	LogoFileIDContainsFold *string  `json:"logoFileIDContainsFold,omitempty"`
}

// Ordering options for Standard connections
type StandardOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Standards.
	Field StandardOrderField `json:"field"`
}

// Return response for updateStandard mutation
type StandardUpdatePayload struct {
	// Updated standard
	Standard *Standard `json:"standard"`
}

// StandardWhereInput is used for filtering Standard objects.
// Input was generated by ent.
type StandardWhereInput struct {
	Not *StandardWhereInput   `json:"not,omitempty"`
	And []*StandardWhereInput `json:"and,omitempty"`
	Or  []*StandardWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// short_name field predicates
	ShortName             *string  `json:"shortName,omitempty"`
	ShortNameNeq          *string  `json:"shortNameNEQ,omitempty"`
	ShortNameIn           []string `json:"shortNameIn,omitempty"`
	ShortNameNotIn        []string `json:"shortNameNotIn,omitempty"`
	ShortNameGt           *string  `json:"shortNameGT,omitempty"`
	ShortNameGte          *string  `json:"shortNameGTE,omitempty"`
	ShortNameLt           *string  `json:"shortNameLT,omitempty"`
	ShortNameLte          *string  `json:"shortNameLTE,omitempty"`
	ShortNameContains     *string  `json:"shortNameContains,omitempty"`
	ShortNameHasPrefix    *string  `json:"shortNameHasPrefix,omitempty"`
	ShortNameHasSuffix    *string  `json:"shortNameHasSuffix,omitempty"`
	ShortNameIsNil        *bool    `json:"shortNameIsNil,omitempty"`
	ShortNameNotNil       *bool    `json:"shortNameNotNil,omitempty"`
	ShortNameEqualFold    *string  `json:"shortNameEqualFold,omitempty"`
	ShortNameContainsFold *string  `json:"shortNameContainsFold,omitempty"`
	// framework field predicates
	Framework             *string  `json:"framework,omitempty"`
	FrameworkNeq          *string  `json:"frameworkNEQ,omitempty"`
	FrameworkIn           []string `json:"frameworkIn,omitempty"`
	FrameworkNotIn        []string `json:"frameworkNotIn,omitempty"`
	FrameworkGt           *string  `json:"frameworkGT,omitempty"`
	FrameworkGte          *string  `json:"frameworkGTE,omitempty"`
	FrameworkLt           *string  `json:"frameworkLT,omitempty"`
	FrameworkLte          *string  `json:"frameworkLTE,omitempty"`
	FrameworkContains     *string  `json:"frameworkContains,omitempty"`
	FrameworkHasPrefix    *string  `json:"frameworkHasPrefix,omitempty"`
	FrameworkHasSuffix    *string  `json:"frameworkHasSuffix,omitempty"`
	FrameworkIsNil        *bool    `json:"frameworkIsNil,omitempty"`
	FrameworkNotNil       *bool    `json:"frameworkNotNil,omitempty"`
	FrameworkEqualFold    *string  `json:"frameworkEqualFold,omitempty"`
	FrameworkContainsFold *string  `json:"frameworkContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// governing_body_logo_url field predicates
	GoverningBodyLogoURL             *string  `json:"governingBodyLogoURL,omitempty"`
	GoverningBodyLogoURLNeq          *string  `json:"governingBodyLogoURLNEQ,omitempty"`
	GoverningBodyLogoURLIn           []string `json:"governingBodyLogoURLIn,omitempty"`
	GoverningBodyLogoURLNotIn        []string `json:"governingBodyLogoURLNotIn,omitempty"`
	GoverningBodyLogoURLGt           *string  `json:"governingBodyLogoURLGT,omitempty"`
	GoverningBodyLogoURLGte          *string  `json:"governingBodyLogoURLGTE,omitempty"`
	GoverningBodyLogoURLLt           *string  `json:"governingBodyLogoURLLT,omitempty"`
	GoverningBodyLogoURLLte          *string  `json:"governingBodyLogoURLLTE,omitempty"`
	GoverningBodyLogoURLContains     *string  `json:"governingBodyLogoURLContains,omitempty"`
	GoverningBodyLogoURLHasPrefix    *string  `json:"governingBodyLogoURLHasPrefix,omitempty"`
	GoverningBodyLogoURLHasSuffix    *string  `json:"governingBodyLogoURLHasSuffix,omitempty"`
	GoverningBodyLogoURLIsNil        *bool    `json:"governingBodyLogoURLIsNil,omitempty"`
	GoverningBodyLogoURLNotNil       *bool    `json:"governingBodyLogoURLNotNil,omitempty"`
	GoverningBodyLogoURLEqualFold    *string  `json:"governingBodyLogoURLEqualFold,omitempty"`
	GoverningBodyLogoURLContainsFold *string  `json:"governingBodyLogoURLContainsFold,omitempty"`
	// governing_body field predicates
	GoverningBody             *string  `json:"governingBody,omitempty"`
	GoverningBodyNeq          *string  `json:"governingBodyNEQ,omitempty"`
	GoverningBodyIn           []string `json:"governingBodyIn,omitempty"`
	GoverningBodyNotIn        []string `json:"governingBodyNotIn,omitempty"`
	GoverningBodyGt           *string  `json:"governingBodyGT,omitempty"`
	GoverningBodyGte          *string  `json:"governingBodyGTE,omitempty"`
	GoverningBodyLt           *string  `json:"governingBodyLT,omitempty"`
	GoverningBodyLte          *string  `json:"governingBodyLTE,omitempty"`
	GoverningBodyContains     *string  `json:"governingBodyContains,omitempty"`
	GoverningBodyHasPrefix    *string  `json:"governingBodyHasPrefix,omitempty"`
	GoverningBodyHasSuffix    *string  `json:"governingBodyHasSuffix,omitempty"`
	GoverningBodyIsNil        *bool    `json:"governingBodyIsNil,omitempty"`
	GoverningBodyNotNil       *bool    `json:"governingBodyNotNil,omitempty"`
	GoverningBodyEqualFold    *string  `json:"governingBodyEqualFold,omitempty"`
	GoverningBodyContainsFold *string  `json:"governingBodyContainsFold,omitempty"`
	// link field predicates
	Link             *string  `json:"link,omitempty"`
	LinkNeq          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGt           *string  `json:"linkGT,omitempty"`
	LinkGte          *string  `json:"linkGTE,omitempty"`
	LinkLt           *string  `json:"linkLT,omitempty"`
	LinkLte          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        *bool    `json:"linkIsNil,omitempty"`
	LinkNotNil       *bool    `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`
	// status field predicates
	Status       *enums.StandardStatus  `json:"status,omitempty"`
	StatusNeq    *enums.StandardStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.StandardStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.StandardStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// is_public field predicates
	IsPublic       *bool `json:"isPublic,omitempty"`
	IsPublicNeq    *bool `json:"isPublicNEQ,omitempty"`
	IsPublicIsNil  *bool `json:"isPublicIsNil,omitempty"`
	IsPublicNotNil *bool `json:"isPublicNotNil,omitempty"`
	// free_to_use field predicates
	FreeToUse       *bool `json:"freeToUse,omitempty"`
	FreeToUseNeq    *bool `json:"freeToUseNEQ,omitempty"`
	FreeToUseIsNil  *bool `json:"freeToUseIsNil,omitempty"`
	FreeToUseNotNil *bool `json:"freeToUseNotNil,omitempty"`
	// standard_type field predicates
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNeq          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGt           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGte          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLt           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLte          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        *bool    `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       *bool    `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// logo_file_id field predicates
	LogoFileID             *string  `json:"logoFileID,omitempty"`
	LogoFileIdneq          *string  `json:"logoFileIDNEQ,omitempty"`
	LogoFileIDIn           []string `json:"logoFileIDIn,omitempty"`
	LogoFileIDNotIn        []string `json:"logoFileIDNotIn,omitempty"`
	LogoFileIdgt           *string  `json:"logoFileIDGT,omitempty"`
	LogoFileIdgte          *string  `json:"logoFileIDGTE,omitempty"`
	LogoFileIdlt           *string  `json:"logoFileIDLT,omitempty"`
	LogoFileIdlte          *string  `json:"logoFileIDLTE,omitempty"`
	LogoFileIDContains     *string  `json:"logoFileIDContains,omitempty"`
	LogoFileIDHasPrefix    *string  `json:"logoFileIDHasPrefix,omitempty"`
	LogoFileIDHasSuffix    *string  `json:"logoFileIDHasSuffix,omitempty"`
	LogoFileIDIsNil        *bool    `json:"logoFileIDIsNil,omitempty"`
	LogoFileIDNotNil       *bool    `json:"logoFileIDNotNil,omitempty"`
	LogoFileIDEqualFold    *string  `json:"logoFileIDEqualFold,omitempty"`
	LogoFileIDContainsFold *string  `json:"logoFileIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// trust_center_compliances edge predicates
	HasTrustCenterCompliances     *bool                              `json:"hasTrustCenterCompliances,omitempty"`
	HasTrustCenterCompliancesWith []*TrustCenterComplianceWhereInput `json:"hasTrustCenterCompliancesWith,omitempty"`
	// trust_center_docs edge predicates
	HasTrustCenterDocs     *bool                       `json:"hasTrustCenterDocs,omitempty"`
	HasTrustCenterDocsWith []*TrustCenterDocWhereInput `json:"hasTrustCenterDocsWith,omitempty"`
	// logo_file edge predicates
	HasLogoFile     *bool             `json:"hasLogoFile,omitempty"`
	HasLogoFileWith []*FileWhereInput `json:"hasLogoFileWith,omitempty"`
}

type Subcontrol struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// human readable title of the control for quick identification
	Title *string `json:"title,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// additional names (ref_codes) for the control
	Aliases []string `json:"aliases,omitempty"`
	// internal reference id of the control, can be used for internal tracking
	ReferenceID *string `json:"referenceID,omitempty"`
	// external auditor id of the control, can be used to map to external audit partner mappings
	AuditorReferenceID *string `json:"auditorReferenceID,omitempty"`
	// the id of the party responsible for the control, usually used when the control is implemented by a third party
	ResponsiblePartyID *string `json:"responsiblePartyID,omitempty"`
	// status of the control
	Status *enums.ControlStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// the reference framework for the control if it came from a standard, empty if not associated with a standard
	ReferenceFramework *string `json:"referenceFramework,omitempty"`
	// the reference framework revision for the control if it came from a standard, empty if not associated with a standard, allows for pulling in updates when the standard is updated
	ReferenceFrameworkRevision *string `json:"referenceFrameworkRevision,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the id of the group that owns the control
	ControlOwnerID *string `json:"controlOwnerID,omitempty"`
	// the id of the group that is temporarily delegated to own the control
	DelegateID *string `json:"delegateID,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the subcontrol
	SubcontrolKindName *string `json:"subcontrolKindName,omitempty"`
	// the kind of the subcontrol
	SubcontrolKindID *string `json:"subcontrolKindID,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the parent control
	ControlID         string                      `json:"controlID"`
	Evidence          *EvidenceConnection         `json:"evidence"`
	ControlObjectives *ControlObjectiveConnection `json:"controlObjectives"`
	Tasks             *TaskConnection             `json:"tasks"`
	Narratives        *NarrativeConnection        `json:"narratives"`
	Risks             *RiskConnection             `json:"risks"`
	ActionPlans       *ActionPlanConnection       `json:"actionPlans"`
	Procedures        *ProcedureConnection        `json:"procedures"`
	InternalPolicies  *InternalPolicyConnection   `json:"internalPolicies"`
	Comments          *NoteConnection             `json:"comments"`
	// the group of users who are responsible for the control, will be assigned tasks, approval, etc.
	ControlOwner *Group `json:"controlOwner,omitempty"`
	// temporary delegate for the control, used for temporary control ownership
	Delegate *Group `json:"delegate,omitempty"`
	// the entity who is responsible for the control implementation when it is a third party
	ResponsibleParty       *Entity                          `json:"responsibleParty,omitempty"`
	Owner                  *Organization                    `json:"owner,omitempty"`
	SubcontrolKind         *CustomTypeEnum                  `json:"subcontrolKind,omitempty"`
	Control                *Control                         `json:"control"`
	ControlImplementations *ControlImplementationConnection `json:"controlImplementations"`
	ScheduledJobs          *ScheduledJobConnection          `json:"scheduledJobs"`
}

func (Subcontrol) IsNode() {}

// Return response for createBulkSubcontrol mutation
type SubcontrolBulkCreatePayload struct {
	// Created subcontrols
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
}

// Return response for deleteBulkSubcontrol mutation
type SubcontrolBulkDeletePayload struct {
	// Deleted subcontrol IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type SubcontrolConnection struct {
	// A list of edges.
	Edges []*SubcontrolEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubcontrol mutation
type SubcontrolCreatePayload struct {
	// Created subcontrol
	Subcontrol *Subcontrol `json:"subcontrol"`
}

// Return response for deleteSubcontrol mutation
type SubcontrolDeletePayload struct {
	// Deleted subcontrol ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type SubcontrolEdge struct {
	// The item at the end of the edge.
	Node *Subcontrol `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type SubcontrolHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// human readable title of the control for quick identification
	Title *string `json:"title,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// additional names (ref_codes) for the control
	Aliases []string `json:"aliases,omitempty"`
	// internal reference id of the control, can be used for internal tracking
	ReferenceID *string `json:"referenceID,omitempty"`
	// external auditor id of the control, can be used to map to external audit partner mappings
	AuditorReferenceID *string `json:"auditorReferenceID,omitempty"`
	// the id of the party responsible for the control, usually used when the control is implemented by a third party
	ResponsiblePartyID *string `json:"responsiblePartyID,omitempty"`
	// status of the control
	Status *enums.ControlStatus `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// the reference framework for the control if it came from a standard, empty if not associated with a standard
	ReferenceFramework *string `json:"referenceFramework,omitempty"`
	// the reference framework revision for the control if it came from a standard, empty if not associated with a standard, allows for pulling in updates when the standard is updated
	ReferenceFrameworkRevision *string `json:"referenceFrameworkRevision,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the id of the group that owns the control
	ControlOwnerID *string `json:"controlOwnerID,omitempty"`
	// the id of the group that is temporarily delegated to own the control
	DelegateID *string `json:"delegateID,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the kind of the subcontrol
	SubcontrolKindName *string `json:"subcontrolKindName,omitempty"`
	// the kind of the subcontrol
	SubcontrolKindID *string `json:"subcontrolKindID,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the parent control
	ControlID string `json:"controlID"`
}

func (SubcontrolHistory) IsNode() {}

// A connection to a list of items.
type SubcontrolHistoryConnection struct {
	// A list of edges.
	Edges []*SubcontrolHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type SubcontrolHistoryEdge struct {
	// The item at the end of the edge.
	Node *SubcontrolHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for SubcontrolHistory connections
type SubcontrolHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order SubcontrolHistories.
	Field SubcontrolHistoryOrderField `json:"field"`
}

// SubcontrolHistoryWhereInput is used for filtering SubcontrolHistory objects.
// Input was generated by ent.
type SubcontrolHistoryWhereInput struct {
	Not *SubcontrolHistoryWhereInput   `json:"not,omitempty"`
	And []*SubcontrolHistoryWhereInput `json:"and,omitempty"`
	Or  []*SubcontrolHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// reference_id field predicates
	ReferenceID             *string  `json:"referenceID,omitempty"`
	ReferenceIdneq          *string  `json:"referenceIDNEQ,omitempty"`
	ReferenceIDIn           []string `json:"referenceIDIn,omitempty"`
	ReferenceIDNotIn        []string `json:"referenceIDNotIn,omitempty"`
	ReferenceIdgt           *string  `json:"referenceIDGT,omitempty"`
	ReferenceIdgte          *string  `json:"referenceIDGTE,omitempty"`
	ReferenceIdlt           *string  `json:"referenceIDLT,omitempty"`
	ReferenceIdlte          *string  `json:"referenceIDLTE,omitempty"`
	ReferenceIDContains     *string  `json:"referenceIDContains,omitempty"`
	ReferenceIDHasPrefix    *string  `json:"referenceIDHasPrefix,omitempty"`
	ReferenceIDHasSuffix    *string  `json:"referenceIDHasSuffix,omitempty"`
	ReferenceIDIsNil        *bool    `json:"referenceIDIsNil,omitempty"`
	ReferenceIDNotNil       *bool    `json:"referenceIDNotNil,omitempty"`
	ReferenceIDEqualFold    *string  `json:"referenceIDEqualFold,omitempty"`
	ReferenceIDContainsFold *string  `json:"referenceIDContainsFold,omitempty"`
	// auditor_reference_id field predicates
	AuditorReferenceID             *string  `json:"auditorReferenceID,omitempty"`
	AuditorReferenceIdneq          *string  `json:"auditorReferenceIDNEQ,omitempty"`
	AuditorReferenceIDIn           []string `json:"auditorReferenceIDIn,omitempty"`
	AuditorReferenceIDNotIn        []string `json:"auditorReferenceIDNotIn,omitempty"`
	AuditorReferenceIdgt           *string  `json:"auditorReferenceIDGT,omitempty"`
	AuditorReferenceIdgte          *string  `json:"auditorReferenceIDGTE,omitempty"`
	AuditorReferenceIdlt           *string  `json:"auditorReferenceIDLT,omitempty"`
	AuditorReferenceIdlte          *string  `json:"auditorReferenceIDLTE,omitempty"`
	AuditorReferenceIDContains     *string  `json:"auditorReferenceIDContains,omitempty"`
	AuditorReferenceIDHasPrefix    *string  `json:"auditorReferenceIDHasPrefix,omitempty"`
	AuditorReferenceIDHasSuffix    *string  `json:"auditorReferenceIDHasSuffix,omitempty"`
	AuditorReferenceIDIsNil        *bool    `json:"auditorReferenceIDIsNil,omitempty"`
	AuditorReferenceIDNotNil       *bool    `json:"auditorReferenceIDNotNil,omitempty"`
	AuditorReferenceIDEqualFold    *string  `json:"auditorReferenceIDEqualFold,omitempty"`
	AuditorReferenceIDContainsFold *string  `json:"auditorReferenceIDContainsFold,omitempty"`
	// responsible_party_id field predicates
	ResponsiblePartyID             *string  `json:"responsiblePartyID,omitempty"`
	ResponsiblePartyIdneq          *string  `json:"responsiblePartyIDNEQ,omitempty"`
	ResponsiblePartyIDIn           []string `json:"responsiblePartyIDIn,omitempty"`
	ResponsiblePartyIDNotIn        []string `json:"responsiblePartyIDNotIn,omitempty"`
	ResponsiblePartyIdgt           *string  `json:"responsiblePartyIDGT,omitempty"`
	ResponsiblePartyIdgte          *string  `json:"responsiblePartyIDGTE,omitempty"`
	ResponsiblePartyIdlt           *string  `json:"responsiblePartyIDLT,omitempty"`
	ResponsiblePartyIdlte          *string  `json:"responsiblePartyIDLTE,omitempty"`
	ResponsiblePartyIDContains     *string  `json:"responsiblePartyIDContains,omitempty"`
	ResponsiblePartyIDHasPrefix    *string  `json:"responsiblePartyIDHasPrefix,omitempty"`
	ResponsiblePartyIDHasSuffix    *string  `json:"responsiblePartyIDHasSuffix,omitempty"`
	ResponsiblePartyIDIsNil        *bool    `json:"responsiblePartyIDIsNil,omitempty"`
	ResponsiblePartyIDNotNil       *bool    `json:"responsiblePartyIDNotNil,omitempty"`
	ResponsiblePartyIDEqualFold    *string  `json:"responsiblePartyIDEqualFold,omitempty"`
	ResponsiblePartyIDContainsFold *string  `json:"responsiblePartyIDContainsFold,omitempty"`
	// status field predicates
	Status       *enums.ControlStatus  `json:"status,omitempty"`
	StatusNeq    *enums.ControlStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ControlStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ControlStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                 `json:"statusNotNil,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// reference_framework field predicates
	ReferenceFramework             *string  `json:"referenceFramework,omitempty"`
	ReferenceFrameworkNeq          *string  `json:"referenceFrameworkNEQ,omitempty"`
	ReferenceFrameworkIn           []string `json:"referenceFrameworkIn,omitempty"`
	ReferenceFrameworkNotIn        []string `json:"referenceFrameworkNotIn,omitempty"`
	ReferenceFrameworkGt           *string  `json:"referenceFrameworkGT,omitempty"`
	ReferenceFrameworkGte          *string  `json:"referenceFrameworkGTE,omitempty"`
	ReferenceFrameworkLt           *string  `json:"referenceFrameworkLT,omitempty"`
	ReferenceFrameworkLte          *string  `json:"referenceFrameworkLTE,omitempty"`
	ReferenceFrameworkContains     *string  `json:"referenceFrameworkContains,omitempty"`
	ReferenceFrameworkHasPrefix    *string  `json:"referenceFrameworkHasPrefix,omitempty"`
	ReferenceFrameworkHasSuffix    *string  `json:"referenceFrameworkHasSuffix,omitempty"`
	ReferenceFrameworkIsNil        *bool    `json:"referenceFrameworkIsNil,omitempty"`
	ReferenceFrameworkNotNil       *bool    `json:"referenceFrameworkNotNil,omitempty"`
	ReferenceFrameworkEqualFold    *string  `json:"referenceFrameworkEqualFold,omitempty"`
	ReferenceFrameworkContainsFold *string  `json:"referenceFrameworkContainsFold,omitempty"`
	// reference_framework_revision field predicates
	ReferenceFrameworkRevision             *string  `json:"referenceFrameworkRevision,omitempty"`
	ReferenceFrameworkRevisionNeq          *string  `json:"referenceFrameworkRevisionNEQ,omitempty"`
	ReferenceFrameworkRevisionIn           []string `json:"referenceFrameworkRevisionIn,omitempty"`
	ReferenceFrameworkRevisionNotIn        []string `json:"referenceFrameworkRevisionNotIn,omitempty"`
	ReferenceFrameworkRevisionGt           *string  `json:"referenceFrameworkRevisionGT,omitempty"`
	ReferenceFrameworkRevisionGte          *string  `json:"referenceFrameworkRevisionGTE,omitempty"`
	ReferenceFrameworkRevisionLt           *string  `json:"referenceFrameworkRevisionLT,omitempty"`
	ReferenceFrameworkRevisionLte          *string  `json:"referenceFrameworkRevisionLTE,omitempty"`
	ReferenceFrameworkRevisionContains     *string  `json:"referenceFrameworkRevisionContains,omitempty"`
	ReferenceFrameworkRevisionHasPrefix    *string  `json:"referenceFrameworkRevisionHasPrefix,omitempty"`
	ReferenceFrameworkRevisionHasSuffix    *string  `json:"referenceFrameworkRevisionHasSuffix,omitempty"`
	ReferenceFrameworkRevisionIsNil        *bool    `json:"referenceFrameworkRevisionIsNil,omitempty"`
	ReferenceFrameworkRevisionNotNil       *bool    `json:"referenceFrameworkRevisionNotNil,omitempty"`
	ReferenceFrameworkRevisionEqualFold    *string  `json:"referenceFrameworkRevisionEqualFold,omitempty"`
	ReferenceFrameworkRevisionContainsFold *string  `json:"referenceFrameworkRevisionContainsFold,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// control_owner_id field predicates
	ControlOwnerID             *string  `json:"controlOwnerID,omitempty"`
	ControlOwnerIdneq          *string  `json:"controlOwnerIDNEQ,omitempty"`
	ControlOwnerIDIn           []string `json:"controlOwnerIDIn,omitempty"`
	ControlOwnerIDNotIn        []string `json:"controlOwnerIDNotIn,omitempty"`
	ControlOwnerIdgt           *string  `json:"controlOwnerIDGT,omitempty"`
	ControlOwnerIdgte          *string  `json:"controlOwnerIDGTE,omitempty"`
	ControlOwnerIdlt           *string  `json:"controlOwnerIDLT,omitempty"`
	ControlOwnerIdlte          *string  `json:"controlOwnerIDLTE,omitempty"`
	ControlOwnerIDContains     *string  `json:"controlOwnerIDContains,omitempty"`
	ControlOwnerIDHasPrefix    *string  `json:"controlOwnerIDHasPrefix,omitempty"`
	ControlOwnerIDHasSuffix    *string  `json:"controlOwnerIDHasSuffix,omitempty"`
	ControlOwnerIDIsNil        *bool    `json:"controlOwnerIDIsNil,omitempty"`
	ControlOwnerIDNotNil       *bool    `json:"controlOwnerIDNotNil,omitempty"`
	ControlOwnerIDEqualFold    *string  `json:"controlOwnerIDEqualFold,omitempty"`
	ControlOwnerIDContainsFold *string  `json:"controlOwnerIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// subcontrol_kind_name field predicates
	SubcontrolKindName             *string  `json:"subcontrolKindName,omitempty"`
	SubcontrolKindNameNeq          *string  `json:"subcontrolKindNameNEQ,omitempty"`
	SubcontrolKindNameIn           []string `json:"subcontrolKindNameIn,omitempty"`
	SubcontrolKindNameNotIn        []string `json:"subcontrolKindNameNotIn,omitempty"`
	SubcontrolKindNameGt           *string  `json:"subcontrolKindNameGT,omitempty"`
	SubcontrolKindNameGte          *string  `json:"subcontrolKindNameGTE,omitempty"`
	SubcontrolKindNameLt           *string  `json:"subcontrolKindNameLT,omitempty"`
	SubcontrolKindNameLte          *string  `json:"subcontrolKindNameLTE,omitempty"`
	SubcontrolKindNameContains     *string  `json:"subcontrolKindNameContains,omitempty"`
	SubcontrolKindNameHasPrefix    *string  `json:"subcontrolKindNameHasPrefix,omitempty"`
	SubcontrolKindNameHasSuffix    *string  `json:"subcontrolKindNameHasSuffix,omitempty"`
	SubcontrolKindNameIsNil        *bool    `json:"subcontrolKindNameIsNil,omitempty"`
	SubcontrolKindNameNotNil       *bool    `json:"subcontrolKindNameNotNil,omitempty"`
	SubcontrolKindNameEqualFold    *string  `json:"subcontrolKindNameEqualFold,omitempty"`
	SubcontrolKindNameContainsFold *string  `json:"subcontrolKindNameContainsFold,omitempty"`
	// subcontrol_kind_id field predicates
	SubcontrolKindID             *string  `json:"subcontrolKindID,omitempty"`
	SubcontrolKindIdneq          *string  `json:"subcontrolKindIDNEQ,omitempty"`
	SubcontrolKindIDIn           []string `json:"subcontrolKindIDIn,omitempty"`
	SubcontrolKindIDNotIn        []string `json:"subcontrolKindIDNotIn,omitempty"`
	SubcontrolKindIdgt           *string  `json:"subcontrolKindIDGT,omitempty"`
	SubcontrolKindIdgte          *string  `json:"subcontrolKindIDGTE,omitempty"`
	SubcontrolKindIdlt           *string  `json:"subcontrolKindIDLT,omitempty"`
	SubcontrolKindIdlte          *string  `json:"subcontrolKindIDLTE,omitempty"`
	SubcontrolKindIDContains     *string  `json:"subcontrolKindIDContains,omitempty"`
	SubcontrolKindIDHasPrefix    *string  `json:"subcontrolKindIDHasPrefix,omitempty"`
	SubcontrolKindIDHasSuffix    *string  `json:"subcontrolKindIDHasSuffix,omitempty"`
	SubcontrolKindIDIsNil        *bool    `json:"subcontrolKindIDIsNil,omitempty"`
	SubcontrolKindIDNotNil       *bool    `json:"subcontrolKindIDNotNil,omitempty"`
	SubcontrolKindIDEqualFold    *string  `json:"subcontrolKindIDEqualFold,omitempty"`
	SubcontrolKindIDContainsFold *string  `json:"subcontrolKindIDContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
}

// Ordering options for Subcontrol connections
type SubcontrolOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Subcontrols.
	Field SubcontrolOrderField `json:"field"`
}

// Return response for updateSubcontrol mutation
type SubcontrolUpdatePayload struct {
	// Updated subcontrol
	Subcontrol *Subcontrol `json:"subcontrol"`
}

// SubcontrolWhereInput is used for filtering Subcontrol objects.
// Input was generated by ent.
type SubcontrolWhereInput struct {
	Not *SubcontrolWhereInput   `json:"not,omitempty"`
	And []*SubcontrolWhereInput `json:"and,omitempty"`
	Or  []*SubcontrolWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// reference_id field predicates
	ReferenceID             *string  `json:"referenceID,omitempty"`
	ReferenceIdneq          *string  `json:"referenceIDNEQ,omitempty"`
	ReferenceIDIn           []string `json:"referenceIDIn,omitempty"`
	ReferenceIDNotIn        []string `json:"referenceIDNotIn,omitempty"`
	ReferenceIdgt           *string  `json:"referenceIDGT,omitempty"`
	ReferenceIdgte          *string  `json:"referenceIDGTE,omitempty"`
	ReferenceIdlt           *string  `json:"referenceIDLT,omitempty"`
	ReferenceIdlte          *string  `json:"referenceIDLTE,omitempty"`
	ReferenceIDContains     *string  `json:"referenceIDContains,omitempty"`
	ReferenceIDHasPrefix    *string  `json:"referenceIDHasPrefix,omitempty"`
	ReferenceIDHasSuffix    *string  `json:"referenceIDHasSuffix,omitempty"`
	ReferenceIDIsNil        *bool    `json:"referenceIDIsNil,omitempty"`
	ReferenceIDNotNil       *bool    `json:"referenceIDNotNil,omitempty"`
	ReferenceIDEqualFold    *string  `json:"referenceIDEqualFold,omitempty"`
	ReferenceIDContainsFold *string  `json:"referenceIDContainsFold,omitempty"`
	// auditor_reference_id field predicates
	AuditorReferenceID             *string  `json:"auditorReferenceID,omitempty"`
	AuditorReferenceIdneq          *string  `json:"auditorReferenceIDNEQ,omitempty"`
	AuditorReferenceIDIn           []string `json:"auditorReferenceIDIn,omitempty"`
	AuditorReferenceIDNotIn        []string `json:"auditorReferenceIDNotIn,omitempty"`
	AuditorReferenceIdgt           *string  `json:"auditorReferenceIDGT,omitempty"`
	AuditorReferenceIdgte          *string  `json:"auditorReferenceIDGTE,omitempty"`
	AuditorReferenceIdlt           *string  `json:"auditorReferenceIDLT,omitempty"`
	AuditorReferenceIdlte          *string  `json:"auditorReferenceIDLTE,omitempty"`
	AuditorReferenceIDContains     *string  `json:"auditorReferenceIDContains,omitempty"`
	AuditorReferenceIDHasPrefix    *string  `json:"auditorReferenceIDHasPrefix,omitempty"`
	AuditorReferenceIDHasSuffix    *string  `json:"auditorReferenceIDHasSuffix,omitempty"`
	AuditorReferenceIDIsNil        *bool    `json:"auditorReferenceIDIsNil,omitempty"`
	AuditorReferenceIDNotNil       *bool    `json:"auditorReferenceIDNotNil,omitempty"`
	AuditorReferenceIDEqualFold    *string  `json:"auditorReferenceIDEqualFold,omitempty"`
	AuditorReferenceIDContainsFold *string  `json:"auditorReferenceIDContainsFold,omitempty"`
	// responsible_party_id field predicates
	ResponsiblePartyID             *string  `json:"responsiblePartyID,omitempty"`
	ResponsiblePartyIdneq          *string  `json:"responsiblePartyIDNEQ,omitempty"`
	ResponsiblePartyIDIn           []string `json:"responsiblePartyIDIn,omitempty"`
	ResponsiblePartyIDNotIn        []string `json:"responsiblePartyIDNotIn,omitempty"`
	ResponsiblePartyIdgt           *string  `json:"responsiblePartyIDGT,omitempty"`
	ResponsiblePartyIdgte          *string  `json:"responsiblePartyIDGTE,omitempty"`
	ResponsiblePartyIdlt           *string  `json:"responsiblePartyIDLT,omitempty"`
	ResponsiblePartyIdlte          *string  `json:"responsiblePartyIDLTE,omitempty"`
	ResponsiblePartyIDContains     *string  `json:"responsiblePartyIDContains,omitempty"`
	ResponsiblePartyIDHasPrefix    *string  `json:"responsiblePartyIDHasPrefix,omitempty"`
	ResponsiblePartyIDHasSuffix    *string  `json:"responsiblePartyIDHasSuffix,omitempty"`
	ResponsiblePartyIDIsNil        *bool    `json:"responsiblePartyIDIsNil,omitempty"`
	ResponsiblePartyIDNotNil       *bool    `json:"responsiblePartyIDNotNil,omitempty"`
	ResponsiblePartyIDEqualFold    *string  `json:"responsiblePartyIDEqualFold,omitempty"`
	ResponsiblePartyIDContainsFold *string  `json:"responsiblePartyIDContainsFold,omitempty"`
	// status field predicates
	Status       *enums.ControlStatus  `json:"status,omitempty"`
	StatusNeq    *enums.ControlStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.ControlStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.ControlStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                 `json:"statusNotNil,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// reference_framework field predicates
	ReferenceFramework             *string  `json:"referenceFramework,omitempty"`
	ReferenceFrameworkNeq          *string  `json:"referenceFrameworkNEQ,omitempty"`
	ReferenceFrameworkIn           []string `json:"referenceFrameworkIn,omitempty"`
	ReferenceFrameworkNotIn        []string `json:"referenceFrameworkNotIn,omitempty"`
	ReferenceFrameworkGt           *string  `json:"referenceFrameworkGT,omitempty"`
	ReferenceFrameworkGte          *string  `json:"referenceFrameworkGTE,omitempty"`
	ReferenceFrameworkLt           *string  `json:"referenceFrameworkLT,omitempty"`
	ReferenceFrameworkLte          *string  `json:"referenceFrameworkLTE,omitempty"`
	ReferenceFrameworkContains     *string  `json:"referenceFrameworkContains,omitempty"`
	ReferenceFrameworkHasPrefix    *string  `json:"referenceFrameworkHasPrefix,omitempty"`
	ReferenceFrameworkHasSuffix    *string  `json:"referenceFrameworkHasSuffix,omitempty"`
	ReferenceFrameworkIsNil        *bool    `json:"referenceFrameworkIsNil,omitempty"`
	ReferenceFrameworkNotNil       *bool    `json:"referenceFrameworkNotNil,omitempty"`
	ReferenceFrameworkEqualFold    *string  `json:"referenceFrameworkEqualFold,omitempty"`
	ReferenceFrameworkContainsFold *string  `json:"referenceFrameworkContainsFold,omitempty"`
	// reference_framework_revision field predicates
	ReferenceFrameworkRevision             *string  `json:"referenceFrameworkRevision,omitempty"`
	ReferenceFrameworkRevisionNeq          *string  `json:"referenceFrameworkRevisionNEQ,omitempty"`
	ReferenceFrameworkRevisionIn           []string `json:"referenceFrameworkRevisionIn,omitempty"`
	ReferenceFrameworkRevisionNotIn        []string `json:"referenceFrameworkRevisionNotIn,omitempty"`
	ReferenceFrameworkRevisionGt           *string  `json:"referenceFrameworkRevisionGT,omitempty"`
	ReferenceFrameworkRevisionGte          *string  `json:"referenceFrameworkRevisionGTE,omitempty"`
	ReferenceFrameworkRevisionLt           *string  `json:"referenceFrameworkRevisionLT,omitempty"`
	ReferenceFrameworkRevisionLte          *string  `json:"referenceFrameworkRevisionLTE,omitempty"`
	ReferenceFrameworkRevisionContains     *string  `json:"referenceFrameworkRevisionContains,omitempty"`
	ReferenceFrameworkRevisionHasPrefix    *string  `json:"referenceFrameworkRevisionHasPrefix,omitempty"`
	ReferenceFrameworkRevisionHasSuffix    *string  `json:"referenceFrameworkRevisionHasSuffix,omitempty"`
	ReferenceFrameworkRevisionIsNil        *bool    `json:"referenceFrameworkRevisionIsNil,omitempty"`
	ReferenceFrameworkRevisionNotNil       *bool    `json:"referenceFrameworkRevisionNotNil,omitempty"`
	ReferenceFrameworkRevisionEqualFold    *string  `json:"referenceFrameworkRevisionEqualFold,omitempty"`
	ReferenceFrameworkRevisionContainsFold *string  `json:"referenceFrameworkRevisionContainsFold,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// control_owner_id field predicates
	ControlOwnerID             *string  `json:"controlOwnerID,omitempty"`
	ControlOwnerIdneq          *string  `json:"controlOwnerIDNEQ,omitempty"`
	ControlOwnerIDIn           []string `json:"controlOwnerIDIn,omitempty"`
	ControlOwnerIDNotIn        []string `json:"controlOwnerIDNotIn,omitempty"`
	ControlOwnerIdgt           *string  `json:"controlOwnerIDGT,omitempty"`
	ControlOwnerIdgte          *string  `json:"controlOwnerIDGTE,omitempty"`
	ControlOwnerIdlt           *string  `json:"controlOwnerIDLT,omitempty"`
	ControlOwnerIdlte          *string  `json:"controlOwnerIDLTE,omitempty"`
	ControlOwnerIDContains     *string  `json:"controlOwnerIDContains,omitempty"`
	ControlOwnerIDHasPrefix    *string  `json:"controlOwnerIDHasPrefix,omitempty"`
	ControlOwnerIDHasSuffix    *string  `json:"controlOwnerIDHasSuffix,omitempty"`
	ControlOwnerIDIsNil        *bool    `json:"controlOwnerIDIsNil,omitempty"`
	ControlOwnerIDNotNil       *bool    `json:"controlOwnerIDNotNil,omitempty"`
	ControlOwnerIDEqualFold    *string  `json:"controlOwnerIDEqualFold,omitempty"`
	ControlOwnerIDContainsFold *string  `json:"controlOwnerIDContainsFold,omitempty"`
	// delegate_id field predicates
	DelegateID             *string  `json:"delegateID,omitempty"`
	DelegateIdneq          *string  `json:"delegateIDNEQ,omitempty"`
	DelegateIDIn           []string `json:"delegateIDIn,omitempty"`
	DelegateIDNotIn        []string `json:"delegateIDNotIn,omitempty"`
	DelegateIdgt           *string  `json:"delegateIDGT,omitempty"`
	DelegateIdgte          *string  `json:"delegateIDGTE,omitempty"`
	DelegateIdlt           *string  `json:"delegateIDLT,omitempty"`
	DelegateIdlte          *string  `json:"delegateIDLTE,omitempty"`
	DelegateIDContains     *string  `json:"delegateIDContains,omitempty"`
	DelegateIDHasPrefix    *string  `json:"delegateIDHasPrefix,omitempty"`
	DelegateIDHasSuffix    *string  `json:"delegateIDHasSuffix,omitempty"`
	DelegateIDIsNil        *bool    `json:"delegateIDIsNil,omitempty"`
	DelegateIDNotNil       *bool    `json:"delegateIDNotNil,omitempty"`
	DelegateIDEqualFold    *string  `json:"delegateIDEqualFold,omitempty"`
	DelegateIDContainsFold *string  `json:"delegateIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// subcontrol_kind_name field predicates
	SubcontrolKindName             *string  `json:"subcontrolKindName,omitempty"`
	SubcontrolKindNameNeq          *string  `json:"subcontrolKindNameNEQ,omitempty"`
	SubcontrolKindNameIn           []string `json:"subcontrolKindNameIn,omitempty"`
	SubcontrolKindNameNotIn        []string `json:"subcontrolKindNameNotIn,omitempty"`
	SubcontrolKindNameGt           *string  `json:"subcontrolKindNameGT,omitempty"`
	SubcontrolKindNameGte          *string  `json:"subcontrolKindNameGTE,omitempty"`
	SubcontrolKindNameLt           *string  `json:"subcontrolKindNameLT,omitempty"`
	SubcontrolKindNameLte          *string  `json:"subcontrolKindNameLTE,omitempty"`
	SubcontrolKindNameContains     *string  `json:"subcontrolKindNameContains,omitempty"`
	SubcontrolKindNameHasPrefix    *string  `json:"subcontrolKindNameHasPrefix,omitempty"`
	SubcontrolKindNameHasSuffix    *string  `json:"subcontrolKindNameHasSuffix,omitempty"`
	SubcontrolKindNameIsNil        *bool    `json:"subcontrolKindNameIsNil,omitempty"`
	SubcontrolKindNameNotNil       *bool    `json:"subcontrolKindNameNotNil,omitempty"`
	SubcontrolKindNameEqualFold    *string  `json:"subcontrolKindNameEqualFold,omitempty"`
	SubcontrolKindNameContainsFold *string  `json:"subcontrolKindNameContainsFold,omitempty"`
	// subcontrol_kind_id field predicates
	SubcontrolKindID             *string  `json:"subcontrolKindID,omitempty"`
	SubcontrolKindIdneq          *string  `json:"subcontrolKindIDNEQ,omitempty"`
	SubcontrolKindIDIn           []string `json:"subcontrolKindIDIn,omitempty"`
	SubcontrolKindIDNotIn        []string `json:"subcontrolKindIDNotIn,omitempty"`
	SubcontrolKindIdgt           *string  `json:"subcontrolKindIDGT,omitempty"`
	SubcontrolKindIdgte          *string  `json:"subcontrolKindIDGTE,omitempty"`
	SubcontrolKindIdlt           *string  `json:"subcontrolKindIDLT,omitempty"`
	SubcontrolKindIdlte          *string  `json:"subcontrolKindIDLTE,omitempty"`
	SubcontrolKindIDContains     *string  `json:"subcontrolKindIDContains,omitempty"`
	SubcontrolKindIDHasPrefix    *string  `json:"subcontrolKindIDHasPrefix,omitempty"`
	SubcontrolKindIDHasSuffix    *string  `json:"subcontrolKindIDHasSuffix,omitempty"`
	SubcontrolKindIDIsNil        *bool    `json:"subcontrolKindIDIsNil,omitempty"`
	SubcontrolKindIDNotNil       *bool    `json:"subcontrolKindIDNotNil,omitempty"`
	SubcontrolKindIDEqualFold    *string  `json:"subcontrolKindIDEqualFold,omitempty"`
	SubcontrolKindIDContainsFold *string  `json:"subcontrolKindIDContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// control_owner edge predicates
	HasControlOwner     *bool              `json:"hasControlOwner,omitempty"`
	HasControlOwnerWith []*GroupWhereInput `json:"hasControlOwnerWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// responsible_party edge predicates
	HasResponsibleParty     *bool               `json:"hasResponsibleParty,omitempty"`
	HasResponsiblePartyWith []*EntityWhereInput `json:"hasResponsiblePartyWith,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// subcontrol_kind edge predicates
	HasSubcontrolKind     *bool                       `json:"hasSubcontrolKind,omitempty"`
	HasSubcontrolKindWith []*CustomTypeEnumWhereInput `json:"hasSubcontrolKindWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// control_implementations edge predicates
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`
	// scheduled_jobs edge predicates
	HasScheduledJobs     *bool                     `json:"hasScheduledJobs,omitempty"`
	HasScheduledJobsWith []*ScheduledJobWhereInput `json:"hasScheduledJobsWith,omitempty"`
	// mapped_to_subcontrols edge predicates
	HasMappedToSubcontrols     *bool                      `json:"hasMappedToSubcontrols,omitempty"`
	HasMappedToSubcontrolsWith []*MappedControlWhereInput `json:"hasMappedToSubcontrolsWith,omitempty"`
	// mapped_from_subcontrols edge predicates
	HasMappedFromSubcontrols     *bool                      `json:"hasMappedFromSubcontrols,omitempty"`
	HasMappedFromSubcontrolsWith []*MappedControlWhereInput `json:"hasMappedFromSubcontrolsWith,omitempty"`
}

type SubmitTrustCenterNDAResponseInput struct {
	// template id
	TemplateID string `json:"templateID"`
	// json response
	Response map[string]any `json:"response"`
}

type SubmitTrustCenterNDAResponsePayload struct {
	DocumentData *DocumentData `json:"documentData"`
}

type Subprocessor struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// name of the standard body
	Name string `json:"name"`
	// description of the subprocessor
	Description *string `json:"description,omitempty"`
	// URL of the logo
	LogoRemoteURL *string `json:"logoRemoteURL,omitempty"`
	// The local logo file id, takes precedence over the logo remote URL
	LogoFileID               *string                            `json:"logoFileID,omitempty"`
	Owner                    *Organization                      `json:"owner,omitempty"`
	LogoFile                 *File                              `json:"logoFile,omitempty"`
	TrustCenterSubprocessors *TrustCenterSubprocessorConnection `json:"trustCenterSubprocessors"`
}

func (Subprocessor) IsNode() {}

// Return response for createBulkSubprocessor mutation
type SubprocessorBulkCreatePayload struct {
	// Created subprocessors
	Subprocessors []*Subprocessor `json:"subprocessors,omitempty"`
}

// Return response for deleteBulkSubprocessor mutation
type SubprocessorBulkDeletePayload struct {
	// Deleted subprocessor IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkSubprocessor mutation
type SubprocessorBulkUpdatePayload struct {
	// Updated subprocessors
	Subprocessors []*Subprocessor `json:"subprocessors,omitempty"`
	// IDs of the updated subprocessors
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type SubprocessorConnection struct {
	// A list of edges.
	Edges []*SubprocessorEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubprocessor mutation
type SubprocessorCreatePayload struct {
	// Created subprocessor
	Subprocessor *Subprocessor `json:"subprocessor"`
}

// Return response for deleteSubprocessor mutation
type SubprocessorDeletePayload struct {
	// Deleted subprocessor ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type SubprocessorEdge struct {
	// The item at the end of the edge.
	Node *Subprocessor `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type SubprocessorHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// name of the standard body
	Name string `json:"name"`
	// description of the subprocessor
	Description *string `json:"description,omitempty"`
	// URL of the logo
	LogoRemoteURL *string `json:"logoRemoteURL,omitempty"`
	// The local logo file id, takes precedence over the logo remote URL
	LogoFileID *string `json:"logoFileID,omitempty"`
}

func (SubprocessorHistory) IsNode() {}

// A connection to a list of items.
type SubprocessorHistoryConnection struct {
	// A list of edges.
	Edges []*SubprocessorHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type SubprocessorHistoryEdge struct {
	// The item at the end of the edge.
	Node *SubprocessorHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for SubprocessorHistory connections
type SubprocessorHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order SubprocessorHistories.
	Field SubprocessorHistoryOrderField `json:"field"`
}

// SubprocessorHistoryWhereInput is used for filtering SubprocessorHistory objects.
// Input was generated by ent.
type SubprocessorHistoryWhereInput struct {
	Not *SubprocessorHistoryWhereInput   `json:"not,omitempty"`
	And []*SubprocessorHistoryWhereInput `json:"and,omitempty"`
	Or  []*SubprocessorHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// logo_remote_url field predicates
	LogoRemoteURL             *string  `json:"logoRemoteURL,omitempty"`
	LogoRemoteURLNeq          *string  `json:"logoRemoteURLNEQ,omitempty"`
	LogoRemoteURLIn           []string `json:"logoRemoteURLIn,omitempty"`
	LogoRemoteURLNotIn        []string `json:"logoRemoteURLNotIn,omitempty"`
	LogoRemoteURLGt           *string  `json:"logoRemoteURLGT,omitempty"`
	LogoRemoteURLGte          *string  `json:"logoRemoteURLGTE,omitempty"`
	LogoRemoteURLLt           *string  `json:"logoRemoteURLLT,omitempty"`
	LogoRemoteURLLte          *string  `json:"logoRemoteURLLTE,omitempty"`
	LogoRemoteURLContains     *string  `json:"logoRemoteURLContains,omitempty"`
	LogoRemoteURLHasPrefix    *string  `json:"logoRemoteURLHasPrefix,omitempty"`
	LogoRemoteURLHasSuffix    *string  `json:"logoRemoteURLHasSuffix,omitempty"`
	LogoRemoteURLIsNil        *bool    `json:"logoRemoteURLIsNil,omitempty"`
	LogoRemoteURLNotNil       *bool    `json:"logoRemoteURLNotNil,omitempty"`
	LogoRemoteURLEqualFold    *string  `json:"logoRemoteURLEqualFold,omitempty"`
	LogoRemoteURLContainsFold *string  `json:"logoRemoteURLContainsFold,omitempty"`
	// logo_file_id field predicates
	LogoFileID             *string  `json:"logoFileID,omitempty"`
	LogoFileIdneq          *string  `json:"logoFileIDNEQ,omitempty"`
	LogoFileIDIn           []string `json:"logoFileIDIn,omitempty"`
	LogoFileIDNotIn        []string `json:"logoFileIDNotIn,omitempty"`
	LogoFileIdgt           *string  `json:"logoFileIDGT,omitempty"`
	LogoFileIdgte          *string  `json:"logoFileIDGTE,omitempty"`
	LogoFileIdlt           *string  `json:"logoFileIDLT,omitempty"`
	LogoFileIdlte          *string  `json:"logoFileIDLTE,omitempty"`
	LogoFileIDContains     *string  `json:"logoFileIDContains,omitempty"`
	LogoFileIDHasPrefix    *string  `json:"logoFileIDHasPrefix,omitempty"`
	LogoFileIDHasSuffix    *string  `json:"logoFileIDHasSuffix,omitempty"`
	LogoFileIDIsNil        *bool    `json:"logoFileIDIsNil,omitempty"`
	LogoFileIDNotNil       *bool    `json:"logoFileIDNotNil,omitempty"`
	LogoFileIDEqualFold    *string  `json:"logoFileIDEqualFold,omitempty"`
	LogoFileIDContainsFold *string  `json:"logoFileIDContainsFold,omitempty"`
}

// Ordering options for Subprocessor connections
type SubprocessorOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Subprocessors.
	Field SubprocessorOrderField `json:"field"`
}

// Return response for updateSubprocessor mutation
type SubprocessorUpdatePayload struct {
	// Updated subprocessor
	Subprocessor *Subprocessor `json:"subprocessor"`
}

// SubprocessorWhereInput is used for filtering Subprocessor objects.
// Input was generated by ent.
type SubprocessorWhereInput struct {
	Not *SubprocessorWhereInput   `json:"not,omitempty"`
	And []*SubprocessorWhereInput `json:"and,omitempty"`
	Or  []*SubprocessorWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// logo_remote_url field predicates
	LogoRemoteURL             *string  `json:"logoRemoteURL,omitempty"`
	LogoRemoteURLNeq          *string  `json:"logoRemoteURLNEQ,omitempty"`
	LogoRemoteURLIn           []string `json:"logoRemoteURLIn,omitempty"`
	LogoRemoteURLNotIn        []string `json:"logoRemoteURLNotIn,omitempty"`
	LogoRemoteURLGt           *string  `json:"logoRemoteURLGT,omitempty"`
	LogoRemoteURLGte          *string  `json:"logoRemoteURLGTE,omitempty"`
	LogoRemoteURLLt           *string  `json:"logoRemoteURLLT,omitempty"`
	LogoRemoteURLLte          *string  `json:"logoRemoteURLLTE,omitempty"`
	LogoRemoteURLContains     *string  `json:"logoRemoteURLContains,omitempty"`
	LogoRemoteURLHasPrefix    *string  `json:"logoRemoteURLHasPrefix,omitempty"`
	LogoRemoteURLHasSuffix    *string  `json:"logoRemoteURLHasSuffix,omitempty"`
	LogoRemoteURLIsNil        *bool    `json:"logoRemoteURLIsNil,omitempty"`
	LogoRemoteURLNotNil       *bool    `json:"logoRemoteURLNotNil,omitempty"`
	LogoRemoteURLEqualFold    *string  `json:"logoRemoteURLEqualFold,omitempty"`
	LogoRemoteURLContainsFold *string  `json:"logoRemoteURLContainsFold,omitempty"`
	// logo_file_id field predicates
	LogoFileID             *string  `json:"logoFileID,omitempty"`
	LogoFileIdneq          *string  `json:"logoFileIDNEQ,omitempty"`
	LogoFileIDIn           []string `json:"logoFileIDIn,omitempty"`
	LogoFileIDNotIn        []string `json:"logoFileIDNotIn,omitempty"`
	LogoFileIdgt           *string  `json:"logoFileIDGT,omitempty"`
	LogoFileIdgte          *string  `json:"logoFileIDGTE,omitempty"`
	LogoFileIdlt           *string  `json:"logoFileIDLT,omitempty"`
	LogoFileIdlte          *string  `json:"logoFileIDLTE,omitempty"`
	LogoFileIDContains     *string  `json:"logoFileIDContains,omitempty"`
	LogoFileIDHasPrefix    *string  `json:"logoFileIDHasPrefix,omitempty"`
	LogoFileIDHasSuffix    *string  `json:"logoFileIDHasSuffix,omitempty"`
	LogoFileIDIsNil        *bool    `json:"logoFileIDIsNil,omitempty"`
	LogoFileIDNotNil       *bool    `json:"logoFileIDNotNil,omitempty"`
	LogoFileIDEqualFold    *string  `json:"logoFileIDEqualFold,omitempty"`
	LogoFileIDContainsFold *string  `json:"logoFileIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// logo_file edge predicates
	HasLogoFile     *bool             `json:"hasLogoFile,omitempty"`
	HasLogoFileWith []*FileWhereInput `json:"hasLogoFileWith,omitempty"`
	// trust_center_subprocessors edge predicates
	HasTrustCenterSubprocessors     *bool                                `json:"hasTrustCenterSubprocessors,omitempty"`
	HasTrustCenterSubprocessorsWith []*TrustCenterSubprocessorWhereInput `json:"hasTrustCenterSubprocessorsWith,omitempty"`
}

type Subscriber struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// indicates if the email address has been verified
	VerifiedEmail bool `json:"verifiedEmail"`
	// indicates if the phone number has been verified
	VerifiedPhone bool `json:"verifiedPhone"`
	// indicates if the subscriber is active or not, active users will have at least one verified contact method
	Active bool `json:"active"`
	// indicates if the subscriber has unsubscribed from communications
	Unsubscribed bool `json:"unsubscribed"`
	// the number of attempts made to perform email send of the subscription, maximum of 5
	SendAttempts int64            `json:"sendAttempts"`
	Owner        *Organization    `json:"owner,omitempty"`
	Events       *EventConnection `json:"events"`
}

func (Subscriber) IsNode() {}

// Return response for createBulkSubscriber mutation
type SubscriberBulkCreatePayload struct {
	// Created subscribers
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

// A connection to a list of items.
type SubscriberConnection struct {
	// A list of edges.
	Edges []*SubscriberEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubscriber mutation
type SubscriberCreatePayload struct {
	// Created subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// Return response for deleteSubscriber mutation
type SubscriberDeletePayload struct {
	// Deleted subscriber email
	Email string `json:"email"`
}

// An edge in a connection.
type SubscriberEdge struct {
	// The item at the end of the edge.
	Node *Subscriber `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Subscriber connections
type SubscriberOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Subscribers.
	Field SubscriberOrderField `json:"field"`
}

// Return response for updateSubscriber mutation
type SubscriberUpdatePayload struct {
	// Updated subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// SubscriberWhereInput is used for filtering Subscriber objects.
// Input was generated by ent.
type SubscriberWhereInput struct {
	Not *SubscriberWhereInput   `json:"not,omitempty"`
	And []*SubscriberWhereInput `json:"and,omitempty"`
	Or  []*SubscriberWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// verified_email field predicates
	VerifiedEmail    *bool `json:"verifiedEmail,omitempty"`
	VerifiedEmailNeq *bool `json:"verifiedEmailNEQ,omitempty"`
	// verified_phone field predicates
	VerifiedPhone    *bool `json:"verifiedPhone,omitempty"`
	VerifiedPhoneNeq *bool `json:"verifiedPhoneNEQ,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// unsubscribed field predicates
	Unsubscribed    *bool `json:"unsubscribed,omitempty"`
	UnsubscribedNeq *bool `json:"unsubscribedNEQ,omitempty"`
	// send_attempts field predicates
	SendAttempts      *int64  `json:"sendAttempts,omitempty"`
	SendAttemptsNeq   *int64  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int64 `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int64 `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGt    *int64  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGte   *int64  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLt    *int64  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLte   *int64  `json:"sendAttemptsLTE,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Subscription struct {
}

type TFASetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// specifies if the TFA device has been verified
	Verified bool `json:"verified"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool `json:"totpAllowed,omitempty"`
	Owner       *User `json:"owner,omitempty"`
}

func (TFASetting) IsNode() {}

// A connection to a list of items.
type TFASettingConnection struct {
	// A list of edges.
	Edges []*TFASettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTFASetting mutation
type TFASettingCreatePayload struct {
	// Created tfaSetting
	TfaSetting *TFASetting `json:"tfaSetting"`
	TfaSecret  *string     `json:"tfaSecret,omitempty"`
	QRCode     *string     `json:"qrCode,omitempty"`
}

// An edge in a connection.
type TFASettingEdge struct {
	// The item at the end of the edge.
	Node *TFASetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TFASetting connections
type TFASettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TFASettings.
	Field TFASettingOrderField `json:"field"`
}

// Return response for updateTFASetting mutation
type TFASettingUpdatePayload struct {
	// Updated tfaSetting
	TfaSetting    *TFASetting `json:"tfaSetting"`
	TfaSecret     *string     `json:"tfaSecret,omitempty"`
	QRCode        *string     `json:"qrCode,omitempty"`
	RecoveryCodes []string    `json:"recoveryCodes,omitempty"`
}

// TFASettingWhereInput is used for filtering TFASetting objects.
// Input was generated by ent.
type TFASettingWhereInput struct {
	Not *TFASettingWhereInput   `json:"not,omitempty"`
	And []*TFASettingWhereInput `json:"and,omitempty"`
	Or  []*TFASettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// verified field predicates
	Verified    *bool `json:"verified,omitempty"`
	VerifiedNeq *bool `json:"verifiedNEQ,omitempty"`
	// totp_allowed field predicates
	TotpAllowed       *bool `json:"totpAllowed,omitempty"`
	TotpAllowedNeq    *bool `json:"totpAllowedNEQ,omitempty"`
	TotpAllowedIsNil  *bool `json:"totpAllowedIsNil,omitempty"`
	TotpAllowedNotNil *bool `json:"totpAllowedNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type TagDefinition struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// The name of the tag definition
	Name string `json:"name"`
	// common aliases or misspellings for the tag definition
	Aliases []string `json:"aliases,omitempty"`
	// The slug of the tag definition, derived from the name, unique per organization
	Slug *string `json:"slug,omitempty"`
	// The description of the tag definition
	Description *string `json:"description,omitempty"`
	// The color of the tag definition in hex format
	Color *string       `json:"color,omitempty"`
	Owner *Organization `json:"owner,omitempty"`
}

func (TagDefinition) IsNode() {}

// Return response for createBulkTagDefinition mutation
type TagDefinitionBulkCreatePayload struct {
	// Created tagDefinitions
	TagDefinitions []*TagDefinition `json:"tagDefinitions,omitempty"`
}

// A connection to a list of items.
type TagDefinitionConnection struct {
	// A list of edges.
	Edges []*TagDefinitionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTagDefinition mutation
type TagDefinitionCreatePayload struct {
	// Created tagDefinition
	TagDefinition *TagDefinition `json:"tagDefinition"`
}

// Return response for deleteTagDefinition mutation
type TagDefinitionDeletePayload struct {
	// Deleted tagDefinition ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TagDefinitionEdge struct {
	// The item at the end of the edge.
	Node *TagDefinition `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TagDefinition connections
type TagDefinitionOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TagDefinitions.
	Field TagDefinitionOrderField `json:"field"`
}

// Return response for updateTagDefinition mutation
type TagDefinitionUpdatePayload struct {
	// Updated tagDefinition
	TagDefinition *TagDefinition `json:"tagDefinition"`
}

// TagDefinitionWhereInput is used for filtering TagDefinition objects.
// Input was generated by ent.
type TagDefinitionWhereInput struct {
	Not *TagDefinitionWhereInput   `json:"not,omitempty"`
	And []*TagDefinitionWhereInput `json:"and,omitempty"`
	Or  []*TagDefinitionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// slug field predicates
	Slug             *string  `json:"slug,omitempty"`
	SlugNeq          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGt           *string  `json:"slugGT,omitempty"`
	SlugGte          *string  `json:"slugGTE,omitempty"`
	SlugLt           *string  `json:"slugLT,omitempty"`
	SlugLte          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        *bool    `json:"slugIsNil,omitempty"`
	SlugNotNil       *bool    `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// color field predicates
	Color             *string  `json:"color,omitempty"`
	ColorNeq          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGt           *string  `json:"colorGT,omitempty"`
	ColorGte          *string  `json:"colorGTE,omitempty"`
	ColorLt           *string  `json:"colorLT,omitempty"`
	ColorLte          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorIsNil        *bool    `json:"colorIsNil,omitempty"`
	ColorNotNil       *bool    `json:"colorNotNil,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type Task struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the kind of the task
	TaskKindName *string `json:"taskKindName,omitempty"`
	// the kind of the task
	TaskKindID *string `json:"taskKindID,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status enums.TaskStatus `json:"status"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *models.DateTime `json:"due,omitempty"`
	// the completion date of the task
	Completed *models.DateTime `json:"completed,omitempty"`
	// the id of the user who was assigned the task
	AssigneeID *string `json:"assigneeID,omitempty"`
	// the id of the user who assigned the task, can be left empty if created by the system or a service token
	AssignerID *string `json:"assignerID,omitempty"`
	// indicates if the task was generated by the system
	SystemGenerated bool `json:"systemGenerated"`
	// key to prevent duplicates for auto-generated task based on rules
	IdempotencyKey *string `json:"idempotencyKey,omitempty"`
	// an optional external reference URL for the task
	ExternalReferenceURL []string `json:"externalReferenceURL,omitempty"`
	// the parent task this task belongs to
	ParentTaskID           *string                          `json:"parentTaskID,omitempty"`
	Owner                  *Organization                    `json:"owner,omitempty"`
	TaskKind               *CustomTypeEnum                  `json:"taskKind,omitempty"`
	Assigner               *User                            `json:"assigner,omitempty"`
	Assignee               *User                            `json:"assignee,omitempty"`
	Comments               *NoteConnection                  `json:"comments"`
	Groups                 *GroupConnection                 `json:"groups"`
	InternalPolicies       *InternalPolicyConnection        `json:"internalPolicies"`
	Procedures             *ProcedureConnection             `json:"procedures"`
	Controls               *ControlConnection               `json:"controls"`
	Subcontrols            *SubcontrolConnection            `json:"subcontrols"`
	ControlObjectives      *ControlObjectiveConnection      `json:"controlObjectives"`
	Programs               *ProgramConnection               `json:"programs"`
	Risks                  *RiskConnection                  `json:"risks"`
	ControlImplementations *ControlImplementationConnection `json:"controlImplementations"`
	ActionPlans            *ActionPlanConnection            `json:"actionPlans"`
	Evidence               *EvidenceConnection              `json:"evidence"`
	WorkflowObjectRefs     *WorkflowObjectRefConnection     `json:"workflowObjectRefs"`
	Parent                 *Task                            `json:"parent,omitempty"`
	Tasks                  []*Task                          `json:"tasks,omitempty"`
}

func (Task) IsNode() {}

// Return response for createBulkTask mutation
type TaskBulkCreatePayload struct {
	// Created tasks
	Tasks []*Task `json:"tasks,omitempty"`
}

// Return response for deleteBulkTask mutation
type TaskBulkDeletePayload struct {
	// Deleted task IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkTask mutation
type TaskBulkUpdatePayload struct {
	// Updated tasks
	Tasks []*Task `json:"tasks,omitempty"`
	// IDs of the updated tasks
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type TaskConnection struct {
	// A list of edges.
	Edges []*TaskEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTask mutation
type TaskCreatePayload struct {
	// Created task
	Task *Task `json:"task"`
}

// Return response for deleteTask mutation
type TaskDeletePayload struct {
	// Deleted task ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TaskEdge struct {
	// The item at the end of the edge.
	Node *Task `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TaskHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the kind of the task
	TaskKindName *string `json:"taskKindName,omitempty"`
	// the kind of the task
	TaskKindID *string `json:"taskKindID,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status enums.TaskStatus `json:"status"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *models.DateTime `json:"due,omitempty"`
	// the completion date of the task
	Completed *models.DateTime `json:"completed,omitempty"`
	// the id of the user who was assigned the task
	AssigneeID *string `json:"assigneeID,omitempty"`
	// the id of the user who assigned the task, can be left empty if created by the system or a service token
	AssignerID *string `json:"assignerID,omitempty"`
	// indicates if the task was generated by the system
	SystemGenerated bool `json:"systemGenerated"`
	// key to prevent duplicates for auto-generated task based on rules
	IdempotencyKey *string `json:"idempotencyKey,omitempty"`
	// an optional external reference URL for the task
	ExternalReferenceURL []string `json:"externalReferenceURL,omitempty"`
	// the parent task this task belongs to
	ParentTaskID *string `json:"parentTaskID,omitempty"`
}

func (TaskHistory) IsNode() {}

// A connection to a list of items.
type TaskHistoryConnection struct {
	// A list of edges.
	Edges []*TaskHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TaskHistoryEdge struct {
	// The item at the end of the edge.
	Node *TaskHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TaskHistory connections
type TaskHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TaskHistories.
	Field TaskHistoryOrderField `json:"field"`
}

// TaskHistoryWhereInput is used for filtering TaskHistory objects.
// Input was generated by ent.
type TaskHistoryWhereInput struct {
	Not *TaskHistoryWhereInput   `json:"not,omitempty"`
	And []*TaskHistoryWhereInput `json:"and,omitempty"`
	Or  []*TaskHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// task_kind_name field predicates
	TaskKindName             *string  `json:"taskKindName,omitempty"`
	TaskKindNameNeq          *string  `json:"taskKindNameNEQ,omitempty"`
	TaskKindNameIn           []string `json:"taskKindNameIn,omitempty"`
	TaskKindNameNotIn        []string `json:"taskKindNameNotIn,omitempty"`
	TaskKindNameGt           *string  `json:"taskKindNameGT,omitempty"`
	TaskKindNameGte          *string  `json:"taskKindNameGTE,omitempty"`
	TaskKindNameLt           *string  `json:"taskKindNameLT,omitempty"`
	TaskKindNameLte          *string  `json:"taskKindNameLTE,omitempty"`
	TaskKindNameContains     *string  `json:"taskKindNameContains,omitempty"`
	TaskKindNameHasPrefix    *string  `json:"taskKindNameHasPrefix,omitempty"`
	TaskKindNameHasSuffix    *string  `json:"taskKindNameHasSuffix,omitempty"`
	TaskKindNameIsNil        *bool    `json:"taskKindNameIsNil,omitempty"`
	TaskKindNameNotNil       *bool    `json:"taskKindNameNotNil,omitempty"`
	TaskKindNameEqualFold    *string  `json:"taskKindNameEqualFold,omitempty"`
	TaskKindNameContainsFold *string  `json:"taskKindNameContainsFold,omitempty"`
	// task_kind_id field predicates
	TaskKindID             *string  `json:"taskKindID,omitempty"`
	TaskKindIdneq          *string  `json:"taskKindIDNEQ,omitempty"`
	TaskKindIDIn           []string `json:"taskKindIDIn,omitempty"`
	TaskKindIDNotIn        []string `json:"taskKindIDNotIn,omitempty"`
	TaskKindIdgt           *string  `json:"taskKindIDGT,omitempty"`
	TaskKindIdgte          *string  `json:"taskKindIDGTE,omitempty"`
	TaskKindIdlt           *string  `json:"taskKindIDLT,omitempty"`
	TaskKindIdlte          *string  `json:"taskKindIDLTE,omitempty"`
	TaskKindIDContains     *string  `json:"taskKindIDContains,omitempty"`
	TaskKindIDHasPrefix    *string  `json:"taskKindIDHasPrefix,omitempty"`
	TaskKindIDHasSuffix    *string  `json:"taskKindIDHasSuffix,omitempty"`
	TaskKindIDIsNil        *bool    `json:"taskKindIDIsNil,omitempty"`
	TaskKindIDNotNil       *bool    `json:"taskKindIDNotNil,omitempty"`
	TaskKindIDEqualFold    *string  `json:"taskKindIDEqualFold,omitempty"`
	TaskKindIDContainsFold *string  `json:"taskKindIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// status field predicates
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNeq   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// due field predicates
	Due       *models.DateTime   `json:"due,omitempty"`
	DueNeq    *models.DateTime   `json:"dueNEQ,omitempty"`
	DueIn     []*models.DateTime `json:"dueIn,omitempty"`
	DueNotIn  []*models.DateTime `json:"dueNotIn,omitempty"`
	DueGt     *models.DateTime   `json:"dueGT,omitempty"`
	DueGte    *models.DateTime   `json:"dueGTE,omitempty"`
	DueLt     *models.DateTime   `json:"dueLT,omitempty"`
	DueLte    *models.DateTime   `json:"dueLTE,omitempty"`
	DueIsNil  *bool              `json:"dueIsNil,omitempty"`
	DueNotNil *bool              `json:"dueNotNil,omitempty"`
	// completed field predicates
	Completed       *models.DateTime   `json:"completed,omitempty"`
	CompletedNeq    *models.DateTime   `json:"completedNEQ,omitempty"`
	CompletedIn     []*models.DateTime `json:"completedIn,omitempty"`
	CompletedNotIn  []*models.DateTime `json:"completedNotIn,omitempty"`
	CompletedGt     *models.DateTime   `json:"completedGT,omitempty"`
	CompletedGte    *models.DateTime   `json:"completedGTE,omitempty"`
	CompletedLt     *models.DateTime   `json:"completedLT,omitempty"`
	CompletedLte    *models.DateTime   `json:"completedLTE,omitempty"`
	CompletedIsNil  *bool              `json:"completedIsNil,omitempty"`
	CompletedNotNil *bool              `json:"completedNotNil,omitempty"`
	// assignee_id field predicates
	AssigneeID             *string  `json:"assigneeID,omitempty"`
	AssigneeIdneq          *string  `json:"assigneeIDNEQ,omitempty"`
	AssigneeIDIn           []string `json:"assigneeIDIn,omitempty"`
	AssigneeIDNotIn        []string `json:"assigneeIDNotIn,omitempty"`
	AssigneeIdgt           *string  `json:"assigneeIDGT,omitempty"`
	AssigneeIdgte          *string  `json:"assigneeIDGTE,omitempty"`
	AssigneeIdlt           *string  `json:"assigneeIDLT,omitempty"`
	AssigneeIdlte          *string  `json:"assigneeIDLTE,omitempty"`
	AssigneeIDContains     *string  `json:"assigneeIDContains,omitempty"`
	AssigneeIDHasPrefix    *string  `json:"assigneeIDHasPrefix,omitempty"`
	AssigneeIDHasSuffix    *string  `json:"assigneeIDHasSuffix,omitempty"`
	AssigneeIDIsNil        *bool    `json:"assigneeIDIsNil,omitempty"`
	AssigneeIDNotNil       *bool    `json:"assigneeIDNotNil,omitempty"`
	AssigneeIDEqualFold    *string  `json:"assigneeIDEqualFold,omitempty"`
	AssigneeIDContainsFold *string  `json:"assigneeIDContainsFold,omitempty"`
	// assigner_id field predicates
	AssignerID             *string  `json:"assignerID,omitempty"`
	AssignerIdneq          *string  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn           []string `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn        []string `json:"assignerIDNotIn,omitempty"`
	AssignerIdgt           *string  `json:"assignerIDGT,omitempty"`
	AssignerIdgte          *string  `json:"assignerIDGTE,omitempty"`
	AssignerIdlt           *string  `json:"assignerIDLT,omitempty"`
	AssignerIdlte          *string  `json:"assignerIDLTE,omitempty"`
	AssignerIDContains     *string  `json:"assignerIDContains,omitempty"`
	AssignerIDHasPrefix    *string  `json:"assignerIDHasPrefix,omitempty"`
	AssignerIDHasSuffix    *string  `json:"assignerIDHasSuffix,omitempty"`
	AssignerIDIsNil        *bool    `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil       *bool    `json:"assignerIDNotNil,omitempty"`
	AssignerIDEqualFold    *string  `json:"assignerIDEqualFold,omitempty"`
	AssignerIDContainsFold *string  `json:"assignerIDContainsFold,omitempty"`
	// system_generated field predicates
	SystemGenerated    *bool `json:"systemGenerated,omitempty"`
	SystemGeneratedNeq *bool `json:"systemGeneratedNEQ,omitempty"`
	// idempotency_key field predicates
	IdempotencyKey             *string  `json:"idempotencyKey,omitempty"`
	IdempotencyKeyNeq          *string  `json:"idempotencyKeyNEQ,omitempty"`
	IdempotencyKeyIn           []string `json:"idempotencyKeyIn,omitempty"`
	IdempotencyKeyNotIn        []string `json:"idempotencyKeyNotIn,omitempty"`
	IdempotencyKeyGt           *string  `json:"idempotencyKeyGT,omitempty"`
	IdempotencyKeyGte          *string  `json:"idempotencyKeyGTE,omitempty"`
	IdempotencyKeyLt           *string  `json:"idempotencyKeyLT,omitempty"`
	IdempotencyKeyLte          *string  `json:"idempotencyKeyLTE,omitempty"`
	IdempotencyKeyContains     *string  `json:"idempotencyKeyContains,omitempty"`
	IdempotencyKeyHasPrefix    *string  `json:"idempotencyKeyHasPrefix,omitempty"`
	IdempotencyKeyHasSuffix    *string  `json:"idempotencyKeyHasSuffix,omitempty"`
	IdempotencyKeyIsNil        *bool    `json:"idempotencyKeyIsNil,omitempty"`
	IdempotencyKeyNotNil       *bool    `json:"idempotencyKeyNotNil,omitempty"`
	IdempotencyKeyEqualFold    *string  `json:"idempotencyKeyEqualFold,omitempty"`
	IdempotencyKeyContainsFold *string  `json:"idempotencyKeyContainsFold,omitempty"`
	// parent_task_id field predicates
	ParentTaskID             *string  `json:"parentTaskID,omitempty"`
	ParentTaskIdneq          *string  `json:"parentTaskIDNEQ,omitempty"`
	ParentTaskIDIn           []string `json:"parentTaskIDIn,omitempty"`
	ParentTaskIDNotIn        []string `json:"parentTaskIDNotIn,omitempty"`
	ParentTaskIdgt           *string  `json:"parentTaskIDGT,omitempty"`
	ParentTaskIdgte          *string  `json:"parentTaskIDGTE,omitempty"`
	ParentTaskIdlt           *string  `json:"parentTaskIDLT,omitempty"`
	ParentTaskIdlte          *string  `json:"parentTaskIDLTE,omitempty"`
	ParentTaskIDContains     *string  `json:"parentTaskIDContains,omitempty"`
	ParentTaskIDHasPrefix    *string  `json:"parentTaskIDHasPrefix,omitempty"`
	ParentTaskIDHasSuffix    *string  `json:"parentTaskIDHasSuffix,omitempty"`
	ParentTaskIDIsNil        *bool    `json:"parentTaskIDIsNil,omitempty"`
	ParentTaskIDNotNil       *bool    `json:"parentTaskIDNotNil,omitempty"`
	ParentTaskIDEqualFold    *string  `json:"parentTaskIDEqualFold,omitempty"`
	ParentTaskIDContainsFold *string  `json:"parentTaskIDContainsFold,omitempty"`
}

// Ordering options for Task connections
type TaskOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Tasks.
	Field TaskOrderField `json:"field"`
}

// Return response for updateTask mutation
type TaskUpdatePayload struct {
	// Updated task
	Task *Task `json:"task"`
}

// TaskWhereInput is used for filtering Task objects.
// Input was generated by ent.
type TaskWhereInput struct {
	Not *TaskWhereInput   `json:"not,omitempty"`
	And []*TaskWhereInput `json:"and,omitempty"`
	Or  []*TaskWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// task_kind_name field predicates
	TaskKindName             *string  `json:"taskKindName,omitempty"`
	TaskKindNameNeq          *string  `json:"taskKindNameNEQ,omitempty"`
	TaskKindNameIn           []string `json:"taskKindNameIn,omitempty"`
	TaskKindNameNotIn        []string `json:"taskKindNameNotIn,omitempty"`
	TaskKindNameGt           *string  `json:"taskKindNameGT,omitempty"`
	TaskKindNameGte          *string  `json:"taskKindNameGTE,omitempty"`
	TaskKindNameLt           *string  `json:"taskKindNameLT,omitempty"`
	TaskKindNameLte          *string  `json:"taskKindNameLTE,omitempty"`
	TaskKindNameContains     *string  `json:"taskKindNameContains,omitempty"`
	TaskKindNameHasPrefix    *string  `json:"taskKindNameHasPrefix,omitempty"`
	TaskKindNameHasSuffix    *string  `json:"taskKindNameHasSuffix,omitempty"`
	TaskKindNameIsNil        *bool    `json:"taskKindNameIsNil,omitempty"`
	TaskKindNameNotNil       *bool    `json:"taskKindNameNotNil,omitempty"`
	TaskKindNameEqualFold    *string  `json:"taskKindNameEqualFold,omitempty"`
	TaskKindNameContainsFold *string  `json:"taskKindNameContainsFold,omitempty"`
	// task_kind_id field predicates
	TaskKindID             *string  `json:"taskKindID,omitempty"`
	TaskKindIdneq          *string  `json:"taskKindIDNEQ,omitempty"`
	TaskKindIDIn           []string `json:"taskKindIDIn,omitempty"`
	TaskKindIDNotIn        []string `json:"taskKindIDNotIn,omitempty"`
	TaskKindIdgt           *string  `json:"taskKindIDGT,omitempty"`
	TaskKindIdgte          *string  `json:"taskKindIDGTE,omitempty"`
	TaskKindIdlt           *string  `json:"taskKindIDLT,omitempty"`
	TaskKindIdlte          *string  `json:"taskKindIDLTE,omitempty"`
	TaskKindIDContains     *string  `json:"taskKindIDContains,omitempty"`
	TaskKindIDHasPrefix    *string  `json:"taskKindIDHasPrefix,omitempty"`
	TaskKindIDHasSuffix    *string  `json:"taskKindIDHasSuffix,omitempty"`
	TaskKindIDIsNil        *bool    `json:"taskKindIDIsNil,omitempty"`
	TaskKindIDNotNil       *bool    `json:"taskKindIDNotNil,omitempty"`
	TaskKindIDEqualFold    *string  `json:"taskKindIDEqualFold,omitempty"`
	TaskKindIDContainsFold *string  `json:"taskKindIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// status field predicates
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNeq   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// due field predicates
	Due       *models.DateTime   `json:"due,omitempty"`
	DueNeq    *models.DateTime   `json:"dueNEQ,omitempty"`
	DueIn     []*models.DateTime `json:"dueIn,omitempty"`
	DueNotIn  []*models.DateTime `json:"dueNotIn,omitempty"`
	DueGt     *models.DateTime   `json:"dueGT,omitempty"`
	DueGte    *models.DateTime   `json:"dueGTE,omitempty"`
	DueLt     *models.DateTime   `json:"dueLT,omitempty"`
	DueLte    *models.DateTime   `json:"dueLTE,omitempty"`
	DueIsNil  *bool              `json:"dueIsNil,omitempty"`
	DueNotNil *bool              `json:"dueNotNil,omitempty"`
	// completed field predicates
	Completed       *models.DateTime   `json:"completed,omitempty"`
	CompletedNeq    *models.DateTime   `json:"completedNEQ,omitempty"`
	CompletedIn     []*models.DateTime `json:"completedIn,omitempty"`
	CompletedNotIn  []*models.DateTime `json:"completedNotIn,omitempty"`
	CompletedGt     *models.DateTime   `json:"completedGT,omitempty"`
	CompletedGte    *models.DateTime   `json:"completedGTE,omitempty"`
	CompletedLt     *models.DateTime   `json:"completedLT,omitempty"`
	CompletedLte    *models.DateTime   `json:"completedLTE,omitempty"`
	CompletedIsNil  *bool              `json:"completedIsNil,omitempty"`
	CompletedNotNil *bool              `json:"completedNotNil,omitempty"`
	// assignee_id field predicates
	AssigneeID             *string  `json:"assigneeID,omitempty"`
	AssigneeIdneq          *string  `json:"assigneeIDNEQ,omitempty"`
	AssigneeIDIn           []string `json:"assigneeIDIn,omitempty"`
	AssigneeIDNotIn        []string `json:"assigneeIDNotIn,omitempty"`
	AssigneeIdgt           *string  `json:"assigneeIDGT,omitempty"`
	AssigneeIdgte          *string  `json:"assigneeIDGTE,omitempty"`
	AssigneeIdlt           *string  `json:"assigneeIDLT,omitempty"`
	AssigneeIdlte          *string  `json:"assigneeIDLTE,omitempty"`
	AssigneeIDContains     *string  `json:"assigneeIDContains,omitempty"`
	AssigneeIDHasPrefix    *string  `json:"assigneeIDHasPrefix,omitempty"`
	AssigneeIDHasSuffix    *string  `json:"assigneeIDHasSuffix,omitempty"`
	AssigneeIDIsNil        *bool    `json:"assigneeIDIsNil,omitempty"`
	AssigneeIDNotNil       *bool    `json:"assigneeIDNotNil,omitempty"`
	AssigneeIDEqualFold    *string  `json:"assigneeIDEqualFold,omitempty"`
	AssigneeIDContainsFold *string  `json:"assigneeIDContainsFold,omitempty"`
	// assigner_id field predicates
	AssignerID             *string  `json:"assignerID,omitempty"`
	AssignerIdneq          *string  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn           []string `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn        []string `json:"assignerIDNotIn,omitempty"`
	AssignerIdgt           *string  `json:"assignerIDGT,omitempty"`
	AssignerIdgte          *string  `json:"assignerIDGTE,omitempty"`
	AssignerIdlt           *string  `json:"assignerIDLT,omitempty"`
	AssignerIdlte          *string  `json:"assignerIDLTE,omitempty"`
	AssignerIDContains     *string  `json:"assignerIDContains,omitempty"`
	AssignerIDHasPrefix    *string  `json:"assignerIDHasPrefix,omitempty"`
	AssignerIDHasSuffix    *string  `json:"assignerIDHasSuffix,omitempty"`
	AssignerIDIsNil        *bool    `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil       *bool    `json:"assignerIDNotNil,omitempty"`
	AssignerIDEqualFold    *string  `json:"assignerIDEqualFold,omitempty"`
	AssignerIDContainsFold *string  `json:"assignerIDContainsFold,omitempty"`
	// system_generated field predicates
	SystemGenerated    *bool `json:"systemGenerated,omitempty"`
	SystemGeneratedNeq *bool `json:"systemGeneratedNEQ,omitempty"`
	// idempotency_key field predicates
	IdempotencyKey             *string  `json:"idempotencyKey,omitempty"`
	IdempotencyKeyNeq          *string  `json:"idempotencyKeyNEQ,omitempty"`
	IdempotencyKeyIn           []string `json:"idempotencyKeyIn,omitempty"`
	IdempotencyKeyNotIn        []string `json:"idempotencyKeyNotIn,omitempty"`
	IdempotencyKeyGt           *string  `json:"idempotencyKeyGT,omitempty"`
	IdempotencyKeyGte          *string  `json:"idempotencyKeyGTE,omitempty"`
	IdempotencyKeyLt           *string  `json:"idempotencyKeyLT,omitempty"`
	IdempotencyKeyLte          *string  `json:"idempotencyKeyLTE,omitempty"`
	IdempotencyKeyContains     *string  `json:"idempotencyKeyContains,omitempty"`
	IdempotencyKeyHasPrefix    *string  `json:"idempotencyKeyHasPrefix,omitempty"`
	IdempotencyKeyHasSuffix    *string  `json:"idempotencyKeyHasSuffix,omitempty"`
	IdempotencyKeyIsNil        *bool    `json:"idempotencyKeyIsNil,omitempty"`
	IdempotencyKeyNotNil       *bool    `json:"idempotencyKeyNotNil,omitempty"`
	IdempotencyKeyEqualFold    *string  `json:"idempotencyKeyEqualFold,omitempty"`
	IdempotencyKeyContainsFold *string  `json:"idempotencyKeyContainsFold,omitempty"`
	// parent_task_id field predicates
	ParentTaskID             *string  `json:"parentTaskID,omitempty"`
	ParentTaskIdneq          *string  `json:"parentTaskIDNEQ,omitempty"`
	ParentTaskIDIn           []string `json:"parentTaskIDIn,omitempty"`
	ParentTaskIDNotIn        []string `json:"parentTaskIDNotIn,omitempty"`
	ParentTaskIdgt           *string  `json:"parentTaskIDGT,omitempty"`
	ParentTaskIdgte          *string  `json:"parentTaskIDGTE,omitempty"`
	ParentTaskIdlt           *string  `json:"parentTaskIDLT,omitempty"`
	ParentTaskIdlte          *string  `json:"parentTaskIDLTE,omitempty"`
	ParentTaskIDContains     *string  `json:"parentTaskIDContains,omitempty"`
	ParentTaskIDHasPrefix    *string  `json:"parentTaskIDHasPrefix,omitempty"`
	ParentTaskIDHasSuffix    *string  `json:"parentTaskIDHasSuffix,omitempty"`
	ParentTaskIDIsNil        *bool    `json:"parentTaskIDIsNil,omitempty"`
	ParentTaskIDNotNil       *bool    `json:"parentTaskIDNotNil,omitempty"`
	ParentTaskIDEqualFold    *string  `json:"parentTaskIDEqualFold,omitempty"`
	ParentTaskIDContainsFold *string  `json:"parentTaskIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// task_kind edge predicates
	HasTaskKind     *bool                       `json:"hasTaskKind,omitempty"`
	HasTaskKindWith []*CustomTypeEnumWhereInput `json:"hasTaskKindWith,omitempty"`
	// assigner edge predicates
	HasAssigner     *bool             `json:"hasAssigner,omitempty"`
	HasAssignerWith []*UserWhereInput `json:"hasAssignerWith,omitempty"`
	// assignee edge predicates
	HasAssignee     *bool             `json:"hasAssignee,omitempty"`
	HasAssigneeWith []*UserWhereInput `json:"hasAssigneeWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// control_implementations edge predicates
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// workflow_object_refs edge predicates
	HasWorkflowObjectRefs     *bool                          `json:"hasWorkflowObjectRefs,omitempty"`
	HasWorkflowObjectRefsWith []*WorkflowObjectRefWhereInput `json:"hasWorkflowObjectRefsWith,omitempty"`
	// parent edge predicates
	HasParent     *bool             `json:"hasParent,omitempty"`
	HasParentWith []*TaskWhereInput `json:"hasParentWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

type Template struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the kind of template, e.g. questionnaire
	Kind *enums.TemplateKind `json:"kind,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema map[string]any `json:"uischema,omitempty"`
	// the id of the trust center this template is associated with
	TrustCenterID *string                 `json:"trustCenterID,omitempty"`
	Owner         *Organization           `json:"owner,omitempty"`
	Documents     *DocumentDataConnection `json:"documents"`
	Files         *FileConnection         `json:"files"`
	TrustCenter   *TrustCenter            `json:"trustCenter,omitempty"`
	Assessments   *AssessmentConnection   `json:"assessments"`
}

func (Template) IsNode() {}

// Return response for createBulkTemplate mutation
type TemplateBulkCreatePayload struct {
	// Created templates
	Templates []*Template `json:"templates,omitempty"`
}

// Return response for deleteBulkTemplate mutation
type TemplateBulkDeletePayload struct {
	// Deleted template IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type TemplateConnection struct {
	// A list of edges.
	Edges []*TemplateEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTemplate mutation
type TemplateCreatePayload struct {
	// Created template
	Template *Template `json:"template"`
}

// Return response for deleteTemplate mutation
type TemplateDeletePayload struct {
	// Deleted template ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TemplateEdge struct {
	// The item at the end of the edge.
	Node *Template `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TemplateHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the kind of template, e.g. questionnaire
	Kind *enums.TemplateKind `json:"kind,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema map[string]any `json:"uischema,omitempty"`
	// the id of the trust center this template is associated with
	TrustCenterID *string `json:"trustCenterID,omitempty"`
}

func (TemplateHistory) IsNode() {}

// A connection to a list of items.
type TemplateHistoryConnection struct {
	// A list of edges.
	Edges []*TemplateHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TemplateHistoryEdge struct {
	// The item at the end of the edge.
	Node *TemplateHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TemplateHistory connections
type TemplateHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TemplateHistories.
	Field TemplateHistoryOrderField `json:"field"`
}

// TemplateHistoryWhereInput is used for filtering TemplateHistory objects.
// Input was generated by ent.
type TemplateHistoryWhereInput struct {
	Not *TemplateHistoryWhereInput   `json:"not,omitempty"`
	And []*TemplateHistoryWhereInput `json:"and,omitempty"`
	Or  []*TemplateHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// kind field predicates
	Kind       *enums.TemplateKind  `json:"kind,omitempty"`
	KindNeq    *enums.TemplateKind  `json:"kindNEQ,omitempty"`
	KindIn     []enums.TemplateKind `json:"kindIn,omitempty"`
	KindNotIn  []enums.TemplateKind `json:"kindNotIn,omitempty"`
	KindIsNil  *bool                `json:"kindIsNil,omitempty"`
	KindNotNil *bool                `json:"kindNotNil,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
}

// Ordering options for Template connections
type TemplateOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Templates.
	Field TemplateOrderField `json:"field"`
}

// Return response for updateTemplate mutation
type TemplateUpdatePayload struct {
	// Updated template
	Template *Template `json:"template"`
}

// TemplateWhereInput is used for filtering Template objects.
// Input was generated by ent.
type TemplateWhereInput struct {
	Not *TemplateWhereInput   `json:"not,omitempty"`
	And []*TemplateWhereInput `json:"and,omitempty"`
	Or  []*TemplateWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// kind field predicates
	Kind       *enums.TemplateKind  `json:"kind,omitempty"`
	KindNeq    *enums.TemplateKind  `json:"kindNEQ,omitempty"`
	KindIn     []enums.TemplateKind `json:"kindIn,omitempty"`
	KindNotIn  []enums.TemplateKind `json:"kindNotIn,omitempty"`
	KindIsNil  *bool                `json:"kindIsNil,omitempty"`
	KindNotNil *bool                `json:"kindNotNil,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// trust_center edge predicates
	HasTrustCenter     *bool                    `json:"hasTrustCenter,omitempty"`
	HasTrustCenterWith []*TrustCenterWhereInput `json:"hasTrustCenterWith,omitempty"`
	// assessments edge predicates
	HasAssessments     *bool                   `json:"hasAssessments,omitempty"`
	HasAssessmentsWith []*AssessmentWhereInput `json:"hasAssessmentsWith,omitempty"`
}

type TrustCenter struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// Slug for the trust center
	Slug *string `json:"slug,omitempty"`
	// custom domain id for the trust center
	CustomDomainID *string `json:"customDomainID,omitempty"`
	// preview domain id for the trust center
	PreviewDomainID *string `json:"previewDomainID,omitempty"`
	// Pirsch domain ID
	PirschDomainID *string `json:"pirschDomainID,omitempty"`
	// Pirsch ID code
	PirschIdentificationCode *string `json:"pirschIdentificationCode,omitempty"`
	// preview status of the trust center
	PreviewStatus            *enums.TrustCenterPreviewStatus    `json:"previewStatus,omitempty"`
	Owner                    *Organization                      `json:"owner,omitempty"`
	CustomDomain             *CustomDomain                      `json:"customDomain,omitempty"`
	PreviewDomain            *CustomDomain                      `json:"previewDomain,omitempty"`
	Setting                  *TrustCenterSetting                `json:"setting,omitempty"`
	PreviewSetting           *TrustCenterSetting                `json:"previewSetting,omitempty"`
	WatermarkConfig          *TrustCenterWatermarkConfig        `json:"watermarkConfig,omitempty"`
	TrustCenterSubprocessors *TrustCenterSubprocessorConnection `json:"trustCenterSubprocessors"`
	TrustCenterDocs          *TrustCenterDocConnection          `json:"trustCenterDocs"`
	TrustCenterCompliances   *TrustCenterComplianceConnection   `json:"trustCenterCompliances"`
	Templates                *TemplateConnection                `json:"templates"`
	Posts                    *NoteConnection                    `json:"posts"`
	TrustcenterEntities      *TrustcenterEntityConnection       `json:"trustcenterEntities"`
}

func (TrustCenter) IsNode() {}

type TrustCenterCompliance struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// ID of the standard
	StandardID string `json:"standardID"`
	// ID of the trust center
	TrustCenterID *string      `json:"trustCenterID,omitempty"`
	TrustCenter   *TrustCenter `json:"trustCenter,omitempty"`
	Standard      *Standard    `json:"standard"`
}

func (TrustCenterCompliance) IsNode() {}

// Return response for createBulkTrustCenterCompliance mutation
type TrustCenterComplianceBulkCreatePayload struct {
	// Created trustCenterCompliances
	TrustCenterCompliances []*TrustCenterCompliance `json:"trustCenterCompliances,omitempty"`
}

// Return response for deleteBulkTrustCenterCompliance mutation
type TrustCenterComplianceBulkDeletePayload struct {
	// Deleted trustCenterCompliance IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type TrustCenterComplianceConnection struct {
	// A list of edges.
	Edges []*TrustCenterComplianceEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTrustCenterCompliance mutation
type TrustCenterComplianceCreatePayload struct {
	// Created trustCenterCompliance
	TrustCenterCompliance *TrustCenterCompliance `json:"trustCenterCompliance"`
}

// Return response for deleteTrustCenterCompliance mutation
type TrustCenterComplianceDeletePayload struct {
	// Deleted trustCenterCompliance ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TrustCenterComplianceEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterCompliance `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TrustCenterComplianceHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// ID of the standard
	StandardID string `json:"standardID"`
	// ID of the trust center
	TrustCenterID *string `json:"trustCenterID,omitempty"`
}

func (TrustCenterComplianceHistory) IsNode() {}

// A connection to a list of items.
type TrustCenterComplianceHistoryConnection struct {
	// A list of edges.
	Edges []*TrustCenterComplianceHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TrustCenterComplianceHistoryEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterComplianceHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TrustCenterComplianceHistory connections
type TrustCenterComplianceHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterComplianceHistories.
	Field TrustCenterComplianceHistoryOrderField `json:"field"`
}

// TrustCenterComplianceHistoryWhereInput is used for filtering TrustCenterComplianceHistory objects.
// Input was generated by ent.
type TrustCenterComplianceHistoryWhereInput struct {
	Not *TrustCenterComplianceHistoryWhereInput   `json:"not,omitempty"`
	And []*TrustCenterComplianceHistoryWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterComplianceHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
}

// Ordering options for TrustCenterCompliance connections
type TrustCenterComplianceOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterCompliances.
	Field TrustCenterComplianceOrderField `json:"field"`
}

// Return response for updateTrustCenterCompliance mutation
type TrustCenterComplianceUpdatePayload struct {
	// Updated trustCenterCompliance
	TrustCenterCompliance *TrustCenterCompliance `json:"trustCenterCompliance"`
}

// TrustCenterComplianceWhereInput is used for filtering TrustCenterCompliance objects.
// Input was generated by ent.
type TrustCenterComplianceWhereInput struct {
	Not *TrustCenterComplianceWhereInput   `json:"not,omitempty"`
	And []*TrustCenterComplianceWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterComplianceWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// trust_center edge predicates
	HasTrustCenter     *bool                    `json:"hasTrustCenter,omitempty"`
	HasTrustCenterWith []*TrustCenterWhereInput `json:"hasTrustCenterWith,omitempty"`
	// standard edge predicates
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`
}

// A connection to a list of items.
type TrustCenterConnection struct {
	// A list of edges.
	Edges []*TrustCenterEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTrustCenter mutation
type TrustCenterCreatePayload struct {
	// Created trustCenter
	TrustCenter *TrustCenter `json:"trustCenter"`
}

// Return response for deleteTrustCenter mutation
type TrustCenterDeletePayload struct {
	// Deleted trustCenter ID
	DeletedID string `json:"deletedID"`
}

type TrustCenterDoc struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// ID of the trust center
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// title of the document
	Title string `json:"title"`
	// category of the document
	Category string `json:"category"`
	// ID of the file containing the document
	FileID *string `json:"fileID,omitempty"`
	// ID of the file containing the document, before any watermarking
	OriginalFileID *string `json:"originalFileID,omitempty"`
	// whether watermarking is enabled for the document. this will only take effect if watermarking is configured for the trust center
	WatermarkingEnabled bool `json:"watermarkingEnabled"`
	// status of the watermarking
	WatermarkStatus *enums.WatermarkStatus `json:"watermarkStatus,omitempty"`
	// visibility of the document
	Visibility *enums.TrustCenterDocumentVisibility `json:"visibility,omitempty"`
	// ID of the standard
	StandardID  *string      `json:"standardID,omitempty"`
	TrustCenter *TrustCenter `json:"trustCenter,omitempty"`
	Standard    *Standard    `json:"standard,omitempty"`
	// the file containing the document content
	File *File `json:"file,omitempty"`
	// the file containing the document content, pre watermarking
	OriginalFile *File `json:"originalFile,omitempty"`
}

func (TrustCenterDoc) IsNode() {}

// Return response for createBulkTrustCenterDoc mutation
type TrustCenterDocBulkCreatePayload struct {
	// Created trustCenterDocs
	TrustCenterDocs []*TrustCenterDoc `json:"trustCenterDocs,omitempty"`
}

// Return response for deleteBulkTrustCenterDoc mutation
type TrustCenterDocBulkDeletePayload struct {
	// Deleted trustCenterDoc IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkTrustCenterDoc mutation
type TrustCenterDocBulkUpdatePayload struct {
	// Updated trust center docs
	TrustCenterDocs []*TrustCenterDoc `json:"trustCenterDocs,omitempty"`
	// IDs of the updated trust center docs
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type TrustCenterDocConnection struct {
	// A list of edges.
	Edges []*TrustCenterDocEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTrustCenterDoc mutation
type TrustCenterDocCreatePayload struct {
	// Created trustCenterDoc
	TrustCenterDoc *TrustCenterDoc `json:"trustCenterDoc"`
}

// Return response for deleteTrustCenterDoc mutation
type TrustCenterDocDeletePayload struct {
	// Deleted trustCenterDoc ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TrustCenterDocEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterDoc `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TrustCenterDocHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// ID of the trust center
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// title of the document
	Title string `json:"title"`
	// category of the document
	Category string `json:"category"`
	// ID of the file containing the document
	FileID *string `json:"fileID,omitempty"`
	// ID of the file containing the document, before any watermarking
	OriginalFileID *string `json:"originalFileID,omitempty"`
	// whether watermarking is enabled for the document. this will only take effect if watermarking is configured for the trust center
	WatermarkingEnabled bool `json:"watermarkingEnabled"`
	// status of the watermarking
	WatermarkStatus *enums.WatermarkStatus `json:"watermarkStatus,omitempty"`
	// visibility of the document
	Visibility *enums.TrustCenterDocumentVisibility `json:"visibility,omitempty"`
	// ID of the standard
	StandardID *string `json:"standardID,omitempty"`
}

func (TrustCenterDocHistory) IsNode() {}

// A connection to a list of items.
type TrustCenterDocHistoryConnection struct {
	// A list of edges.
	Edges []*TrustCenterDocHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TrustCenterDocHistoryEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterDocHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TrustCenterDocHistory connections
type TrustCenterDocHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterDocHistories.
	Field TrustCenterDocHistoryOrderField `json:"field"`
}

// TrustCenterDocHistoryWhereInput is used for filtering TrustCenterDocHistory objects.
// Input was generated by ent.
type TrustCenterDocHistoryWhereInput struct {
	Not *TrustCenterDocHistoryWhereInput   `json:"not,omitempty"`
	And []*TrustCenterDocHistoryWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterDocHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDIsNil        *bool    `json:"fileIDIsNil,omitempty"`
	FileIDNotNil       *bool    `json:"fileIDNotNil,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// original_file_id field predicates
	OriginalFileID             *string  `json:"originalFileID,omitempty"`
	OriginalFileIdneq          *string  `json:"originalFileIDNEQ,omitempty"`
	OriginalFileIDIn           []string `json:"originalFileIDIn,omitempty"`
	OriginalFileIDNotIn        []string `json:"originalFileIDNotIn,omitempty"`
	OriginalFileIdgt           *string  `json:"originalFileIDGT,omitempty"`
	OriginalFileIdgte          *string  `json:"originalFileIDGTE,omitempty"`
	OriginalFileIdlt           *string  `json:"originalFileIDLT,omitempty"`
	OriginalFileIdlte          *string  `json:"originalFileIDLTE,omitempty"`
	OriginalFileIDContains     *string  `json:"originalFileIDContains,omitempty"`
	OriginalFileIDHasPrefix    *string  `json:"originalFileIDHasPrefix,omitempty"`
	OriginalFileIDHasSuffix    *string  `json:"originalFileIDHasSuffix,omitempty"`
	OriginalFileIDIsNil        *bool    `json:"originalFileIDIsNil,omitempty"`
	OriginalFileIDNotNil       *bool    `json:"originalFileIDNotNil,omitempty"`
	OriginalFileIDEqualFold    *string  `json:"originalFileIDEqualFold,omitempty"`
	OriginalFileIDContainsFold *string  `json:"originalFileIDContainsFold,omitempty"`
	// watermarking_enabled field predicates
	WatermarkingEnabled    *bool `json:"watermarkingEnabled,omitempty"`
	WatermarkingEnabledNeq *bool `json:"watermarkingEnabledNEQ,omitempty"`
	// watermark_status field predicates
	WatermarkStatus       *enums.WatermarkStatus  `json:"watermarkStatus,omitempty"`
	WatermarkStatusNeq    *enums.WatermarkStatus  `json:"watermarkStatusNEQ,omitempty"`
	WatermarkStatusIn     []enums.WatermarkStatus `json:"watermarkStatusIn,omitempty"`
	WatermarkStatusNotIn  []enums.WatermarkStatus `json:"watermarkStatusNotIn,omitempty"`
	WatermarkStatusIsNil  *bool                   `json:"watermarkStatusIsNil,omitempty"`
	WatermarkStatusNotNil *bool                   `json:"watermarkStatusNotNil,omitempty"`
	// visibility field predicates
	Visibility       *enums.TrustCenterDocumentVisibility  `json:"visibility,omitempty"`
	VisibilityNeq    *enums.TrustCenterDocumentVisibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn     []enums.TrustCenterDocumentVisibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn  []enums.TrustCenterDocumentVisibility `json:"visibilityNotIn,omitempty"`
	VisibilityIsNil  *bool                                 `json:"visibilityIsNil,omitempty"`
	VisibilityNotNil *bool                                 `json:"visibilityNotNil,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
}

// Ordering options for TrustCenterDoc connections
type TrustCenterDocOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterDocs.
	Field TrustCenterDocOrderField `json:"field"`
}

// Return response for updateTrustCenterDoc mutation
type TrustCenterDocUpdatePayload struct {
	// Updated trustCenterDoc
	TrustCenterDoc *TrustCenterDoc `json:"trustCenterDoc"`
}

// TrustCenterDocWhereInput is used for filtering TrustCenterDoc objects.
// Input was generated by ent.
type TrustCenterDocWhereInput struct {
	Not *TrustCenterDocWhereInput   `json:"not,omitempty"`
	And []*TrustCenterDocWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterDocWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// file_id field predicates
	FileID             *string  `json:"fileID,omitempty"`
	FileIdneq          *string  `json:"fileIDNEQ,omitempty"`
	FileIDIn           []string `json:"fileIDIn,omitempty"`
	FileIDNotIn        []string `json:"fileIDNotIn,omitempty"`
	FileIdgt           *string  `json:"fileIDGT,omitempty"`
	FileIdgte          *string  `json:"fileIDGTE,omitempty"`
	FileIdlt           *string  `json:"fileIDLT,omitempty"`
	FileIdlte          *string  `json:"fileIDLTE,omitempty"`
	FileIDContains     *string  `json:"fileIDContains,omitempty"`
	FileIDHasPrefix    *string  `json:"fileIDHasPrefix,omitempty"`
	FileIDHasSuffix    *string  `json:"fileIDHasSuffix,omitempty"`
	FileIDIsNil        *bool    `json:"fileIDIsNil,omitempty"`
	FileIDNotNil       *bool    `json:"fileIDNotNil,omitempty"`
	FileIDEqualFold    *string  `json:"fileIDEqualFold,omitempty"`
	FileIDContainsFold *string  `json:"fileIDContainsFold,omitempty"`
	// original_file_id field predicates
	OriginalFileID             *string  `json:"originalFileID,omitempty"`
	OriginalFileIdneq          *string  `json:"originalFileIDNEQ,omitempty"`
	OriginalFileIDIn           []string `json:"originalFileIDIn,omitempty"`
	OriginalFileIDNotIn        []string `json:"originalFileIDNotIn,omitempty"`
	OriginalFileIdgt           *string  `json:"originalFileIDGT,omitempty"`
	OriginalFileIdgte          *string  `json:"originalFileIDGTE,omitempty"`
	OriginalFileIdlt           *string  `json:"originalFileIDLT,omitempty"`
	OriginalFileIdlte          *string  `json:"originalFileIDLTE,omitempty"`
	OriginalFileIDContains     *string  `json:"originalFileIDContains,omitempty"`
	OriginalFileIDHasPrefix    *string  `json:"originalFileIDHasPrefix,omitempty"`
	OriginalFileIDHasSuffix    *string  `json:"originalFileIDHasSuffix,omitempty"`
	OriginalFileIDIsNil        *bool    `json:"originalFileIDIsNil,omitempty"`
	OriginalFileIDNotNil       *bool    `json:"originalFileIDNotNil,omitempty"`
	OriginalFileIDEqualFold    *string  `json:"originalFileIDEqualFold,omitempty"`
	OriginalFileIDContainsFold *string  `json:"originalFileIDContainsFold,omitempty"`
	// watermarking_enabled field predicates
	WatermarkingEnabled    *bool `json:"watermarkingEnabled,omitempty"`
	WatermarkingEnabledNeq *bool `json:"watermarkingEnabledNEQ,omitempty"`
	// watermark_status field predicates
	WatermarkStatus       *enums.WatermarkStatus  `json:"watermarkStatus,omitempty"`
	WatermarkStatusNeq    *enums.WatermarkStatus  `json:"watermarkStatusNEQ,omitempty"`
	WatermarkStatusIn     []enums.WatermarkStatus `json:"watermarkStatusIn,omitempty"`
	WatermarkStatusNotIn  []enums.WatermarkStatus `json:"watermarkStatusNotIn,omitempty"`
	WatermarkStatusIsNil  *bool                   `json:"watermarkStatusIsNil,omitempty"`
	WatermarkStatusNotNil *bool                   `json:"watermarkStatusNotNil,omitempty"`
	// visibility field predicates
	Visibility       *enums.TrustCenterDocumentVisibility  `json:"visibility,omitempty"`
	VisibilityNeq    *enums.TrustCenterDocumentVisibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn     []enums.TrustCenterDocumentVisibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn  []enums.TrustCenterDocumentVisibility `json:"visibilityNotIn,omitempty"`
	VisibilityIsNil  *bool                                 `json:"visibilityIsNil,omitempty"`
	VisibilityNotNil *bool                                 `json:"visibilityNotNil,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
	// trust_center edge predicates
	HasTrustCenter     *bool                    `json:"hasTrustCenter,omitempty"`
	HasTrustCenterWith []*TrustCenterWhereInput `json:"hasTrustCenterWith,omitempty"`
	// standard edge predicates
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
	// original_file edge predicates
	HasOriginalFile     *bool             `json:"hasOriginalFile,omitempty"`
	HasOriginalFileWith []*FileWhereInput `json:"hasOriginalFileWith,omitempty"`
}

// Return response for createTrustCenterDomain mutation
type TrustCenterDomainCreatePayload struct {
	CustomDomain *CustomDomain `json:"customDomain"`
}

// An edge in a connection.
type TrustCenterEdge struct {
	// The item at the end of the edge.
	Node *TrustCenter `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TrustCenterHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// Slug for the trust center
	Slug *string `json:"slug,omitempty"`
	// custom domain id for the trust center
	CustomDomainID *string `json:"customDomainID,omitempty"`
	// preview domain id for the trust center
	PreviewDomainID *string `json:"previewDomainID,omitempty"`
	// Pirsch domain ID
	PirschDomainID *string `json:"pirschDomainID,omitempty"`
	// Pirsch ID code
	PirschIdentificationCode *string `json:"pirschIdentificationCode,omitempty"`
	// preview status of the trust center
	PreviewStatus *enums.TrustCenterPreviewStatus `json:"previewStatus,omitempty"`
}

func (TrustCenterHistory) IsNode() {}

// A connection to a list of items.
type TrustCenterHistoryConnection struct {
	// A list of edges.
	Edges []*TrustCenterHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TrustCenterHistoryEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TrustCenterHistory connections
type TrustCenterHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterHistories.
	Field TrustCenterHistoryOrderField `json:"field"`
}

// TrustCenterHistoryWhereInput is used for filtering TrustCenterHistory objects.
// Input was generated by ent.
type TrustCenterHistoryWhereInput struct {
	Not *TrustCenterHistoryWhereInput   `json:"not,omitempty"`
	And []*TrustCenterHistoryWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// slug field predicates
	Slug             *string  `json:"slug,omitempty"`
	SlugNeq          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGt           *string  `json:"slugGT,omitempty"`
	SlugGte          *string  `json:"slugGTE,omitempty"`
	SlugLt           *string  `json:"slugLT,omitempty"`
	SlugLte          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        *bool    `json:"slugIsNil,omitempty"`
	SlugNotNil       *bool    `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`
	// custom_domain_id field predicates
	CustomDomainID             *string  `json:"customDomainID,omitempty"`
	CustomDomainIdneq          *string  `json:"customDomainIDNEQ,omitempty"`
	CustomDomainIDIn           []string `json:"customDomainIDIn,omitempty"`
	CustomDomainIDNotIn        []string `json:"customDomainIDNotIn,omitempty"`
	CustomDomainIdgt           *string  `json:"customDomainIDGT,omitempty"`
	CustomDomainIdgte          *string  `json:"customDomainIDGTE,omitempty"`
	CustomDomainIdlt           *string  `json:"customDomainIDLT,omitempty"`
	CustomDomainIdlte          *string  `json:"customDomainIDLTE,omitempty"`
	CustomDomainIDContains     *string  `json:"customDomainIDContains,omitempty"`
	CustomDomainIDHasPrefix    *string  `json:"customDomainIDHasPrefix,omitempty"`
	CustomDomainIDHasSuffix    *string  `json:"customDomainIDHasSuffix,omitempty"`
	CustomDomainIDIsNil        *bool    `json:"customDomainIDIsNil,omitempty"`
	CustomDomainIDNotNil       *bool    `json:"customDomainIDNotNil,omitempty"`
	CustomDomainIDEqualFold    *string  `json:"customDomainIDEqualFold,omitempty"`
	CustomDomainIDContainsFold *string  `json:"customDomainIDContainsFold,omitempty"`
	// preview_domain_id field predicates
	PreviewDomainID             *string  `json:"previewDomainID,omitempty"`
	PreviewDomainIdneq          *string  `json:"previewDomainIDNEQ,omitempty"`
	PreviewDomainIDIn           []string `json:"previewDomainIDIn,omitempty"`
	PreviewDomainIDNotIn        []string `json:"previewDomainIDNotIn,omitempty"`
	PreviewDomainIdgt           *string  `json:"previewDomainIDGT,omitempty"`
	PreviewDomainIdgte          *string  `json:"previewDomainIDGTE,omitempty"`
	PreviewDomainIdlt           *string  `json:"previewDomainIDLT,omitempty"`
	PreviewDomainIdlte          *string  `json:"previewDomainIDLTE,omitempty"`
	PreviewDomainIDContains     *string  `json:"previewDomainIDContains,omitempty"`
	PreviewDomainIDHasPrefix    *string  `json:"previewDomainIDHasPrefix,omitempty"`
	PreviewDomainIDHasSuffix    *string  `json:"previewDomainIDHasSuffix,omitempty"`
	PreviewDomainIDIsNil        *bool    `json:"previewDomainIDIsNil,omitempty"`
	PreviewDomainIDNotNil       *bool    `json:"previewDomainIDNotNil,omitempty"`
	PreviewDomainIDEqualFold    *string  `json:"previewDomainIDEqualFold,omitempty"`
	PreviewDomainIDContainsFold *string  `json:"previewDomainIDContainsFold,omitempty"`
	// pirsch_domain_id field predicates
	PirschDomainID             *string  `json:"pirschDomainID,omitempty"`
	PirschDomainIdneq          *string  `json:"pirschDomainIDNEQ,omitempty"`
	PirschDomainIDIn           []string `json:"pirschDomainIDIn,omitempty"`
	PirschDomainIDNotIn        []string `json:"pirschDomainIDNotIn,omitempty"`
	PirschDomainIdgt           *string  `json:"pirschDomainIDGT,omitempty"`
	PirschDomainIdgte          *string  `json:"pirschDomainIDGTE,omitempty"`
	PirschDomainIdlt           *string  `json:"pirschDomainIDLT,omitempty"`
	PirschDomainIdlte          *string  `json:"pirschDomainIDLTE,omitempty"`
	PirschDomainIDContains     *string  `json:"pirschDomainIDContains,omitempty"`
	PirschDomainIDHasPrefix    *string  `json:"pirschDomainIDHasPrefix,omitempty"`
	PirschDomainIDHasSuffix    *string  `json:"pirschDomainIDHasSuffix,omitempty"`
	PirschDomainIDIsNil        *bool    `json:"pirschDomainIDIsNil,omitempty"`
	PirschDomainIDNotNil       *bool    `json:"pirschDomainIDNotNil,omitempty"`
	PirschDomainIDEqualFold    *string  `json:"pirschDomainIDEqualFold,omitempty"`
	PirschDomainIDContainsFold *string  `json:"pirschDomainIDContainsFold,omitempty"`
	// pirsch_identification_code field predicates
	PirschIdentificationCode             *string  `json:"pirschIdentificationCode,omitempty"`
	PirschIdentificationCodeNeq          *string  `json:"pirschIdentificationCodeNEQ,omitempty"`
	PirschIdentificationCodeIn           []string `json:"pirschIdentificationCodeIn,omitempty"`
	PirschIdentificationCodeNotIn        []string `json:"pirschIdentificationCodeNotIn,omitempty"`
	PirschIdentificationCodeGt           *string  `json:"pirschIdentificationCodeGT,omitempty"`
	PirschIdentificationCodeGte          *string  `json:"pirschIdentificationCodeGTE,omitempty"`
	PirschIdentificationCodeLt           *string  `json:"pirschIdentificationCodeLT,omitempty"`
	PirschIdentificationCodeLte          *string  `json:"pirschIdentificationCodeLTE,omitempty"`
	PirschIdentificationCodeContains     *string  `json:"pirschIdentificationCodeContains,omitempty"`
	PirschIdentificationCodeHasPrefix    *string  `json:"pirschIdentificationCodeHasPrefix,omitempty"`
	PirschIdentificationCodeHasSuffix    *string  `json:"pirschIdentificationCodeHasSuffix,omitempty"`
	PirschIdentificationCodeIsNil        *bool    `json:"pirschIdentificationCodeIsNil,omitempty"`
	PirschIdentificationCodeNotNil       *bool    `json:"pirschIdentificationCodeNotNil,omitempty"`
	PirschIdentificationCodeEqualFold    *string  `json:"pirschIdentificationCodeEqualFold,omitempty"`
	PirschIdentificationCodeContainsFold *string  `json:"pirschIdentificationCodeContainsFold,omitempty"`
	// preview_status field predicates
	PreviewStatus       *enums.TrustCenterPreviewStatus  `json:"previewStatus,omitempty"`
	PreviewStatusNeq    *enums.TrustCenterPreviewStatus  `json:"previewStatusNEQ,omitempty"`
	PreviewStatusIn     []enums.TrustCenterPreviewStatus `json:"previewStatusIn,omitempty"`
	PreviewStatusNotIn  []enums.TrustCenterPreviewStatus `json:"previewStatusNotIn,omitempty"`
	PreviewStatusIsNil  *bool                            `json:"previewStatusIsNil,omitempty"`
	PreviewStatusNotNil *bool                            `json:"previewStatusNotNil,omitempty"`
}

type TrustCenterNDACreatePayload struct {
	Template *Template `json:"template"`
}

type TrustCenterNDAUpdatePayload struct {
	Template *Template `json:"template"`
}

// Ordering options for TrustCenter connections
type TrustCenterOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenters.
	Field TrustCenterOrderField `json:"field"`
}

type TrustCenterSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the ID of the trust center the settings belong to
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// title of the trust center
	Title *string `json:"title,omitempty"`
	// overview of the trust center
	Overview *string `json:"overview,omitempty"`
	// URL of the logo
	LogoRemoteURL *string `json:"logoRemoteURL,omitempty"`
	// The local logo file id, takes precedence over the logo remote URL
	LogoLocalFileID *string `json:"logoLocalFileID,omitempty"`
	// URL of the favicon
	FaviconRemoteURL *string `json:"faviconRemoteURL,omitempty"`
	// The local favicon file id, takes precedence over the favicon remote URL
	FaviconLocalFileID *string `json:"faviconLocalFileID,omitempty"`
	// Theme mode for the trust center
	ThemeMode *enums.TrustCenterThemeMode `json:"themeMode,omitempty"`
	// primary color for the trust center
	PrimaryColor *string `json:"primaryColor,omitempty"`
	// font for the trust center
	Font *string `json:"font,omitempty"`
	// foreground color for the trust center
	ForegroundColor *string `json:"foregroundColor,omitempty"`
	// background color for the trust center
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	// accent/brand color for the trust center
	AccentColor *string `json:"accentColor,omitempty"`
	// secondary background color for the trust center
	SecondaryBackgroundColor *string `json:"secondaryBackgroundColor,omitempty"`
	// secondary foreground color for the trust center
	SecondaryForegroundColor *string `json:"secondaryForegroundColor,omitempty"`
	// environment of the trust center
	Environment *enums.TrustCenterEnvironment `json:"environment,omitempty"`
	Files       *FileConnection               `json:"files"`
	LogoFile    *File                         `json:"logoFile,omitempty"`
	FaviconFile *File                         `json:"faviconFile,omitempty"`
}

func (TrustCenterSetting) IsNode() {}

// Return response for createBulkTrustCenterSetting mutation
type TrustCenterSettingBulkCreatePayload struct {
	// Created trustCenterSettings
	TrustCenterSettings []*TrustCenterSetting `json:"trustCenterSettings,omitempty"`
}

// A connection to a list of items.
type TrustCenterSettingConnection struct {
	// A list of edges.
	Edges []*TrustCenterSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTrustCenterSetting mutation
type TrustCenterSettingCreatePayload struct {
	// Created trustCenterSetting
	TrustCenterSetting *TrustCenterSetting `json:"trustCenterSetting"`
}

// Return response for deleteTrustCenterSetting mutation
type TrustCenterSettingDeletePayload struct {
	// Deleted trustCenterSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TrustCenterSettingEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TrustCenterSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// the ID of the trust center the settings belong to
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// title of the trust center
	Title *string `json:"title,omitempty"`
	// overview of the trust center
	Overview *string `json:"overview,omitempty"`
	// URL of the logo
	LogoRemoteURL *string `json:"logoRemoteURL,omitempty"`
	// The local logo file id, takes precedence over the logo remote URL
	LogoLocalFileID *string `json:"logoLocalFileID,omitempty"`
	// URL of the favicon
	FaviconRemoteURL *string `json:"faviconRemoteURL,omitempty"`
	// The local favicon file id, takes precedence over the favicon remote URL
	FaviconLocalFileID *string `json:"faviconLocalFileID,omitempty"`
	// Theme mode for the trust center
	ThemeMode *enums.TrustCenterThemeMode `json:"themeMode,omitempty"`
	// primary color for the trust center
	PrimaryColor *string `json:"primaryColor,omitempty"`
	// font for the trust center
	Font *string `json:"font,omitempty"`
	// foreground color for the trust center
	ForegroundColor *string `json:"foregroundColor,omitempty"`
	// background color for the trust center
	BackgroundColor *string `json:"backgroundColor,omitempty"`
	// accent/brand color for the trust center
	AccentColor *string `json:"accentColor,omitempty"`
	// secondary background color for the trust center
	SecondaryBackgroundColor *string `json:"secondaryBackgroundColor,omitempty"`
	// secondary foreground color for the trust center
	SecondaryForegroundColor *string `json:"secondaryForegroundColor,omitempty"`
	// environment of the trust center
	Environment *enums.TrustCenterEnvironment `json:"environment,omitempty"`
}

func (TrustCenterSettingHistory) IsNode() {}

// A connection to a list of items.
type TrustCenterSettingHistoryConnection struct {
	// A list of edges.
	Edges []*TrustCenterSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TrustCenterSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TrustCenterSettingHistory connections
type TrustCenterSettingHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterSettingHistories.
	Field TrustCenterSettingHistoryOrderField `json:"field"`
}

// TrustCenterSettingHistoryWhereInput is used for filtering TrustCenterSettingHistory objects.
// Input was generated by ent.
type TrustCenterSettingHistoryWhereInput struct {
	Not *TrustCenterSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*TrustCenterSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// overview field predicates
	Overview             *string  `json:"overview,omitempty"`
	OverviewNeq          *string  `json:"overviewNEQ,omitempty"`
	OverviewIn           []string `json:"overviewIn,omitempty"`
	OverviewNotIn        []string `json:"overviewNotIn,omitempty"`
	OverviewGt           *string  `json:"overviewGT,omitempty"`
	OverviewGte          *string  `json:"overviewGTE,omitempty"`
	OverviewLt           *string  `json:"overviewLT,omitempty"`
	OverviewLte          *string  `json:"overviewLTE,omitempty"`
	OverviewContains     *string  `json:"overviewContains,omitempty"`
	OverviewHasPrefix    *string  `json:"overviewHasPrefix,omitempty"`
	OverviewHasSuffix    *string  `json:"overviewHasSuffix,omitempty"`
	OverviewIsNil        *bool    `json:"overviewIsNil,omitempty"`
	OverviewNotNil       *bool    `json:"overviewNotNil,omitempty"`
	OverviewEqualFold    *string  `json:"overviewEqualFold,omitempty"`
	OverviewContainsFold *string  `json:"overviewContainsFold,omitempty"`
	// logo_remote_url field predicates
	LogoRemoteURL             *string  `json:"logoRemoteURL,omitempty"`
	LogoRemoteURLNeq          *string  `json:"logoRemoteURLNEQ,omitempty"`
	LogoRemoteURLIn           []string `json:"logoRemoteURLIn,omitempty"`
	LogoRemoteURLNotIn        []string `json:"logoRemoteURLNotIn,omitempty"`
	LogoRemoteURLGt           *string  `json:"logoRemoteURLGT,omitempty"`
	LogoRemoteURLGte          *string  `json:"logoRemoteURLGTE,omitempty"`
	LogoRemoteURLLt           *string  `json:"logoRemoteURLLT,omitempty"`
	LogoRemoteURLLte          *string  `json:"logoRemoteURLLTE,omitempty"`
	LogoRemoteURLContains     *string  `json:"logoRemoteURLContains,omitempty"`
	LogoRemoteURLHasPrefix    *string  `json:"logoRemoteURLHasPrefix,omitempty"`
	LogoRemoteURLHasSuffix    *string  `json:"logoRemoteURLHasSuffix,omitempty"`
	LogoRemoteURLIsNil        *bool    `json:"logoRemoteURLIsNil,omitempty"`
	LogoRemoteURLNotNil       *bool    `json:"logoRemoteURLNotNil,omitempty"`
	LogoRemoteURLEqualFold    *string  `json:"logoRemoteURLEqualFold,omitempty"`
	LogoRemoteURLContainsFold *string  `json:"logoRemoteURLContainsFold,omitempty"`
	// logo_local_file_id field predicates
	LogoLocalFileID             *string  `json:"logoLocalFileID,omitempty"`
	LogoLocalFileIdneq          *string  `json:"logoLocalFileIDNEQ,omitempty"`
	LogoLocalFileIDIn           []string `json:"logoLocalFileIDIn,omitempty"`
	LogoLocalFileIDNotIn        []string `json:"logoLocalFileIDNotIn,omitempty"`
	LogoLocalFileIdgt           *string  `json:"logoLocalFileIDGT,omitempty"`
	LogoLocalFileIdgte          *string  `json:"logoLocalFileIDGTE,omitempty"`
	LogoLocalFileIdlt           *string  `json:"logoLocalFileIDLT,omitempty"`
	LogoLocalFileIdlte          *string  `json:"logoLocalFileIDLTE,omitempty"`
	LogoLocalFileIDContains     *string  `json:"logoLocalFileIDContains,omitempty"`
	LogoLocalFileIDHasPrefix    *string  `json:"logoLocalFileIDHasPrefix,omitempty"`
	LogoLocalFileIDHasSuffix    *string  `json:"logoLocalFileIDHasSuffix,omitempty"`
	LogoLocalFileIDIsNil        *bool    `json:"logoLocalFileIDIsNil,omitempty"`
	LogoLocalFileIDNotNil       *bool    `json:"logoLocalFileIDNotNil,omitempty"`
	LogoLocalFileIDEqualFold    *string  `json:"logoLocalFileIDEqualFold,omitempty"`
	LogoLocalFileIDContainsFold *string  `json:"logoLocalFileIDContainsFold,omitempty"`
	// favicon_remote_url field predicates
	FaviconRemoteURL             *string  `json:"faviconRemoteURL,omitempty"`
	FaviconRemoteURLNeq          *string  `json:"faviconRemoteURLNEQ,omitempty"`
	FaviconRemoteURLIn           []string `json:"faviconRemoteURLIn,omitempty"`
	FaviconRemoteURLNotIn        []string `json:"faviconRemoteURLNotIn,omitempty"`
	FaviconRemoteURLGt           *string  `json:"faviconRemoteURLGT,omitempty"`
	FaviconRemoteURLGte          *string  `json:"faviconRemoteURLGTE,omitempty"`
	FaviconRemoteURLLt           *string  `json:"faviconRemoteURLLT,omitempty"`
	FaviconRemoteURLLte          *string  `json:"faviconRemoteURLLTE,omitempty"`
	FaviconRemoteURLContains     *string  `json:"faviconRemoteURLContains,omitempty"`
	FaviconRemoteURLHasPrefix    *string  `json:"faviconRemoteURLHasPrefix,omitempty"`
	FaviconRemoteURLHasSuffix    *string  `json:"faviconRemoteURLHasSuffix,omitempty"`
	FaviconRemoteURLIsNil        *bool    `json:"faviconRemoteURLIsNil,omitempty"`
	FaviconRemoteURLNotNil       *bool    `json:"faviconRemoteURLNotNil,omitempty"`
	FaviconRemoteURLEqualFold    *string  `json:"faviconRemoteURLEqualFold,omitempty"`
	FaviconRemoteURLContainsFold *string  `json:"faviconRemoteURLContainsFold,omitempty"`
	// favicon_local_file_id field predicates
	FaviconLocalFileID             *string  `json:"faviconLocalFileID,omitempty"`
	FaviconLocalFileIdneq          *string  `json:"faviconLocalFileIDNEQ,omitempty"`
	FaviconLocalFileIDIn           []string `json:"faviconLocalFileIDIn,omitempty"`
	FaviconLocalFileIDNotIn        []string `json:"faviconLocalFileIDNotIn,omitempty"`
	FaviconLocalFileIdgt           *string  `json:"faviconLocalFileIDGT,omitempty"`
	FaviconLocalFileIdgte          *string  `json:"faviconLocalFileIDGTE,omitempty"`
	FaviconLocalFileIdlt           *string  `json:"faviconLocalFileIDLT,omitempty"`
	FaviconLocalFileIdlte          *string  `json:"faviconLocalFileIDLTE,omitempty"`
	FaviconLocalFileIDContains     *string  `json:"faviconLocalFileIDContains,omitempty"`
	FaviconLocalFileIDHasPrefix    *string  `json:"faviconLocalFileIDHasPrefix,omitempty"`
	FaviconLocalFileIDHasSuffix    *string  `json:"faviconLocalFileIDHasSuffix,omitempty"`
	FaviconLocalFileIDIsNil        *bool    `json:"faviconLocalFileIDIsNil,omitempty"`
	FaviconLocalFileIDNotNil       *bool    `json:"faviconLocalFileIDNotNil,omitempty"`
	FaviconLocalFileIDEqualFold    *string  `json:"faviconLocalFileIDEqualFold,omitempty"`
	FaviconLocalFileIDContainsFold *string  `json:"faviconLocalFileIDContainsFold,omitempty"`
	// theme_mode field predicates
	ThemeMode       *enums.TrustCenterThemeMode  `json:"themeMode,omitempty"`
	ThemeModeNeq    *enums.TrustCenterThemeMode  `json:"themeModeNEQ,omitempty"`
	ThemeModeIn     []enums.TrustCenterThemeMode `json:"themeModeIn,omitempty"`
	ThemeModeNotIn  []enums.TrustCenterThemeMode `json:"themeModeNotIn,omitempty"`
	ThemeModeIsNil  *bool                        `json:"themeModeIsNil,omitempty"`
	ThemeModeNotNil *bool                        `json:"themeModeNotNil,omitempty"`
	// primary_color field predicates
	PrimaryColor             *string  `json:"primaryColor,omitempty"`
	PrimaryColorNeq          *string  `json:"primaryColorNEQ,omitempty"`
	PrimaryColorIn           []string `json:"primaryColorIn,omitempty"`
	PrimaryColorNotIn        []string `json:"primaryColorNotIn,omitempty"`
	PrimaryColorGt           *string  `json:"primaryColorGT,omitempty"`
	PrimaryColorGte          *string  `json:"primaryColorGTE,omitempty"`
	PrimaryColorLt           *string  `json:"primaryColorLT,omitempty"`
	PrimaryColorLte          *string  `json:"primaryColorLTE,omitempty"`
	PrimaryColorContains     *string  `json:"primaryColorContains,omitempty"`
	PrimaryColorHasPrefix    *string  `json:"primaryColorHasPrefix,omitempty"`
	PrimaryColorHasSuffix    *string  `json:"primaryColorHasSuffix,omitempty"`
	PrimaryColorIsNil        *bool    `json:"primaryColorIsNil,omitempty"`
	PrimaryColorNotNil       *bool    `json:"primaryColorNotNil,omitempty"`
	PrimaryColorEqualFold    *string  `json:"primaryColorEqualFold,omitempty"`
	PrimaryColorContainsFold *string  `json:"primaryColorContainsFold,omitempty"`
	// font field predicates
	Font             *string  `json:"font,omitempty"`
	FontNeq          *string  `json:"fontNEQ,omitempty"`
	FontIn           []string `json:"fontIn,omitempty"`
	FontNotIn        []string `json:"fontNotIn,omitempty"`
	FontGt           *string  `json:"fontGT,omitempty"`
	FontGte          *string  `json:"fontGTE,omitempty"`
	FontLt           *string  `json:"fontLT,omitempty"`
	FontLte          *string  `json:"fontLTE,omitempty"`
	FontContains     *string  `json:"fontContains,omitempty"`
	FontHasPrefix    *string  `json:"fontHasPrefix,omitempty"`
	FontHasSuffix    *string  `json:"fontHasSuffix,omitempty"`
	FontIsNil        *bool    `json:"fontIsNil,omitempty"`
	FontNotNil       *bool    `json:"fontNotNil,omitempty"`
	FontEqualFold    *string  `json:"fontEqualFold,omitempty"`
	FontContainsFold *string  `json:"fontContainsFold,omitempty"`
	// foreground_color field predicates
	ForegroundColor             *string  `json:"foregroundColor,omitempty"`
	ForegroundColorNeq          *string  `json:"foregroundColorNEQ,omitempty"`
	ForegroundColorIn           []string `json:"foregroundColorIn,omitempty"`
	ForegroundColorNotIn        []string `json:"foregroundColorNotIn,omitempty"`
	ForegroundColorGt           *string  `json:"foregroundColorGT,omitempty"`
	ForegroundColorGte          *string  `json:"foregroundColorGTE,omitempty"`
	ForegroundColorLt           *string  `json:"foregroundColorLT,omitempty"`
	ForegroundColorLte          *string  `json:"foregroundColorLTE,omitempty"`
	ForegroundColorContains     *string  `json:"foregroundColorContains,omitempty"`
	ForegroundColorHasPrefix    *string  `json:"foregroundColorHasPrefix,omitempty"`
	ForegroundColorHasSuffix    *string  `json:"foregroundColorHasSuffix,omitempty"`
	ForegroundColorIsNil        *bool    `json:"foregroundColorIsNil,omitempty"`
	ForegroundColorNotNil       *bool    `json:"foregroundColorNotNil,omitempty"`
	ForegroundColorEqualFold    *string  `json:"foregroundColorEqualFold,omitempty"`
	ForegroundColorContainsFold *string  `json:"foregroundColorContainsFold,omitempty"`
	// background_color field predicates
	BackgroundColor             *string  `json:"backgroundColor,omitempty"`
	BackgroundColorNeq          *string  `json:"backgroundColorNEQ,omitempty"`
	BackgroundColorIn           []string `json:"backgroundColorIn,omitempty"`
	BackgroundColorNotIn        []string `json:"backgroundColorNotIn,omitempty"`
	BackgroundColorGt           *string  `json:"backgroundColorGT,omitempty"`
	BackgroundColorGte          *string  `json:"backgroundColorGTE,omitempty"`
	BackgroundColorLt           *string  `json:"backgroundColorLT,omitempty"`
	BackgroundColorLte          *string  `json:"backgroundColorLTE,omitempty"`
	BackgroundColorContains     *string  `json:"backgroundColorContains,omitempty"`
	BackgroundColorHasPrefix    *string  `json:"backgroundColorHasPrefix,omitempty"`
	BackgroundColorHasSuffix    *string  `json:"backgroundColorHasSuffix,omitempty"`
	BackgroundColorIsNil        *bool    `json:"backgroundColorIsNil,omitempty"`
	BackgroundColorNotNil       *bool    `json:"backgroundColorNotNil,omitempty"`
	BackgroundColorEqualFold    *string  `json:"backgroundColorEqualFold,omitempty"`
	BackgroundColorContainsFold *string  `json:"backgroundColorContainsFold,omitempty"`
	// accent_color field predicates
	AccentColor             *string  `json:"accentColor,omitempty"`
	AccentColorNeq          *string  `json:"accentColorNEQ,omitempty"`
	AccentColorIn           []string `json:"accentColorIn,omitempty"`
	AccentColorNotIn        []string `json:"accentColorNotIn,omitempty"`
	AccentColorGt           *string  `json:"accentColorGT,omitempty"`
	AccentColorGte          *string  `json:"accentColorGTE,omitempty"`
	AccentColorLt           *string  `json:"accentColorLT,omitempty"`
	AccentColorLte          *string  `json:"accentColorLTE,omitempty"`
	AccentColorContains     *string  `json:"accentColorContains,omitempty"`
	AccentColorHasPrefix    *string  `json:"accentColorHasPrefix,omitempty"`
	AccentColorHasSuffix    *string  `json:"accentColorHasSuffix,omitempty"`
	AccentColorIsNil        *bool    `json:"accentColorIsNil,omitempty"`
	AccentColorNotNil       *bool    `json:"accentColorNotNil,omitempty"`
	AccentColorEqualFold    *string  `json:"accentColorEqualFold,omitempty"`
	AccentColorContainsFold *string  `json:"accentColorContainsFold,omitempty"`
	// secondary_background_color field predicates
	SecondaryBackgroundColor             *string  `json:"secondaryBackgroundColor,omitempty"`
	SecondaryBackgroundColorNeq          *string  `json:"secondaryBackgroundColorNEQ,omitempty"`
	SecondaryBackgroundColorIn           []string `json:"secondaryBackgroundColorIn,omitempty"`
	SecondaryBackgroundColorNotIn        []string `json:"secondaryBackgroundColorNotIn,omitempty"`
	SecondaryBackgroundColorGt           *string  `json:"secondaryBackgroundColorGT,omitempty"`
	SecondaryBackgroundColorGte          *string  `json:"secondaryBackgroundColorGTE,omitempty"`
	SecondaryBackgroundColorLt           *string  `json:"secondaryBackgroundColorLT,omitempty"`
	SecondaryBackgroundColorLte          *string  `json:"secondaryBackgroundColorLTE,omitempty"`
	SecondaryBackgroundColorContains     *string  `json:"secondaryBackgroundColorContains,omitempty"`
	SecondaryBackgroundColorHasPrefix    *string  `json:"secondaryBackgroundColorHasPrefix,omitempty"`
	SecondaryBackgroundColorHasSuffix    *string  `json:"secondaryBackgroundColorHasSuffix,omitempty"`
	SecondaryBackgroundColorIsNil        *bool    `json:"secondaryBackgroundColorIsNil,omitempty"`
	SecondaryBackgroundColorNotNil       *bool    `json:"secondaryBackgroundColorNotNil,omitempty"`
	SecondaryBackgroundColorEqualFold    *string  `json:"secondaryBackgroundColorEqualFold,omitempty"`
	SecondaryBackgroundColorContainsFold *string  `json:"secondaryBackgroundColorContainsFold,omitempty"`
	// secondary_foreground_color field predicates
	SecondaryForegroundColor             *string  `json:"secondaryForegroundColor,omitempty"`
	SecondaryForegroundColorNeq          *string  `json:"secondaryForegroundColorNEQ,omitempty"`
	SecondaryForegroundColorIn           []string `json:"secondaryForegroundColorIn,omitempty"`
	SecondaryForegroundColorNotIn        []string `json:"secondaryForegroundColorNotIn,omitempty"`
	SecondaryForegroundColorGt           *string  `json:"secondaryForegroundColorGT,omitempty"`
	SecondaryForegroundColorGte          *string  `json:"secondaryForegroundColorGTE,omitempty"`
	SecondaryForegroundColorLt           *string  `json:"secondaryForegroundColorLT,omitempty"`
	SecondaryForegroundColorLte          *string  `json:"secondaryForegroundColorLTE,omitempty"`
	SecondaryForegroundColorContains     *string  `json:"secondaryForegroundColorContains,omitempty"`
	SecondaryForegroundColorHasPrefix    *string  `json:"secondaryForegroundColorHasPrefix,omitempty"`
	SecondaryForegroundColorHasSuffix    *string  `json:"secondaryForegroundColorHasSuffix,omitempty"`
	SecondaryForegroundColorIsNil        *bool    `json:"secondaryForegroundColorIsNil,omitempty"`
	SecondaryForegroundColorNotNil       *bool    `json:"secondaryForegroundColorNotNil,omitempty"`
	SecondaryForegroundColorEqualFold    *string  `json:"secondaryForegroundColorEqualFold,omitempty"`
	SecondaryForegroundColorContainsFold *string  `json:"secondaryForegroundColorContainsFold,omitempty"`
	// environment field predicates
	Environment       *enums.TrustCenterEnvironment  `json:"environment,omitempty"`
	EnvironmentNeq    *enums.TrustCenterEnvironment  `json:"environmentNEQ,omitempty"`
	EnvironmentIn     []enums.TrustCenterEnvironment `json:"environmentIn,omitempty"`
	EnvironmentNotIn  []enums.TrustCenterEnvironment `json:"environmentNotIn,omitempty"`
	EnvironmentIsNil  *bool                          `json:"environmentIsNil,omitempty"`
	EnvironmentNotNil *bool                          `json:"environmentNotNil,omitempty"`
}

// Ordering options for TrustCenterSetting connections
type TrustCenterSettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterSettings.
	Field TrustCenterSettingOrderField `json:"field"`
}

// Return response for updateTrustCenterSetting mutation
type TrustCenterSettingUpdatePayload struct {
	// Updated trustCenterSetting
	TrustCenterSetting *TrustCenterSetting `json:"trustCenterSetting"`
}

// TrustCenterSettingWhereInput is used for filtering TrustCenterSetting objects.
// Input was generated by ent.
type TrustCenterSettingWhereInput struct {
	Not *TrustCenterSettingWhereInput   `json:"not,omitempty"`
	And []*TrustCenterSettingWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// overview field predicates
	Overview             *string  `json:"overview,omitempty"`
	OverviewNeq          *string  `json:"overviewNEQ,omitempty"`
	OverviewIn           []string `json:"overviewIn,omitempty"`
	OverviewNotIn        []string `json:"overviewNotIn,omitempty"`
	OverviewGt           *string  `json:"overviewGT,omitempty"`
	OverviewGte          *string  `json:"overviewGTE,omitempty"`
	OverviewLt           *string  `json:"overviewLT,omitempty"`
	OverviewLte          *string  `json:"overviewLTE,omitempty"`
	OverviewContains     *string  `json:"overviewContains,omitempty"`
	OverviewHasPrefix    *string  `json:"overviewHasPrefix,omitempty"`
	OverviewHasSuffix    *string  `json:"overviewHasSuffix,omitempty"`
	OverviewIsNil        *bool    `json:"overviewIsNil,omitempty"`
	OverviewNotNil       *bool    `json:"overviewNotNil,omitempty"`
	OverviewEqualFold    *string  `json:"overviewEqualFold,omitempty"`
	OverviewContainsFold *string  `json:"overviewContainsFold,omitempty"`
	// logo_remote_url field predicates
	LogoRemoteURL             *string  `json:"logoRemoteURL,omitempty"`
	LogoRemoteURLNeq          *string  `json:"logoRemoteURLNEQ,omitempty"`
	LogoRemoteURLIn           []string `json:"logoRemoteURLIn,omitempty"`
	LogoRemoteURLNotIn        []string `json:"logoRemoteURLNotIn,omitempty"`
	LogoRemoteURLGt           *string  `json:"logoRemoteURLGT,omitempty"`
	LogoRemoteURLGte          *string  `json:"logoRemoteURLGTE,omitempty"`
	LogoRemoteURLLt           *string  `json:"logoRemoteURLLT,omitempty"`
	LogoRemoteURLLte          *string  `json:"logoRemoteURLLTE,omitempty"`
	LogoRemoteURLContains     *string  `json:"logoRemoteURLContains,omitempty"`
	LogoRemoteURLHasPrefix    *string  `json:"logoRemoteURLHasPrefix,omitempty"`
	LogoRemoteURLHasSuffix    *string  `json:"logoRemoteURLHasSuffix,omitempty"`
	LogoRemoteURLIsNil        *bool    `json:"logoRemoteURLIsNil,omitempty"`
	LogoRemoteURLNotNil       *bool    `json:"logoRemoteURLNotNil,omitempty"`
	LogoRemoteURLEqualFold    *string  `json:"logoRemoteURLEqualFold,omitempty"`
	LogoRemoteURLContainsFold *string  `json:"logoRemoteURLContainsFold,omitempty"`
	// logo_local_file_id field predicates
	LogoLocalFileID             *string  `json:"logoLocalFileID,omitempty"`
	LogoLocalFileIdneq          *string  `json:"logoLocalFileIDNEQ,omitempty"`
	LogoLocalFileIDIn           []string `json:"logoLocalFileIDIn,omitempty"`
	LogoLocalFileIDNotIn        []string `json:"logoLocalFileIDNotIn,omitempty"`
	LogoLocalFileIdgt           *string  `json:"logoLocalFileIDGT,omitempty"`
	LogoLocalFileIdgte          *string  `json:"logoLocalFileIDGTE,omitempty"`
	LogoLocalFileIdlt           *string  `json:"logoLocalFileIDLT,omitempty"`
	LogoLocalFileIdlte          *string  `json:"logoLocalFileIDLTE,omitempty"`
	LogoLocalFileIDContains     *string  `json:"logoLocalFileIDContains,omitempty"`
	LogoLocalFileIDHasPrefix    *string  `json:"logoLocalFileIDHasPrefix,omitempty"`
	LogoLocalFileIDHasSuffix    *string  `json:"logoLocalFileIDHasSuffix,omitempty"`
	LogoLocalFileIDIsNil        *bool    `json:"logoLocalFileIDIsNil,omitempty"`
	LogoLocalFileIDNotNil       *bool    `json:"logoLocalFileIDNotNil,omitempty"`
	LogoLocalFileIDEqualFold    *string  `json:"logoLocalFileIDEqualFold,omitempty"`
	LogoLocalFileIDContainsFold *string  `json:"logoLocalFileIDContainsFold,omitempty"`
	// favicon_remote_url field predicates
	FaviconRemoteURL             *string  `json:"faviconRemoteURL,omitempty"`
	FaviconRemoteURLNeq          *string  `json:"faviconRemoteURLNEQ,omitempty"`
	FaviconRemoteURLIn           []string `json:"faviconRemoteURLIn,omitempty"`
	FaviconRemoteURLNotIn        []string `json:"faviconRemoteURLNotIn,omitempty"`
	FaviconRemoteURLGt           *string  `json:"faviconRemoteURLGT,omitempty"`
	FaviconRemoteURLGte          *string  `json:"faviconRemoteURLGTE,omitempty"`
	FaviconRemoteURLLt           *string  `json:"faviconRemoteURLLT,omitempty"`
	FaviconRemoteURLLte          *string  `json:"faviconRemoteURLLTE,omitempty"`
	FaviconRemoteURLContains     *string  `json:"faviconRemoteURLContains,omitempty"`
	FaviconRemoteURLHasPrefix    *string  `json:"faviconRemoteURLHasPrefix,omitempty"`
	FaviconRemoteURLHasSuffix    *string  `json:"faviconRemoteURLHasSuffix,omitempty"`
	FaviconRemoteURLIsNil        *bool    `json:"faviconRemoteURLIsNil,omitempty"`
	FaviconRemoteURLNotNil       *bool    `json:"faviconRemoteURLNotNil,omitempty"`
	FaviconRemoteURLEqualFold    *string  `json:"faviconRemoteURLEqualFold,omitempty"`
	FaviconRemoteURLContainsFold *string  `json:"faviconRemoteURLContainsFold,omitempty"`
	// favicon_local_file_id field predicates
	FaviconLocalFileID             *string  `json:"faviconLocalFileID,omitempty"`
	FaviconLocalFileIdneq          *string  `json:"faviconLocalFileIDNEQ,omitempty"`
	FaviconLocalFileIDIn           []string `json:"faviconLocalFileIDIn,omitempty"`
	FaviconLocalFileIDNotIn        []string `json:"faviconLocalFileIDNotIn,omitempty"`
	FaviconLocalFileIdgt           *string  `json:"faviconLocalFileIDGT,omitempty"`
	FaviconLocalFileIdgte          *string  `json:"faviconLocalFileIDGTE,omitempty"`
	FaviconLocalFileIdlt           *string  `json:"faviconLocalFileIDLT,omitempty"`
	FaviconLocalFileIdlte          *string  `json:"faviconLocalFileIDLTE,omitempty"`
	FaviconLocalFileIDContains     *string  `json:"faviconLocalFileIDContains,omitempty"`
	FaviconLocalFileIDHasPrefix    *string  `json:"faviconLocalFileIDHasPrefix,omitempty"`
	FaviconLocalFileIDHasSuffix    *string  `json:"faviconLocalFileIDHasSuffix,omitempty"`
	FaviconLocalFileIDIsNil        *bool    `json:"faviconLocalFileIDIsNil,omitempty"`
	FaviconLocalFileIDNotNil       *bool    `json:"faviconLocalFileIDNotNil,omitempty"`
	FaviconLocalFileIDEqualFold    *string  `json:"faviconLocalFileIDEqualFold,omitempty"`
	FaviconLocalFileIDContainsFold *string  `json:"faviconLocalFileIDContainsFold,omitempty"`
	// theme_mode field predicates
	ThemeMode       *enums.TrustCenterThemeMode  `json:"themeMode,omitempty"`
	ThemeModeNeq    *enums.TrustCenterThemeMode  `json:"themeModeNEQ,omitempty"`
	ThemeModeIn     []enums.TrustCenterThemeMode `json:"themeModeIn,omitempty"`
	ThemeModeNotIn  []enums.TrustCenterThemeMode `json:"themeModeNotIn,omitempty"`
	ThemeModeIsNil  *bool                        `json:"themeModeIsNil,omitempty"`
	ThemeModeNotNil *bool                        `json:"themeModeNotNil,omitempty"`
	// primary_color field predicates
	PrimaryColor             *string  `json:"primaryColor,omitempty"`
	PrimaryColorNeq          *string  `json:"primaryColorNEQ,omitempty"`
	PrimaryColorIn           []string `json:"primaryColorIn,omitempty"`
	PrimaryColorNotIn        []string `json:"primaryColorNotIn,omitempty"`
	PrimaryColorGt           *string  `json:"primaryColorGT,omitempty"`
	PrimaryColorGte          *string  `json:"primaryColorGTE,omitempty"`
	PrimaryColorLt           *string  `json:"primaryColorLT,omitempty"`
	PrimaryColorLte          *string  `json:"primaryColorLTE,omitempty"`
	PrimaryColorContains     *string  `json:"primaryColorContains,omitempty"`
	PrimaryColorHasPrefix    *string  `json:"primaryColorHasPrefix,omitempty"`
	PrimaryColorHasSuffix    *string  `json:"primaryColorHasSuffix,omitempty"`
	PrimaryColorIsNil        *bool    `json:"primaryColorIsNil,omitempty"`
	PrimaryColorNotNil       *bool    `json:"primaryColorNotNil,omitempty"`
	PrimaryColorEqualFold    *string  `json:"primaryColorEqualFold,omitempty"`
	PrimaryColorContainsFold *string  `json:"primaryColorContainsFold,omitempty"`
	// font field predicates
	Font             *string  `json:"font,omitempty"`
	FontNeq          *string  `json:"fontNEQ,omitempty"`
	FontIn           []string `json:"fontIn,omitempty"`
	FontNotIn        []string `json:"fontNotIn,omitempty"`
	FontGt           *string  `json:"fontGT,omitempty"`
	FontGte          *string  `json:"fontGTE,omitempty"`
	FontLt           *string  `json:"fontLT,omitempty"`
	FontLte          *string  `json:"fontLTE,omitempty"`
	FontContains     *string  `json:"fontContains,omitempty"`
	FontHasPrefix    *string  `json:"fontHasPrefix,omitempty"`
	FontHasSuffix    *string  `json:"fontHasSuffix,omitempty"`
	FontIsNil        *bool    `json:"fontIsNil,omitempty"`
	FontNotNil       *bool    `json:"fontNotNil,omitempty"`
	FontEqualFold    *string  `json:"fontEqualFold,omitempty"`
	FontContainsFold *string  `json:"fontContainsFold,omitempty"`
	// foreground_color field predicates
	ForegroundColor             *string  `json:"foregroundColor,omitempty"`
	ForegroundColorNeq          *string  `json:"foregroundColorNEQ,omitempty"`
	ForegroundColorIn           []string `json:"foregroundColorIn,omitempty"`
	ForegroundColorNotIn        []string `json:"foregroundColorNotIn,omitempty"`
	ForegroundColorGt           *string  `json:"foregroundColorGT,omitempty"`
	ForegroundColorGte          *string  `json:"foregroundColorGTE,omitempty"`
	ForegroundColorLt           *string  `json:"foregroundColorLT,omitempty"`
	ForegroundColorLte          *string  `json:"foregroundColorLTE,omitempty"`
	ForegroundColorContains     *string  `json:"foregroundColorContains,omitempty"`
	ForegroundColorHasPrefix    *string  `json:"foregroundColorHasPrefix,omitempty"`
	ForegroundColorHasSuffix    *string  `json:"foregroundColorHasSuffix,omitempty"`
	ForegroundColorIsNil        *bool    `json:"foregroundColorIsNil,omitempty"`
	ForegroundColorNotNil       *bool    `json:"foregroundColorNotNil,omitempty"`
	ForegroundColorEqualFold    *string  `json:"foregroundColorEqualFold,omitempty"`
	ForegroundColorContainsFold *string  `json:"foregroundColorContainsFold,omitempty"`
	// background_color field predicates
	BackgroundColor             *string  `json:"backgroundColor,omitempty"`
	BackgroundColorNeq          *string  `json:"backgroundColorNEQ,omitempty"`
	BackgroundColorIn           []string `json:"backgroundColorIn,omitempty"`
	BackgroundColorNotIn        []string `json:"backgroundColorNotIn,omitempty"`
	BackgroundColorGt           *string  `json:"backgroundColorGT,omitempty"`
	BackgroundColorGte          *string  `json:"backgroundColorGTE,omitempty"`
	BackgroundColorLt           *string  `json:"backgroundColorLT,omitempty"`
	BackgroundColorLte          *string  `json:"backgroundColorLTE,omitempty"`
	BackgroundColorContains     *string  `json:"backgroundColorContains,omitempty"`
	BackgroundColorHasPrefix    *string  `json:"backgroundColorHasPrefix,omitempty"`
	BackgroundColorHasSuffix    *string  `json:"backgroundColorHasSuffix,omitempty"`
	BackgroundColorIsNil        *bool    `json:"backgroundColorIsNil,omitempty"`
	BackgroundColorNotNil       *bool    `json:"backgroundColorNotNil,omitempty"`
	BackgroundColorEqualFold    *string  `json:"backgroundColorEqualFold,omitempty"`
	BackgroundColorContainsFold *string  `json:"backgroundColorContainsFold,omitempty"`
	// accent_color field predicates
	AccentColor             *string  `json:"accentColor,omitempty"`
	AccentColorNeq          *string  `json:"accentColorNEQ,omitempty"`
	AccentColorIn           []string `json:"accentColorIn,omitempty"`
	AccentColorNotIn        []string `json:"accentColorNotIn,omitempty"`
	AccentColorGt           *string  `json:"accentColorGT,omitempty"`
	AccentColorGte          *string  `json:"accentColorGTE,omitempty"`
	AccentColorLt           *string  `json:"accentColorLT,omitempty"`
	AccentColorLte          *string  `json:"accentColorLTE,omitempty"`
	AccentColorContains     *string  `json:"accentColorContains,omitempty"`
	AccentColorHasPrefix    *string  `json:"accentColorHasPrefix,omitempty"`
	AccentColorHasSuffix    *string  `json:"accentColorHasSuffix,omitempty"`
	AccentColorIsNil        *bool    `json:"accentColorIsNil,omitempty"`
	AccentColorNotNil       *bool    `json:"accentColorNotNil,omitempty"`
	AccentColorEqualFold    *string  `json:"accentColorEqualFold,omitempty"`
	AccentColorContainsFold *string  `json:"accentColorContainsFold,omitempty"`
	// secondary_background_color field predicates
	SecondaryBackgroundColor             *string  `json:"secondaryBackgroundColor,omitempty"`
	SecondaryBackgroundColorNeq          *string  `json:"secondaryBackgroundColorNEQ,omitempty"`
	SecondaryBackgroundColorIn           []string `json:"secondaryBackgroundColorIn,omitempty"`
	SecondaryBackgroundColorNotIn        []string `json:"secondaryBackgroundColorNotIn,omitempty"`
	SecondaryBackgroundColorGt           *string  `json:"secondaryBackgroundColorGT,omitempty"`
	SecondaryBackgroundColorGte          *string  `json:"secondaryBackgroundColorGTE,omitempty"`
	SecondaryBackgroundColorLt           *string  `json:"secondaryBackgroundColorLT,omitempty"`
	SecondaryBackgroundColorLte          *string  `json:"secondaryBackgroundColorLTE,omitempty"`
	SecondaryBackgroundColorContains     *string  `json:"secondaryBackgroundColorContains,omitempty"`
	SecondaryBackgroundColorHasPrefix    *string  `json:"secondaryBackgroundColorHasPrefix,omitempty"`
	SecondaryBackgroundColorHasSuffix    *string  `json:"secondaryBackgroundColorHasSuffix,omitempty"`
	SecondaryBackgroundColorIsNil        *bool    `json:"secondaryBackgroundColorIsNil,omitempty"`
	SecondaryBackgroundColorNotNil       *bool    `json:"secondaryBackgroundColorNotNil,omitempty"`
	SecondaryBackgroundColorEqualFold    *string  `json:"secondaryBackgroundColorEqualFold,omitempty"`
	SecondaryBackgroundColorContainsFold *string  `json:"secondaryBackgroundColorContainsFold,omitempty"`
	// secondary_foreground_color field predicates
	SecondaryForegroundColor             *string  `json:"secondaryForegroundColor,omitempty"`
	SecondaryForegroundColorNeq          *string  `json:"secondaryForegroundColorNEQ,omitempty"`
	SecondaryForegroundColorIn           []string `json:"secondaryForegroundColorIn,omitempty"`
	SecondaryForegroundColorNotIn        []string `json:"secondaryForegroundColorNotIn,omitempty"`
	SecondaryForegroundColorGt           *string  `json:"secondaryForegroundColorGT,omitempty"`
	SecondaryForegroundColorGte          *string  `json:"secondaryForegroundColorGTE,omitempty"`
	SecondaryForegroundColorLt           *string  `json:"secondaryForegroundColorLT,omitempty"`
	SecondaryForegroundColorLte          *string  `json:"secondaryForegroundColorLTE,omitempty"`
	SecondaryForegroundColorContains     *string  `json:"secondaryForegroundColorContains,omitempty"`
	SecondaryForegroundColorHasPrefix    *string  `json:"secondaryForegroundColorHasPrefix,omitempty"`
	SecondaryForegroundColorHasSuffix    *string  `json:"secondaryForegroundColorHasSuffix,omitempty"`
	SecondaryForegroundColorIsNil        *bool    `json:"secondaryForegroundColorIsNil,omitempty"`
	SecondaryForegroundColorNotNil       *bool    `json:"secondaryForegroundColorNotNil,omitempty"`
	SecondaryForegroundColorEqualFold    *string  `json:"secondaryForegroundColorEqualFold,omitempty"`
	SecondaryForegroundColorContainsFold *string  `json:"secondaryForegroundColorContainsFold,omitempty"`
	// environment field predicates
	Environment       *enums.TrustCenterEnvironment  `json:"environment,omitempty"`
	EnvironmentNeq    *enums.TrustCenterEnvironment  `json:"environmentNEQ,omitempty"`
	EnvironmentIn     []enums.TrustCenterEnvironment `json:"environmentIn,omitempty"`
	EnvironmentNotIn  []enums.TrustCenterEnvironment `json:"environmentNotIn,omitempty"`
	EnvironmentIsNil  *bool                          `json:"environmentIsNil,omitempty"`
	EnvironmentNotNil *bool                          `json:"environmentNotNil,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// logo_file edge predicates
	HasLogoFile     *bool             `json:"hasLogoFile,omitempty"`
	HasLogoFileWith []*FileWhereInput `json:"hasLogoFileWith,omitempty"`
	// favicon_file edge predicates
	HasFaviconFile     *bool             `json:"hasFaviconFile,omitempty"`
	HasFaviconFileWith []*FileWhereInput `json:"hasFaviconFileWith,omitempty"`
}

type TrustCenterSubprocessor struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// ID of the subprocessor
	SubprocessorID string `json:"subprocessorID"`
	// ID of the trust center
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// country codes or country where the subprocessor is located
	Countries []string `json:"countries,omitempty"`
	// Category of the subprocessor, e.g. 'Data Warehouse' or 'Infrastructure Hosting'
	Category     string        `json:"category"`
	TrustCenter  *TrustCenter  `json:"trustCenter,omitempty"`
	Subprocessor *Subprocessor `json:"subprocessor"`
}

func (TrustCenterSubprocessor) IsNode() {}

// Return response for createBulkTrustCenterSubprocessor mutation
type TrustCenterSubprocessorBulkCreatePayload struct {
	// Created trustCenterSubprocessors
	TrustCenterSubprocessors []*TrustCenterSubprocessor `json:"trustCenterSubprocessors,omitempty"`
}

// Return response for deleteBulkTrustCenterSubprocessor mutation
type TrustCenterSubprocessorBulkDeletePayload struct {
	// Deleted trustCenterSubprocessor IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// Return response for updateBulkTrustCenterSubprocessor mutation
type TrustCenterSubprocessorBulkUpdatePayload struct {
	// Updated trustCenterSubprocessors
	TrustCenterSubprocessors []*TrustCenterSubprocessor `json:"trustCenterSubprocessors,omitempty"`
	// IDs of the updated trustCenterSubprocessors
	UpdatedIDs []string `json:"updatedIDs,omitempty"`
}

// A connection to a list of items.
type TrustCenterSubprocessorConnection struct {
	// A list of edges.
	Edges []*TrustCenterSubprocessorEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTrustCenterSubprocessor mutation
type TrustCenterSubprocessorCreatePayload struct {
	// Created trustCenterSubprocessor
	TrustCenterSubprocessor *TrustCenterSubprocessor `json:"trustCenterSubprocessor"`
}

// Return response for deleteTrustCenterSubprocessor mutation
type TrustCenterSubprocessorDeletePayload struct {
	// Deleted trustCenterSubprocessor ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TrustCenterSubprocessorEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterSubprocessor `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TrustCenterSubprocessorHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// ID of the subprocessor
	SubprocessorID string `json:"subprocessorID"`
	// ID of the trust center
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// country codes or country where the subprocessor is located
	Countries []string `json:"countries,omitempty"`
	// Category of the subprocessor, e.g. 'Data Warehouse' or 'Infrastructure Hosting'
	Category string `json:"category"`
}

func (TrustCenterSubprocessorHistory) IsNode() {}

// A connection to a list of items.
type TrustCenterSubprocessorHistoryConnection struct {
	// A list of edges.
	Edges []*TrustCenterSubprocessorHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TrustCenterSubprocessorHistoryEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterSubprocessorHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TrustCenterSubprocessorHistory connections
type TrustCenterSubprocessorHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterSubprocessorHistories.
	Field TrustCenterSubprocessorHistoryOrderField `json:"field"`
}

// TrustCenterSubprocessorHistoryWhereInput is used for filtering TrustCenterSubprocessorHistory objects.
// Input was generated by ent.
type TrustCenterSubprocessorHistoryWhereInput struct {
	Not *TrustCenterSubprocessorHistoryWhereInput   `json:"not,omitempty"`
	And []*TrustCenterSubprocessorHistoryWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterSubprocessorHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// subprocessor_id field predicates
	SubprocessorID             *string  `json:"subprocessorID,omitempty"`
	SubprocessorIdneq          *string  `json:"subprocessorIDNEQ,omitempty"`
	SubprocessorIDIn           []string `json:"subprocessorIDIn,omitempty"`
	SubprocessorIDNotIn        []string `json:"subprocessorIDNotIn,omitempty"`
	SubprocessorIdgt           *string  `json:"subprocessorIDGT,omitempty"`
	SubprocessorIdgte          *string  `json:"subprocessorIDGTE,omitempty"`
	SubprocessorIdlt           *string  `json:"subprocessorIDLT,omitempty"`
	SubprocessorIdlte          *string  `json:"subprocessorIDLTE,omitempty"`
	SubprocessorIDContains     *string  `json:"subprocessorIDContains,omitempty"`
	SubprocessorIDHasPrefix    *string  `json:"subprocessorIDHasPrefix,omitempty"`
	SubprocessorIDHasSuffix    *string  `json:"subprocessorIDHasSuffix,omitempty"`
	SubprocessorIDEqualFold    *string  `json:"subprocessorIDEqualFold,omitempty"`
	SubprocessorIDContainsFold *string  `json:"subprocessorIDContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
}

// Ordering options for TrustCenterSubprocessor connections
type TrustCenterSubprocessorOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterSubprocessors.
	Field TrustCenterSubprocessorOrderField `json:"field"`
}

// Return response for updateTrustCenterSubprocessor mutation
type TrustCenterSubprocessorUpdatePayload struct {
	// Updated trustCenterSubprocessor
	TrustCenterSubprocessor *TrustCenterSubprocessor `json:"trustCenterSubprocessor"`
}

// TrustCenterSubprocessorWhereInput is used for filtering TrustCenterSubprocessor objects.
// Input was generated by ent.
type TrustCenterSubprocessorWhereInput struct {
	Not *TrustCenterSubprocessorWhereInput   `json:"not,omitempty"`
	And []*TrustCenterSubprocessorWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterSubprocessorWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// subprocessor_id field predicates
	SubprocessorID             *string  `json:"subprocessorID,omitempty"`
	SubprocessorIdneq          *string  `json:"subprocessorIDNEQ,omitempty"`
	SubprocessorIDIn           []string `json:"subprocessorIDIn,omitempty"`
	SubprocessorIDNotIn        []string `json:"subprocessorIDNotIn,omitempty"`
	SubprocessorIdgt           *string  `json:"subprocessorIDGT,omitempty"`
	SubprocessorIdgte          *string  `json:"subprocessorIDGTE,omitempty"`
	SubprocessorIdlt           *string  `json:"subprocessorIDLT,omitempty"`
	SubprocessorIdlte          *string  `json:"subprocessorIDLTE,omitempty"`
	SubprocessorIDContains     *string  `json:"subprocessorIDContains,omitempty"`
	SubprocessorIDHasPrefix    *string  `json:"subprocessorIDHasPrefix,omitempty"`
	SubprocessorIDHasSuffix    *string  `json:"subprocessorIDHasSuffix,omitempty"`
	SubprocessorIDEqualFold    *string  `json:"subprocessorIDEqualFold,omitempty"`
	SubprocessorIDContainsFold *string  `json:"subprocessorIDContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// trust_center edge predicates
	HasTrustCenter     *bool                    `json:"hasTrustCenter,omitempty"`
	HasTrustCenterWith []*TrustCenterWhereInput `json:"hasTrustCenterWith,omitempty"`
	// subprocessor edge predicates
	HasSubprocessor     *bool                     `json:"hasSubprocessor,omitempty"`
	HasSubprocessorWith []*SubprocessorWhereInput `json:"hasSubprocessorWith,omitempty"`
}

// Return response for updateTrustCenter mutation
type TrustCenterUpdatePayload struct {
	// Updated trustCenter
	TrustCenter *TrustCenter `json:"trustCenter"`
}

type TrustCenterWatermarkConfig struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// ID of the trust center
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// whether the watermarking is enabled for all trust center documents, default is true
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// ID of the file containing the document
	LogoID *string `json:"logoID,omitempty"`
	// text to watermark the document with
	Text *string `json:"text,omitempty"`
	// font size of the watermark text
	FontSize *float64 `json:"fontSize,omitempty"`
	// opacity of the watermark text
	Opacity *float64 `json:"opacity,omitempty"`
	// rotation of the watermark text
	Rotation *float64 `json:"rotation,omitempty"`
	// color of the watermark text
	Color *string `json:"color,omitempty"`
	// font of the watermark text
	Font        *enums.Font    `json:"font,omitempty"`
	Owner       *Organization  `json:"owner,omitempty"`
	TrustCenter []*TrustCenter `json:"trustCenter,omitempty"`
	// the file containing the image for watermarking, if applicable
	File *File `json:"file,omitempty"`
}

func (TrustCenterWatermarkConfig) IsNode() {}

// Return response for createBulkTrustCenterWatermarkConfig mutation
type TrustCenterWatermarkConfigBulkCreatePayload struct {
	// Created trustCenterWatermarkConfigs
	TrustCenterWatermarkConfigs []*TrustCenterWatermarkConfig `json:"trustCenterWatermarkConfigs,omitempty"`
}

// A connection to a list of items.
type TrustCenterWatermarkConfigConnection struct {
	// A list of edges.
	Edges []*TrustCenterWatermarkConfigEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTrustCenterWatermarkConfig mutation
type TrustCenterWatermarkConfigCreatePayload struct {
	// Created trustCenterWatermarkConfig
	TrustCenterWatermarkConfig *TrustCenterWatermarkConfig `json:"trustCenterWatermarkConfig"`
}

// Return response for deleteTrustCenterWatermarkConfig mutation
type TrustCenterWatermarkConfigDeletePayload struct {
	// Deleted trustCenterWatermarkConfig ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TrustCenterWatermarkConfigEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterWatermarkConfig `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TrustCenterWatermarkConfigHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// ID of the trust center
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// whether the watermarking is enabled for all trust center documents, default is true
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// ID of the file containing the document
	LogoID *string `json:"logoID,omitempty"`
	// text to watermark the document with
	Text *string `json:"text,omitempty"`
	// font size of the watermark text
	FontSize *float64 `json:"fontSize,omitempty"`
	// opacity of the watermark text
	Opacity *float64 `json:"opacity,omitempty"`
	// rotation of the watermark text
	Rotation *float64 `json:"rotation,omitempty"`
	// color of the watermark text
	Color *string `json:"color,omitempty"`
	// font of the watermark text
	Font *enums.Font `json:"font,omitempty"`
}

func (TrustCenterWatermarkConfigHistory) IsNode() {}

// A connection to a list of items.
type TrustCenterWatermarkConfigHistoryConnection struct {
	// A list of edges.
	Edges []*TrustCenterWatermarkConfigHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TrustCenterWatermarkConfigHistoryEdge struct {
	// The item at the end of the edge.
	Node *TrustCenterWatermarkConfigHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TrustCenterWatermarkConfigHistory connections
type TrustCenterWatermarkConfigHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterWatermarkConfigHistories.
	Field TrustCenterWatermarkConfigHistoryOrderField `json:"field"`
}

// TrustCenterWatermarkConfigHistoryWhereInput is used for filtering TrustCenterWatermarkConfigHistory objects.
// Input was generated by ent.
type TrustCenterWatermarkConfigHistoryWhereInput struct {
	Not *TrustCenterWatermarkConfigHistoryWhereInput   `json:"not,omitempty"`
	And []*TrustCenterWatermarkConfigHistoryWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterWatermarkConfigHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// is_enabled field predicates
	IsEnabled       *bool `json:"isEnabled,omitempty"`
	IsEnabledNeq    *bool `json:"isEnabledNEQ,omitempty"`
	IsEnabledIsNil  *bool `json:"isEnabledIsNil,omitempty"`
	IsEnabledNotNil *bool `json:"isEnabledNotNil,omitempty"`
	// logo_id field predicates
	LogoID             *string  `json:"logoID,omitempty"`
	LogoIdneq          *string  `json:"logoIDNEQ,omitempty"`
	LogoIDIn           []string `json:"logoIDIn,omitempty"`
	LogoIDNotIn        []string `json:"logoIDNotIn,omitempty"`
	LogoIdgt           *string  `json:"logoIDGT,omitempty"`
	LogoIdgte          *string  `json:"logoIDGTE,omitempty"`
	LogoIdlt           *string  `json:"logoIDLT,omitempty"`
	LogoIdlte          *string  `json:"logoIDLTE,omitempty"`
	LogoIDContains     *string  `json:"logoIDContains,omitempty"`
	LogoIDHasPrefix    *string  `json:"logoIDHasPrefix,omitempty"`
	LogoIDHasSuffix    *string  `json:"logoIDHasSuffix,omitempty"`
	LogoIDIsNil        *bool    `json:"logoIDIsNil,omitempty"`
	LogoIDNotNil       *bool    `json:"logoIDNotNil,omitempty"`
	LogoIDEqualFold    *string  `json:"logoIDEqualFold,omitempty"`
	LogoIDContainsFold *string  `json:"logoIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextIsNil        *bool    `json:"textIsNil,omitempty"`
	TextNotNil       *bool    `json:"textNotNil,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
	// font_size field predicates
	FontSize       *float64  `json:"fontSize,omitempty"`
	FontSizeNeq    *float64  `json:"fontSizeNEQ,omitempty"`
	FontSizeIn     []float64 `json:"fontSizeIn,omitempty"`
	FontSizeNotIn  []float64 `json:"fontSizeNotIn,omitempty"`
	FontSizeGt     *float64  `json:"fontSizeGT,omitempty"`
	FontSizeGte    *float64  `json:"fontSizeGTE,omitempty"`
	FontSizeLt     *float64  `json:"fontSizeLT,omitempty"`
	FontSizeLte    *float64  `json:"fontSizeLTE,omitempty"`
	FontSizeIsNil  *bool     `json:"fontSizeIsNil,omitempty"`
	FontSizeNotNil *bool     `json:"fontSizeNotNil,omitempty"`
	// opacity field predicates
	Opacity       *float64  `json:"opacity,omitempty"`
	OpacityNeq    *float64  `json:"opacityNEQ,omitempty"`
	OpacityIn     []float64 `json:"opacityIn,omitempty"`
	OpacityNotIn  []float64 `json:"opacityNotIn,omitempty"`
	OpacityGt     *float64  `json:"opacityGT,omitempty"`
	OpacityGte    *float64  `json:"opacityGTE,omitempty"`
	OpacityLt     *float64  `json:"opacityLT,omitempty"`
	OpacityLte    *float64  `json:"opacityLTE,omitempty"`
	OpacityIsNil  *bool     `json:"opacityIsNil,omitempty"`
	OpacityNotNil *bool     `json:"opacityNotNil,omitempty"`
	// rotation field predicates
	Rotation       *float64  `json:"rotation,omitempty"`
	RotationNeq    *float64  `json:"rotationNEQ,omitempty"`
	RotationIn     []float64 `json:"rotationIn,omitempty"`
	RotationNotIn  []float64 `json:"rotationNotIn,omitempty"`
	RotationGt     *float64  `json:"rotationGT,omitempty"`
	RotationGte    *float64  `json:"rotationGTE,omitempty"`
	RotationLt     *float64  `json:"rotationLT,omitempty"`
	RotationLte    *float64  `json:"rotationLTE,omitempty"`
	RotationIsNil  *bool     `json:"rotationIsNil,omitempty"`
	RotationNotNil *bool     `json:"rotationNotNil,omitempty"`
	// color field predicates
	Color             *string  `json:"color,omitempty"`
	ColorNeq          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGt           *string  `json:"colorGT,omitempty"`
	ColorGte          *string  `json:"colorGTE,omitempty"`
	ColorLt           *string  `json:"colorLT,omitempty"`
	ColorLte          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorIsNil        *bool    `json:"colorIsNil,omitempty"`
	ColorNotNil       *bool    `json:"colorNotNil,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`
	// font field predicates
	Font       *enums.Font  `json:"font,omitempty"`
	FontNeq    *enums.Font  `json:"fontNEQ,omitempty"`
	FontIn     []enums.Font `json:"fontIn,omitempty"`
	FontNotIn  []enums.Font `json:"fontNotIn,omitempty"`
	FontIsNil  *bool        `json:"fontIsNil,omitempty"`
	FontNotNil *bool        `json:"fontNotNil,omitempty"`
}

// Ordering options for TrustCenterWatermarkConfig connections
type TrustCenterWatermarkConfigOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustCenterWatermarkConfigs.
	Field TrustCenterWatermarkConfigOrderField `json:"field"`
}

// Return response for updateTrustCenterWatermarkConfig mutation
type TrustCenterWatermarkConfigUpdatePayload struct {
	// Updated trustCenterWatermarkConfig
	TrustCenterWatermarkConfig *TrustCenterWatermarkConfig `json:"trustCenterWatermarkConfig"`
}

// TrustCenterWatermarkConfigWhereInput is used for filtering TrustCenterWatermarkConfig objects.
// Input was generated by ent.
type TrustCenterWatermarkConfigWhereInput struct {
	Not *TrustCenterWatermarkConfigWhereInput   `json:"not,omitempty"`
	And []*TrustCenterWatermarkConfigWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterWatermarkConfigWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// trust_center_id field predicates
	TrustCenterID             *string  `json:"trustCenterID,omitempty"`
	TrustCenterIdneq          *string  `json:"trustCenterIDNEQ,omitempty"`
	TrustCenterIDIn           []string `json:"trustCenterIDIn,omitempty"`
	TrustCenterIDNotIn        []string `json:"trustCenterIDNotIn,omitempty"`
	TrustCenterIdgt           *string  `json:"trustCenterIDGT,omitempty"`
	TrustCenterIdgte          *string  `json:"trustCenterIDGTE,omitempty"`
	TrustCenterIdlt           *string  `json:"trustCenterIDLT,omitempty"`
	TrustCenterIdlte          *string  `json:"trustCenterIDLTE,omitempty"`
	TrustCenterIDContains     *string  `json:"trustCenterIDContains,omitempty"`
	TrustCenterIDHasPrefix    *string  `json:"trustCenterIDHasPrefix,omitempty"`
	TrustCenterIDHasSuffix    *string  `json:"trustCenterIDHasSuffix,omitempty"`
	TrustCenterIDIsNil        *bool    `json:"trustCenterIDIsNil,omitempty"`
	TrustCenterIDNotNil       *bool    `json:"trustCenterIDNotNil,omitempty"`
	TrustCenterIDEqualFold    *string  `json:"trustCenterIDEqualFold,omitempty"`
	TrustCenterIDContainsFold *string  `json:"trustCenterIDContainsFold,omitempty"`
	// is_enabled field predicates
	IsEnabled       *bool `json:"isEnabled,omitempty"`
	IsEnabledNeq    *bool `json:"isEnabledNEQ,omitempty"`
	IsEnabledIsNil  *bool `json:"isEnabledIsNil,omitempty"`
	IsEnabledNotNil *bool `json:"isEnabledNotNil,omitempty"`
	// logo_id field predicates
	LogoID             *string  `json:"logoID,omitempty"`
	LogoIdneq          *string  `json:"logoIDNEQ,omitempty"`
	LogoIDIn           []string `json:"logoIDIn,omitempty"`
	LogoIDNotIn        []string `json:"logoIDNotIn,omitempty"`
	LogoIdgt           *string  `json:"logoIDGT,omitempty"`
	LogoIdgte          *string  `json:"logoIDGTE,omitempty"`
	LogoIdlt           *string  `json:"logoIDLT,omitempty"`
	LogoIdlte          *string  `json:"logoIDLTE,omitempty"`
	LogoIDContains     *string  `json:"logoIDContains,omitempty"`
	LogoIDHasPrefix    *string  `json:"logoIDHasPrefix,omitempty"`
	LogoIDHasSuffix    *string  `json:"logoIDHasSuffix,omitempty"`
	LogoIDIsNil        *bool    `json:"logoIDIsNil,omitempty"`
	LogoIDNotNil       *bool    `json:"logoIDNotNil,omitempty"`
	LogoIDEqualFold    *string  `json:"logoIDEqualFold,omitempty"`
	LogoIDContainsFold *string  `json:"logoIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextIsNil        *bool    `json:"textIsNil,omitempty"`
	TextNotNil       *bool    `json:"textNotNil,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
	// font_size field predicates
	FontSize       *float64  `json:"fontSize,omitempty"`
	FontSizeNeq    *float64  `json:"fontSizeNEQ,omitempty"`
	FontSizeIn     []float64 `json:"fontSizeIn,omitempty"`
	FontSizeNotIn  []float64 `json:"fontSizeNotIn,omitempty"`
	FontSizeGt     *float64  `json:"fontSizeGT,omitempty"`
	FontSizeGte    *float64  `json:"fontSizeGTE,omitempty"`
	FontSizeLt     *float64  `json:"fontSizeLT,omitempty"`
	FontSizeLte    *float64  `json:"fontSizeLTE,omitempty"`
	FontSizeIsNil  *bool     `json:"fontSizeIsNil,omitempty"`
	FontSizeNotNil *bool     `json:"fontSizeNotNil,omitempty"`
	// opacity field predicates
	Opacity       *float64  `json:"opacity,omitempty"`
	OpacityNeq    *float64  `json:"opacityNEQ,omitempty"`
	OpacityIn     []float64 `json:"opacityIn,omitempty"`
	OpacityNotIn  []float64 `json:"opacityNotIn,omitempty"`
	OpacityGt     *float64  `json:"opacityGT,omitempty"`
	OpacityGte    *float64  `json:"opacityGTE,omitempty"`
	OpacityLt     *float64  `json:"opacityLT,omitempty"`
	OpacityLte    *float64  `json:"opacityLTE,omitempty"`
	OpacityIsNil  *bool     `json:"opacityIsNil,omitempty"`
	OpacityNotNil *bool     `json:"opacityNotNil,omitempty"`
	// rotation field predicates
	Rotation       *float64  `json:"rotation,omitempty"`
	RotationNeq    *float64  `json:"rotationNEQ,omitempty"`
	RotationIn     []float64 `json:"rotationIn,omitempty"`
	RotationNotIn  []float64 `json:"rotationNotIn,omitempty"`
	RotationGt     *float64  `json:"rotationGT,omitempty"`
	RotationGte    *float64  `json:"rotationGTE,omitempty"`
	RotationLt     *float64  `json:"rotationLT,omitempty"`
	RotationLte    *float64  `json:"rotationLTE,omitempty"`
	RotationIsNil  *bool     `json:"rotationIsNil,omitempty"`
	RotationNotNil *bool     `json:"rotationNotNil,omitempty"`
	// color field predicates
	Color             *string  `json:"color,omitempty"`
	ColorNeq          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGt           *string  `json:"colorGT,omitempty"`
	ColorGte          *string  `json:"colorGTE,omitempty"`
	ColorLt           *string  `json:"colorLT,omitempty"`
	ColorLte          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorIsNil        *bool    `json:"colorIsNil,omitempty"`
	ColorNotNil       *bool    `json:"colorNotNil,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`
	// font field predicates
	Font       *enums.Font  `json:"font,omitempty"`
	FontNeq    *enums.Font  `json:"fontNEQ,omitempty"`
	FontIn     []enums.Font `json:"fontIn,omitempty"`
	FontNotIn  []enums.Font `json:"fontNotIn,omitempty"`
	FontIsNil  *bool        `json:"fontIsNil,omitempty"`
	FontNotNil *bool        `json:"fontNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// trust_center edge predicates
	HasTrustCenter     *bool                    `json:"hasTrustCenter,omitempty"`
	HasTrustCenterWith []*TrustCenterWhereInput `json:"hasTrustCenterWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

// TrustCenterWhereInput is used for filtering TrustCenter objects.
// Input was generated by ent.
type TrustCenterWhereInput struct {
	Not *TrustCenterWhereInput   `json:"not,omitempty"`
	And []*TrustCenterWhereInput `json:"and,omitempty"`
	Or  []*TrustCenterWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// slug field predicates
	Slug             *string  `json:"slug,omitempty"`
	SlugNeq          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGt           *string  `json:"slugGT,omitempty"`
	SlugGte          *string  `json:"slugGTE,omitempty"`
	SlugLt           *string  `json:"slugLT,omitempty"`
	SlugLte          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        *bool    `json:"slugIsNil,omitempty"`
	SlugNotNil       *bool    `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`
	// custom_domain_id field predicates
	CustomDomainID             *string  `json:"customDomainID,omitempty"`
	CustomDomainIdneq          *string  `json:"customDomainIDNEQ,omitempty"`
	CustomDomainIDIn           []string `json:"customDomainIDIn,omitempty"`
	CustomDomainIDNotIn        []string `json:"customDomainIDNotIn,omitempty"`
	CustomDomainIdgt           *string  `json:"customDomainIDGT,omitempty"`
	CustomDomainIdgte          *string  `json:"customDomainIDGTE,omitempty"`
	CustomDomainIdlt           *string  `json:"customDomainIDLT,omitempty"`
	CustomDomainIdlte          *string  `json:"customDomainIDLTE,omitempty"`
	CustomDomainIDContains     *string  `json:"customDomainIDContains,omitempty"`
	CustomDomainIDHasPrefix    *string  `json:"customDomainIDHasPrefix,omitempty"`
	CustomDomainIDHasSuffix    *string  `json:"customDomainIDHasSuffix,omitempty"`
	CustomDomainIDIsNil        *bool    `json:"customDomainIDIsNil,omitempty"`
	CustomDomainIDNotNil       *bool    `json:"customDomainIDNotNil,omitempty"`
	CustomDomainIDEqualFold    *string  `json:"customDomainIDEqualFold,omitempty"`
	CustomDomainIDContainsFold *string  `json:"customDomainIDContainsFold,omitempty"`
	// preview_domain_id field predicates
	PreviewDomainID             *string  `json:"previewDomainID,omitempty"`
	PreviewDomainIdneq          *string  `json:"previewDomainIDNEQ,omitempty"`
	PreviewDomainIDIn           []string `json:"previewDomainIDIn,omitempty"`
	PreviewDomainIDNotIn        []string `json:"previewDomainIDNotIn,omitempty"`
	PreviewDomainIdgt           *string  `json:"previewDomainIDGT,omitempty"`
	PreviewDomainIdgte          *string  `json:"previewDomainIDGTE,omitempty"`
	PreviewDomainIdlt           *string  `json:"previewDomainIDLT,omitempty"`
	PreviewDomainIdlte          *string  `json:"previewDomainIDLTE,omitempty"`
	PreviewDomainIDContains     *string  `json:"previewDomainIDContains,omitempty"`
	PreviewDomainIDHasPrefix    *string  `json:"previewDomainIDHasPrefix,omitempty"`
	PreviewDomainIDHasSuffix    *string  `json:"previewDomainIDHasSuffix,omitempty"`
	PreviewDomainIDIsNil        *bool    `json:"previewDomainIDIsNil,omitempty"`
	PreviewDomainIDNotNil       *bool    `json:"previewDomainIDNotNil,omitempty"`
	PreviewDomainIDEqualFold    *string  `json:"previewDomainIDEqualFold,omitempty"`
	PreviewDomainIDContainsFold *string  `json:"previewDomainIDContainsFold,omitempty"`
	// pirsch_domain_id field predicates
	PirschDomainID             *string  `json:"pirschDomainID,omitempty"`
	PirschDomainIdneq          *string  `json:"pirschDomainIDNEQ,omitempty"`
	PirschDomainIDIn           []string `json:"pirschDomainIDIn,omitempty"`
	PirschDomainIDNotIn        []string `json:"pirschDomainIDNotIn,omitempty"`
	PirschDomainIdgt           *string  `json:"pirschDomainIDGT,omitempty"`
	PirschDomainIdgte          *string  `json:"pirschDomainIDGTE,omitempty"`
	PirschDomainIdlt           *string  `json:"pirschDomainIDLT,omitempty"`
	PirschDomainIdlte          *string  `json:"pirschDomainIDLTE,omitempty"`
	PirschDomainIDContains     *string  `json:"pirschDomainIDContains,omitempty"`
	PirschDomainIDHasPrefix    *string  `json:"pirschDomainIDHasPrefix,omitempty"`
	PirschDomainIDHasSuffix    *string  `json:"pirschDomainIDHasSuffix,omitempty"`
	PirschDomainIDIsNil        *bool    `json:"pirschDomainIDIsNil,omitempty"`
	PirschDomainIDNotNil       *bool    `json:"pirschDomainIDNotNil,omitempty"`
	PirschDomainIDEqualFold    *string  `json:"pirschDomainIDEqualFold,omitempty"`
	PirschDomainIDContainsFold *string  `json:"pirschDomainIDContainsFold,omitempty"`
	// pirsch_identification_code field predicates
	PirschIdentificationCode             *string  `json:"pirschIdentificationCode,omitempty"`
	PirschIdentificationCodeNeq          *string  `json:"pirschIdentificationCodeNEQ,omitempty"`
	PirschIdentificationCodeIn           []string `json:"pirschIdentificationCodeIn,omitempty"`
	PirschIdentificationCodeNotIn        []string `json:"pirschIdentificationCodeNotIn,omitempty"`
	PirschIdentificationCodeGt           *string  `json:"pirschIdentificationCodeGT,omitempty"`
	PirschIdentificationCodeGte          *string  `json:"pirschIdentificationCodeGTE,omitempty"`
	PirschIdentificationCodeLt           *string  `json:"pirschIdentificationCodeLT,omitempty"`
	PirschIdentificationCodeLte          *string  `json:"pirschIdentificationCodeLTE,omitempty"`
	PirschIdentificationCodeContains     *string  `json:"pirschIdentificationCodeContains,omitempty"`
	PirschIdentificationCodeHasPrefix    *string  `json:"pirschIdentificationCodeHasPrefix,omitempty"`
	PirschIdentificationCodeHasSuffix    *string  `json:"pirschIdentificationCodeHasSuffix,omitempty"`
	PirschIdentificationCodeIsNil        *bool    `json:"pirschIdentificationCodeIsNil,omitempty"`
	PirschIdentificationCodeNotNil       *bool    `json:"pirschIdentificationCodeNotNil,omitempty"`
	PirschIdentificationCodeEqualFold    *string  `json:"pirschIdentificationCodeEqualFold,omitempty"`
	PirschIdentificationCodeContainsFold *string  `json:"pirschIdentificationCodeContainsFold,omitempty"`
	// preview_status field predicates
	PreviewStatus       *enums.TrustCenterPreviewStatus  `json:"previewStatus,omitempty"`
	PreviewStatusNeq    *enums.TrustCenterPreviewStatus  `json:"previewStatusNEQ,omitempty"`
	PreviewStatusIn     []enums.TrustCenterPreviewStatus `json:"previewStatusIn,omitempty"`
	PreviewStatusNotIn  []enums.TrustCenterPreviewStatus `json:"previewStatusNotIn,omitempty"`
	PreviewStatusIsNil  *bool                            `json:"previewStatusIsNil,omitempty"`
	PreviewStatusNotNil *bool                            `json:"previewStatusNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// custom_domain edge predicates
	HasCustomDomain     *bool                     `json:"hasCustomDomain,omitempty"`
	HasCustomDomainWith []*CustomDomainWhereInput `json:"hasCustomDomainWith,omitempty"`
	// preview_domain edge predicates
	HasPreviewDomain     *bool                     `json:"hasPreviewDomain,omitempty"`
	HasPreviewDomainWith []*CustomDomainWhereInput `json:"hasPreviewDomainWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                           `json:"hasSetting,omitempty"`
	HasSettingWith []*TrustCenterSettingWhereInput `json:"hasSettingWith,omitempty"`
	// preview_setting edge predicates
	HasPreviewSetting     *bool                           `json:"hasPreviewSetting,omitempty"`
	HasPreviewSettingWith []*TrustCenterSettingWhereInput `json:"hasPreviewSettingWith,omitempty"`
	// watermark_config edge predicates
	HasWatermarkConfig     *bool                                   `json:"hasWatermarkConfig,omitempty"`
	HasWatermarkConfigWith []*TrustCenterWatermarkConfigWhereInput `json:"hasWatermarkConfigWith,omitempty"`
	// trust_center_subprocessors edge predicates
	HasTrustCenterSubprocessors     *bool                                `json:"hasTrustCenterSubprocessors,omitempty"`
	HasTrustCenterSubprocessorsWith []*TrustCenterSubprocessorWhereInput `json:"hasTrustCenterSubprocessorsWith,omitempty"`
	// trust_center_docs edge predicates
	HasTrustCenterDocs     *bool                       `json:"hasTrustCenterDocs,omitempty"`
	HasTrustCenterDocsWith []*TrustCenterDocWhereInput `json:"hasTrustCenterDocsWith,omitempty"`
	// trust_center_compliances edge predicates
	HasTrustCenterCompliances     *bool                              `json:"hasTrustCenterCompliances,omitempty"`
	HasTrustCenterCompliancesWith []*TrustCenterComplianceWhereInput `json:"hasTrustCenterCompliancesWith,omitempty"`
	// templates edge predicates
	HasTemplates     *bool                 `json:"hasTemplates,omitempty"`
	HasTemplatesWith []*TemplateWhereInput `json:"hasTemplatesWith,omitempty"`
	// posts edge predicates
	HasPosts     *bool             `json:"hasPosts,omitempty"`
	HasPostsWith []*NoteWhereInput `json:"hasPostsWith,omitempty"`
	// trustcenter_entities edge predicates
	HasTrustcenterEntities     *bool                          `json:"hasTrustcenterEntities,omitempty"`
	HasTrustcenterEntitiesWith []*TrustcenterEntityWhereInput `json:"hasTrustcenterEntitiesWith,omitempty"`
}

type TrustcenterEntity struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// The local logo file id
	LogoFileID *string `json:"logoFileID,omitempty"`
	// URL of customer's website
	URL *string `json:"url,omitempty"`
	// The trust center this entity belongs to
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// The name of the tag definition
	Name string `json:"name"`
	// The entity type for the customer entity
	EntityTypeID *string      `json:"entityTypeID,omitempty"`
	LogoFile     *File        `json:"logoFile,omitempty"`
	TrustCenter  *TrustCenter `json:"trustCenter,omitempty"`
	EntityType   *EntityType  `json:"entityType,omitempty"`
}

func (TrustcenterEntity) IsNode() {}

// Return response for createBulkTrustcenterEntity mutation
type TrustcenterEntityBulkCreatePayload struct {
	// Created trustcenterEntitys
	TrustcenterEntities []*TrustcenterEntity `json:"trustcenterEntities,omitempty"`
}

// A connection to a list of items.
type TrustcenterEntityConnection struct {
	// A list of edges.
	Edges []*TrustcenterEntityEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTrustcenterEntity mutation
type TrustcenterEntityCreatePayload struct {
	// Created trustcenterEntity
	TrustcenterEntity *TrustcenterEntity `json:"trustcenterEntity"`
}

// Return response for deleteTrustcenterEntity mutation
type TrustcenterEntityDeletePayload struct {
	// Deleted trustcenterEntity ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TrustcenterEntityEdge struct {
	// The item at the end of the edge.
	Node *TrustcenterEntity `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TrustcenterEntityHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// The local logo file id
	LogoFileID *string `json:"logoFileID,omitempty"`
	// URL of customer's website
	URL *string `json:"url,omitempty"`
	// The trust center this entity belongs to
	TrustCenterID *string `json:"trustCenterID,omitempty"`
	// The name of the tag definition
	Name string `json:"name"`
	// The entity type for the customer entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
}

func (TrustcenterEntityHistory) IsNode() {}

// A connection to a list of items.
type TrustcenterEntityHistoryConnection struct {
	// A list of edges.
	Edges []*TrustcenterEntityHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TrustcenterEntityHistoryEdge struct {
	// The item at the end of the edge.
	Node *TrustcenterEntityHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TrustcenterEntityHistory connections
type TrustcenterEntityHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustcenterEntityHistories.
	Field TrustcenterEntityHistoryOrderField `json:"field"`
}

// TrustcenterEntityHistoryWhereInput is used for filtering TrustcenterEntityHistory objects.
// Input was generated by ent.
type TrustcenterEntityHistoryWhereInput struct {
	Not *TrustcenterEntityHistoryWhereInput   `json:"not,omitempty"`
	And []*TrustcenterEntityHistoryWhereInput `json:"and,omitempty"`
	Or  []*TrustcenterEntityHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// logo_file_id field predicates
	LogoFileID             *string  `json:"logoFileID,omitempty"`
	LogoFileIdneq          *string  `json:"logoFileIDNEQ,omitempty"`
	LogoFileIDIn           []string `json:"logoFileIDIn,omitempty"`
	LogoFileIDNotIn        []string `json:"logoFileIDNotIn,omitempty"`
	LogoFileIdgt           *string  `json:"logoFileIDGT,omitempty"`
	LogoFileIdgte          *string  `json:"logoFileIDGTE,omitempty"`
	LogoFileIdlt           *string  `json:"logoFileIDLT,omitempty"`
	LogoFileIdlte          *string  `json:"logoFileIDLTE,omitempty"`
	LogoFileIDContains     *string  `json:"logoFileIDContains,omitempty"`
	LogoFileIDHasPrefix    *string  `json:"logoFileIDHasPrefix,omitempty"`
	LogoFileIDHasSuffix    *string  `json:"logoFileIDHasSuffix,omitempty"`
	LogoFileIDIsNil        *bool    `json:"logoFileIDIsNil,omitempty"`
	LogoFileIDNotNil       *bool    `json:"logoFileIDNotNil,omitempty"`
	LogoFileIDEqualFold    *string  `json:"logoFileIDEqualFold,omitempty"`
	LogoFileIDContainsFold *string  `json:"logoFileIDContainsFold,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// Ordering options for TrustcenterEntity connections
type TrustcenterEntityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TrustcenterEntities.
	Field TrustcenterEntityOrderField `json:"field"`
}

// Return response for updateTrustcenterEntity mutation
type TrustcenterEntityUpdatePayload struct {
	// Updated trustcenterEntity
	TrustcenterEntity *TrustcenterEntity `json:"trustcenterEntity"`
}

// TrustcenterEntityWhereInput is used for filtering TrustcenterEntity objects.
// Input was generated by ent.
type TrustcenterEntityWhereInput struct {
	Not *TrustcenterEntityWhereInput   `json:"not,omitempty"`
	And []*TrustcenterEntityWhereInput `json:"and,omitempty"`
	Or  []*TrustcenterEntityWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// logo_file_id field predicates
	LogoFileID             *string  `json:"logoFileID,omitempty"`
	LogoFileIdneq          *string  `json:"logoFileIDNEQ,omitempty"`
	LogoFileIDIn           []string `json:"logoFileIDIn,omitempty"`
	LogoFileIDNotIn        []string `json:"logoFileIDNotIn,omitempty"`
	LogoFileIdgt           *string  `json:"logoFileIDGT,omitempty"`
	LogoFileIdgte          *string  `json:"logoFileIDGTE,omitempty"`
	LogoFileIdlt           *string  `json:"logoFileIDLT,omitempty"`
	LogoFileIdlte          *string  `json:"logoFileIDLTE,omitempty"`
	LogoFileIDContains     *string  `json:"logoFileIDContains,omitempty"`
	LogoFileIDHasPrefix    *string  `json:"logoFileIDHasPrefix,omitempty"`
	LogoFileIDHasSuffix    *string  `json:"logoFileIDHasSuffix,omitempty"`
	LogoFileIDIsNil        *bool    `json:"logoFileIDIsNil,omitempty"`
	LogoFileIDNotNil       *bool    `json:"logoFileIDNotNil,omitempty"`
	LogoFileIDEqualFold    *string  `json:"logoFileIDEqualFold,omitempty"`
	LogoFileIDContainsFold *string  `json:"logoFileIDContainsFold,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// logo_file edge predicates
	HasLogoFile     *bool             `json:"hasLogoFile,omitempty"`
	HasLogoFileWith []*FileWhereInput `json:"hasLogoFileWith,omitempty"`
	// trust_center edge predicates
	HasTrustCenter     *bool                    `json:"hasTrustCenter,omitempty"`
	HasTrustCenterWith []*TrustCenterWhereInput `json:"hasTrustCenterWith,omitempty"`
	// entity_type edge predicates
	HasEntityType     *bool                   `json:"hasEntityType,omitempty"`
	HasEntityTypeWith []*EntityTypeWhereInput `json:"hasEntityTypeWith,omitempty"`
}

// UpdateAPITokenInput is used for update APIToken object.
// Input was generated by ent.
type UpdateAPITokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// when the token expires
	ExpiresAt      *time.Time `json:"expiresAt,omitempty"`
	ClearExpiresAt *bool      `json:"clearExpiresAt,omitempty"`
	// a description of the token's purpose
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	Scopes           []string   `json:"scopes,omitempty"`
	AppendScopes     []string   `json:"appendScopes,omitempty"`
	ClearScopes      *bool      `json:"clearScopes,omitempty"`
	LastUsedAt       *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt  *bool      `json:"clearLastUsedAt,omitempty"`
	// whether the token is active
	IsActive      *bool `json:"isActive,omitempty"`
	ClearIsActive *bool `json:"clearIsActive,omitempty"`
	// the reason the token was revoked
	RevokedReason      *string `json:"revokedReason,omitempty"`
	ClearRevokedReason *bool   `json:"clearRevokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy      *string `json:"revokedBy,omitempty"`
	ClearRevokedBy *bool   `json:"clearRevokedBy,omitempty"`
	// when the token was revoked
	RevokedAt      *time.Time `json:"revokedAt,omitempty"`
	ClearRevokedAt *bool      `json:"clearRevokedAt,omitempty"`
	OwnerID        *string    `json:"ownerID,omitempty"`
	ClearOwner     *bool      `json:"clearOwner,omitempty"`
}

// UpdateActionPlanInput is used for update ActionPlan object.
// Input was generated by ent.
type UpdateActionPlanInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// the name of the action_plan
	Name *string `json:"name,omitempty"`
	// status of the action_plan, e.g. draft, published, archived, etc.
	Status      *enums.DocumentStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// type of the action_plan, e.g. compliance, operational, health and safety, etc.
	ActionPlanType      *string `json:"actionPlanType,omitempty"`
	ClearActionPlanType *bool   `json:"clearActionPlanType,omitempty"`
	// details of the action_plan
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// whether approval is required for edits to the action_plan
	ApprovalRequired      *bool `json:"approvalRequired,omitempty"`
	ClearApprovalRequired *bool `json:"clearApprovalRequired,omitempty"`
	// the date the action_plan should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue      *time.Time `json:"reviewDue,omitempty"`
	ClearReviewDue *bool      `json:"clearReviewDue,omitempty"`
	// the frequency at which the action_plan should be reviewed, used to calculate the review_due date
	ReviewFrequency      *enums.Frequency `json:"reviewFrequency,omitempty"`
	ClearReviewFrequency *bool            `json:"clearReviewFrequency,omitempty"`
	// auto-generated tag suggestions for the action_plan
	TagSuggestions       []string `json:"tagSuggestions,omitempty"`
	AppendTagSuggestions []string `json:"appendTagSuggestions,omitempty"`
	ClearTagSuggestions  *bool    `json:"clearTagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the action_plan
	DismissedTagSuggestions       []string `json:"dismissedTagSuggestions,omitempty"`
	AppendDismissedTagSuggestions []string `json:"appendDismissedTagSuggestions,omitempty"`
	ClearDismissedTagSuggestions  *bool    `json:"clearDismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the action_plan
	ControlSuggestions       []string `json:"controlSuggestions,omitempty"`
	AppendControlSuggestions []string `json:"appendControlSuggestions,omitempty"`
	ClearControlSuggestions  *bool    `json:"clearControlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the action_plan
	DismissedControlSuggestions       []string `json:"dismissedControlSuggestions,omitempty"`
	AppendDismissedControlSuggestions []string `json:"appendDismissedControlSuggestions,omitempty"`
	ClearDismissedControlSuggestions  *bool    `json:"clearDismissedControlSuggestions,omitempty"`
	// suggested improvements for the action_plan
	ImprovementSuggestions       []string `json:"improvementSuggestions,omitempty"`
	AppendImprovementSuggestions []string `json:"appendImprovementSuggestions,omitempty"`
	ClearImprovementSuggestions  *bool    `json:"clearImprovementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the action_plan
	DismissedImprovementSuggestions       []string `json:"dismissedImprovementSuggestions,omitempty"`
	AppendDismissedImprovementSuggestions []string `json:"appendDismissedImprovementSuggestions,omitempty"`
	ClearDismissedImprovementSuggestions  *bool    `json:"clearDismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the action_plan
	URL      *string `json:"url,omitempty"`
	ClearURL *bool   `json:"clearURL,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the kind of the action_plan
	ActionPlanKindName      *string `json:"actionPlanKindName,omitempty"`
	ClearActionPlanKindName *bool   `json:"clearActionPlanKindName,omitempty"`
	// short title describing the action plan
	Title *string `json:"title,omitempty"`
	// detailed description of remediation steps and objectives
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// due date of the action plan
	DueDate      *time.Time `json:"dueDate,omitempty"`
	ClearDueDate *bool      `json:"clearDueDate,omitempty"`
	// timestamp when the action plan was completed
	CompletedAt      *time.Time `json:"completedAt,omitempty"`
	ClearCompletedAt *bool      `json:"clearCompletedAt,omitempty"`
	// priority of the action plan
	Priority      *enums.Priority `json:"priority,omitempty"`
	ClearPriority *bool           `json:"clearPriority,omitempty"`
	// indicates if the action plan requires explicit approval before closure
	RequiresApproval *bool `json:"requiresApproval,omitempty"`
	// true when the action plan is currently blocked
	Blocked *bool `json:"blocked,omitempty"`
	// context on why the action plan is blocked
	BlockerReason      *string `json:"blockerReason,omitempty"`
	ClearBlockerReason *bool   `json:"clearBlockerReason,omitempty"`
	// additional structured metadata for the action plan
	Metadata      map[string]any `json:"metadata,omitempty"`
	ClearMetadata *bool          `json:"clearMetadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload      map[string]any `json:"rawPayload,omitempty"`
	ClearRawPayload *bool          `json:"clearRawPayload,omitempty"`
	// source of the action plan
	Source                 *string             `json:"source,omitempty"`
	ClearSource            *bool               `json:"clearSource,omitempty"`
	ApproverID             *string             `json:"approverID,omitempty"`
	ClearApprover          *bool               `json:"clearApprover,omitempty"`
	DelegateID             *string             `json:"delegateID,omitempty"`
	ClearDelegate          *bool               `json:"clearDelegate,omitempty"`
	OwnerID                *string             `json:"ownerID,omitempty"`
	ClearOwner             *bool               `json:"clearOwner,omitempty"`
	ActionPlanKindID       *string             `json:"actionPlanKindID,omitempty"`
	ClearActionPlanKind    *bool               `json:"clearActionPlanKind,omitempty"`
	AddRiskIDs             []string            `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs          []string            `json:"removeRiskIDs,omitempty"`
	ClearRisks             *bool               `json:"clearRisks,omitempty"`
	AddControlIDs          []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs       []string            `json:"removeControlIDs,omitempty"`
	ClearControls          *bool               `json:"clearControls,omitempty"`
	AddProgramIDs          []string            `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs       []string            `json:"removeProgramIDs,omitempty"`
	ClearPrograms          *bool               `json:"clearPrograms,omitempty"`
	AddFindingIDs          []string            `json:"addFindingIDs,omitempty"`
	RemoveFindingIDs       []string            `json:"removeFindingIDs,omitempty"`
	ClearFindings          *bool               `json:"clearFindings,omitempty"`
	AddVulnerabilityIDs    []string            `json:"addVulnerabilityIDs,omitempty"`
	RemoveVulnerabilityIDs []string            `json:"removeVulnerabilityIDs,omitempty"`
	ClearVulnerabilities   *bool               `json:"clearVulnerabilities,omitempty"`
	AddReviewIDs           []string            `json:"addReviewIDs,omitempty"`
	RemoveReviewIDs        []string            `json:"removeReviewIDs,omitempty"`
	ClearReviews           *bool               `json:"clearReviews,omitempty"`
	AddRemediationIDs      []string            `json:"addRemediationIDs,omitempty"`
	RemoveRemediationIDs   []string            `json:"removeRemediationIDs,omitempty"`
	ClearRemediations      *bool               `json:"clearRemediations,omitempty"`
	AddTaskIDs             []string            `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs          []string            `json:"removeTaskIDs,omitempty"`
	ClearTasks             *bool               `json:"clearTasks,omitempty"`
	AddIntegrationIDs      []string            `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs   []string            `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations      *bool               `json:"clearIntegrations,omitempty"`
	FileID                 *string             `json:"fileID,omitempty"`
	ClearFile              *bool               `json:"clearFile,omitempty"`
	RevisionBump           *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateAssessmentInput is used for update Assessment object.
// Input was generated by ent.
type UpdateAssessmentInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the assessment, e.g. cloud providers, marketing team
	Name *string `json:"name,omitempty"`
	// the jsonschema object of the questionnaire. If not provided it will be inherited from the template.
	Jsonconfig      map[string]any `json:"jsonconfig,omitempty"`
	ClearJsonconfig *bool          `json:"clearJsonconfig,omitempty"`
	// the uischema for the template to render in the UI. If not provided, it will be inherited from the template
	Uischema      map[string]any `json:"uischema,omitempty"`
	ClearUischema *bool          `json:"clearUischema,omitempty"`
	// the duration in seconds that the user has to complete the assessment response, defaults to 7 days
	ResponseDueDuration         *int64   `json:"responseDueDuration,omitempty"`
	ClearResponseDueDuration    *bool    `json:"clearResponseDueDuration,omitempty"`
	OwnerID                     *string  `json:"ownerID,omitempty"`
	ClearOwner                  *bool    `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs          []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs       []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups          *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs                []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs             []string `json:"removeEditorIDs,omitempty"`
	ClearEditors                *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs                []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs             []string `json:"removeViewerIDs,omitempty"`
	ClearViewers                *bool    `json:"clearViewers,omitempty"`
	TemplateID                  *string  `json:"templateID,omitempty"`
	ClearTemplate               *bool    `json:"clearTemplate,omitempty"`
	AddAssessmentResponseIDs    []string `json:"addAssessmentResponseIDs,omitempty"`
	RemoveAssessmentResponseIDs []string `json:"removeAssessmentResponseIDs,omitempty"`
	ClearAssessmentResponses    *bool    `json:"clearAssessmentResponses,omitempty"`
}

// UpdateAssetInput is used for update Asset object.
// Input was generated by ent.
type UpdateAssetInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the type of the asset, e.g. technology, domain, device, etc
	AssetType *enums.AssetType `json:"assetType,omitempty"`
	// the name of the asset, e.g. matts computer, office router, IP address, etc
	Name             *string `json:"name,omitempty"`
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// unique identifier like domain, device id, etc
	Identifier      *string `json:"identifier,omitempty"`
	ClearIdentifier *bool   `json:"clearIdentifier,omitempty"`
	// the website of the asset, if applicable
	Website      *string `json:"website,omitempty"`
	ClearWebsite *bool   `json:"clearWebsite,omitempty"`
	// the CPE (Common Platform Enumeration) of the asset, if applicable
	Cpe      *string `json:"cpe,omitempty"`
	ClearCpe *bool   `json:"clearCpe,omitempty"`
	// the categories of the asset, e.g. web server, database, etc
	Categories            []string `json:"categories,omitempty"`
	AppendCategories      []string `json:"appendCategories,omitempty"`
	ClearCategories       *bool    `json:"clearCategories,omitempty"`
	OwnerID               *string  `json:"ownerID,omitempty"`
	ClearOwner            *bool    `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs    []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs          []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool    `json:"clearViewers,omitempty"`
	AddScanIDs            []string `json:"addScanIDs,omitempty"`
	RemoveScanIDs         []string `json:"removeScanIDs,omitempty"`
	ClearScans            *bool    `json:"clearScans,omitempty"`
	AddEntityIDs          []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs       []string `json:"removeEntityIDs,omitempty"`
	ClearEntities         *bool    `json:"clearEntities,omitempty"`
	AddControlIDs         []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs      []string `json:"removeControlIDs,omitempty"`
	ClearControls         *bool    `json:"clearControls,omitempty"`
}

// UpdateContactInput is used for update Contact object.
// Input was generated by ent.
type UpdateContactInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the full name of the contact
	FullName      *string `json:"fullName,omitempty"`
	ClearFullName *bool   `json:"clearFullName,omitempty"`
	// the title of the contact
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// the company of the contact
	Company      *string `json:"company,omitempty"`
	ClearCompany *bool   `json:"clearCompany,omitempty"`
	// the email of the contact
	Email      *string `json:"email,omitempty"`
	ClearEmail *bool   `json:"clearEmail,omitempty"`
	// the phone number of the contact
	PhoneNumber      *string `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool   `json:"clearPhoneNumber,omitempty"`
	// the address of the contact
	Address      *string `json:"address,omitempty"`
	ClearAddress *bool   `json:"clearAddress,omitempty"`
	// status of the contact
	Status          *enums.UserStatus `json:"status,omitempty"`
	OwnerID         *string           `json:"ownerID,omitempty"`
	ClearOwner      *bool             `json:"clearOwner,omitempty"`
	AddEntityIDs    []string          `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string          `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool             `json:"clearEntities,omitempty"`
	AddFileIDs      []string          `json:"addFileIDs,omitempty"`
	RemoveFileIDs   []string          `json:"removeFileIDs,omitempty"`
	ClearFiles      *bool             `json:"clearFiles,omitempty"`
}

// UpdateControlImplementationInput is used for update ControlImplementation object.
// Input was generated by ent.
type UpdateControlImplementationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// status of the %s, e.g. draft, published, archived, etc.
	Status      *enums.DocumentStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// date the control was implemented
	ImplementationDate      *time.Time `json:"implementationDate,omitempty"`
	ClearImplementationDate *bool      `json:"clearImplementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified      *bool `json:"verified,omitempty"`
	ClearVerified *bool `json:"clearVerified,omitempty"`
	// date the control implementation was verified
	VerificationDate      *time.Time `json:"verificationDate,omitempty"`
	ClearVerificationDate *bool      `json:"clearVerificationDate,omitempty"`
	// details of the control implementation
	Details               *string  `json:"details,omitempty"`
	ClearDetails          *bool    `json:"clearDetails,omitempty"`
	AddBlockedGroupIDs    []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs          []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool    `json:"clearViewers,omitempty"`
	AddControlIDs         []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs      []string `json:"removeControlIDs,omitempty"`
	ClearControls         *bool    `json:"clearControls,omitempty"`
	AddSubcontrolIDs      []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs   []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols      *bool    `json:"clearSubcontrols,omitempty"`
	AddTaskIDs            []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs         []string `json:"removeTaskIDs,omitempty"`
	ClearTasks            *bool    `json:"clearTasks,omitempty"`
}

// UpdateControlInput is used for update Control object.
// Input was generated by ent.
type UpdateControlInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// human readable title of the control for quick identification
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// description of what the control is supposed to accomplish
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// additional names (ref_codes) for the control
	Aliases       []string `json:"aliases,omitempty"`
	AppendAliases []string `json:"appendAliases,omitempty"`
	ClearAliases  *bool    `json:"clearAliases,omitempty"`
	// internal reference id of the control, can be used for internal tracking
	ReferenceID      *string `json:"referenceID,omitempty"`
	ClearReferenceID *bool   `json:"clearReferenceID,omitempty"`
	// external auditor id of the control, can be used to map to external audit partner mappings
	AuditorReferenceID      *string `json:"auditorReferenceID,omitempty"`
	ClearAuditorReferenceID *bool   `json:"clearAuditorReferenceID,omitempty"`
	// status of the control
	Status      *enums.ControlStatus `json:"status,omitempty"`
	ClearStatus *bool                `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// the reference framework revision for the control if it came from a standard, empty if not associated with a standard, allows for pulling in updates when the standard is updated
	ReferenceFrameworkRevision      *string `json:"referenceFrameworkRevision,omitempty"`
	ClearReferenceFrameworkRevision *bool   `json:"clearReferenceFrameworkRevision,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType      *enums.ControlType `json:"controlType,omitempty"`
	ClearControlType *bool              `json:"clearControlType,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// category id of the control
	CategoryID      *string `json:"categoryID,omitempty"`
	ClearCategoryID *bool   `json:"clearCategoryID,omitempty"`
	// subcategory of the control
	Subcategory      *string `json:"subcategory,omitempty"`
	ClearSubcategory *bool   `json:"clearSubcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories       []string `json:"mappedCategories,omitempty"`
	AppendMappedCategories []string `json:"appendMappedCategories,omitempty"`
	ClearMappedCategories  *bool    `json:"clearMappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives       []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	AppendAssessmentObjectives []*models.AssessmentObjective `json:"appendAssessmentObjectives,omitempty"`
	ClearAssessmentObjectives  *bool                         `json:"clearAssessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods       []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	AppendAssessmentMethods []*models.AssessmentMethod `json:"appendAssessmentMethods,omitempty"`
	ClearAssessmentMethods  *bool                      `json:"clearAssessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions       []string `json:"controlQuestions,omitempty"`
	AppendControlQuestions []string `json:"appendControlQuestions,omitempty"`
	ClearControlQuestions  *bool    `json:"clearControlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance       []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	AppendImplementationGuidance []*models.ImplementationGuidance `json:"appendImplementationGuidance,omitempty"`
	ClearImplementationGuidance  *bool                            `json:"clearImplementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence       []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	AppendExampleEvidence []*models.ExampleEvidence `json:"appendExampleEvidence,omitempty"`
	ClearExampleEvidence  *bool                     `json:"clearExampleEvidence,omitempty"`
	// references for the control
	References       []*models.Reference `json:"references,omitempty"`
	AppendReferences []*models.Reference `json:"appendReferences,omitempty"`
	ClearReferences  *bool               `json:"clearReferences,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the kind of the control
	ControlKindName      *string `json:"controlKindName,omitempty"`
	ClearControlKindName *bool   `json:"clearControlKindName,omitempty"`
	// the unique reference code for the control
	RefCode                        *string          `json:"refCode,omitempty"`
	AddEvidenceIDs                 []string         `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs              []string         `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                  *bool            `json:"clearEvidence,omitempty"`
	AddControlObjectiveIDs         []string         `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs      []string         `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives         *bool            `json:"clearControlObjectives,omitempty"`
	AddTaskIDs                     []string         `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                  []string         `json:"removeTaskIDs,omitempty"`
	ClearTasks                     *bool            `json:"clearTasks,omitempty"`
	AddNarrativeIDs                []string         `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs             []string         `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives                *bool            `json:"clearNarratives,omitempty"`
	AddRiskIDs                     []string         `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                  []string         `json:"removeRiskIDs,omitempty"`
	ClearRisks                     *bool            `json:"clearRisks,omitempty"`
	AddActionPlanIDs               []string         `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs            []string         `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans               *bool            `json:"clearActionPlans,omitempty"`
	AddProcedureIDs                []string         `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs             []string         `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                *bool            `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs           []string         `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs        []string         `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies          *bool            `json:"clearInternalPolicies,omitempty"`
	AddCommentIDs                  []string         `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs               []string         `json:"removeCommentIDs,omitempty"`
	ClearComments                  *bool            `json:"clearComments,omitempty"`
	ControlOwnerID                 *string          `json:"controlOwnerID,omitempty"`
	ClearControlOwner              *bool            `json:"clearControlOwner,omitempty"`
	DelegateID                     *string          `json:"delegateID,omitempty"`
	ClearDelegate                  *bool            `json:"clearDelegate,omitempty"`
	ResponsiblePartyID             *string          `json:"responsiblePartyID,omitempty"`
	ClearResponsibleParty          *bool            `json:"clearResponsibleParty,omitempty"`
	AddBlockedGroupIDs             []string         `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs          []string         `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups             *bool            `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs                   []string         `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs                []string         `json:"removeEditorIDs,omitempty"`
	ClearEditors                   *bool            `json:"clearEditors,omitempty"`
	ControlKindID                  *string          `json:"controlKindID,omitempty"`
	ClearControlKind               *bool            `json:"clearControlKind,omitempty"`
	StandardID                     *string          `json:"standardID,omitempty"`
	ClearStandard                  *bool            `json:"clearStandard,omitempty"`
	AddProgramIDs                  []string         `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs               []string         `json:"removeProgramIDs,omitempty"`
	ClearPrograms                  *bool            `json:"clearPrograms,omitempty"`
	AddAssetIDs                    []string         `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs                 []string         `json:"removeAssetIDs,omitempty"`
	ClearAssets                    *bool            `json:"clearAssets,omitempty"`
	AddScanIDs                     []string         `json:"addScanIDs,omitempty"`
	RemoveScanIDs                  []string         `json:"removeScanIDs,omitempty"`
	ClearScans                     *bool            `json:"clearScans,omitempty"`
	AddFindingIDs                  []string         `json:"addFindingIDs,omitempty"`
	RemoveFindingIDs               []string         `json:"removeFindingIDs,omitempty"`
	ClearFindings                  *bool            `json:"clearFindings,omitempty"`
	AddControlImplementationIDs    []string         `json:"addControlImplementationIDs,omitempty"`
	RemoveControlImplementationIDs []string         `json:"removeControlImplementationIDs,omitempty"`
	ClearControlImplementations    *bool            `json:"clearControlImplementations,omitempty"`
	AddSubcontrolIDs               []string         `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs            []string         `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols               *bool            `json:"clearSubcontrols,omitempty"`
	AddScheduledJobIDs             []string         `json:"addScheduledJobIDs,omitempty"`
	RemoveScheduledJobIDs          []string         `json:"removeScheduledJobIDs,omitempty"`
	ClearScheduledJobs             *bool            `json:"clearScheduledJobs,omitempty"`
	AddWorkflowObjectRefIDs        []string         `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs     []string         `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs        *bool            `json:"clearWorkflowObjectRefs,omitempty"`
	AddComment                     *CreateNoteInput `json:"addComment,omitempty"`
	DeleteComment                  *string          `json:"deleteComment,omitempty"`
}

// UpdateControlObjectiveInput is used for update ControlObjective object.
// Input was generated by ent.
type UpdateControlObjectiveInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the name of the control objective
	Name *string `json:"name,omitempty"`
	// the desired outcome or target of the control objective
	DesiredOutcome      *string `json:"desiredOutcome,omitempty"`
	ClearDesiredOutcome *bool   `json:"clearDesiredOutcome,omitempty"`
	// status of the control objective
	Status      *enums.ObjectiveStatus `json:"status,omitempty"`
	ClearStatus *bool                  `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType      *string `json:"controlObjectiveType,omitempty"`
	ClearControlObjectiveType *bool   `json:"clearControlObjectiveType,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// subcategory of the control
	Subcategory             *string             `json:"subcategory,omitempty"`
	ClearSubcategory        *bool               `json:"clearSubcategory,omitempty"`
	AddBlockedGroupIDs      []string            `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string            `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool               `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string            `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string            `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool               `json:"clearEditors,omitempty"`
	AddViewerIDs            []string            `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs         []string            `json:"removeViewerIDs,omitempty"`
	ClearViewers            *bool               `json:"clearViewers,omitempty"`
	AddProgramIDs           []string            `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string            `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool               `json:"clearPrograms,omitempty"`
	AddEvidenceIDs          []string            `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs       []string            `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence           *bool               `json:"clearEvidence,omitempty"`
	AddControlIDs           []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string            `json:"removeControlIDs,omitempty"`
	ClearControls           *bool               `json:"clearControls,omitempty"`
	AddSubcontrolIDs        []string            `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs     []string            `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols        *bool               `json:"clearSubcontrols,omitempty"`
	AddInternalPolicyIDs    []string            `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string            `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool               `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs         []string            `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs      []string            `json:"removeProcedureIDs,omitempty"`
	ClearProcedures         *bool               `json:"clearProcedures,omitempty"`
	AddRiskIDs              []string            `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs           []string            `json:"removeRiskIDs,omitempty"`
	ClearRisks              *bool               `json:"clearRisks,omitempty"`
	AddNarrativeIDs         []string            `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs      []string            `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives         *bool               `json:"clearNarratives,omitempty"`
	AddTaskIDs              []string            `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string            `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool               `json:"clearTasks,omitempty"`
	RevisionBump            *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateCustomDomainInput is used for update CustomDomain object.
// Input was generated by ent.
type UpdateCustomDomainInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	OwnerID               *string `json:"ownerID,omitempty"`
	ClearOwner            *bool   `json:"clearOwner,omitempty"`
	DNSVerificationID     *string `json:"dnsVerificationID,omitempty"`
	ClearDNSVerification  *bool   `json:"clearDNSVerification,omitempty"`
}

// UpdateCustomTypeEnumInput is used for update CustomTypeEnum object.
// Input was generated by ent.
type UpdateCustomTypeEnumInput struct {
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// The description of the custom type
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// The color of the tag definition in hex format
	Color      *string `json:"color,omitempty"`
	ClearColor *bool   `json:"clearColor,omitempty"`
	// The icon of the custom type enum in SVG format
	Icon                    *string  `json:"icon,omitempty"`
	ClearIcon               *bool    `json:"clearIcon,omitempty"`
	OwnerID                 *string  `json:"ownerID,omitempty"`
	ClearOwner              *bool    `json:"clearOwner,omitempty"`
	AddTaskIDs              []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool    `json:"clearTasks,omitempty"`
	AddControlIDs           []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string `json:"removeControlIDs,omitempty"`
	ClearControls           *bool    `json:"clearControls,omitempty"`
	AddSubcontrolIDs        []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs     []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols        *bool    `json:"clearSubcontrols,omitempty"`
	AddRiskIDs              []string `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs           []string `json:"removeRiskIDs,omitempty"`
	ClearRisks              *bool    `json:"clearRisks,omitempty"`
	AddRiskCategoryIDs      []string `json:"addRiskCategoryIDs,omitempty"`
	RemoveRiskCategoryIDs   []string `json:"removeRiskCategoryIDs,omitempty"`
	ClearRiskCategories     *bool    `json:"clearRiskCategories,omitempty"`
	AddInternalPolicyIDs    []string `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool    `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs         []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs      []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures         *bool    `json:"clearProcedures,omitempty"`
	AddActionPlanIDs        []string `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs     []string `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans        *bool    `json:"clearActionPlans,omitempty"`
	AddProgramIDs           []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool    `json:"clearPrograms,omitempty"`
}

// UpdateDNSVerificationInput is used for update DNSVerification object.
// Input was generated by ent.
type UpdateDNSVerificationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the dns txt record
	DNSTxtRecord *string `json:"dnsTxtRecord,omitempty"`
	// the expected value of the dns txt record
	DNSTxtValue *string `json:"dnsTxtValue,omitempty"`
	// Status of the domain verification
	DNSVerificationStatus *enums.DNSVerificationStatus `json:"dnsVerificationStatus,omitempty"`
	// Reason of the dns verification status, for giving the user diagnostic info
	DNSVerificationStatusReason      *string `json:"dnsVerificationStatusReason,omitempty"`
	ClearDNSVerificationStatusReason *bool   `json:"clearDNSVerificationStatusReason,omitempty"`
	// Path under /.well-known/acme-challenge/ to serve the ACME challenge
	AcmeChallengePath      *string `json:"acmeChallengePath,omitempty"`
	ClearAcmeChallengePath *bool   `json:"clearAcmeChallengePath,omitempty"`
	// the expected value of the acme challenge record
	ExpectedAcmeChallengeValue      *string `json:"expectedAcmeChallengeValue,omitempty"`
	ClearExpectedAcmeChallengeValue *bool   `json:"clearExpectedAcmeChallengeValue,omitempty"`
	// Status of the ACME challenge validation
	AcmeChallengeStatus *enums.SSLVerificationStatus `json:"acmeChallengeStatus,omitempty"`
	// Reason of the ACME status, for giving the user diagnostic info
	AcmeChallengeStatusReason      *string  `json:"acmeChallengeStatusReason,omitempty"`
	ClearAcmeChallengeStatusReason *bool    `json:"clearAcmeChallengeStatusReason,omitempty"`
	OwnerID                        *string  `json:"ownerID,omitempty"`
	ClearOwner                     *bool    `json:"clearOwner,omitempty"`
	AddCustomDomainIDs             []string `json:"addCustomDomainIDs,omitempty"`
	RemoveCustomDomainIDs          []string `json:"removeCustomDomainIDs,omitempty"`
	ClearCustomDomains             *bool    `json:"clearCustomDomains,omitempty"`
}

// UpdateDirectoryAccountInput is used for update DirectoryAccount object.
// Input was generated by ent.
type UpdateDirectoryAccountInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// optional secondary identifier such as Azure immutable ID
	SecondaryKey      *string `json:"secondaryKey,omitempty"`
	ClearSecondaryKey *bool   `json:"clearSecondaryKey,omitempty"`
	// lower-cased primary email address, if present
	CanonicalEmail      *string `json:"canonicalEmail,omitempty"`
	ClearCanonicalEmail *bool   `json:"clearCanonicalEmail,omitempty"`
	// provider supplied display name
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// first name reported by the provider
	GivenName      *string `json:"givenName,omitempty"`
	ClearGivenName *bool   `json:"clearGivenName,omitempty"`
	// last name reported by the provider
	FamilyName      *string `json:"familyName,omitempty"`
	ClearFamilyName *bool   `json:"clearFamilyName,omitempty"`
	// title captured at sync time
	JobTitle      *string `json:"jobTitle,omitempty"`
	ClearJobTitle *bool   `json:"clearJobTitle,omitempty"`
	// department captured at sync time
	Department      *string `json:"department,omitempty"`
	ClearDepartment *bool   `json:"clearDepartment,omitempty"`
	// organizational unit or OU path the account lives under
	OrganizationUnit      *string `json:"organizationUnit,omitempty"`
	ClearOrganizationUnit *bool   `json:"clearOrganizationUnit,omitempty"`
	// type of principal represented in the directory
	AccountType      *enums.DirectoryAccountType `json:"accountType,omitempty"`
	ClearAccountType *bool                       `json:"clearAccountType,omitempty"`
	// lifecycle status returned by the directory
	Status *enums.DirectoryAccountStatus `json:"status,omitempty"`
	// multi-factor authentication state reported by the directory
	MfaState *enums.DirectoryAccountMFAState `json:"mfaState,omitempty"`
	// last IP address observed by the provider, if any
	LastSeenIP      *string `json:"lastSeenIP,omitempty"`
	ClearLastSeenIP *bool   `json:"clearLastSeenIP,omitempty"`
	// timestamp of the most recent login reported by the provider
	LastLoginAt      *time.Time `json:"lastLoginAt,omitempty"`
	ClearLastLoginAt *bool      `json:"clearLastLoginAt,omitempty"`
	// hash of the normalized profile payload for change detection
	ProfileHash *string `json:"profileHash,omitempty"`
	// flattened attribute bag used for filtering/diffing
	Profile      map[string]any `json:"profile,omitempty"`
	ClearProfile *bool          `json:"clearProfile,omitempty"`
	// cursor or ETag supplied by the source system for auditing
	SourceVersion              *string  `json:"sourceVersion,omitempty"`
	ClearSourceVersion         *bool    `json:"clearSourceVersion,omitempty"`
	OwnerID                    *string  `json:"ownerID,omitempty"`
	ClearOwner                 *bool    `json:"clearOwner,omitempty"`
	AddGroupIDs                []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs             []string `json:"removeGroupIDs,omitempty"`
	ClearGroups                *bool    `json:"clearGroups,omitempty"`
	AddWorkflowObjectRefIDs    []string `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs []string `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs    *bool    `json:"clearWorkflowObjectRefs,omitempty"`
}

// UpdateDirectoryGroupInput is used for update DirectoryGroup object.
// Input was generated by ent.
type UpdateDirectoryGroupInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// primary group email address, when applicable
	Email      *string `json:"email,omitempty"`
	ClearEmail *bool   `json:"clearEmail,omitempty"`
	// directory supplied display name
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// free-form description captured at sync time
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// provider classification such as security, distribution, or dynamic
	Classification *enums.DirectoryGroupClassification `json:"classification,omitempty"`
	// lifecycle status reported by the directory
	Status *enums.DirectoryGroupStatus `json:"status,omitempty"`
	// true when directory settings allow sharing outside the tenant
	ExternalSharingAllowed      *bool `json:"externalSharingAllowed,omitempty"`
	ClearExternalSharingAllowed *bool `json:"clearExternalSharingAllowed,omitempty"`
	// member count reported by the directory
	MemberCount      *int64 `json:"memberCount,omitempty"`
	ClearMemberCount *bool  `json:"clearMemberCount,omitempty"`
	// hash of the normalized payload for diffing
	ProfileHash *string `json:"profileHash,omitempty"`
	// flattened attribute bag used for filtering/diffing
	Profile      map[string]any `json:"profile,omitempty"`
	ClearProfile *bool          `json:"clearProfile,omitempty"`
	// cursor or ETag supplied by the source system for auditing
	SourceVersion              *string  `json:"sourceVersion,omitempty"`
	ClearSourceVersion         *bool    `json:"clearSourceVersion,omitempty"`
	OwnerID                    *string  `json:"ownerID,omitempty"`
	ClearOwner                 *bool    `json:"clearOwner,omitempty"`
	AddWorkflowObjectRefIDs    []string `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs []string `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs    *bool    `json:"clearWorkflowObjectRefs,omitempty"`
}

// UpdateDirectoryMembershipInput is used for update DirectoryMembership object.
// Input was generated by ent.
type UpdateDirectoryMembershipInput struct {
	// membership role reported by the provider
	Role      *enums.DirectoryMembershipRole `json:"role,omitempty"`
	ClearRole *bool                          `json:"clearRole,omitempty"`
	// mechanism used to populate the membership (api, scim, csv, etc)
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// first time the membership was detected
	FirstSeenAt      *time.Time `json:"firstSeenAt,omitempty"`
	ClearFirstSeenAt *bool      `json:"clearFirstSeenAt,omitempty"`
	// most recent time the membership was detected
	LastSeenAt      *time.Time `json:"lastSeenAt,omitempty"`
	ClearLastSeenAt *bool      `json:"clearLastSeenAt,omitempty"`
	// sync run identifier that most recently confirmed this membership
	LastConfirmedRunID      *string `json:"lastConfirmedRunID,omitempty"`
	ClearLastConfirmedRunID *bool   `json:"clearLastConfirmedRunID,omitempty"`
	// raw metadata associated with this membership from the provider
	Metadata                   map[string]any `json:"metadata,omitempty"`
	ClearMetadata              *bool          `json:"clearMetadata,omitempty"`
	OwnerID                    *string        `json:"ownerID,omitempty"`
	ClearOwner                 *bool          `json:"clearOwner,omitempty"`
	AddEventIDs                []string       `json:"addEventIDs,omitempty"`
	RemoveEventIDs             []string       `json:"removeEventIDs,omitempty"`
	ClearEvents                *bool          `json:"clearEvents,omitempty"`
	AddWorkflowObjectRefIDs    []string       `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs []string       `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs    *bool          `json:"clearWorkflowObjectRefs,omitempty"`
}

// UpdateDirectorySyncRunInput is used for update DirectorySyncRun object.
// Input was generated by ent.
type UpdateDirectorySyncRunInput struct {
	// current state of the sync run
	Status *enums.DirectorySyncRunStatus `json:"status,omitempty"`
	// time the sync started
	StartedAt *time.Time `json:"startedAt,omitempty"`
	// time the sync finished
	CompletedAt      *time.Time `json:"completedAt,omitempty"`
	ClearCompletedAt *bool      `json:"clearCompletedAt,omitempty"`
	// cursor or checkpoint returned by the provider for the next run
	SourceCursor      *string `json:"sourceCursor,omitempty"`
	ClearSourceCursor *bool   `json:"clearSourceCursor,omitempty"`
	// total records processed during this run
	FullCount *int64 `json:"fullCount,omitempty"`
	// number of records that changed compared to the prior run
	DeltaCount *int64 `json:"deltaCount,omitempty"`
	// serialized error information when the run failed
	Error      *string `json:"error,omitempty"`
	ClearError *bool   `json:"clearError,omitempty"`
	// object storage file identifier for the manifest captured during the run
	RawManifestFileID      *string `json:"rawManifestFileID,omitempty"`
	ClearRawManifestFileID *bool   `json:"clearRawManifestFileID,omitempty"`
	// additional provider-specific stats for the run
	Stats                     map[string]any `json:"stats,omitempty"`
	ClearStats                *bool          `json:"clearStats,omitempty"`
	OwnerID                   *string        `json:"ownerID,omitempty"`
	ClearOwner                *bool          `json:"clearOwner,omitempty"`
	AddDirectoryAccountIDs    []string       `json:"addDirectoryAccountIDs,omitempty"`
	RemoveDirectoryAccountIDs []string       `json:"removeDirectoryAccountIDs,omitempty"`
	ClearDirectoryAccounts    *bool          `json:"clearDirectoryAccounts,omitempty"`
	AddDirectoryGroupIDs      []string       `json:"addDirectoryGroupIDs,omitempty"`
	RemoveDirectoryGroupIDs   []string       `json:"removeDirectoryGroupIDs,omitempty"`
	ClearDirectoryGroups      *bool          `json:"clearDirectoryGroups,omitempty"`
}

// UpdateDocumentDataInput is used for update DocumentData object.
// Input was generated by ent.
type UpdateDocumentDataInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the json data of the document
	Data            map[string]any `json:"data,omitempty"`
	TemplateID      *string        `json:"templateID,omitempty"`
	ClearTemplate   *bool          `json:"clearTemplate,omitempty"`
	AddEntityIDs    []string       `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string       `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool          `json:"clearEntities,omitempty"`
	AddFileIDs      []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs   []string       `json:"removeFileIDs,omitempty"`
	ClearFiles      *bool          `json:"clearFiles,omitempty"`
}

// UpdateEntityInput is used for update Entity object.
// Input was generated by ent.
type UpdateEntityInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the name of the entity
	Name      *string `json:"name,omitempty"`
	ClearName *bool   `json:"clearName,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// An optional description of the entity
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// domains associated with the entity
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// status of the entity
	Status                *string          `json:"status,omitempty"`
	ClearStatus           *bool            `json:"clearStatus,omitempty"`
	OwnerID               *string          `json:"ownerID,omitempty"`
	ClearOwner            *bool            `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs    []string         `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string         `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool            `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string         `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string         `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool            `json:"clearEditors,omitempty"`
	AddViewerIDs          []string         `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string         `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool            `json:"clearViewers,omitempty"`
	AddContactIDs         []string         `json:"addContactIDs,omitempty"`
	RemoveContactIDs      []string         `json:"removeContactIDs,omitempty"`
	ClearContacts         *bool            `json:"clearContacts,omitempty"`
	AddDocumentIDs        []string         `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs     []string         `json:"removeDocumentIDs,omitempty"`
	ClearDocuments        *bool            `json:"clearDocuments,omitempty"`
	AddNoteIDs            []string         `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs         []string         `json:"removeNoteIDs,omitempty"`
	ClearNotes            *bool            `json:"clearNotes,omitempty"`
	AddFileIDs            []string         `json:"addFileIDs,omitempty"`
	RemoveFileIDs         []string         `json:"removeFileIDs,omitempty"`
	ClearFiles            *bool            `json:"clearFiles,omitempty"`
	AddAssetIDs           []string         `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs        []string         `json:"removeAssetIDs,omitempty"`
	ClearAssets           *bool            `json:"clearAssets,omitempty"`
	AddScanIDs            []string         `json:"addScanIDs,omitempty"`
	RemoveScanIDs         []string         `json:"removeScanIDs,omitempty"`
	ClearScans            *bool            `json:"clearScans,omitempty"`
	EntityTypeID          *string          `json:"entityTypeID,omitempty"`
	ClearEntityType       *bool            `json:"clearEntityType,omitempty"`
	Note                  *CreateNoteInput `json:"note,omitempty"`
}

// UpdateEntityTypeInput is used for update EntityType object.
// Input was generated by ent.
type UpdateEntityTypeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the name of the entity
	Name            *string  `json:"name,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	ClearOwner      *bool    `json:"clearOwner,omitempty"`
	AddEntityIDs    []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool    `json:"clearEntities,omitempty"`
}

// UpdateEventInput is used for update Event object.
// Input was generated by ent.
type UpdateEventInput struct {
	// tags associated with the object
	Tags                         []string       `json:"tags,omitempty"`
	AppendTags                   []string       `json:"appendTags,omitempty"`
	ClearTags                    *bool          `json:"clearTags,omitempty"`
	EventID                      *string        `json:"eventID,omitempty"`
	ClearEventID                 *bool          `json:"clearEventID,omitempty"`
	CorrelationID                *string        `json:"correlationID,omitempty"`
	ClearCorrelationID           *bool          `json:"clearCorrelationID,omitempty"`
	EventType                    *string        `json:"eventType,omitempty"`
	Metadata                     map[string]any `json:"metadata,omitempty"`
	ClearMetadata                *bool          `json:"clearMetadata,omitempty"`
	AddUserIDs                   []string       `json:"addUserIDs,omitempty"`
	RemoveUserIDs                []string       `json:"removeUserIDs,omitempty"`
	ClearUsers                   *bool          `json:"clearUsers,omitempty"`
	AddGroupIDs                  []string       `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string       `json:"removeGroupIDs,omitempty"`
	ClearGroups                  *bool          `json:"clearGroups,omitempty"`
	AddIntegrationIDs            []string       `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs         []string       `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations            *bool          `json:"clearIntegrations,omitempty"`
	AddOrganizationIDs           []string       `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string       `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations           *bool          `json:"clearOrganizations,omitempty"`
	AddInviteIDs                 []string       `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs              []string       `json:"removeInviteIDs,omitempty"`
	ClearInvites                 *bool          `json:"clearInvites,omitempty"`
	AddPersonalAccessTokenIDs    []string       `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs []string       `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens    *bool          `json:"clearPersonalAccessTokens,omitempty"`
	AddSecretIDs                 []string       `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs              []string       `json:"removeSecretIDs,omitempty"`
	ClearSecrets                 *bool          `json:"clearSecrets,omitempty"`
	AddSubscriberIDs             []string       `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs          []string       `json:"removeSubscriberIDs,omitempty"`
	ClearSubscribers             *bool          `json:"clearSubscribers,omitempty"`
	AddFileIDs                   []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs                []string       `json:"removeFileIDs,omitempty"`
	ClearFiles                   *bool          `json:"clearFiles,omitempty"`
	AddOrgSubscriptionIDs        []string       `json:"addOrgSubscriptionIDs,omitempty"`
	RemoveOrgSubscriptionIDs     []string       `json:"removeOrgSubscriptionIDs,omitempty"`
	ClearOrgSubscriptions        *bool          `json:"clearOrgSubscriptions,omitempty"`
}

// UpdateEvidenceInput is used for update Evidence object.
// Input was generated by ent.
type UpdateEvidenceInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the evidence
	Name *string `json:"name,omitempty"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure      *string `json:"collectionProcedure,omitempty"`
	ClearCollectionProcedure *bool   `json:"clearCollectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate *time.Time `json:"creationDate,omitempty"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate      *time.Time `json:"renewalDate,omitempty"`
	ClearRenewalDate *bool      `json:"clearRenewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated      *bool `json:"isAutomated,omitempty"`
	ClearIsAutomated *bool `json:"clearIsAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL      *string `json:"url,omitempty"`
	ClearURL *bool   `json:"clearURL,omitempty"`
	// the status of the evidence, ready, approved, needs renewal, missing artifact, rejected
	Status                         *enums.EvidenceStatus `json:"status,omitempty"`
	ClearStatus                    *bool                 `json:"clearStatus,omitempty"`
	AddControlIDs                  []string              `json:"addControlIDs,omitempty"`
	RemoveControlIDs               []string              `json:"removeControlIDs,omitempty"`
	ClearControls                  *bool                 `json:"clearControls,omitempty"`
	AddSubcontrolIDs               []string              `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs            []string              `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols               *bool                 `json:"clearSubcontrols,omitempty"`
	AddControlObjectiveIDs         []string              `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs      []string              `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives         *bool                 `json:"clearControlObjectives,omitempty"`
	AddControlImplementationIDs    []string              `json:"addControlImplementationIDs,omitempty"`
	RemoveControlImplementationIDs []string              `json:"removeControlImplementationIDs,omitempty"`
	ClearControlImplementations    *bool                 `json:"clearControlImplementations,omitempty"`
	AddFileIDs                     []string              `json:"addFileIDs,omitempty"`
	RemoveFileIDs                  []string              `json:"removeFileIDs,omitempty"`
	ClearFiles                     *bool                 `json:"clearFiles,omitempty"`
	AddProgramIDs                  []string              `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs               []string              `json:"removeProgramIDs,omitempty"`
	ClearPrograms                  *bool                 `json:"clearPrograms,omitempty"`
	AddTaskIDs                     []string              `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                  []string              `json:"removeTaskIDs,omitempty"`
	ClearTasks                     *bool                 `json:"clearTasks,omitempty"`
	AddCommentIDs                  []string              `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs               []string              `json:"removeCommentIDs,omitempty"`
	ClearComments                  *bool                 `json:"clearComments,omitempty"`
	AddComment                     *CreateNoteInput      `json:"addComment,omitempty"`
	DeleteComment                  *string               `json:"deleteComment,omitempty"`
}

// UpdateExportInput is used for update Export object.
// Input was generated by ent.
type UpdateExportInput struct {
	// the status of the export, e.g., pending, ready, failed
	Status *enums.ExportStatus `json:"status,omitempty"`
	// if we try to export and it fails, the error message will be stored here
	ErrorMessage      *string  `json:"errorMessage,omitempty"`
	ClearErrorMessage *bool    `json:"clearErrorMessage,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	ClearOwner        *bool    `json:"clearOwner,omitempty"`
	AddEventIDs       []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs    []string `json:"removeEventIDs,omitempty"`
	ClearEvents       *bool    `json:"clearEvents,omitempty"`
	AddFileIDs        []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool    `json:"clearFiles,omitempty"`
}

// UpdateFileInput is used for update File object.
// Input was generated by ent.
type UpdateFileInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName *string `json:"providedFileName,omitempty"`
	// the extension of the file provided
	ProvidedFileExtension *string `json:"providedFileExtension,omitempty"`
	// the computed size of the file in the original http request
	ProvidedFileSize       *int64 `json:"providedFileSize,omitempty"`
	ClearProvidedFileSize  *bool  `json:"clearProvidedFileSize,omitempty"`
	PersistedFileSize      *int64 `json:"persistedFileSize,omitempty"`
	ClearPersistedFileSize *bool  `json:"clearPersistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType      *string `json:"detectedMimeType,omitempty"`
	ClearDetectedMimeType *bool   `json:"clearDetectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash      *string `json:"md5Hash,omitempty"`
	ClearMd5Hash *bool   `json:"clearMd5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType *string `json:"detectedContentType,omitempty"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey      *string `json:"storeKey,omitempty"`
	ClearStoreKey *bool   `json:"clearStoreKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType      *string `json:"categoryType,omitempty"`
	ClearCategoryType *bool   `json:"clearCategoryType,omitempty"`
	// the full URI of the file
	URI      *string `json:"uri,omitempty"`
	ClearURI *bool   `json:"clearURI,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme      *string `json:"storageScheme,omitempty"`
	ClearStorageScheme *bool   `json:"clearStorageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume      *string `json:"storageVolume,omitempty"`
	ClearStorageVolume *bool   `json:"clearStorageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath      *string `json:"storagePath,omitempty"`
	ClearStoragePath *bool   `json:"clearStoragePath,omitempty"`
	// additional metadata about the file
	Metadata      map[string]any `json:"metadata,omitempty"`
	ClearMetadata *bool          `json:"clearMetadata,omitempty"`
	// the region the file is stored in, if applicable
	StorageRegion      *string `json:"storageRegion,omitempty"`
	ClearStorageRegion *bool   `json:"clearStorageRegion,omitempty"`
	// the storage provider the file is stored in, if applicable
	StorageProvider              *string    `json:"storageProvider,omitempty"`
	ClearStorageProvider         *bool      `json:"clearStorageProvider,omitempty"`
	LastAccessedAt               *time.Time `json:"lastAccessedAt,omitempty"`
	ClearLastAccessedAt          *bool      `json:"clearLastAccessedAt,omitempty"`
	AddOrganizationIDs           []string   `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string   `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization            *bool      `json:"clearOrganization,omitempty"`
	AddGroupIDs                  []string   `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string   `json:"removeGroupIDs,omitempty"`
	ClearGroups                  *bool      `json:"clearGroups,omitempty"`
	AddContactIDs                []string   `json:"addContactIDs,omitempty"`
	RemoveContactIDs             []string   `json:"removeContactIDs,omitempty"`
	ClearContact                 *bool      `json:"clearContact,omitempty"`
	AddEntityIDs                 []string   `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs              []string   `json:"removeEntityIDs,omitempty"`
	ClearEntity                  *bool      `json:"clearEntity,omitempty"`
	AddOrganizationSettingIDs    []string   `json:"addOrganizationSettingIDs,omitempty"`
	RemoveOrganizationSettingIDs []string   `json:"removeOrganizationSettingIDs,omitempty"`
	ClearOrganizationSetting     *bool      `json:"clearOrganizationSetting,omitempty"`
	AddTemplateIDs               []string   `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs            []string   `json:"removeTemplateIDs,omitempty"`
	ClearTemplate                *bool      `json:"clearTemplate,omitempty"`
	AddDocumentIDs               []string   `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs            []string   `json:"removeDocumentIDs,omitempty"`
	ClearDocument                *bool      `json:"clearDocument,omitempty"`
	AddProgramIDs                []string   `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs             []string   `json:"removeProgramIDs,omitempty"`
	ClearProgram                 *bool      `json:"clearProgram,omitempty"`
	AddEvidenceIDs               []string   `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs            []string   `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                *bool      `json:"clearEvidence,omitempty"`
	AddEventIDs                  []string   `json:"addEventIDs,omitempty"`
	RemoveEventIDs               []string   `json:"removeEventIDs,omitempty"`
	ClearEvents                  *bool      `json:"clearEvents,omitempty"`
	AddTrustCenterSettingIDs     []string   `json:"addTrustCenterSettingIDs,omitempty"`
	RemoveTrustCenterSettingIDs  []string   `json:"removeTrustCenterSettingIDs,omitempty"`
	ClearTrustCenterSetting      *bool      `json:"clearTrustCenterSetting,omitempty"`
	AddIntegrationIDs            []string   `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs         []string   `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations            *bool      `json:"clearIntegrations,omitempty"`
	AddSecretIDs                 []string   `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs              []string   `json:"removeSecretIDs,omitempty"`
	ClearSecrets                 *bool      `json:"clearSecrets,omitempty"`
	AddTrustcenterEntityIDs      []string   `json:"addTrustcenterEntityIDs,omitempty"`
	RemoveTrustcenterEntityIDs   []string   `json:"removeTrustcenterEntityIDs,omitempty"`
	ClearTrustcenterEntities     *bool      `json:"clearTrustcenterEntities,omitempty"`
}

// UpdateFindingControlInput is used for update FindingControl object.
// Input was generated by ent.
type UpdateFindingControlInput struct {
	// external identifier for the standard provided by the source system such as iso or hipaa
	ExternalStandard      *string `json:"externalStandard,omitempty"`
	ClearExternalStandard *bool   `json:"clearExternalStandard,omitempty"`
	// version for the external standard provided by the source system
	ExternalStandardVersion      *string `json:"externalStandardVersion,omitempty"`
	ClearExternalStandardVersion *bool   `json:"clearExternalStandardVersion,omitempty"`
	// control identifier provided by the source system such as A.5.10
	ExternalControlID      *string `json:"externalControlID,omitempty"`
	ClearExternalControlID *bool   `json:"clearExternalControlID,omitempty"`
	// the integration source that provided the mapping
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// additional metadata about the control mapping from the source system
	Metadata      map[string]any `json:"metadata,omitempty"`
	ClearMetadata *bool          `json:"clearMetadata,omitempty"`
	// timestamp when the mapping was first observed
	DiscoveredAt      *models.DateTime `json:"discoveredAt,omitempty"`
	ClearDiscoveredAt *bool            `json:"clearDiscoveredAt,omitempty"`
}

// UpdateFindingInput is used for update Finding object.
// Input was generated by ent.
type UpdateFindingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// external identifier from the integration source for the finding
	ExternalID      *string `json:"externalID,omitempty"`
	ClearExternalID *bool   `json:"clearExternalID,omitempty"`
	// the owner of the finding
	ExternalOwnerID      *string `json:"externalOwnerID,omitempty"`
	ClearExternalOwnerID *bool   `json:"clearExternalOwnerID,omitempty"`
	// system that produced the finding, e.g. gcp_scc
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// resource identifier provided by the source system
	ResourceName      *string `json:"resourceName,omitempty"`
	ClearResourceName *bool   `json:"clearResourceName,omitempty"`
	// display name for the finding when provided by the source
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// state reported by the source system, such as ACTIVE or INACTIVE
	State      *string `json:"state,omitempty"`
	ClearState *bool   `json:"clearState,omitempty"`
	// primary category of the finding
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// normalized categories for the finding
	Categories       []string `json:"categories,omitempty"`
	AppendCategories []string `json:"appendCategories,omitempty"`
	ClearCategories  *bool    `json:"clearCategories,omitempty"`
	// classification provided by the source, e.g. MISCONFIGURATION
	FindingClass      *string `json:"findingClass,omitempty"`
	ClearFindingClass *bool   `json:"clearFindingClass,omitempty"`
	// severity label for the finding
	Severity      *string `json:"severity,omitempty"`
	ClearSeverity *bool   `json:"clearSeverity,omitempty"`
	// numeric severity score for the finding if provided
	NumericSeverity      *float64 `json:"numericSeverity,omitempty"`
	ClearNumericSeverity *bool    `json:"clearNumericSeverity,omitempty"`
	// aggregated score such as CVSS for the finding
	Score      *float64 `json:"score,omitempty"`
	ClearScore *bool    `json:"clearScore,omitempty"`
	// impact score or rating for the finding
	Impact      *float64 `json:"impact,omitempty"`
	ClearImpact *bool    `json:"clearImpact,omitempty"`
	// exploitability score or rating for the finding
	Exploitability      *float64 `json:"exploitability,omitempty"`
	ClearExploitability *bool    `json:"clearExploitability,omitempty"`
	// priority assigned to the finding
	Priority      *string `json:"priority,omitempty"`
	ClearPriority *bool   `json:"clearPriority,omitempty"`
	// indicates if the finding is still open
	Open      *bool `json:"open,omitempty"`
	ClearOpen *bool `json:"clearOpen,omitempty"`
	// true when the finding blocks production changes
	BlocksProduction      *bool `json:"blocksProduction,omitempty"`
	ClearBlocksProduction *bool `json:"clearBlocksProduction,omitempty"`
	// true when the finding affects production systems
	Production      *bool `json:"production,omitempty"`
	ClearProduction *bool `json:"clearProduction,omitempty"`
	// true when the finding is publicly disclosed
	Public      *bool `json:"public,omitempty"`
	ClearPublic *bool `json:"clearPublic,omitempty"`
	// true when the finding has been validated by the security team
	Validated      *bool `json:"validated,omitempty"`
	ClearValidated *bool `json:"clearValidated,omitempty"`
	// identifier for the assessment that generated the finding
	AssessmentID      *string `json:"assessmentID,omitempty"`
	ClearAssessmentID *bool   `json:"clearAssessmentID,omitempty"`
	// long form description of the finding
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// short recommendation text from the source system (deprecated upstream)
	Recommendation      *string `json:"recommendation,omitempty"`
	ClearRecommendation *bool   `json:"clearRecommendation,omitempty"`
	// markdown formatted remediation guidance for the finding
	RecommendedActions      *string `json:"recommendedActions,omitempty"`
	ClearRecommendedActions *bool   `json:"clearRecommendedActions,omitempty"`
	// reference links for the finding
	References       []string `json:"references,omitempty"`
	AppendReferences []string `json:"appendReferences,omitempty"`
	ClearReferences  *bool    `json:"clearReferences,omitempty"`
	// steps required to reproduce the finding
	StepsToReproduce       []string `json:"stepsToReproduce,omitempty"`
	AppendStepsToReproduce []string `json:"appendStepsToReproduce,omitempty"`
	ClearStepsToReproduce  *bool    `json:"clearStepsToReproduce,omitempty"`
	// targets impacted by the finding such as projects or applications
	Targets       []string `json:"targets,omitempty"`
	AppendTargets []string `json:"appendTargets,omitempty"`
	ClearTargets  *bool    `json:"clearTargets,omitempty"`
	// structured details about the impacted targets
	TargetDetails      map[string]any `json:"targetDetails,omitempty"`
	ClearTargetDetails *bool          `json:"clearTargetDetails,omitempty"`
	// attack vector string such as a CVSS vector
	Vector      *string `json:"vector,omitempty"`
	ClearVector *bool   `json:"clearVector,omitempty"`
	// remediation service level agreement in days
	RemediationSLA      *int64 `json:"remediationSLA,omitempty"`
	ClearRemediationSLA *bool  `json:"clearRemediationSLA,omitempty"`
	// lifecycle status of the finding
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// timestamp when the finding was last observed by the source
	EventTime      *models.DateTime `json:"eventTime,omitempty"`
	ClearEventTime *bool            `json:"clearEventTime,omitempty"`
	// timestamp when the finding was first reported by the source
	ReportedAt      *models.DateTime `json:"reportedAt,omitempty"`
	ClearReportedAt *bool            `json:"clearReportedAt,omitempty"`
	// timestamp when the source last updated the finding
	SourceUpdatedAt      *models.DateTime `json:"sourceUpdatedAt,omitempty"`
	ClearSourceUpdatedAt *bool            `json:"clearSourceUpdatedAt,omitempty"`
	// link to the finding in the source system
	ExternalURI      *string `json:"externalURI,omitempty"`
	ClearExternalURI *bool   `json:"clearExternalURI,omitempty"`
	// raw metadata payload for the finding from the source system
	Metadata      map[string]any `json:"metadata,omitempty"`
	ClearMetadata *bool          `json:"clearMetadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload                 map[string]any `json:"rawPayload,omitempty"`
	ClearRawPayload            *bool          `json:"clearRawPayload,omitempty"`
	AddBlockedGroupIDs         []string       `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs      []string       `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups         *bool          `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs               []string       `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs            []string       `json:"removeEditorIDs,omitempty"`
	ClearEditors               *bool          `json:"clearEditors,omitempty"`
	AddViewerIDs               []string       `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs            []string       `json:"removeViewerIDs,omitempty"`
	ClearViewers               *bool          `json:"clearViewers,omitempty"`
	AddIntegrationIDs          []string       `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs       []string       `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations          *bool          `json:"clearIntegrations,omitempty"`
	AddVulnerabilityIDs        []string       `json:"addVulnerabilityIDs,omitempty"`
	RemoveVulnerabilityIDs     []string       `json:"removeVulnerabilityIDs,omitempty"`
	ClearVulnerabilities       *bool          `json:"clearVulnerabilities,omitempty"`
	AddActionPlanIDs           []string       `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs        []string       `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans           *bool          `json:"clearActionPlans,omitempty"`
	AddControlIDs              []string       `json:"addControlIDs,omitempty"`
	RemoveControlIDs           []string       `json:"removeControlIDs,omitempty"`
	ClearControls              *bool          `json:"clearControls,omitempty"`
	AddSubcontrolIDs           []string       `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs        []string       `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols           *bool          `json:"clearSubcontrols,omitempty"`
	AddRiskIDs                 []string       `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs              []string       `json:"removeRiskIDs,omitempty"`
	ClearRisks                 *bool          `json:"clearRisks,omitempty"`
	AddProgramIDs              []string       `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs           []string       `json:"removeProgramIDs,omitempty"`
	ClearPrograms              *bool          `json:"clearPrograms,omitempty"`
	AddAssetIDs                []string       `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs             []string       `json:"removeAssetIDs,omitempty"`
	ClearAssets                *bool          `json:"clearAssets,omitempty"`
	AddEntityIDs               []string       `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs            []string       `json:"removeEntityIDs,omitempty"`
	ClearEntities              *bool          `json:"clearEntities,omitempty"`
	AddScanIDs                 []string       `json:"addScanIDs,omitempty"`
	RemoveScanIDs              []string       `json:"removeScanIDs,omitempty"`
	ClearScans                 *bool          `json:"clearScans,omitempty"`
	AddTaskIDs                 []string       `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs              []string       `json:"removeTaskIDs,omitempty"`
	ClearTasks                 *bool          `json:"clearTasks,omitempty"`
	AddRemediationIDs          []string       `json:"addRemediationIDs,omitempty"`
	RemoveRemediationIDs       []string       `json:"removeRemediationIDs,omitempty"`
	ClearRemediations          *bool          `json:"clearRemediations,omitempty"`
	AddReviewIDs               []string       `json:"addReviewIDs,omitempty"`
	RemoveReviewIDs            []string       `json:"removeReviewIDs,omitempty"`
	ClearReviews               *bool          `json:"clearReviews,omitempty"`
	AddCommentIDs              []string       `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs           []string       `json:"removeCommentIDs,omitempty"`
	ClearComments              *bool          `json:"clearComments,omitempty"`
	AddFileIDs                 []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs              []string       `json:"removeFileIDs,omitempty"`
	ClearFiles                 *bool          `json:"clearFiles,omitempty"`
	AddWorkflowObjectRefIDs    []string       `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs []string       `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs    *bool          `json:"clearWorkflowObjectRefs,omitempty"`
}

// UpdateGroupInput is used for update Group object.
// Input was generated by ent.
type UpdateGroupInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the group - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// the groups description
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL      *string `json:"logoURL,omitempty"`
	ClearLogoURL *bool   `json:"clearLogoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// the SCIM external ID for the group
	ScimExternalID      *string `json:"scimExternalID,omitempty"`
	ClearScimExternalID *bool   `json:"clearScimExternalID,omitempty"`
	// the SCIM displayname for the group
	ScimDisplayName      *string `json:"scimDisplayName,omitempty"`
	ClearScimDisplayName *bool   `json:"clearScimDisplayName,omitempty"`
	// whether the SCIM group is marked as active
	ScimActive      *bool `json:"scimActive,omitempty"`
	ClearScimActive *bool `json:"clearScimActive,omitempty"`
	// the SCIM group mailing list email
	ScimGroupMailing                           *string                       `json:"scimGroupMailing,omitempty"`
	ClearScimGroupMailing                      *bool                         `json:"clearScimGroupMailing,omitempty"`
	OwnerID                                    *string                       `json:"ownerID,omitempty"`
	ClearOwner                                 *bool                         `json:"clearOwner,omitempty"`
	AddProgramEditorIDs                        []string                      `json:"addProgramEditorIDs,omitempty"`
	RemoveProgramEditorIDs                     []string                      `json:"removeProgramEditorIDs,omitempty"`
	ClearProgramEditors                        *bool                         `json:"clearProgramEditors,omitempty"`
	AddProgramBlockedGroupIDs                  []string                      `json:"addProgramBlockedGroupIDs,omitempty"`
	RemoveProgramBlockedGroupIDs               []string                      `json:"removeProgramBlockedGroupIDs,omitempty"`
	ClearProgramBlockedGroups                  *bool                         `json:"clearProgramBlockedGroups,omitempty"`
	AddProgramViewerIDs                        []string                      `json:"addProgramViewerIDs,omitempty"`
	RemoveProgramViewerIDs                     []string                      `json:"removeProgramViewerIDs,omitempty"`
	ClearProgramViewers                        *bool                         `json:"clearProgramViewers,omitempty"`
	AddRiskEditorIDs                           []string                      `json:"addRiskEditorIDs,omitempty"`
	RemoveRiskEditorIDs                        []string                      `json:"removeRiskEditorIDs,omitempty"`
	ClearRiskEditors                           *bool                         `json:"clearRiskEditors,omitempty"`
	AddRiskBlockedGroupIDs                     []string                      `json:"addRiskBlockedGroupIDs,omitempty"`
	RemoveRiskBlockedGroupIDs                  []string                      `json:"removeRiskBlockedGroupIDs,omitempty"`
	ClearRiskBlockedGroups                     *bool                         `json:"clearRiskBlockedGroups,omitempty"`
	AddRiskViewerIDs                           []string                      `json:"addRiskViewerIDs,omitempty"`
	RemoveRiskViewerIDs                        []string                      `json:"removeRiskViewerIDs,omitempty"`
	ClearRiskViewers                           *bool                         `json:"clearRiskViewers,omitempty"`
	AddControlObjectiveEditorIDs               []string                      `json:"addControlObjectiveEditorIDs,omitempty"`
	RemoveControlObjectiveEditorIDs            []string                      `json:"removeControlObjectiveEditorIDs,omitempty"`
	ClearControlObjectiveEditors               *bool                         `json:"clearControlObjectiveEditors,omitempty"`
	AddControlObjectiveBlockedGroupIDs         []string                      `json:"addControlObjectiveBlockedGroupIDs,omitempty"`
	RemoveControlObjectiveBlockedGroupIDs      []string                      `json:"removeControlObjectiveBlockedGroupIDs,omitempty"`
	ClearControlObjectiveBlockedGroups         *bool                         `json:"clearControlObjectiveBlockedGroups,omitempty"`
	AddControlObjectiveViewerIDs               []string                      `json:"addControlObjectiveViewerIDs,omitempty"`
	RemoveControlObjectiveViewerIDs            []string                      `json:"removeControlObjectiveViewerIDs,omitempty"`
	ClearControlObjectiveViewers               *bool                         `json:"clearControlObjectiveViewers,omitempty"`
	AddNarrativeEditorIDs                      []string                      `json:"addNarrativeEditorIDs,omitempty"`
	RemoveNarrativeEditorIDs                   []string                      `json:"removeNarrativeEditorIDs,omitempty"`
	ClearNarrativeEditors                      *bool                         `json:"clearNarrativeEditors,omitempty"`
	AddNarrativeBlockedGroupIDs                []string                      `json:"addNarrativeBlockedGroupIDs,omitempty"`
	RemoveNarrativeBlockedGroupIDs             []string                      `json:"removeNarrativeBlockedGroupIDs,omitempty"`
	ClearNarrativeBlockedGroups                *bool                         `json:"clearNarrativeBlockedGroups,omitempty"`
	AddNarrativeViewerIDs                      []string                      `json:"addNarrativeViewerIDs,omitempty"`
	RemoveNarrativeViewerIDs                   []string                      `json:"removeNarrativeViewerIDs,omitempty"`
	ClearNarrativeViewers                      *bool                         `json:"clearNarrativeViewers,omitempty"`
	AddControlImplementationEditorIDs          []string                      `json:"addControlImplementationEditorIDs,omitempty"`
	RemoveControlImplementationEditorIDs       []string                      `json:"removeControlImplementationEditorIDs,omitempty"`
	ClearControlImplementationEditors          *bool                         `json:"clearControlImplementationEditors,omitempty"`
	AddControlImplementationBlockedGroupIDs    []string                      `json:"addControlImplementationBlockedGroupIDs,omitempty"`
	RemoveControlImplementationBlockedGroupIDs []string                      `json:"removeControlImplementationBlockedGroupIDs,omitempty"`
	ClearControlImplementationBlockedGroups    *bool                         `json:"clearControlImplementationBlockedGroups,omitempty"`
	AddControlImplementationViewerIDs          []string                      `json:"addControlImplementationViewerIDs,omitempty"`
	RemoveControlImplementationViewerIDs       []string                      `json:"removeControlImplementationViewerIDs,omitempty"`
	ClearControlImplementationViewers          *bool                         `json:"clearControlImplementationViewers,omitempty"`
	AddScanEditorIDs                           []string                      `json:"addScanEditorIDs,omitempty"`
	RemoveScanEditorIDs                        []string                      `json:"removeScanEditorIDs,omitempty"`
	ClearScanEditors                           *bool                         `json:"clearScanEditors,omitempty"`
	AddScanBlockedGroupIDs                     []string                      `json:"addScanBlockedGroupIDs,omitempty"`
	RemoveScanBlockedGroupIDs                  []string                      `json:"removeScanBlockedGroupIDs,omitempty"`
	ClearScanBlockedGroups                     *bool                         `json:"clearScanBlockedGroups,omitempty"`
	AddScanViewerIDs                           []string                      `json:"addScanViewerIDs,omitempty"`
	RemoveScanViewerIDs                        []string                      `json:"removeScanViewerIDs,omitempty"`
	ClearScanViewers                           *bool                         `json:"clearScanViewers,omitempty"`
	AddEntityEditorIDs                         []string                      `json:"addEntityEditorIDs,omitempty"`
	RemoveEntityEditorIDs                      []string                      `json:"removeEntityEditorIDs,omitempty"`
	ClearEntityEditors                         *bool                         `json:"clearEntityEditors,omitempty"`
	AddEntityBlockedGroupIDs                   []string                      `json:"addEntityBlockedGroupIDs,omitempty"`
	RemoveEntityBlockedGroupIDs                []string                      `json:"removeEntityBlockedGroupIDs,omitempty"`
	ClearEntityBlockedGroups                   *bool                         `json:"clearEntityBlockedGroups,omitempty"`
	AddEntityViewerIDs                         []string                      `json:"addEntityViewerIDs,omitempty"`
	RemoveEntityViewerIDs                      []string                      `json:"removeEntityViewerIDs,omitempty"`
	ClearEntityViewers                         *bool                         `json:"clearEntityViewers,omitempty"`
	AddProcedureEditorIDs                      []string                      `json:"addProcedureEditorIDs,omitempty"`
	RemoveProcedureEditorIDs                   []string                      `json:"removeProcedureEditorIDs,omitempty"`
	ClearProcedureEditors                      *bool                         `json:"clearProcedureEditors,omitempty"`
	AddProcedureBlockedGroupIDs                []string                      `json:"addProcedureBlockedGroupIDs,omitempty"`
	RemoveProcedureBlockedGroupIDs             []string                      `json:"removeProcedureBlockedGroupIDs,omitempty"`
	ClearProcedureBlockedGroups                *bool                         `json:"clearProcedureBlockedGroups,omitempty"`
	AddInternalPolicyEditorIDs                 []string                      `json:"addInternalPolicyEditorIDs,omitempty"`
	RemoveInternalPolicyEditorIDs              []string                      `json:"removeInternalPolicyEditorIDs,omitempty"`
	ClearInternalPolicyEditors                 *bool                         `json:"clearInternalPolicyEditors,omitempty"`
	AddInternalPolicyBlockedGroupIDs           []string                      `json:"addInternalPolicyBlockedGroupIDs,omitempty"`
	RemoveInternalPolicyBlockedGroupIDs        []string                      `json:"removeInternalPolicyBlockedGroupIDs,omitempty"`
	ClearInternalPolicyBlockedGroups           *bool                         `json:"clearInternalPolicyBlockedGroups,omitempty"`
	AddControlEditorIDs                        []string                      `json:"addControlEditorIDs,omitempty"`
	RemoveControlEditorIDs                     []string                      `json:"removeControlEditorIDs,omitempty"`
	ClearControlEditors                        *bool                         `json:"clearControlEditors,omitempty"`
	AddControlBlockedGroupIDs                  []string                      `json:"addControlBlockedGroupIDs,omitempty"`
	RemoveControlBlockedGroupIDs               []string                      `json:"removeControlBlockedGroupIDs,omitempty"`
	ClearControlBlockedGroups                  *bool                         `json:"clearControlBlockedGroups,omitempty"`
	AddMappedControlEditorIDs                  []string                      `json:"addMappedControlEditorIDs,omitempty"`
	RemoveMappedControlEditorIDs               []string                      `json:"removeMappedControlEditorIDs,omitempty"`
	ClearMappedControlEditors                  *bool                         `json:"clearMappedControlEditors,omitempty"`
	AddMappedControlBlockedGroupIDs            []string                      `json:"addMappedControlBlockedGroupIDs,omitempty"`
	RemoveMappedControlBlockedGroupIDs         []string                      `json:"removeMappedControlBlockedGroupIDs,omitempty"`
	ClearMappedControlBlockedGroups            *bool                         `json:"clearMappedControlBlockedGroups,omitempty"`
	SettingID                                  *string                       `json:"settingID,omitempty"`
	ClearSetting                               *bool                         `json:"clearSetting,omitempty"`
	AddEventIDs                                []string                      `json:"addEventIDs,omitempty"`
	RemoveEventIDs                             []string                      `json:"removeEventIDs,omitempty"`
	ClearEvents                                *bool                         `json:"clearEvents,omitempty"`
	AddIntegrationIDs                          []string                      `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs                       []string                      `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations                          *bool                         `json:"clearIntegrations,omitempty"`
	AddFileIDs                                 []string                      `json:"addFileIDs,omitempty"`
	RemoveFileIDs                              []string                      `json:"removeFileIDs,omitempty"`
	ClearFiles                                 *bool                         `json:"clearFiles,omitempty"`
	AddTaskIDs                                 []string                      `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                              []string                      `json:"removeTaskIDs,omitempty"`
	ClearTasks                                 *bool                         `json:"clearTasks,omitempty"`
	AddGroupMembers                            []*CreateGroupMembershipInput `json:"addGroupMembers,omitempty"`
	RemoveGroupMembers                         []string                      `json:"removeGroupMembers,omitempty"`
	UpdateGroupSettings                        *UpdateGroupSettingInput      `json:"updateGroupSettings,omitempty"`
	// inheritGroupPermissions allows a group to be updated with the same permissions
	// as the specified group ID, existing permissions will be removed
	InheritGroupPermissions *string `json:"inheritGroupPermissions,omitempty"`
}

// UpdateGroupMembershipInput is used for update GroupMembership object.
// Input was generated by ent.
type UpdateGroupMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateGroupSettingInput is used for update GroupSetting object.
// Input was generated by ent.
type UpdateGroupSettingInput struct {
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack      *bool `json:"syncToSlack,omitempty"`
	ClearSyncToSlack *bool `json:"clearSyncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub      *bool   `json:"syncToGithub,omitempty"`
	ClearSyncToGithub *bool   `json:"clearSyncToGithub,omitempty"`
	GroupID           *string `json:"groupID,omitempty"`
	ClearGroup        *bool   `json:"clearGroup,omitempty"`
}

// UpdateHushInput is used for update Hush object.
// Input was generated by ent.
type UpdateHushInput struct {
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name *string `json:"name,omitempty"`
	// a description of the hush value or purpose, such as github PAT
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind      *string `json:"kind,omitempty"`
	ClearKind *bool   `json:"clearKind,omitempty"`
	// a credential set, typically where you have multiple tokens or keys that compose one credential such as when accessing s3 and using access key ID, secret key, etc.
	CredentialSet      *models.CredentialSet `json:"credentialSet,omitempty"`
	ClearCredentialSet *bool                 `json:"clearCredentialSet,omitempty"`
	// additional metadata about the credential
	Metadata        map[string]any `json:"metadata,omitempty"`
	ClearMetadata   *bool          `json:"clearMetadata,omitempty"`
	LastUsedAt      *time.Time     `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt *bool          `json:"clearLastUsedAt,omitempty"`
	// when the token expires
	ExpiresAt            *time.Time `json:"expiresAt,omitempty"`
	ClearExpiresAt       *bool      `json:"clearExpiresAt,omitempty"`
	OwnerID              *string    `json:"ownerID,omitempty"`
	ClearOwner           *bool      `json:"clearOwner,omitempty"`
	AddIntegrationIDs    []string   `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs []string   `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations    *bool      `json:"clearIntegrations,omitempty"`
	AddFileIDs           []string   `json:"addFileIDs,omitempty"`
	RemoveFileIDs        []string   `json:"removeFileIDs,omitempty"`
	ClearFiles           *bool      `json:"clearFiles,omitempty"`
	AddEventIDs          []string   `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string   `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool      `json:"clearEvents,omitempty"`
}

// UpdateInternalPolicyInput is used for update InternalPolicy object.
// Input was generated by ent.
type UpdateInternalPolicyInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the name of the policy
	Name *string `json:"name,omitempty"`
	// status of the policy, e.g. draft, published, archived, etc.
	Status      *enums.DocumentStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// type of the policy, e.g. compliance, operational, health and safety, etc.
	PolicyType      *string `json:"policyType,omitempty"`
	ClearPolicyType *bool   `json:"clearPolicyType,omitempty"`
	// details of the policy
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// whether approval is required for edits to the policy
	ApprovalRequired      *bool `json:"approvalRequired,omitempty"`
	ClearApprovalRequired *bool `json:"clearApprovalRequired,omitempty"`
	// the date the policy should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue      *time.Time `json:"reviewDue,omitempty"`
	ClearReviewDue *bool      `json:"clearReviewDue,omitempty"`
	// the frequency at which the policy should be reviewed, used to calculate the review_due date
	ReviewFrequency      *enums.Frequency `json:"reviewFrequency,omitempty"`
	ClearReviewFrequency *bool            `json:"clearReviewFrequency,omitempty"`
	// auto-generated tag suggestions for the policy
	TagSuggestions       []string `json:"tagSuggestions,omitempty"`
	AppendTagSuggestions []string `json:"appendTagSuggestions,omitempty"`
	ClearTagSuggestions  *bool    `json:"clearTagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the policy
	DismissedTagSuggestions       []string `json:"dismissedTagSuggestions,omitempty"`
	AppendDismissedTagSuggestions []string `json:"appendDismissedTagSuggestions,omitempty"`
	ClearDismissedTagSuggestions  *bool    `json:"clearDismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the policy
	ControlSuggestions       []string `json:"controlSuggestions,omitempty"`
	AppendControlSuggestions []string `json:"appendControlSuggestions,omitempty"`
	ClearControlSuggestions  *bool    `json:"clearControlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the policy
	DismissedControlSuggestions       []string `json:"dismissedControlSuggestions,omitempty"`
	AppendDismissedControlSuggestions []string `json:"appendDismissedControlSuggestions,omitempty"`
	ClearDismissedControlSuggestions  *bool    `json:"clearDismissedControlSuggestions,omitempty"`
	// suggested improvements for the policy
	ImprovementSuggestions       []string `json:"improvementSuggestions,omitempty"`
	AppendImprovementSuggestions []string `json:"appendImprovementSuggestions,omitempty"`
	ClearImprovementSuggestions  *bool    `json:"clearImprovementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the policy
	DismissedImprovementSuggestions       []string `json:"dismissedImprovementSuggestions,omitempty"`
	AppendDismissedImprovementSuggestions []string `json:"appendDismissedImprovementSuggestions,omitempty"`
	ClearDismissedImprovementSuggestions  *bool    `json:"clearDismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the policy
	URL      *string `json:"url,omitempty"`
	ClearURL *bool   `json:"clearURL,omitempty"`
	// the kind of the internal_policy
	InternalPolicyKindName         *string             `json:"internalPolicyKindName,omitempty"`
	ClearInternalPolicyKindName    *bool               `json:"clearInternalPolicyKindName,omitempty"`
	OwnerID                        *string             `json:"ownerID,omitempty"`
	ClearOwner                     *bool               `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs             []string            `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs          []string            `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups             *bool               `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs                   []string            `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs                []string            `json:"removeEditorIDs,omitempty"`
	ClearEditors                   *bool               `json:"clearEditors,omitempty"`
	ApproverID                     *string             `json:"approverID,omitempty"`
	ClearApprover                  *bool               `json:"clearApprover,omitempty"`
	DelegateID                     *string             `json:"delegateID,omitempty"`
	ClearDelegate                  *bool               `json:"clearDelegate,omitempty"`
	InternalPolicyKindID           *string             `json:"internalPolicyKindID,omitempty"`
	ClearInternalPolicyKind        *bool               `json:"clearInternalPolicyKind,omitempty"`
	AddControlObjectiveIDs         []string            `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs      []string            `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives         *bool               `json:"clearControlObjectives,omitempty"`
	AddControlImplementationIDs    []string            `json:"addControlImplementationIDs,omitempty"`
	RemoveControlImplementationIDs []string            `json:"removeControlImplementationIDs,omitempty"`
	ClearControlImplementations    *bool               `json:"clearControlImplementations,omitempty"`
	AddControlIDs                  []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs               []string            `json:"removeControlIDs,omitempty"`
	ClearControls                  *bool               `json:"clearControls,omitempty"`
	AddSubcontrolIDs               []string            `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs            []string            `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols               *bool               `json:"clearSubcontrols,omitempty"`
	AddProcedureIDs                []string            `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs             []string            `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                *bool               `json:"clearProcedures,omitempty"`
	AddNarrativeIDs                []string            `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs             []string            `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives                *bool               `json:"clearNarratives,omitempty"`
	AddTaskIDs                     []string            `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                  []string            `json:"removeTaskIDs,omitempty"`
	ClearTasks                     *bool               `json:"clearTasks,omitempty"`
	AddRiskIDs                     []string            `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                  []string            `json:"removeRiskIDs,omitempty"`
	ClearRisks                     *bool               `json:"clearRisks,omitempty"`
	AddProgramIDs                  []string            `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs               []string            `json:"removeProgramIDs,omitempty"`
	ClearPrograms                  *bool               `json:"clearPrograms,omitempty"`
	FileID                         *string             `json:"fileID,omitempty"`
	ClearFile                      *bool               `json:"clearFile,omitempty"`
	AddCommentIDs                  []string            `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs               []string            `json:"removeCommentIDs,omitempty"`
	ClearComments                  *bool               `json:"clearComments,omitempty"`
	AddWorkflowObjectRefIDs        []string            `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs     []string            `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs        *bool               `json:"clearWorkflowObjectRefs,omitempty"`
	AddComment                     *CreateNoteInput    `json:"addComment,omitempty"`
	DeleteComment                  *string             `json:"deleteComment,omitempty"`
	RevisionBump                   *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateInviteInput is used for update Invite object.
// Input was generated by ent.
type UpdateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires      *time.Time `json:"expires,omitempty"`
	ClearExpires *bool      `json:"clearExpires,omitempty"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts *int64 `json:"sendAttempts,omitempty"`
	// indicates if this invitation is for transferring organization ownership - when accepted, current owner becomes admin and invitee becomes owner
	OwnershipTransfer      *bool    `json:"ownershipTransfer,omitempty"`
	ClearOwnershipTransfer *bool    `json:"clearOwnershipTransfer,omitempty"`
	OwnerID                *string  `json:"ownerID,omitempty"`
	ClearOwner             *bool    `json:"clearOwner,omitempty"`
	AddEventIDs            []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs         []string `json:"removeEventIDs,omitempty"`
	ClearEvents            *bool    `json:"clearEvents,omitempty"`
	AddGroupIDs            []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs         []string `json:"removeGroupIDs,omitempty"`
	ClearGroups            *bool    `json:"clearGroups,omitempty"`
}

// UpdateJobResultInput is used for update JobResult object.
// Input was generated by ent.
type UpdateJobResultInput struct {
	// the status of this job. did it fail? did it succeed?
	Status *enums.JobExecutionStatus `json:"status,omitempty"`
	// the log output from the job
	Log            *string `json:"log,omitempty"`
	ClearLog       *bool   `json:"clearLog,omitempty"`
	OwnerID        *string `json:"ownerID,omitempty"`
	ClearOwner     *bool   `json:"clearOwner,omitempty"`
	ScheduledJobID *string `json:"scheduledJobID,omitempty"`
	FileID         *string `json:"fileID,omitempty"`
}

// UpdateJobRunnerInput is used for update JobRunner object.
// Input was generated by ent.
type UpdateJobRunnerInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the name of the runner
	Name *string `json:"name,omitempty"`
	// the IP address of this runner
	IPAddress      *string `json:"ipAddress,omitempty"`
	ClearIPAddress *bool   `json:"clearIPAddress,omitempty"`
	// the last time this runner was seen
	LastSeen      *time.Time `json:"lastSeen,omitempty"`
	ClearLastSeen *bool      `json:"clearLastSeen,omitempty"`
	// the version of the runner
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// the operating system of the runner
	Os                      *string  `json:"os,omitempty"`
	ClearOs                 *bool    `json:"clearOs,omitempty"`
	OwnerID                 *string  `json:"ownerID,omitempty"`
	ClearOwner              *bool    `json:"clearOwner,omitempty"`
	AddJobRunnerTokenIDs    []string `json:"addJobRunnerTokenIDs,omitempty"`
	RemoveJobRunnerTokenIDs []string `json:"removeJobRunnerTokenIDs,omitempty"`
	ClearJobRunnerTokens    *bool    `json:"clearJobRunnerTokens,omitempty"`
}

// UpdateJobRunnerRegistrationTokenInput is used for update JobRunnerRegistrationToken object.
// Input was generated by ent.
type UpdateJobRunnerRegistrationTokenInput struct {
	// tags associated with the object
	Tags            []string   `json:"tags,omitempty"`
	AppendTags      []string   `json:"appendTags,omitempty"`
	ClearTags       *bool      `json:"clearTags,omitempty"`
	LastUsedAt      *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt *bool      `json:"clearLastUsedAt,omitempty"`
	OwnerID         *string    `json:"ownerID,omitempty"`
	ClearOwner      *bool      `json:"clearOwner,omitempty"`
	JobRunnerID     *string    `json:"jobRunnerID,omitempty"`
	ClearJobRunner  *bool      `json:"clearJobRunner,omitempty"`
}

// UpdateJobRunnerTokenInput is used for update JobRunnerToken object.
// Input was generated by ent.
type UpdateJobRunnerTokenInput struct {
	// tags associated with the object
	Tags            []string   `json:"tags,omitempty"`
	AppendTags      []string   `json:"appendTags,omitempty"`
	ClearTags       *bool      `json:"clearTags,omitempty"`
	LastUsedAt      *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt *bool      `json:"clearLastUsedAt,omitempty"`
	// whether the token is active
	IsActive      *bool `json:"isActive,omitempty"`
	ClearIsActive *bool `json:"clearIsActive,omitempty"`
	// the reason the token was revoked
	RevokedReason      *string `json:"revokedReason,omitempty"`
	ClearRevokedReason *bool   `json:"clearRevokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy      *string `json:"revokedBy,omitempty"`
	ClearRevokedBy *bool   `json:"clearRevokedBy,omitempty"`
	// when the token was revoked
	RevokedAt          *time.Time `json:"revokedAt,omitempty"`
	ClearRevokedAt     *bool      `json:"clearRevokedAt,omitempty"`
	OwnerID            *string    `json:"ownerID,omitempty"`
	ClearOwner         *bool      `json:"clearOwner,omitempty"`
	AddJobRunnerIDs    []string   `json:"addJobRunnerIDs,omitempty"`
	RemoveJobRunnerIDs []string   `json:"removeJobRunnerIDs,omitempty"`
	ClearJobRunners    *bool      `json:"clearJobRunners,omitempty"`
}

// UpdateJobTemplateInput is used for update JobTemplate object.
// Input was generated by ent.
type UpdateJobTemplateInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the title of the job
	Title *string `json:"title,omitempty"`
	// the short description of the job and what it does
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the url from where to download the script from
	DownloadURL *string `json:"downloadURL,omitempty"`
	// the json configuration to run this job, which could be used to template a job, e.g. { "account_name": "my-account" }
	Configuration       models.JobConfiguration `json:"configuration,omitempty"`
	AppendConfiguration models.JobConfiguration `json:"appendConfiguration,omitempty"`
	ClearConfiguration  *bool                   `json:"clearConfiguration,omitempty"`
	// cron schedule to run the job in cron 6-field syntax, e.g. 0 0 0 * * *
	Cron                  *string  `json:"cron,omitempty"`
	ClearCron             *bool    `json:"clearCron,omitempty"`
	OwnerID               *string  `json:"ownerID,omitempty"`
	ClearOwner            *bool    `json:"clearOwner,omitempty"`
	AddScheduledJobIDs    []string `json:"addScheduledJobIDs,omitempty"`
	RemoveScheduledJobIDs []string `json:"removeScheduledJobIDs,omitempty"`
	ClearScheduledJobs    *bool    `json:"clearScheduledJobs,omitempty"`
}

// UpdateMappableDomainInput is used for update MappableDomain object.
// Input was generated by ent.
type UpdateMappableDomainInput struct {
	// tags associated with the object
	Tags                  []string `json:"tags,omitempty"`
	AppendTags            []string `json:"appendTags,omitempty"`
	ClearTags             *bool    `json:"clearTags,omitempty"`
	AddCustomDomainIDs    []string `json:"addCustomDomainIDs,omitempty"`
	RemoveCustomDomainIDs []string `json:"removeCustomDomainIDs,omitempty"`
	ClearCustomDomains    *bool    `json:"clearCustomDomains,omitempty"`
}

// UpdateMappedControlInput is used for update MappedControl object.
// Input was generated by ent.
type UpdateMappedControlInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType *enums.MappingType `json:"mappingType,omitempty"`
	// description of how the two controls are related
	Relation      *string `json:"relation,omitempty"`
	ClearRelation *bool   `json:"clearRelation,omitempty"`
	// percentage (0-100) of confidence in the mapping
	Confidence      *int64 `json:"confidence,omitempty"`
	ClearConfidence *bool  `json:"clearConfidence,omitempty"`
	// source of the mapping, e.g. manual, suggested, etc.
	Source                  *enums.MappingSource `json:"source,omitempty"`
	ClearSource             *bool                `json:"clearSource,omitempty"`
	OwnerID                 *string              `json:"ownerID,omitempty"`
	ClearOwner              *bool                `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs      []string             `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string             `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool                `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string             `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string             `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool                `json:"clearEditors,omitempty"`
	AddFromControlIDs       []string             `json:"addFromControlIDs,omitempty"`
	RemoveFromControlIDs    []string             `json:"removeFromControlIDs,omitempty"`
	ClearFromControls       *bool                `json:"clearFromControls,omitempty"`
	AddToControlIDs         []string             `json:"addToControlIDs,omitempty"`
	RemoveToControlIDs      []string             `json:"removeToControlIDs,omitempty"`
	ClearToControls         *bool                `json:"clearToControls,omitempty"`
	AddFromSubcontrolIDs    []string             `json:"addFromSubcontrolIDs,omitempty"`
	RemoveFromSubcontrolIDs []string             `json:"removeFromSubcontrolIDs,omitempty"`
	ClearFromSubcontrols    *bool                `json:"clearFromSubcontrols,omitempty"`
	AddToSubcontrolIDs      []string             `json:"addToSubcontrolIDs,omitempty"`
	RemoveToSubcontrolIDs   []string             `json:"removeToSubcontrolIDs,omitempty"`
	ClearToSubcontrols      *bool                `json:"clearToSubcontrols,omitempty"`
}

// UpdateNarrativeInput is used for update Narrative object.
// Input was generated by ent.
type UpdateNarrativeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the name of the narrative
	Name *string `json:"name,omitempty"`
	// the description of the narrative
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// text data for the narrative document
	Details                 *string  `json:"details,omitempty"`
	ClearDetails            *bool    `json:"clearDetails,omitempty"`
	AddBlockedGroupIDs      []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs            []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs         []string `json:"removeViewerIDs,omitempty"`
	ClearViewers            *bool    `json:"clearViewers,omitempty"`
	AddSatisfyIDs           []string `json:"addSatisfyIDs,omitempty"`
	RemoveSatisfyIDs        []string `json:"removeSatisfyIDs,omitempty"`
	ClearSatisfies          *bool    `json:"clearSatisfies,omitempty"`
	AddProgramIDs           []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool    `json:"clearPrograms,omitempty"`
	AddInternalPolicyIDs    []string `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool    `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs         []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs      []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures         *bool    `json:"clearProcedures,omitempty"`
}

// UpdateNoteInput is used for update Note object.
// Input was generated by ent.
type UpdateNoteInput struct {
	// the text of the note
	Text                *string  `json:"text,omitempty"`
	TaskID              *string  `json:"taskID,omitempty"`
	ClearTask           *bool    `json:"clearTask,omitempty"`
	ControlID           *string  `json:"controlID,omitempty"`
	ClearControl        *bool    `json:"clearControl,omitempty"`
	SubcontrolID        *string  `json:"subcontrolID,omitempty"`
	ClearSubcontrol     *bool    `json:"clearSubcontrol,omitempty"`
	ProcedureID         *string  `json:"procedureID,omitempty"`
	ClearProcedure      *bool    `json:"clearProcedure,omitempty"`
	RiskID              *string  `json:"riskID,omitempty"`
	ClearRisk           *bool    `json:"clearRisk,omitempty"`
	InternalPolicyID    *string  `json:"internalPolicyID,omitempty"`
	ClearInternalPolicy *bool    `json:"clearInternalPolicy,omitempty"`
	EvidenceID          *string  `json:"evidenceID,omitempty"`
	ClearEvidence       *bool    `json:"clearEvidence,omitempty"`
	TrustCenterID       *string  `json:"trustCenterID,omitempty"`
	ClearTrustCenter    *bool    `json:"clearTrustCenter,omitempty"`
	AddFileIDs          []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs       []string `json:"removeFileIDs,omitempty"`
	ClearFiles          *bool    `json:"clearFiles,omitempty"`
}

// UpdateOrgMembershipInput is used for update OrgMembership object.
// Input was generated by ent.
type UpdateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the organization
	Name *string `json:"name,omitempty"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt                         *time.Time                      `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt                    *bool                           `json:"clearAvatarUpdatedAt,omitempty"`
	AddControlCreatorIDs                    []string                        `json:"addControlCreatorIDs,omitempty"`
	RemoveControlCreatorIDs                 []string                        `json:"removeControlCreatorIDs,omitempty"`
	ClearControlCreators                    *bool                           `json:"clearControlCreators,omitempty"`
	AddControlImplementationCreatorIDs      []string                        `json:"addControlImplementationCreatorIDs,omitempty"`
	RemoveControlImplementationCreatorIDs   []string                        `json:"removeControlImplementationCreatorIDs,omitempty"`
	ClearControlImplementationCreators      *bool                           `json:"clearControlImplementationCreators,omitempty"`
	AddControlObjectiveCreatorIDs           []string                        `json:"addControlObjectiveCreatorIDs,omitempty"`
	RemoveControlObjectiveCreatorIDs        []string                        `json:"removeControlObjectiveCreatorIDs,omitempty"`
	ClearControlObjectiveCreators           *bool                           `json:"clearControlObjectiveCreators,omitempty"`
	AddEvidenceCreatorIDs                   []string                        `json:"addEvidenceCreatorIDs,omitempty"`
	RemoveEvidenceCreatorIDs                []string                        `json:"removeEvidenceCreatorIDs,omitempty"`
	ClearEvidenceCreators                   *bool                           `json:"clearEvidenceCreators,omitempty"`
	AddGroupCreatorIDs                      []string                        `json:"addGroupCreatorIDs,omitempty"`
	RemoveGroupCreatorIDs                   []string                        `json:"removeGroupCreatorIDs,omitempty"`
	ClearGroupCreators                      *bool                           `json:"clearGroupCreators,omitempty"`
	AddInternalPolicyCreatorIDs             []string                        `json:"addInternalPolicyCreatorIDs,omitempty"`
	RemoveInternalPolicyCreatorIDs          []string                        `json:"removeInternalPolicyCreatorIDs,omitempty"`
	ClearInternalPolicyCreators             *bool                           `json:"clearInternalPolicyCreators,omitempty"`
	AddMappedControlCreatorIDs              []string                        `json:"addMappedControlCreatorIDs,omitempty"`
	RemoveMappedControlCreatorIDs           []string                        `json:"removeMappedControlCreatorIDs,omitempty"`
	ClearMappedControlCreators              *bool                           `json:"clearMappedControlCreators,omitempty"`
	AddNarrativeCreatorIDs                  []string                        `json:"addNarrativeCreatorIDs,omitempty"`
	RemoveNarrativeCreatorIDs               []string                        `json:"removeNarrativeCreatorIDs,omitempty"`
	ClearNarrativeCreators                  *bool                           `json:"clearNarrativeCreators,omitempty"`
	AddProcedureCreatorIDs                  []string                        `json:"addProcedureCreatorIDs,omitempty"`
	RemoveProcedureCreatorIDs               []string                        `json:"removeProcedureCreatorIDs,omitempty"`
	ClearProcedureCreators                  *bool                           `json:"clearProcedureCreators,omitempty"`
	AddProgramCreatorIDs                    []string                        `json:"addProgramCreatorIDs,omitempty"`
	RemoveProgramCreatorIDs                 []string                        `json:"removeProgramCreatorIDs,omitempty"`
	ClearProgramCreators                    *bool                           `json:"clearProgramCreators,omitempty"`
	AddRiskCreatorIDs                       []string                        `json:"addRiskCreatorIDs,omitempty"`
	RemoveRiskCreatorIDs                    []string                        `json:"removeRiskCreatorIDs,omitempty"`
	ClearRiskCreators                       *bool                           `json:"clearRiskCreators,omitempty"`
	AddScheduledJobCreatorIDs               []string                        `json:"addScheduledJobCreatorIDs,omitempty"`
	RemoveScheduledJobCreatorIDs            []string                        `json:"removeScheduledJobCreatorIDs,omitempty"`
	ClearScheduledJobCreators               *bool                           `json:"clearScheduledJobCreators,omitempty"`
	AddStandardCreatorIDs                   []string                        `json:"addStandardCreatorIDs,omitempty"`
	RemoveStandardCreatorIDs                []string                        `json:"removeStandardCreatorIDs,omitempty"`
	ClearStandardCreators                   *bool                           `json:"clearStandardCreators,omitempty"`
	AddTemplateCreatorIDs                   []string                        `json:"addTemplateCreatorIDs,omitempty"`
	RemoveTemplateCreatorIDs                []string                        `json:"removeTemplateCreatorIDs,omitempty"`
	ClearTemplateCreators                   *bool                           `json:"clearTemplateCreators,omitempty"`
	AddSubprocessorCreatorIDs               []string                        `json:"addSubprocessorCreatorIDs,omitempty"`
	RemoveSubprocessorCreatorIDs            []string                        `json:"removeSubprocessorCreatorIDs,omitempty"`
	ClearSubprocessorCreators               *bool                           `json:"clearSubprocessorCreators,omitempty"`
	AddTrustCenterDocCreatorIDs             []string                        `json:"addTrustCenterDocCreatorIDs,omitempty"`
	RemoveTrustCenterDocCreatorIDs          []string                        `json:"removeTrustCenterDocCreatorIDs,omitempty"`
	ClearTrustCenterDocCreators             *bool                           `json:"clearTrustCenterDocCreators,omitempty"`
	AddTrustCenterSubprocessorCreatorIDs    []string                        `json:"addTrustCenterSubprocessorCreatorIDs,omitempty"`
	RemoveTrustCenterSubprocessorCreatorIDs []string                        `json:"removeTrustCenterSubprocessorCreatorIDs,omitempty"`
	ClearTrustCenterSubprocessorCreators    *bool                           `json:"clearTrustCenterSubprocessorCreators,omitempty"`
	SettingID                               *string                         `json:"settingID,omitempty"`
	ClearSetting                            *bool                           `json:"clearSetting,omitempty"`
	AddPersonalAccessTokenIDs               []string                        `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs            []string                        `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens               *bool                           `json:"clearPersonalAccessTokens,omitempty"`
	AddAPITokenIDs                          []string                        `json:"addAPITokenIDs,omitempty"`
	RemoveAPITokenIDs                       []string                        `json:"removeAPITokenIDs,omitempty"`
	ClearAPITokens                          *bool                           `json:"clearAPITokens,omitempty"`
	AddFileIDs                              []string                        `json:"addFileIDs,omitempty"`
	RemoveFileIDs                           []string                        `json:"removeFileIDs,omitempty"`
	ClearFiles                              *bool                           `json:"clearFiles,omitempty"`
	AddEventIDs                             []string                        `json:"addEventIDs,omitempty"`
	RemoveEventIDs                          []string                        `json:"removeEventIDs,omitempty"`
	ClearEvents                             *bool                           `json:"clearEvents,omitempty"`
	AddSecretIDs                            []string                        `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs                         []string                        `json:"removeSecretIDs,omitempty"`
	ClearSecrets                            *bool                           `json:"clearSecrets,omitempty"`
	AvatarFileID                            *string                         `json:"avatarFileID,omitempty"`
	ClearAvatarFile                         *bool                           `json:"clearAvatarFile,omitempty"`
	AddGroupIDs                             []string                        `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                          []string                        `json:"removeGroupIDs,omitempty"`
	ClearGroups                             *bool                           `json:"clearGroups,omitempty"`
	AddTemplateIDs                          []string                        `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs                       []string                        `json:"removeTemplateIDs,omitempty"`
	ClearTemplates                          *bool                           `json:"clearTemplates,omitempty"`
	AddIntegrationIDs                       []string                        `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs                    []string                        `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations                       *bool                           `json:"clearIntegrations,omitempty"`
	AddDocumentIDs                          []string                        `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs                       []string                        `json:"removeDocumentIDs,omitempty"`
	ClearDocuments                          *bool                           `json:"clearDocuments,omitempty"`
	AddOrgSubscriptionIDs                   []string                        `json:"addOrgSubscriptionIDs,omitempty"`
	RemoveOrgSubscriptionIDs                []string                        `json:"removeOrgSubscriptionIDs,omitempty"`
	ClearOrgSubscriptions                   *bool                           `json:"clearOrgSubscriptions,omitempty"`
	AddInviteIDs                            []string                        `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs                         []string                        `json:"removeInviteIDs,omitempty"`
	ClearInvites                            *bool                           `json:"clearInvites,omitempty"`
	AddSubscriberIDs                        []string                        `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs                     []string                        `json:"removeSubscriberIDs,omitempty"`
	ClearSubscribers                        *bool                           `json:"clearSubscribers,omitempty"`
	AddEntityIDs                            []string                        `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs                         []string                        `json:"removeEntityIDs,omitempty"`
	ClearEntities                           *bool                           `json:"clearEntities,omitempty"`
	AddEntityTypeIDs                        []string                        `json:"addEntityTypeIDs,omitempty"`
	RemoveEntityTypeIDs                     []string                        `json:"removeEntityTypeIDs,omitempty"`
	ClearEntityTypes                        *bool                           `json:"clearEntityTypes,omitempty"`
	AddContactIDs                           []string                        `json:"addContactIDs,omitempty"`
	RemoveContactIDs                        []string                        `json:"removeContactIDs,omitempty"`
	ClearContacts                           *bool                           `json:"clearContacts,omitempty"`
	AddNoteIDs                              []string                        `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs                           []string                        `json:"removeNoteIDs,omitempty"`
	ClearNotes                              *bool                           `json:"clearNotes,omitempty"`
	AddTaskIDs                              []string                        `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                           []string                        `json:"removeTaskIDs,omitempty"`
	ClearTasks                              *bool                           `json:"clearTasks,omitempty"`
	AddProgramIDs                           []string                        `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs                        []string                        `json:"removeProgramIDs,omitempty"`
	ClearPrograms                           *bool                           `json:"clearPrograms,omitempty"`
	AddProcedureIDs                         []string                        `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs                      []string                        `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                         *bool                           `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs                    []string                        `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs                 []string                        `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies                   *bool                           `json:"clearInternalPolicies,omitempty"`
	AddRiskIDs                              []string                        `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                           []string                        `json:"removeRiskIDs,omitempty"`
	ClearRisks                              *bool                           `json:"clearRisks,omitempty"`
	AddControlObjectiveIDs                  []string                        `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs               []string                        `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives                  *bool                           `json:"clearControlObjectives,omitempty"`
	AddNarrativeIDs                         []string                        `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs                      []string                        `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives                         *bool                           `json:"clearNarratives,omitempty"`
	AddControlIDs                           []string                        `json:"addControlIDs,omitempty"`
	RemoveControlIDs                        []string                        `json:"removeControlIDs,omitempty"`
	ClearControls                           *bool                           `json:"clearControls,omitempty"`
	AddSubcontrolIDs                        []string                        `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs                     []string                        `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols                        *bool                           `json:"clearSubcontrols,omitempty"`
	AddControlImplementationIDs             []string                        `json:"addControlImplementationIDs,omitempty"`
	RemoveControlImplementationIDs          []string                        `json:"removeControlImplementationIDs,omitempty"`
	ClearControlImplementations             *bool                           `json:"clearControlImplementations,omitempty"`
	AddMappedControlIDs                     []string                        `json:"addMappedControlIDs,omitempty"`
	RemoveMappedControlIDs                  []string                        `json:"removeMappedControlIDs,omitempty"`
	ClearMappedControls                     *bool                           `json:"clearMappedControls,omitempty"`
	AddEvidenceIDs                          []string                        `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs                       []string                        `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                           *bool                           `json:"clearEvidence,omitempty"`
	AddStandardIDs                          []string                        `json:"addStandardIDs,omitempty"`
	RemoveStandardIDs                       []string                        `json:"removeStandardIDs,omitempty"`
	ClearStandards                          *bool                           `json:"clearStandards,omitempty"`
	AddActionPlanIDs                        []string                        `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs                     []string                        `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans                        *bool                           `json:"clearActionPlans,omitempty"`
	AddCustomDomainIDs                      []string                        `json:"addCustomDomainIDs,omitempty"`
	RemoveCustomDomainIDs                   []string                        `json:"removeCustomDomainIDs,omitempty"`
	ClearCustomDomains                      *bool                           `json:"clearCustomDomains,omitempty"`
	AddJobRunnerIDs                         []string                        `json:"addJobRunnerIDs,omitempty"`
	RemoveJobRunnerIDs                      []string                        `json:"removeJobRunnerIDs,omitempty"`
	ClearJobRunners                         *bool                           `json:"clearJobRunners,omitempty"`
	AddJobRunnerTokenIDs                    []string                        `json:"addJobRunnerTokenIDs,omitempty"`
	RemoveJobRunnerTokenIDs                 []string                        `json:"removeJobRunnerTokenIDs,omitempty"`
	ClearJobRunnerTokens                    *bool                           `json:"clearJobRunnerTokens,omitempty"`
	AddJobRunnerRegistrationTokenIDs        []string                        `json:"addJobRunnerRegistrationTokenIDs,omitempty"`
	RemoveJobRunnerRegistrationTokenIDs     []string                        `json:"removeJobRunnerRegistrationTokenIDs,omitempty"`
	ClearJobRunnerRegistrationTokens        *bool                           `json:"clearJobRunnerRegistrationTokens,omitempty"`
	AddDNSVerificationIDs                   []string                        `json:"addDNSVerificationIDs,omitempty"`
	RemoveDNSVerificationIDs                []string                        `json:"removeDNSVerificationIDs,omitempty"`
	ClearDNSVerifications                   *bool                           `json:"clearDNSVerifications,omitempty"`
	AddJobTemplateIDs                       []string                        `json:"addJobTemplateIDs,omitempty"`
	RemoveJobTemplateIDs                    []string                        `json:"removeJobTemplateIDs,omitempty"`
	ClearJobTemplates                       *bool                           `json:"clearJobTemplates,omitempty"`
	AddScheduledJobIDs                      []string                        `json:"addScheduledJobIDs,omitempty"`
	RemoveScheduledJobIDs                   []string                        `json:"removeScheduledJobIDs,omitempty"`
	ClearScheduledJobs                      *bool                           `json:"clearScheduledJobs,omitempty"`
	AddJobResultIDs                         []string                        `json:"addJobResultIDs,omitempty"`
	RemoveJobResultIDs                      []string                        `json:"removeJobResultIDs,omitempty"`
	ClearJobResults                         *bool                           `json:"clearJobResults,omitempty"`
	AddScheduledJobRunIDs                   []string                        `json:"addScheduledJobRunIDs,omitempty"`
	RemoveScheduledJobRunIDs                []string                        `json:"removeScheduledJobRunIDs,omitempty"`
	ClearScheduledJobRuns                   *bool                           `json:"clearScheduledJobRuns,omitempty"`
	AddTrustCenterIDs                       []string                        `json:"addTrustCenterIDs,omitempty"`
	RemoveTrustCenterIDs                    []string                        `json:"removeTrustCenterIDs,omitempty"`
	ClearTrustCenters                       *bool                           `json:"clearTrustCenters,omitempty"`
	AddAssetIDs                             []string                        `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs                          []string                        `json:"removeAssetIDs,omitempty"`
	ClearAssets                             *bool                           `json:"clearAssets,omitempty"`
	AddScanIDs                              []string                        `json:"addScanIDs,omitempty"`
	RemoveScanIDs                           []string                        `json:"removeScanIDs,omitempty"`
	ClearScans                              *bool                           `json:"clearScans,omitempty"`
	AddSubprocessorIDs                      []string                        `json:"addSubprocessorIDs,omitempty"`
	RemoveSubprocessorIDs                   []string                        `json:"removeSubprocessorIDs,omitempty"`
	ClearSubprocessors                      *bool                           `json:"clearSubprocessors,omitempty"`
	AddExportIDs                            []string                        `json:"addExportIDs,omitempty"`
	RemoveExportIDs                         []string                        `json:"removeExportIDs,omitempty"`
	ClearExports                            *bool                           `json:"clearExports,omitempty"`
	AddTrustCenterWatermarkConfigIDs        []string                        `json:"addTrustCenterWatermarkConfigIDs,omitempty"`
	RemoveTrustCenterWatermarkConfigIDs     []string                        `json:"removeTrustCenterWatermarkConfigIDs,omitempty"`
	ClearTrustCenterWatermarkConfigs        *bool                           `json:"clearTrustCenterWatermarkConfigs,omitempty"`
	AddImpersonationEventIDs                []string                        `json:"addImpersonationEventIDs,omitempty"`
	RemoveImpersonationEventIDs             []string                        `json:"removeImpersonationEventIDs,omitempty"`
	ClearImpersonationEvents                *bool                           `json:"clearImpersonationEvents,omitempty"`
	AddAssessmentIDs                        []string                        `json:"addAssessmentIDs,omitempty"`
	RemoveAssessmentIDs                     []string                        `json:"removeAssessmentIDs,omitempty"`
	ClearAssessments                        *bool                           `json:"clearAssessments,omitempty"`
	AddAssessmentResponseIDs                []string                        `json:"addAssessmentResponseIDs,omitempty"`
	RemoveAssessmentResponseIDs             []string                        `json:"removeAssessmentResponseIDs,omitempty"`
	ClearAssessmentResponses                *bool                           `json:"clearAssessmentResponses,omitempty"`
	AddCustomTypeEnumIDs                    []string                        `json:"addCustomTypeEnumIDs,omitempty"`
	RemoveCustomTypeEnumIDs                 []string                        `json:"removeCustomTypeEnumIDs,omitempty"`
	ClearCustomTypeEnums                    *bool                           `json:"clearCustomTypeEnums,omitempty"`
	AddTagDefinitionIDs                     []string                        `json:"addTagDefinitionIDs,omitempty"`
	RemoveTagDefinitionIDs                  []string                        `json:"removeTagDefinitionIDs,omitempty"`
	ClearTagDefinitions                     *bool                           `json:"clearTagDefinitions,omitempty"`
	AddRemediationIDs                       []string                        `json:"addRemediationIDs,omitempty"`
	RemoveRemediationIDs                    []string                        `json:"removeRemediationIDs,omitempty"`
	ClearRemediations                       *bool                           `json:"clearRemediations,omitempty"`
	AddFindingIDs                           []string                        `json:"addFindingIDs,omitempty"`
	RemoveFindingIDs                        []string                        `json:"removeFindingIDs,omitempty"`
	ClearFindings                           *bool                           `json:"clearFindings,omitempty"`
	AddReviewIDs                            []string                        `json:"addReviewIDs,omitempty"`
	RemoveReviewIDs                         []string                        `json:"removeReviewIDs,omitempty"`
	ClearReviews                            *bool                           `json:"clearReviews,omitempty"`
	AddVulnerabilityIDs                     []string                        `json:"addVulnerabilityIDs,omitempty"`
	RemoveVulnerabilityIDs                  []string                        `json:"removeVulnerabilityIDs,omitempty"`
	ClearVulnerabilities                    *bool                           `json:"clearVulnerabilities,omitempty"`
	AddWorkflowDefinitionIDs                []string                        `json:"addWorkflowDefinitionIDs,omitempty"`
	RemoveWorkflowDefinitionIDs             []string                        `json:"removeWorkflowDefinitionIDs,omitempty"`
	ClearWorkflowDefinitions                *bool                           `json:"clearWorkflowDefinitions,omitempty"`
	AddWorkflowInstanceIDs                  []string                        `json:"addWorkflowInstanceIDs,omitempty"`
	RemoveWorkflowInstanceIDs               []string                        `json:"removeWorkflowInstanceIDs,omitempty"`
	ClearWorkflowInstances                  *bool                           `json:"clearWorkflowInstances,omitempty"`
	AddWorkflowEventIDs                     []string                        `json:"addWorkflowEventIDs,omitempty"`
	RemoveWorkflowEventIDs                  []string                        `json:"removeWorkflowEventIDs,omitempty"`
	ClearWorkflowEvents                     *bool                           `json:"clearWorkflowEvents,omitempty"`
	AddWorkflowAssignmentIDs                []string                        `json:"addWorkflowAssignmentIDs,omitempty"`
	RemoveWorkflowAssignmentIDs             []string                        `json:"removeWorkflowAssignmentIDs,omitempty"`
	ClearWorkflowAssignments                *bool                           `json:"clearWorkflowAssignments,omitempty"`
	AddWorkflowAssignmentTargetIDs          []string                        `json:"addWorkflowAssignmentTargetIDs,omitempty"`
	RemoveWorkflowAssignmentTargetIDs       []string                        `json:"removeWorkflowAssignmentTargetIDs,omitempty"`
	ClearWorkflowAssignmentTargets          *bool                           `json:"clearWorkflowAssignmentTargets,omitempty"`
	AddWorkflowObjectRefIDs                 []string                        `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs              []string                        `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs                 *bool                           `json:"clearWorkflowObjectRefs,omitempty"`
	AddDirectoryAccountIDs                  []string                        `json:"addDirectoryAccountIDs,omitempty"`
	RemoveDirectoryAccountIDs               []string                        `json:"removeDirectoryAccountIDs,omitempty"`
	ClearDirectoryAccounts                  *bool                           `json:"clearDirectoryAccounts,omitempty"`
	AddDirectoryGroupIDs                    []string                        `json:"addDirectoryGroupIDs,omitempty"`
	RemoveDirectoryGroupIDs                 []string                        `json:"removeDirectoryGroupIDs,omitempty"`
	ClearDirectoryGroups                    *bool                           `json:"clearDirectoryGroups,omitempty"`
	AddDirectorySyncRunIDs                  []string                        `json:"addDirectorySyncRunIDs,omitempty"`
	RemoveDirectorySyncRunIDs               []string                        `json:"removeDirectorySyncRunIDs,omitempty"`
	ClearDirectorySyncRuns                  *bool                           `json:"clearDirectorySyncRuns,omitempty"`
	AddOrgMembers                           []*CreateOrgMembershipInput     `json:"addOrgMembers,omitempty"`
	RemoveOrgMembers                        []string                        `json:"removeOrgMembers,omitempty"`
	UpdateOrgSettings                       *UpdateOrganizationSettingInput `json:"updateOrgSettings,omitempty"`
}

// UpdateOrganizationSettingInput is used for update OrganizationSetting object.
// Input was generated by ent.
type UpdateOrganizationSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// Name of the person to contact for billing
	BillingContact      *string `json:"billingContact,omitempty"`
	ClearBillingContact *bool   `json:"clearBillingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail      *string `json:"billingEmail,omitempty"`
	ClearBillingEmail *bool   `json:"clearBillingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone      *string `json:"billingPhone,omitempty"`
	ClearBillingPhone *bool   `json:"clearBillingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress      *models.Address `json:"billingAddress,omitempty"`
	ClearBillingAddress *bool           `json:"clearBillingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier      *string `json:"taxIdentifier,omitempty"`
	ClearTaxIdentifier *bool   `json:"clearTaxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation      *enums.Region `json:"geoLocation,omitempty"`
	ClearGeoLocation *bool         `json:"clearGeoLocation,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled *bool `json:"billingNotificationsEnabled,omitempty"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains       []string `json:"allowedEmailDomains,omitempty"`
	AppendAllowedEmailDomains []string `json:"appendAllowedEmailDomains,omitempty"`
	ClearAllowedEmailDomains  *bool    `json:"clearAllowedEmailDomains,omitempty"`
	// allow users who can successfully confirm their email or who login via social providers with an email that matches the organizations configured allowed domain to auto-join the organization
	AllowMatchingDomainsAutojoin      *bool `json:"allowMatchingDomainsAutojoin,omitempty"`
	ClearAllowMatchingDomainsAutojoin *bool `json:"clearAllowMatchingDomainsAutojoin,omitempty"`
	// SSO provider type for the organization
	IdentityProvider      *enums.SSOProvider `json:"identityProvider,omitempty"`
	ClearIdentityProvider *bool              `json:"clearIdentityProvider,omitempty"`
	// client ID for SSO integration
	IdentityProviderClientID      *string `json:"identityProviderClientID,omitempty"`
	ClearIdentityProviderClientID *bool   `json:"clearIdentityProviderClientID,omitempty"`
	// client secret for SSO integration
	IdentityProviderClientSecret      *string `json:"identityProviderClientSecret,omitempty"`
	ClearIdentityProviderClientSecret *bool   `json:"clearIdentityProviderClientSecret,omitempty"`
	// metadata URL for the SSO provider
	IdentityProviderMetadataEndpoint      *string `json:"identityProviderMetadataEndpoint,omitempty"`
	ClearIdentityProviderMetadataEndpoint *bool   `json:"clearIdentityProviderMetadataEndpoint,omitempty"`
	// SAML entity ID for the SSO provider
	IdentityProviderEntityID      *string `json:"identityProviderEntityID,omitempty"`
	ClearIdentityProviderEntityID *bool   `json:"clearIdentityProviderEntityID,omitempty"`
	// OIDC discovery URL for the SSO provider
	OidcDiscoveryEndpoint      *string `json:"oidcDiscoveryEndpoint,omitempty"`
	ClearOidcDiscoveryEndpoint *bool   `json:"clearOidcDiscoveryEndpoint,omitempty"`
	// the sign in URL to be used for SAML-based authentication
	SamlSigninURL      *string `json:"samlSigninURL,omitempty"`
	ClearSamlSigninURL *bool   `json:"clearSamlSigninURL,omitempty"`
	// the SAML issuer
	SamlIssuer      *string `json:"samlIssuer,omitempty"`
	ClearSamlIssuer *bool   `json:"clearSamlIssuer,omitempty"`
	// the x509 certificate used to validate SAML responses
	SamlCert      *string `json:"samlCert,omitempty"`
	ClearSamlCert *bool   `json:"clearSamlCert,omitempty"`
	// enforce SSO authentication for organization members
	IdentityProviderLoginEnforced *bool `json:"identityProviderLoginEnforced,omitempty"`
	// enforce 2fa / multifactor authentication for organization members
	MultifactorAuthEnforced      *bool `json:"multifactorAuthEnforced,omitempty"`
	ClearMultifactorAuthEnforced *bool `json:"clearMultifactorAuthEnforced,omitempty"`
	// unique token used to receive compliance webhook events
	ComplianceWebhookToken      *string  `json:"complianceWebhookToken,omitempty"`
	ClearComplianceWebhookToken *bool    `json:"clearComplianceWebhookToken,omitempty"`
	OrganizationID              *string  `json:"organizationID,omitempty"`
	ClearOrganization           *bool    `json:"clearOrganization,omitempty"`
	AddFileIDs                  []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs               []string `json:"removeFileIDs,omitempty"`
	ClearFiles                  *bool    `json:"clearFiles,omitempty"`
}

// UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
// Input was generated by ent.
type UpdatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// when the token expires
	ExpiresAt      *time.Time `json:"expiresAt,omitempty"`
	ClearExpiresAt *bool      `json:"clearExpiresAt,omitempty"`
	// a description of the token's purpose
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	Scopes           []string   `json:"scopes,omitempty"`
	AppendScopes     []string   `json:"appendScopes,omitempty"`
	ClearScopes      *bool      `json:"clearScopes,omitempty"`
	LastUsedAt       *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt  *bool      `json:"clearLastUsedAt,omitempty"`
	// whether the token is active
	IsActive              *bool    `json:"isActive,omitempty"`
	ClearIsActive         *bool    `json:"clearIsActive,omitempty"`
	AddOrganizationIDs    []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations    *bool    `json:"clearOrganizations,omitempty"`
	AddEventIDs           []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool    `json:"clearEvents,omitempty"`
}

// UpdateProcedureInput is used for update Procedure object.
// Input was generated by ent.
type UpdateProcedureInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// the name of the procedure
	Name *string `json:"name,omitempty"`
	// status of the procedure, e.g. draft, published, archived, etc.
	Status      *enums.DocumentStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// type of the procedure, e.g. compliance, operational, health and safety, etc.
	ProcedureType      *string `json:"procedureType,omitempty"`
	ClearProcedureType *bool   `json:"clearProcedureType,omitempty"`
	// details of the procedure
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// whether approval is required for edits to the procedure
	ApprovalRequired      *bool `json:"approvalRequired,omitempty"`
	ClearApprovalRequired *bool `json:"clearApprovalRequired,omitempty"`
	// the date the procedure should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue      *time.Time `json:"reviewDue,omitempty"`
	ClearReviewDue *bool      `json:"clearReviewDue,omitempty"`
	// the frequency at which the procedure should be reviewed, used to calculate the review_due date
	ReviewFrequency      *enums.Frequency `json:"reviewFrequency,omitempty"`
	ClearReviewFrequency *bool            `json:"clearReviewFrequency,omitempty"`
	// auto-generated tag suggestions for the procedure
	TagSuggestions       []string `json:"tagSuggestions,omitempty"`
	AppendTagSuggestions []string `json:"appendTagSuggestions,omitempty"`
	ClearTagSuggestions  *bool    `json:"clearTagSuggestions,omitempty"`
	// tag suggestions dismissed by the user for the procedure
	DismissedTagSuggestions       []string `json:"dismissedTagSuggestions,omitempty"`
	AppendDismissedTagSuggestions []string `json:"appendDismissedTagSuggestions,omitempty"`
	ClearDismissedTagSuggestions  *bool    `json:"clearDismissedTagSuggestions,omitempty"`
	// proposed controls referenced in the procedure
	ControlSuggestions       []string `json:"controlSuggestions,omitempty"`
	AppendControlSuggestions []string `json:"appendControlSuggestions,omitempty"`
	ClearControlSuggestions  *bool    `json:"clearControlSuggestions,omitempty"`
	// control suggestions dismissed by the user for the procedure
	DismissedControlSuggestions       []string `json:"dismissedControlSuggestions,omitempty"`
	AppendDismissedControlSuggestions []string `json:"appendDismissedControlSuggestions,omitempty"`
	ClearDismissedControlSuggestions  *bool    `json:"clearDismissedControlSuggestions,omitempty"`
	// suggested improvements for the procedure
	ImprovementSuggestions       []string `json:"improvementSuggestions,omitempty"`
	AppendImprovementSuggestions []string `json:"appendImprovementSuggestions,omitempty"`
	ClearImprovementSuggestions  *bool    `json:"clearImprovementSuggestions,omitempty"`
	// improvement suggestions dismissed by the user for the procedure
	DismissedImprovementSuggestions       []string `json:"dismissedImprovementSuggestions,omitempty"`
	AppendDismissedImprovementSuggestions []string `json:"appendDismissedImprovementSuggestions,omitempty"`
	ClearDismissedImprovementSuggestions  *bool    `json:"clearDismissedImprovementSuggestions,omitempty"`
	// This will contain the url used to create or update the procedure
	URL      *string `json:"url,omitempty"`
	ClearURL *bool   `json:"clearURL,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the kind of the procedure
	ProcedureKindName       *string             `json:"procedureKindName,omitempty"`
	ClearProcedureKindName  *bool               `json:"clearProcedureKindName,omitempty"`
	OwnerID                 *string             `json:"ownerID,omitempty"`
	ClearOwner              *bool               `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs      []string            `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string            `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool               `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string            `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string            `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool               `json:"clearEditors,omitempty"`
	ApproverID              *string             `json:"approverID,omitempty"`
	ClearApprover           *bool               `json:"clearApprover,omitempty"`
	DelegateID              *string             `json:"delegateID,omitempty"`
	ClearDelegate           *bool               `json:"clearDelegate,omitempty"`
	ProcedureKindID         *string             `json:"procedureKindID,omitempty"`
	ClearProcedureKind      *bool               `json:"clearProcedureKind,omitempty"`
	AddControlIDs           []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string            `json:"removeControlIDs,omitempty"`
	ClearControls           *bool               `json:"clearControls,omitempty"`
	AddSubcontrolIDs        []string            `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs     []string            `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols        *bool               `json:"clearSubcontrols,omitempty"`
	AddInternalPolicyIDs    []string            `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string            `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool               `json:"clearInternalPolicies,omitempty"`
	AddProgramIDs           []string            `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string            `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool               `json:"clearPrograms,omitempty"`
	AddNarrativeIDs         []string            `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs      []string            `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives         *bool               `json:"clearNarratives,omitempty"`
	AddRiskIDs              []string            `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs           []string            `json:"removeRiskIDs,omitempty"`
	ClearRisks              *bool               `json:"clearRisks,omitempty"`
	AddTaskIDs              []string            `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string            `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool               `json:"clearTasks,omitempty"`
	AddCommentIDs           []string            `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs        []string            `json:"removeCommentIDs,omitempty"`
	ClearComments           *bool               `json:"clearComments,omitempty"`
	FileID                  *string             `json:"fileID,omitempty"`
	ClearFile               *bool               `json:"clearFile,omitempty"`
	AddComment              *CreateNoteInput    `json:"addComment,omitempty"`
	DeleteComment           *string             `json:"deleteComment,omitempty"`
	RevisionBump            *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateProgramInput is used for update Program object.
// Input was generated by ent.
type UpdateProgramInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the kind of the program
	ProgramKindName      *string `json:"programKindName,omitempty"`
	ClearProgramKindName *bool   `json:"clearProgramKindName,omitempty"`
	// the name of the program
	Name *string `json:"name,omitempty"`
	// the description of the program
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the status of the program
	Status *enums.ProgramStatus `json:"status,omitempty"`
	// the type of the program
	ProgramType *enums.ProgramType `json:"programType,omitempty"`
	// the short name of the compliance standard the program is based on, only used for framework type programs
	FrameworkName      *string `json:"frameworkName,omitempty"`
	ClearFrameworkName *bool   `json:"clearFrameworkName,omitempty"`
	// the start date of the period
	StartDate      *time.Time `json:"startDate,omitempty"`
	ClearStartDate *bool      `json:"clearStartDate,omitempty"`
	// the end date of the period
	EndDate      *time.Time `json:"endDate,omitempty"`
	ClearEndDate *bool      `json:"clearEndDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady *bool `json:"auditorReady,omitempty"`
	// can the auditor write comments
	AuditorWriteComments *bool `json:"auditorWriteComments,omitempty"`
	// can the auditor read comments
	AuditorReadComments *bool `json:"auditorReadComments,omitempty"`
	// the name of the audit firm conducting the audit
	AuditFirm      *string `json:"auditFirm,omitempty"`
	ClearAuditFirm *bool   `json:"clearAuditFirm,omitempty"`
	// the full name of the auditor conducting the audit
	Auditor      *string `json:"auditor,omitempty"`
	ClearAuditor *bool   `json:"clearAuditor,omitempty"`
	// the email of the auditor conducting the audit
	AuditorEmail              *string                      `json:"auditorEmail,omitempty"`
	ClearAuditorEmail         *bool                        `json:"clearAuditorEmail,omitempty"`
	OwnerID                   *string                      `json:"ownerID,omitempty"`
	ClearOwner                *bool                        `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs        []string                     `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs     []string                     `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups        *bool                        `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs              []string                     `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs           []string                     `json:"removeEditorIDs,omitempty"`
	ClearEditors              *bool                        `json:"clearEditors,omitempty"`
	AddViewerIDs              []string                     `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs           []string                     `json:"removeViewerIDs,omitempty"`
	ClearViewers              *bool                        `json:"clearViewers,omitempty"`
	ProgramKindID             *string                      `json:"programKindID,omitempty"`
	ClearProgramKind          *bool                        `json:"clearProgramKind,omitempty"`
	AddControlIDs             []string                     `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string                     `json:"removeControlIDs,omitempty"`
	ClearControls             *bool                        `json:"clearControls,omitempty"`
	AddSubcontrolIDs          []string                     `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string                     `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols          *bool                        `json:"clearSubcontrols,omitempty"`
	AddControlObjectiveIDs    []string                     `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string                     `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool                        `json:"clearControlObjectives,omitempty"`
	AddInternalPolicyIDs      []string                     `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs   []string                     `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies     *bool                        `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs           []string                     `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string                     `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool                        `json:"clearProcedures,omitempty"`
	AddRiskIDs                []string                     `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs             []string                     `json:"removeRiskIDs,omitempty"`
	ClearRisks                *bool                        `json:"clearRisks,omitempty"`
	AddTaskIDs                []string                     `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string                     `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool                        `json:"clearTasks,omitempty"`
	AddNoteIDs                []string                     `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs             []string                     `json:"removeNoteIDs,omitempty"`
	ClearNotes                *bool                        `json:"clearNotes,omitempty"`
	AddFileIDs                []string                     `json:"addFileIDs,omitempty"`
	RemoveFileIDs             []string                     `json:"removeFileIDs,omitempty"`
	ClearFiles                *bool                        `json:"clearFiles,omitempty"`
	AddEvidenceIDs            []string                     `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs         []string                     `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence             *bool                        `json:"clearEvidence,omitempty"`
	AddNarrativeIDs           []string                     `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string                     `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool                        `json:"clearNarratives,omitempty"`
	AddActionPlanIDs          []string                     `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs       []string                     `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans          *bool                        `json:"clearActionPlans,omitempty"`
	ProgramOwnerID            *string                      `json:"programOwnerID,omitempty"`
	ClearProgramOwner         *bool                        `json:"clearProgramOwner,omitempty"`
	AddProgramMembers         []*AddProgramMembershipInput `json:"addProgramMembers,omitempty"`
	RemoveProgramMembers      []string                     `json:"removeProgramMembers,omitempty"`
}

// UpdateProgramMembershipInput is used for update ProgramMembership object.
// Input was generated by ent.
type UpdateProgramMembershipInput struct {
	Role *enums.Role `json:"role,omitempty"`
}

// UpdateRemediationInput is used for update Remediation object.
// Input was generated by ent.
type UpdateRemediationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// external identifier from the integration source for the remediation
	ExternalID      *string `json:"externalID,omitempty"`
	ClearExternalID *bool   `json:"clearExternalID,omitempty"`
	// external identifier from the integration source for the remediation
	ExternalOwnerID      *string `json:"externalOwnerID,omitempty"`
	ClearExternalOwnerID *bool   `json:"clearExternalOwnerID,omitempty"`
	// title or short description of the remediation effort
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// state of the remediation, such as pending or completed
	State      *string `json:"state,omitempty"`
	ClearState *bool   `json:"clearState,omitempty"`
	// intent or goal of the remediation effort
	Intent      *string `json:"intent,omitempty"`
	ClearIntent *bool   `json:"clearIntent,omitempty"`
	// summary of the remediation approach
	Summary      *string `json:"summary,omitempty"`
	ClearSummary *bool   `json:"clearSummary,omitempty"`
	// detailed explanation of the remediation steps
	Explanation      *string `json:"explanation,omitempty"`
	ClearExplanation *bool   `json:"clearExplanation,omitempty"`
	// specific instructions or steps to implement the remediation
	Instructions      *string `json:"instructions,omitempty"`
	ClearInstructions *bool   `json:"clearInstructions,omitempty"`
	// reference to the owner responsible for remediation
	OwnerReference      *string `json:"ownerReference,omitempty"`
	ClearOwnerReference *bool   `json:"clearOwnerReference,omitempty"`
	// source code repository URI associated with the remediation
	RepositoryURI      *string `json:"repositoryURI,omitempty"`
	ClearRepositoryURI *bool   `json:"clearRepositoryURI,omitempty"`
	// pull request URI associated with the remediation
	PullRequestURI      *string `json:"pullRequestURI,omitempty"`
	ClearPullRequestURI *bool   `json:"clearPullRequestURI,omitempty"`
	// reference to a tracking ticket for the remediation
	TicketReference      *string `json:"ticketReference,omitempty"`
	ClearTicketReference *bool   `json:"clearTicketReference,omitempty"`
	// timestamp when the remediation is due
	DueAt      *models.DateTime `json:"dueAt,omitempty"`
	ClearDueAt *bool            `json:"clearDueAt,omitempty"`
	// timestamp when the remediation was completed
	CompletedAt      *models.DateTime `json:"completedAt,omitempty"`
	ClearCompletedAt *bool            `json:"clearCompletedAt,omitempty"`
	// timestamp when an automated pull request was generated
	PrGeneratedAt      *models.DateTime `json:"prGeneratedAt,omitempty"`
	ClearPrGeneratedAt *bool            `json:"clearPrGeneratedAt,omitempty"`
	// details about any errors encountered during remediation automation
	Error      *string `json:"error,omitempty"`
	ClearError *bool   `json:"clearError,omitempty"`
	// system that produced the remediation record
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// link to the remediation in the source system
	ExternalURI      *string `json:"externalURI,omitempty"`
	ClearExternalURI *bool   `json:"clearExternalURI,omitempty"`
	// raw metadata payload for the remediation from the source system
	Metadata               map[string]any `json:"metadata,omitempty"`
	ClearMetadata          *bool          `json:"clearMetadata,omitempty"`
	AddBlockedGroupIDs     []string       `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs  []string       `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups     *bool          `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs           []string       `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs        []string       `json:"removeEditorIDs,omitempty"`
	ClearEditors           *bool          `json:"clearEditors,omitempty"`
	AddViewerIDs           []string       `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs        []string       `json:"removeViewerIDs,omitempty"`
	ClearViewers           *bool          `json:"clearViewers,omitempty"`
	AddIntegrationIDs      []string       `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs   []string       `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations      *bool          `json:"clearIntegrations,omitempty"`
	AddFindingIDs          []string       `json:"addFindingIDs,omitempty"`
	RemoveFindingIDs       []string       `json:"removeFindingIDs,omitempty"`
	ClearFindings          *bool          `json:"clearFindings,omitempty"`
	AddVulnerabilityIDs    []string       `json:"addVulnerabilityIDs,omitempty"`
	RemoveVulnerabilityIDs []string       `json:"removeVulnerabilityIDs,omitempty"`
	ClearVulnerabilities   *bool          `json:"clearVulnerabilities,omitempty"`
	AddActionPlanIDs       []string       `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs    []string       `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans       *bool          `json:"clearActionPlans,omitempty"`
	AddTaskIDs             []string       `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs          []string       `json:"removeTaskIDs,omitempty"`
	ClearTasks             *bool          `json:"clearTasks,omitempty"`
	AddControlIDs          []string       `json:"addControlIDs,omitempty"`
	RemoveControlIDs       []string       `json:"removeControlIDs,omitempty"`
	ClearControls          *bool          `json:"clearControls,omitempty"`
	AddSubcontrolIDs       []string       `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs    []string       `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols       *bool          `json:"clearSubcontrols,omitempty"`
	AddRiskIDs             []string       `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs          []string       `json:"removeRiskIDs,omitempty"`
	ClearRisks             *bool          `json:"clearRisks,omitempty"`
	AddProgramIDs          []string       `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs       []string       `json:"removeProgramIDs,omitempty"`
	ClearPrograms          *bool          `json:"clearPrograms,omitempty"`
	AddAssetIDs            []string       `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs         []string       `json:"removeAssetIDs,omitempty"`
	ClearAssets            *bool          `json:"clearAssets,omitempty"`
	AddEntityIDs           []string       `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs        []string       `json:"removeEntityIDs,omitempty"`
	ClearEntities          *bool          `json:"clearEntities,omitempty"`
	AddReviewIDs           []string       `json:"addReviewIDs,omitempty"`
	RemoveReviewIDs        []string       `json:"removeReviewIDs,omitempty"`
	ClearReviews           *bool          `json:"clearReviews,omitempty"`
	AddCommentIDs          []string       `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs       []string       `json:"removeCommentIDs,omitempty"`
	ClearComments          *bool          `json:"clearComments,omitempty"`
	AddFileIDs             []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs          []string       `json:"removeFileIDs,omitempty"`
	ClearFiles             *bool          `json:"clearFiles,omitempty"`
}

// UpdateReviewInput is used for update Review object.
// Input was generated by ent.
type UpdateReviewInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// external identifier from the integration source for the review
	ExternalID      *string `json:"externalID,omitempty"`
	ClearExternalID *bool   `json:"clearExternalID,omitempty"`
	// external identifier from the integration source for the review
	ExternalOwnerID      *string `json:"externalOwnerID,omitempty"`
	ClearExternalOwnerID *bool   `json:"clearExternalOwnerID,omitempty"`
	// title of the review
	Title *string `json:"title,omitempty"`
	// state of the review
	State      *string `json:"state,omitempty"`
	ClearState *bool   `json:"clearState,omitempty"`
	// category for the review record
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// classification or sensitivity of the review record
	Classification      *string `json:"classification,omitempty"`
	ClearClassification *bool   `json:"clearClassification,omitempty"`
	// summary text for the review
	Summary      *string `json:"summary,omitempty"`
	ClearSummary *bool   `json:"clearSummary,omitempty"`
	// detailed notes captured during the review
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// person or system that created the review
	Reporter      *string `json:"reporter,omitempty"`
	ClearReporter *bool   `json:"clearReporter,omitempty"`
	// true when the review has been approved
	Approved      *bool `json:"approved,omitempty"`
	ClearApproved *bool `json:"clearApproved,omitempty"`
	// timestamp when the review was completed
	ReviewedAt      *models.DateTime `json:"reviewedAt,omitempty"`
	ClearReviewedAt *bool            `json:"clearReviewedAt,omitempty"`
	// timestamp when the review was reported or opened
	ReportedAt      *models.DateTime `json:"reportedAt,omitempty"`
	ClearReportedAt *bool            `json:"clearReportedAt,omitempty"`
	// timestamp when the review was approved
	ApprovedAt      *models.DateTime `json:"approvedAt,omitempty"`
	ClearApprovedAt *bool            `json:"clearApprovedAt,omitempty"`
	// system that produced the review record
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// link to the review in the source system
	ExternalURI      *string `json:"externalURI,omitempty"`
	ClearExternalURI *bool   `json:"clearExternalURI,omitempty"`
	// raw metadata payload for the review from the source system
	Metadata      map[string]any `json:"metadata,omitempty"`
	ClearMetadata *bool          `json:"clearMetadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload             map[string]any `json:"rawPayload,omitempty"`
	ClearRawPayload        *bool          `json:"clearRawPayload,omitempty"`
	AddBlockedGroupIDs     []string       `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs  []string       `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups     *bool          `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs           []string       `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs        []string       `json:"removeEditorIDs,omitempty"`
	ClearEditors           *bool          `json:"clearEditors,omitempty"`
	AddViewerIDs           []string       `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs        []string       `json:"removeViewerIDs,omitempty"`
	ClearViewers           *bool          `json:"clearViewers,omitempty"`
	AddIntegrationIDs      []string       `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs   []string       `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations      *bool          `json:"clearIntegrations,omitempty"`
	AddFindingIDs          []string       `json:"addFindingIDs,omitempty"`
	RemoveFindingIDs       []string       `json:"removeFindingIDs,omitempty"`
	ClearFindings          *bool          `json:"clearFindings,omitempty"`
	AddVulnerabilityIDs    []string       `json:"addVulnerabilityIDs,omitempty"`
	RemoveVulnerabilityIDs []string       `json:"removeVulnerabilityIDs,omitempty"`
	ClearVulnerabilities   *bool          `json:"clearVulnerabilities,omitempty"`
	AddActionPlanIDs       []string       `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs    []string       `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans       *bool          `json:"clearActionPlans,omitempty"`
	AddRemediationIDs      []string       `json:"addRemediationIDs,omitempty"`
	RemoveRemediationIDs   []string       `json:"removeRemediationIDs,omitempty"`
	ClearRemediations      *bool          `json:"clearRemediations,omitempty"`
	AddControlIDs          []string       `json:"addControlIDs,omitempty"`
	RemoveControlIDs       []string       `json:"removeControlIDs,omitempty"`
	ClearControls          *bool          `json:"clearControls,omitempty"`
	AddSubcontrolIDs       []string       `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs    []string       `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols       *bool          `json:"clearSubcontrols,omitempty"`
	AddRiskIDs             []string       `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs          []string       `json:"removeRiskIDs,omitempty"`
	ClearRisks             *bool          `json:"clearRisks,omitempty"`
	AddProgramIDs          []string       `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs       []string       `json:"removeProgramIDs,omitempty"`
	ClearPrograms          *bool          `json:"clearPrograms,omitempty"`
	AddAssetIDs            []string       `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs         []string       `json:"removeAssetIDs,omitempty"`
	ClearAssets            *bool          `json:"clearAssets,omitempty"`
	AddEntityIDs           []string       `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs        []string       `json:"removeEntityIDs,omitempty"`
	ClearEntities          *bool          `json:"clearEntities,omitempty"`
	AddTaskIDs             []string       `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs          []string       `json:"removeTaskIDs,omitempty"`
	ClearTasks             *bool          `json:"clearTasks,omitempty"`
	ReviewerID             *string        `json:"reviewerID,omitempty"`
	ClearReviewer          *bool          `json:"clearReviewer,omitempty"`
	AddCommentIDs          []string       `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs       []string       `json:"removeCommentIDs,omitempty"`
	ClearComments          *bool          `json:"clearComments,omitempty"`
	AddFileIDs             []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs          []string       `json:"removeFileIDs,omitempty"`
	ClearFiles             *bool          `json:"clearFiles,omitempty"`
}

// UpdateRiskInput is used for update Risk object.
// Input was generated by ent.
type UpdateRiskInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the kind of the risk
	RiskKindName      *string `json:"riskKindName,omitempty"`
	ClearRiskKindName *bool   `json:"clearRiskKindName,omitempty"`
	// the category of the risk
	RiskCategoryName      *string `json:"riskCategoryName,omitempty"`
	ClearRiskCategoryName *bool   `json:"clearRiskCategoryName,omitempty"`
	// the name of the risk
	Name *string `json:"name,omitempty"`
	// status of the risk - identified, mitigated, accepted, closed, transferred, and archived.
	Status      *enums.RiskStatus `json:"status,omitempty"`
	ClearStatus *bool             `json:"clearStatus,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType      *string `json:"riskType,omitempty"`
	ClearRiskType *bool   `json:"clearRiskType,omitempty"`
	// category of the risk, e.g. human resources, operations, IT, etc.
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// impact of the risk -critical, high, medium, low
	Impact      *enums.RiskImpact `json:"impact,omitempty"`
	ClearImpact *bool             `json:"clearImpact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood      *enums.RiskLikelihood `json:"likelihood,omitempty"`
	ClearLikelihood *bool                 `json:"clearLikelihood,omitempty"`
	// score of the risk based on impact and likelihood (1-4 unlikely, 5-9 likely, 10-16 highly likely, 17-20 critical)
	Score      *int64 `json:"score,omitempty"`
	ClearScore *bool  `json:"clearScore,omitempty"`
	// mitigation for the risk
	Mitigation      *string `json:"mitigation,omitempty"`
	ClearMitigation *bool   `json:"clearMitigation,omitempty"`
	// details of the risk
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// business costs associated with the risk
	BusinessCosts           *string          `json:"businessCosts,omitempty"`
	ClearBusinessCosts      *bool            `json:"clearBusinessCosts,omitempty"`
	AddBlockedGroupIDs      []string         `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string         `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool            `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string         `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string         `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool            `json:"clearEditors,omitempty"`
	AddViewerIDs            []string         `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs         []string         `json:"removeViewerIDs,omitempty"`
	ClearViewers            *bool            `json:"clearViewers,omitempty"`
	RiskKindID              *string          `json:"riskKindID,omitempty"`
	ClearRiskKind           *bool            `json:"clearRiskKind,omitempty"`
	RiskCategoryID          *string          `json:"riskCategoryID,omitempty"`
	ClearRiskCategory       *bool            `json:"clearRiskCategory,omitempty"`
	AddControlIDs           []string         `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string         `json:"removeControlIDs,omitempty"`
	ClearControls           *bool            `json:"clearControls,omitempty"`
	AddSubcontrolIDs        []string         `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs     []string         `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols        *bool            `json:"clearSubcontrols,omitempty"`
	AddProcedureIDs         []string         `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs      []string         `json:"removeProcedureIDs,omitempty"`
	ClearProcedures         *bool            `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs    []string         `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string         `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool            `json:"clearInternalPolicies,omitempty"`
	AddProgramIDs           []string         `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string         `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool            `json:"clearPrograms,omitempty"`
	AddActionPlanIDs        []string         `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs     []string         `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans        *bool            `json:"clearActionPlans,omitempty"`
	AddTaskIDs              []string         `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string         `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool            `json:"clearTasks,omitempty"`
	AddAssetIDs             []string         `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs          []string         `json:"removeAssetIDs,omitempty"`
	ClearAssets             *bool            `json:"clearAssets,omitempty"`
	AddEntityIDs            []string         `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs         []string         `json:"removeEntityIDs,omitempty"`
	ClearEntities           *bool            `json:"clearEntities,omitempty"`
	AddScanIDs              []string         `json:"addScanIDs,omitempty"`
	RemoveScanIDs           []string         `json:"removeScanIDs,omitempty"`
	ClearScans              *bool            `json:"clearScans,omitempty"`
	StakeholderID           *string          `json:"stakeholderID,omitempty"`
	ClearStakeholder        *bool            `json:"clearStakeholder,omitempty"`
	DelegateID              *string          `json:"delegateID,omitempty"`
	ClearDelegate           *bool            `json:"clearDelegate,omitempty"`
	AddCommentIDs           []string         `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs        []string         `json:"removeCommentIDs,omitempty"`
	ClearComments           *bool            `json:"clearComments,omitempty"`
	AddComment              *CreateNoteInput `json:"addComment,omitempty"`
	DeleteComment           *string          `json:"deleteComment,omitempty"`
}

// UpdateScanInput is used for update Scan object.
// Input was generated by ent.
type UpdateScanInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the target of the scan, e.g., a domain name or IP address, codebase
	Target *string `json:"target,omitempty"`
	// the type of scan, e.g., domain scan, vulnerability scan, provider scan
	ScanType *enums.ScanType `json:"scanType,omitempty"`
	// additional metadata for the scan, e.g., scan configuration, options, etc
	Metadata      map[string]any `json:"metadata,omitempty"`
	ClearMetadata *bool          `json:"clearMetadata,omitempty"`
	// the status of the scan, e.g., processing, completed, failed
	Status                *enums.ScanStatus `json:"status,omitempty"`
	OwnerID               *string           `json:"ownerID,omitempty"`
	ClearOwner            *bool             `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs    []string          `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string          `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool             `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string          `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string          `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool             `json:"clearEditors,omitempty"`
	AddViewerIDs          []string          `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string          `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool             `json:"clearViewers,omitempty"`
	AddAssetIDs           []string          `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs        []string          `json:"removeAssetIDs,omitempty"`
	ClearAssets           *bool             `json:"clearAssets,omitempty"`
	AddEntityIDs          []string          `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs       []string          `json:"removeEntityIDs,omitempty"`
	ClearEntities         *bool             `json:"clearEntities,omitempty"`
}

// UpdateScheduledJobInput is used for update ScheduledJob object.
// Input was generated by ent.
type UpdateScheduledJobInput struct {
	// whether the scheduled job is active
	Active *bool `json:"active,omitempty"`
	// the json configuration to run this job, which could be used to template a job, e.g. { "account_name": "my-account" }
	Configuration       models.JobConfiguration `json:"configuration,omitempty"`
	AppendConfiguration models.JobConfiguration `json:"appendConfiguration,omitempty"`
	ClearConfiguration  *bool                   `json:"clearConfiguration,omitempty"`
	// cron 6-field syntax, defaults to the job template's cron if not provided
	Cron                *string  `json:"cron,omitempty"`
	ClearCron           *bool    `json:"clearCron,omitempty"`
	JobTemplateID       *string  `json:"jobTemplateID,omitempty"`
	AddControlIDs       []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs    []string `json:"removeControlIDs,omitempty"`
	ClearControls       *bool    `json:"clearControls,omitempty"`
	AddSubcontrolIDs    []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols    *bool    `json:"clearSubcontrols,omitempty"`
	JobRunnerID         *string  `json:"jobRunnerID,omitempty"`
	ClearJobRunner      *bool    `json:"clearJobRunner,omitempty"`
}

// UpdateScheduledJobRunInput is used for update ScheduledJobRun object.
// Input was generated by ent.
type UpdateScheduledJobRunInput struct {
	// The status of the job to be executed. By default will be pending but when
	// 			scheduled on a runner, this will change to acquired.
	Status         *enums.ScheduledJobRunStatus `json:"status,omitempty"`
	OwnerID        *string                      `json:"ownerID,omitempty"`
	ClearOwner     *bool                        `json:"clearOwner,omitempty"`
	ScheduledJobID *string                      `json:"scheduledJobID,omitempty"`
	JobRunnerID    *string                      `json:"jobRunnerID,omitempty"`
}

// UpdateStandardInput is used for update Standard object.
// Input was generated by ent.
type UpdateStandardInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the long name of the standard body
	Name *string `json:"name,omitempty"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName      *string `json:"shortName,omitempty"`
	ClearShortName *bool   `json:"clearShortName,omitempty"`
	// unique identifier of the standard with version
	Framework      *string `json:"framework,omitempty"`
	ClearFramework *bool   `json:"clearFramework,omitempty"`
	// long description of the standard with details of what is covered
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// URL to the logo of the governing body
	GoverningBodyLogoURL      *string `json:"governingBodyLogoURL,omitempty"`
	ClearGoverningBodyLogoURL *bool   `json:"clearGoverningBodyLogoURL,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody      *string `json:"governingBody,omitempty"`
	ClearGoverningBody *bool   `json:"clearGoverningBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// link to the official standard documentation
	Link      *string `json:"link,omitempty"`
	ClearLink *bool   `json:"clearLink,omitempty"`
	// status of the standard - active, draft, and archived
	Status      *enums.StandardStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// indicates if the standard should be made available to all users, only for system owned standards
	IsPublic      *bool `json:"isPublic,omitempty"`
	ClearIsPublic *bool `json:"clearIsPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for system owned standards
	FreeToUse      *bool `json:"freeToUse,omitempty"`
	ClearFreeToUse *bool `json:"clearFreeToUse,omitempty"`
	// type of the standard - cybersecurity, healthcare , financial, etc.
	StandardType      *string `json:"standardType,omitempty"`
	ClearStandardType *bool   `json:"clearStandardType,omitempty"`
	// version of the standard
	Version                        *string             `json:"version,omitempty"`
	ClearVersion                   *bool               `json:"clearVersion,omitempty"`
	OwnerID                        *string             `json:"ownerID,omitempty"`
	ClearOwner                     *bool               `json:"clearOwner,omitempty"`
	AddControlIDs                  []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs               []string            `json:"removeControlIDs,omitempty"`
	ClearControls                  *bool               `json:"clearControls,omitempty"`
	AddTrustCenterComplianceIDs    []string            `json:"addTrustCenterComplianceIDs,omitempty"`
	RemoveTrustCenterComplianceIDs []string            `json:"removeTrustCenterComplianceIDs,omitempty"`
	ClearTrustCenterCompliances    *bool               `json:"clearTrustCenterCompliances,omitempty"`
	AddTrustCenterDocIDs           []string            `json:"addTrustCenterDocIDs,omitempty"`
	RemoveTrustCenterDocIDs        []string            `json:"removeTrustCenterDocIDs,omitempty"`
	ClearTrustCenterDocs           *bool               `json:"clearTrustCenterDocs,omitempty"`
	LogoFileID                     *string             `json:"logoFileID,omitempty"`
	ClearLogoFile                  *bool               `json:"clearLogoFile,omitempty"`
	RevisionBump                   *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateSubcontrolInput is used for update Subcontrol object.
// Input was generated by ent.
type UpdateSubcontrolInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// human readable title of the control for quick identification
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// description of what the control is supposed to accomplish
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// additional names (ref_codes) for the control
	Aliases       []string `json:"aliases,omitempty"`
	AppendAliases []string `json:"appendAliases,omitempty"`
	ClearAliases  *bool    `json:"clearAliases,omitempty"`
	// internal reference id of the control, can be used for internal tracking
	ReferenceID      *string `json:"referenceID,omitempty"`
	ClearReferenceID *bool   `json:"clearReferenceID,omitempty"`
	// external auditor id of the control, can be used to map to external audit partner mappings
	AuditorReferenceID      *string `json:"auditorReferenceID,omitempty"`
	ClearAuditorReferenceID *bool   `json:"clearAuditorReferenceID,omitempty"`
	// status of the control
	Status      *enums.ControlStatus `json:"status,omitempty"`
	ClearStatus *bool                `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// the reference framework revision for the control if it came from a standard, empty if not associated with a standard, allows for pulling in updates when the standard is updated
	ReferenceFrameworkRevision      *string `json:"referenceFrameworkRevision,omitempty"`
	ClearReferenceFrameworkRevision *bool   `json:"clearReferenceFrameworkRevision,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType      *enums.ControlType `json:"controlType,omitempty"`
	ClearControlType *bool              `json:"clearControlType,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// category id of the control
	CategoryID      *string `json:"categoryID,omitempty"`
	ClearCategoryID *bool   `json:"clearCategoryID,omitempty"`
	// subcategory of the control
	Subcategory      *string `json:"subcategory,omitempty"`
	ClearSubcategory *bool   `json:"clearSubcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories       []string `json:"mappedCategories,omitempty"`
	AppendMappedCategories []string `json:"appendMappedCategories,omitempty"`
	ClearMappedCategories  *bool    `json:"clearMappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives       []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	AppendAssessmentObjectives []*models.AssessmentObjective `json:"appendAssessmentObjectives,omitempty"`
	ClearAssessmentObjectives  *bool                         `json:"clearAssessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods       []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	AppendAssessmentMethods []*models.AssessmentMethod `json:"appendAssessmentMethods,omitempty"`
	ClearAssessmentMethods  *bool                      `json:"clearAssessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions       []string `json:"controlQuestions,omitempty"`
	AppendControlQuestions []string `json:"appendControlQuestions,omitempty"`
	ClearControlQuestions  *bool    `json:"clearControlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance       []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	AppendImplementationGuidance []*models.ImplementationGuidance `json:"appendImplementationGuidance,omitempty"`
	ClearImplementationGuidance  *bool                            `json:"clearImplementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence       []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	AppendExampleEvidence []*models.ExampleEvidence `json:"appendExampleEvidence,omitempty"`
	ClearExampleEvidence  *bool                     `json:"clearExampleEvidence,omitempty"`
	// references for the control
	References       []*models.Reference `json:"references,omitempty"`
	AppendReferences []*models.Reference `json:"appendReferences,omitempty"`
	ClearReferences  *bool               `json:"clearReferences,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the kind of the subcontrol
	SubcontrolKindName      *string `json:"subcontrolKindName,omitempty"`
	ClearSubcontrolKindName *bool   `json:"clearSubcontrolKindName,omitempty"`
	// the unique reference code for the control
	RefCode                        *string          `json:"refCode,omitempty"`
	AddEvidenceIDs                 []string         `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs              []string         `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                  *bool            `json:"clearEvidence,omitempty"`
	AddControlObjectiveIDs         []string         `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs      []string         `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives         *bool            `json:"clearControlObjectives,omitempty"`
	AddTaskIDs                     []string         `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                  []string         `json:"removeTaskIDs,omitempty"`
	ClearTasks                     *bool            `json:"clearTasks,omitempty"`
	AddNarrativeIDs                []string         `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs             []string         `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives                *bool            `json:"clearNarratives,omitempty"`
	AddRiskIDs                     []string         `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                  []string         `json:"removeRiskIDs,omitempty"`
	ClearRisks                     *bool            `json:"clearRisks,omitempty"`
	AddActionPlanIDs               []string         `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs            []string         `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans               *bool            `json:"clearActionPlans,omitempty"`
	AddProcedureIDs                []string         `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs             []string         `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                *bool            `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs           []string         `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs        []string         `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies          *bool            `json:"clearInternalPolicies,omitempty"`
	AddCommentIDs                  []string         `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs               []string         `json:"removeCommentIDs,omitempty"`
	ClearComments                  *bool            `json:"clearComments,omitempty"`
	ControlOwnerID                 *string          `json:"controlOwnerID,omitempty"`
	ClearControlOwner              *bool            `json:"clearControlOwner,omitempty"`
	DelegateID                     *string          `json:"delegateID,omitempty"`
	ClearDelegate                  *bool            `json:"clearDelegate,omitempty"`
	ResponsiblePartyID             *string          `json:"responsiblePartyID,omitempty"`
	ClearResponsibleParty          *bool            `json:"clearResponsibleParty,omitempty"`
	SubcontrolKindID               *string          `json:"subcontrolKindID,omitempty"`
	ClearSubcontrolKind            *bool            `json:"clearSubcontrolKind,omitempty"`
	ControlID                      *string          `json:"controlID,omitempty"`
	AddControlImplementationIDs    []string         `json:"addControlImplementationIDs,omitempty"`
	RemoveControlImplementationIDs []string         `json:"removeControlImplementationIDs,omitempty"`
	ClearControlImplementations    *bool            `json:"clearControlImplementations,omitempty"`
	AddScheduledJobIDs             []string         `json:"addScheduledJobIDs,omitempty"`
	RemoveScheduledJobIDs          []string         `json:"removeScheduledJobIDs,omitempty"`
	ClearScheduledJobs             *bool            `json:"clearScheduledJobs,omitempty"`
	AddComment                     *CreateNoteInput `json:"addComment,omitempty"`
	DeleteComment                  *string          `json:"deleteComment,omitempty"`
}

// UpdateSubprocessorInput is used for update Subprocessor object.
// Input was generated by ent.
type UpdateSubprocessorInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// name of the standard body
	Name *string `json:"name,omitempty"`
	// description of the subprocessor
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// URL of the logo
	LogoRemoteURL                    *string  `json:"logoRemoteURL,omitempty"`
	ClearLogoRemoteURL               *bool    `json:"clearLogoRemoteURL,omitempty"`
	OwnerID                          *string  `json:"ownerID,omitempty"`
	ClearOwner                       *bool    `json:"clearOwner,omitempty"`
	LogoFileID                       *string  `json:"logoFileID,omitempty"`
	ClearLogoFile                    *bool    `json:"clearLogoFile,omitempty"`
	AddTrustCenterSubprocessorIDs    []string `json:"addTrustCenterSubprocessorIDs,omitempty"`
	RemoveTrustCenterSubprocessorIDs []string `json:"removeTrustCenterSubprocessorIDs,omitempty"`
	ClearTrustCenterSubprocessors    *bool    `json:"clearTrustCenterSubprocessors,omitempty"`
}

// UpdateSubscriberInput is used for update Subscriber object.
// Input was generated by ent.
type UpdateSubscriberInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// email address of the subscriber
	Email *string `json:"email,omitempty"`
	// phone number of the subscriber
	PhoneNumber      *string `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool   `json:"clearPhoneNumber,omitempty"`
	// indicates if the subscriber has unsubscribed from communications
	Unsubscribed   *bool    `json:"unsubscribed,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	ClearOwner     *bool    `json:"clearOwner,omitempty"`
	AddEventIDs    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool    `json:"clearEvents,omitempty"`
}

// UpdateTFASettingInput is used for update TFASetting object.
// Input was generated by ent.
type UpdateTFASettingInput struct {
	// specifies if the TFA device has been verified
	Verified *bool `json:"verified,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed      *bool `json:"totpAllowed,omitempty"`
	ClearTotpAllowed *bool `json:"clearTotpAllowed,omitempty"`
	// Whether to regenerate backup codes
	RegenBackupCodes *bool `json:"regenBackupCodes,omitempty"`
}

// UpdateTagDefinitionInput is used for update TagDefinition object.
// Input was generated by ent.
type UpdateTagDefinitionInput struct {
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// common aliases or misspellings for the tag definition
	Aliases       []string `json:"aliases,omitempty"`
	AppendAliases []string `json:"appendAliases,omitempty"`
	ClearAliases  *bool    `json:"clearAliases,omitempty"`
	// The description of the tag definition
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// The color of the tag definition in hex format
	Color      *string `json:"color,omitempty"`
	ClearColor *bool   `json:"clearColor,omitempty"`
	OwnerID    *string `json:"ownerID,omitempty"`
	ClearOwner *bool   `json:"clearOwner,omitempty"`
}

// UpdateTaskInput is used for update Task object.
// Input was generated by ent.
type UpdateTaskInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the kind of the task
	TaskKindName      *string `json:"taskKindName,omitempty"`
	ClearTaskKindName *bool   `json:"clearTaskKindName,omitempty"`
	// the title of the task
	Title *string `json:"title,omitempty"`
	// the details of the task
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// the status of the task
	Status *enums.TaskStatus `json:"status,omitempty"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// the due date of the task
	Due      *models.DateTime `json:"due,omitempty"`
	ClearDue *bool            `json:"clearDue,omitempty"`
	// the completion date of the task
	Completed      *models.DateTime `json:"completed,omitempty"`
	ClearCompleted *bool            `json:"clearCompleted,omitempty"`
	// indicates if the task was generated by the system
	SystemGenerated *bool `json:"systemGenerated,omitempty"`
	// an optional external reference URL for the task
	ExternalReferenceURL           []string         `json:"externalReferenceURL,omitempty"`
	AppendExternalReferenceURL     []string         `json:"appendExternalReferenceURL,omitempty"`
	ClearExternalReferenceURL      *bool            `json:"clearExternalReferenceURL,omitempty"`
	TaskKindID                     *string          `json:"taskKindID,omitempty"`
	ClearTaskKind                  *bool            `json:"clearTaskKind,omitempty"`
	AssignerID                     *string          `json:"assignerID,omitempty"`
	ClearAssigner                  *bool            `json:"clearAssigner,omitempty"`
	AssigneeID                     *string          `json:"assigneeID,omitempty"`
	ClearAssignee                  *bool            `json:"clearAssignee,omitempty"`
	AddCommentIDs                  []string         `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs               []string         `json:"removeCommentIDs,omitempty"`
	ClearComments                  *bool            `json:"clearComments,omitempty"`
	AddGroupIDs                    []string         `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                 []string         `json:"removeGroupIDs,omitempty"`
	ClearGroups                    *bool            `json:"clearGroups,omitempty"`
	AddInternalPolicyIDs           []string         `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs        []string         `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies          *bool            `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs                []string         `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs             []string         `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                *bool            `json:"clearProcedures,omitempty"`
	AddControlIDs                  []string         `json:"addControlIDs,omitempty"`
	RemoveControlIDs               []string         `json:"removeControlIDs,omitempty"`
	ClearControls                  *bool            `json:"clearControls,omitempty"`
	AddSubcontrolIDs               []string         `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs            []string         `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols               *bool            `json:"clearSubcontrols,omitempty"`
	AddControlObjectiveIDs         []string         `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs      []string         `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives         *bool            `json:"clearControlObjectives,omitempty"`
	AddProgramIDs                  []string         `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs               []string         `json:"removeProgramIDs,omitempty"`
	ClearPrograms                  *bool            `json:"clearPrograms,omitempty"`
	AddRiskIDs                     []string         `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                  []string         `json:"removeRiskIDs,omitempty"`
	ClearRisks                     *bool            `json:"clearRisks,omitempty"`
	AddControlImplementationIDs    []string         `json:"addControlImplementationIDs,omitempty"`
	RemoveControlImplementationIDs []string         `json:"removeControlImplementationIDs,omitempty"`
	ClearControlImplementations    *bool            `json:"clearControlImplementations,omitempty"`
	AddActionPlanIDs               []string         `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs            []string         `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans               *bool            `json:"clearActionPlans,omitempty"`
	AddEvidenceIDs                 []string         `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs              []string         `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                  *bool            `json:"clearEvidence,omitempty"`
	AddWorkflowObjectRefIDs        []string         `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs     []string         `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs        *bool            `json:"clearWorkflowObjectRefs,omitempty"`
	ParentID                       *string          `json:"parentID,omitempty"`
	ClearParent                    *bool            `json:"clearParent,omitempty"`
	AddTaskIDs                     []string         `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                  []string         `json:"removeTaskIDs,omitempty"`
	ClearTasks                     *bool            `json:"clearTasks,omitempty"`
	AddComment                     *CreateNoteInput `json:"addComment,omitempty"`
	DeleteComment                  *string          `json:"deleteComment,omitempty"`
}

// UpdateTemplateInput is used for update Template object.
// Input was generated by ent.
type UpdateTemplateInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// the name of the template
	Name *string `json:"name,omitempty"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the kind of template, e.g. questionnaire
	Kind      *enums.TemplateKind `json:"kind,omitempty"`
	ClearKind *bool               `json:"clearKind,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig,omitempty"`
	// the uischema for the template to render in the UI
	Uischema            map[string]any `json:"uischema,omitempty"`
	ClearUischema       *bool          `json:"clearUischema,omitempty"`
	AddDocumentIDs      []string       `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs   []string       `json:"removeDocumentIDs,omitempty"`
	ClearDocuments      *bool          `json:"clearDocuments,omitempty"`
	AddFileIDs          []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs       []string       `json:"removeFileIDs,omitempty"`
	ClearFiles          *bool          `json:"clearFiles,omitempty"`
	TrustCenterID       *string        `json:"trustCenterID,omitempty"`
	ClearTrustCenter    *bool          `json:"clearTrustCenter,omitempty"`
	AddAssessmentIDs    []string       `json:"addAssessmentIDs,omitempty"`
	RemoveAssessmentIDs []string       `json:"removeAssessmentIDs,omitempty"`
	ClearAssessments    *bool          `json:"clearAssessments,omitempty"`
}

// UpdateTrustCenterComplianceInput is used for update TrustCenterCompliance object.
// Input was generated by ent.
type UpdateTrustCenterComplianceInput struct {
	// tags associated with the object
	Tags             []string `json:"tags,omitempty"`
	AppendTags       []string `json:"appendTags,omitempty"`
	ClearTags        *bool    `json:"clearTags,omitempty"`
	TrustCenterID    *string  `json:"trustCenterID,omitempty"`
	ClearTrustCenter *bool    `json:"clearTrustCenter,omitempty"`
	StandardID       *string  `json:"standardID,omitempty"`
}

// UpdateTrustCenterDocInput is used for update TrustCenterDoc object.
// Input was generated by ent.
type UpdateTrustCenterDocInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// title of the document
	Title *string `json:"title,omitempty"`
	// category of the document
	Category *string `json:"category,omitempty"`
	// whether watermarking is enabled for the document. this will only take effect if watermarking is configured for the trust center
	WatermarkingEnabled *bool `json:"watermarkingEnabled,omitempty"`
	// status of the watermarking
	WatermarkStatus      *enums.WatermarkStatus `json:"watermarkStatus,omitempty"`
	ClearWatermarkStatus *bool                  `json:"clearWatermarkStatus,omitempty"`
	// visibility of the document
	Visibility        *enums.TrustCenterDocumentVisibility `json:"visibility,omitempty"`
	ClearVisibility   *bool                                `json:"clearVisibility,omitempty"`
	TrustCenterID     *string                              `json:"trustCenterID,omitempty"`
	ClearTrustCenter  *bool                                `json:"clearTrustCenter,omitempty"`
	StandardID        *string                              `json:"standardID,omitempty"`
	ClearStandard     *bool                                `json:"clearStandard,omitempty"`
	FileID            *string                              `json:"fileID,omitempty"`
	ClearFile         *bool                                `json:"clearFile,omitempty"`
	OriginalFileID    *string                              `json:"originalFileID,omitempty"`
	ClearOriginalFile *bool                                `json:"clearOriginalFile,omitempty"`
}

// UpdateTrustCenterInput is used for update TrustCenter object.
// Input was generated by ent.
type UpdateTrustCenterInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// Pirsch domain ID
	PirschDomainID      *string `json:"pirschDomainID,omitempty"`
	ClearPirschDomainID *bool   `json:"clearPirschDomainID,omitempty"`
	// Pirsch ID code
	PirschIdentificationCode      *string `json:"pirschIdentificationCode,omitempty"`
	ClearPirschIdentificationCode *bool   `json:"clearPirschIdentificationCode,omitempty"`
	// preview status of the trust center
	PreviewStatus                    *enums.TrustCenterPreviewStatus `json:"previewStatus,omitempty"`
	ClearPreviewStatus               *bool                           `json:"clearPreviewStatus,omitempty"`
	OwnerID                          *string                         `json:"ownerID,omitempty"`
	ClearOwner                       *bool                           `json:"clearOwner,omitempty"`
	CustomDomainID                   *string                         `json:"customDomainID,omitempty"`
	ClearCustomDomain                *bool                           `json:"clearCustomDomain,omitempty"`
	PreviewDomainID                  *string                         `json:"previewDomainID,omitempty"`
	ClearPreviewDomain               *bool                           `json:"clearPreviewDomain,omitempty"`
	SettingID                        *string                         `json:"settingID,omitempty"`
	ClearSetting                     *bool                           `json:"clearSetting,omitempty"`
	PreviewSettingID                 *string                         `json:"previewSettingID,omitempty"`
	ClearPreviewSetting              *bool                           `json:"clearPreviewSetting,omitempty"`
	WatermarkConfigID                *string                         `json:"watermarkConfigID,omitempty"`
	ClearWatermarkConfig             *bool                           `json:"clearWatermarkConfig,omitempty"`
	AddTrustCenterSubprocessorIDs    []string                        `json:"addTrustCenterSubprocessorIDs,omitempty"`
	RemoveTrustCenterSubprocessorIDs []string                        `json:"removeTrustCenterSubprocessorIDs,omitempty"`
	ClearTrustCenterSubprocessors    *bool                           `json:"clearTrustCenterSubprocessors,omitempty"`
	AddTrustCenterDocIDs             []string                        `json:"addTrustCenterDocIDs,omitempty"`
	RemoveTrustCenterDocIDs          []string                        `json:"removeTrustCenterDocIDs,omitempty"`
	ClearTrustCenterDocs             *bool                           `json:"clearTrustCenterDocs,omitempty"`
	AddTrustCenterComplianceIDs      []string                        `json:"addTrustCenterComplianceIDs,omitempty"`
	RemoveTrustCenterComplianceIDs   []string                        `json:"removeTrustCenterComplianceIDs,omitempty"`
	ClearTrustCenterCompliances      *bool                           `json:"clearTrustCenterCompliances,omitempty"`
	AddTemplateIDs                   []string                        `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs                []string                        `json:"removeTemplateIDs,omitempty"`
	ClearTemplates                   *bool                           `json:"clearTemplates,omitempty"`
	AddPostIDs                       []string                        `json:"addPostIDs,omitempty"`
	RemovePostIDs                    []string                        `json:"removePostIDs,omitempty"`
	ClearPosts                       *bool                           `json:"clearPosts,omitempty"`
	AddTrustcenterEntityIDs          []string                        `json:"addTrustcenterEntityIDs,omitempty"`
	RemoveTrustcenterEntityIDs       []string                        `json:"removeTrustcenterEntityIDs,omitempty"`
	ClearTrustcenterEntities         *bool                           `json:"clearTrustcenterEntities,omitempty"`
	// adds a post for the trust center feed
	AddPost *CreateNoteInput `json:"addPost,omitempty"`
	// delete a post from the trust center feed
	DeletePost               *string                        `json:"deletePost,omitempty"`
	UpdateTrustCenterSetting *UpdateTrustCenterSettingInput `json:"updateTrustCenterSetting,omitempty"`
}

// UpdateTrustCenterSettingInput is used for update TrustCenterSetting object.
// Input was generated by ent.
type UpdateTrustCenterSettingInput struct {
	// the ID of the trust center the settings belong to
	TrustCenterID      *string `json:"trustCenterID,omitempty"`
	ClearTrustCenterID *bool   `json:"clearTrustCenterID,omitempty"`
	// title of the trust center
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// overview of the trust center
	Overview      *string `json:"overview,omitempty"`
	ClearOverview *bool   `json:"clearOverview,omitempty"`
	// URL of the logo
	LogoRemoteURL      *string `json:"logoRemoteURL,omitempty"`
	ClearLogoRemoteURL *bool   `json:"clearLogoRemoteURL,omitempty"`
	// URL of the favicon
	FaviconRemoteURL      *string `json:"faviconRemoteURL,omitempty"`
	ClearFaviconRemoteURL *bool   `json:"clearFaviconRemoteURL,omitempty"`
	// Theme mode for the trust center
	ThemeMode      *enums.TrustCenterThemeMode `json:"themeMode,omitempty"`
	ClearThemeMode *bool                       `json:"clearThemeMode,omitempty"`
	// primary color for the trust center
	PrimaryColor      *string `json:"primaryColor,omitempty"`
	ClearPrimaryColor *bool   `json:"clearPrimaryColor,omitempty"`
	// font for the trust center
	Font      *string `json:"font,omitempty"`
	ClearFont *bool   `json:"clearFont,omitempty"`
	// foreground color for the trust center
	ForegroundColor      *string `json:"foregroundColor,omitempty"`
	ClearForegroundColor *bool   `json:"clearForegroundColor,omitempty"`
	// background color for the trust center
	BackgroundColor      *string `json:"backgroundColor,omitempty"`
	ClearBackgroundColor *bool   `json:"clearBackgroundColor,omitempty"`
	// accent/brand color for the trust center
	AccentColor      *string `json:"accentColor,omitempty"`
	ClearAccentColor *bool   `json:"clearAccentColor,omitempty"`
	// secondary background color for the trust center
	SecondaryBackgroundColor      *string `json:"secondaryBackgroundColor,omitempty"`
	ClearSecondaryBackgroundColor *bool   `json:"clearSecondaryBackgroundColor,omitempty"`
	// secondary foreground color for the trust center
	SecondaryForegroundColor      *string  `json:"secondaryForegroundColor,omitempty"`
	ClearSecondaryForegroundColor *bool    `json:"clearSecondaryForegroundColor,omitempty"`
	AddFileIDs                    []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs                 []string `json:"removeFileIDs,omitempty"`
	ClearFiles                    *bool    `json:"clearFiles,omitempty"`
	LogoFileID                    *string  `json:"logoFileID,omitempty"`
	ClearLogoFile                 *bool    `json:"clearLogoFile,omitempty"`
	FaviconFileID                 *string  `json:"faviconFileID,omitempty"`
	ClearFaviconFile              *bool    `json:"clearFaviconFile,omitempty"`
}

// UpdateTrustCenterSubprocessorInput is used for update TrustCenterSubprocessor object.
// Input was generated by ent.
type UpdateTrustCenterSubprocessorInput struct {
	// country codes or country where the subprocessor is located
	Countries       []string `json:"countries,omitempty"`
	AppendCountries []string `json:"appendCountries,omitempty"`
	ClearCountries  *bool    `json:"clearCountries,omitempty"`
	// Category of the subprocessor, e.g. 'Data Warehouse' or 'Infrastructure Hosting'
	Category         *string `json:"category,omitempty"`
	TrustCenterID    *string `json:"trustCenterID,omitempty"`
	ClearTrustCenter *bool   `json:"clearTrustCenter,omitempty"`
	SubprocessorID   *string `json:"subprocessorID,omitempty"`
}

// UpdateTrustCenterWatermarkConfigInput is used for update TrustCenterWatermarkConfig object.
// Input was generated by ent.
type UpdateTrustCenterWatermarkConfigInput struct {
	// ID of the trust center
	TrustCenterID      *string `json:"trustCenterID,omitempty"`
	ClearTrustCenterID *bool   `json:"clearTrustCenterID,omitempty"`
	// whether the watermarking is enabled for all trust center documents, default is true
	IsEnabled      *bool `json:"isEnabled,omitempty"`
	ClearIsEnabled *bool `json:"clearIsEnabled,omitempty"`
	// text to watermark the document with
	Text      *string `json:"text,omitempty"`
	ClearText *bool   `json:"clearText,omitempty"`
	// font size of the watermark text
	FontSize      *float64 `json:"fontSize,omitempty"`
	ClearFontSize *bool    `json:"clearFontSize,omitempty"`
	// opacity of the watermark text
	Opacity      *float64 `json:"opacity,omitempty"`
	ClearOpacity *bool    `json:"clearOpacity,omitempty"`
	// rotation of the watermark text
	Rotation      *float64 `json:"rotation,omitempty"`
	ClearRotation *bool    `json:"clearRotation,omitempty"`
	// color of the watermark text
	Color      *string `json:"color,omitempty"`
	ClearColor *bool   `json:"clearColor,omitempty"`
	// font of the watermark text
	Font                 *enums.Font `json:"font,omitempty"`
	ClearFont            *bool       `json:"clearFont,omitempty"`
	AddTrustCenterIDs    []string    `json:"addTrustCenterIDs,omitempty"`
	RemoveTrustCenterIDs []string    `json:"removeTrustCenterIDs,omitempty"`
	ClearTrustCenter     *bool       `json:"clearTrustCenter,omitempty"`
	FileID               *string     `json:"fileID,omitempty"`
	ClearFile            *bool       `json:"clearFile,omitempty"`
}

// UpdateTrustcenterEntityInput is used for update TrustcenterEntity object.
// Input was generated by ent.
type UpdateTrustcenterEntityInput struct {
	// URL of customer's website
	URL           *string `json:"url,omitempty"`
	ClearURL      *bool   `json:"clearURL,omitempty"`
	LogoFileID    *string `json:"logoFileID,omitempty"`
	ClearLogoFile *bool   `json:"clearLogoFile,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	// tags associated with the object
	Tags           []string `json:"tags,omitempty"`
	AppendTags     []string `json:"appendTags,omitempty"`
	ClearTags      *bool    `json:"clearTags,omitempty"`
	Email          *string  `json:"email,omitempty"`
	FirstName      *string  `json:"firstName,omitempty"`
	ClearFirstName *bool    `json:"clearFirstName,omitempty"`
	LastName       *string  `json:"lastName,omitempty"`
	ClearLastName  *bool    `json:"clearLastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen      *time.Time `json:"lastSeen,omitempty"`
	ClearLastSeen *bool      `json:"clearLastSeen,omitempty"`
	// the last auth provider used to login
	LastLoginProvider      *enums.AuthProvider `json:"lastLoginProvider,omitempty"`
	ClearLastLoginProvider *bool               `json:"clearLastLoginProvider,omitempty"`
	// user password hash
	Password      *string `json:"password,omitempty"`
	ClearPassword *bool   `json:"clearPassword,omitempty"`
	// the Subject of the user JWT
	Sub      *string `json:"sub,omitempty"`
	ClearSub *bool   `json:"clearSub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role      *enums.Role `json:"role,omitempty"`
	ClearRole *bool       `json:"clearRole,omitempty"`
	// the SCIM external ID for the user
	ScimExternalID      *string `json:"scimExternalID,omitempty"`
	ClearScimExternalID *bool   `json:"clearScimExternalID,omitempty"`
	// the SCIM username for the user
	ScimUsername      *string `json:"scimUsername,omitempty"`
	ClearScimUsername *bool   `json:"clearScimUsername,omitempty"`
	// whether the SCIM user is active
	ScimActive      *bool `json:"scimActive,omitempty"`
	ClearScimActive *bool `json:"clearScimActive,omitempty"`
	// the SCIM preferred language for the user
	ScimPreferredLanguage      *string `json:"scimPreferredLanguage,omitempty"`
	ClearScimPreferredLanguage *bool   `json:"clearScimPreferredLanguage,omitempty"`
	// the SCIM locale for the user
	ScimLocale                     *string  `json:"scimLocale,omitempty"`
	ClearScimLocale                *bool    `json:"clearScimLocale,omitempty"`
	AddPersonalAccessTokenIDs      []string `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs   []string `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens      *bool    `json:"clearPersonalAccessTokens,omitempty"`
	AddTfaSettingIDs               []string `json:"addTfaSettingIDs,omitempty"`
	RemoveTfaSettingIDs            []string `json:"removeTfaSettingIDs,omitempty"`
	ClearTfaSettings               *bool    `json:"clearTfaSettings,omitempty"`
	SettingID                      *string  `json:"settingID,omitempty"`
	AddGroupIDs                    []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                 []string `json:"removeGroupIDs,omitempty"`
	ClearGroups                    *bool    `json:"clearGroups,omitempty"`
	AddOrganizationIDs             []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs          []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations             *bool    `json:"clearOrganizations,omitempty"`
	AddWebauthnIDs                 []string `json:"addWebauthnIDs,omitempty"`
	RemoveWebauthnIDs              []string `json:"removeWebauthnIDs,omitempty"`
	ClearWebauthns                 *bool    `json:"clearWebauthns,omitempty"`
	AvatarFileID                   *string  `json:"avatarFileID,omitempty"`
	ClearAvatarFile                *bool    `json:"clearAvatarFile,omitempty"`
	AddEventIDs                    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs                 []string `json:"removeEventIDs,omitempty"`
	ClearEvents                    *bool    `json:"clearEvents,omitempty"`
	AddActionPlanIDs               []string `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs            []string `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans               *bool    `json:"clearActionPlans,omitempty"`
	AddSubcontrolIDs               []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs            []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols               *bool    `json:"clearSubcontrols,omitempty"`
	AddAssignerTaskIDs             []string `json:"addAssignerTaskIDs,omitempty"`
	RemoveAssignerTaskIDs          []string `json:"removeAssignerTaskIDs,omitempty"`
	ClearAssignerTasks             *bool    `json:"clearAssignerTasks,omitempty"`
	AddAssigneeTaskIDs             []string `json:"addAssigneeTaskIDs,omitempty"`
	RemoveAssigneeTaskIDs          []string `json:"removeAssigneeTaskIDs,omitempty"`
	ClearAssigneeTasks             *bool    `json:"clearAssigneeTasks,omitempty"`
	AddProgramIDs                  []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs               []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms                  *bool    `json:"clearPrograms,omitempty"`
	AddProgramsOwnedIDs            []string `json:"addProgramsOwnedIDs,omitempty"`
	RemoveProgramsOwnedIDs         []string `json:"removeProgramsOwnedIDs,omitempty"`
	ClearProgramsOwned             *bool    `json:"clearProgramsOwned,omitempty"`
	AddImpersonationEventIDs       []string `json:"addImpersonationEventIDs,omitempty"`
	RemoveImpersonationEventIDs    []string `json:"removeImpersonationEventIDs,omitempty"`
	ClearImpersonationEvents       *bool    `json:"clearImpersonationEvents,omitempty"`
	AddTargetedImpersonationIDs    []string `json:"addTargetedImpersonationIDs,omitempty"`
	RemoveTargetedImpersonationIDs []string `json:"removeTargetedImpersonationIDs,omitempty"`
	ClearTargetedImpersonations    *bool    `json:"clearTargetedImpersonations,omitempty"`
}

// UpdateUserSettingInput is used for update UserSetting object.
// Input was generated by ent.
type UpdateUserSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled      *bool   `json:"isTfaEnabled,omitempty"`
	ClearIsTfaEnabled *bool   `json:"clearIsTfaEnabled,omitempty"`
	UserID            *string `json:"userID,omitempty"`
	ClearUser         *bool   `json:"clearUser,omitempty"`
	DefaultOrgID      *string `json:"defaultOrgID,omitempty"`
	ClearDefaultOrg   *bool   `json:"clearDefaultOrg,omitempty"`
}

// UpdateVulnerabilityInput is used for update Vulnerability object.
// Input was generated by ent.
type UpdateVulnerabilityInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// owner of the vulnerability
	ExternalOwnerID      *string `json:"externalOwnerID,omitempty"`
	ClearExternalOwnerID *bool   `json:"clearExternalOwnerID,omitempty"`
	// external identifier from the integration source for the vulnerability
	ExternalID *string `json:"externalID,omitempty"`
	// CVE identifier for the vulnerability when applicable
	CveID      *string `json:"cveID,omitempty"`
	ClearCveID *bool   `json:"clearCveID,omitempty"`
	// system that produced the vulnerability record
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// display name for the vulnerability when provided
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// category of the vulnerability such as application or infrastructure
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// severity label for the vulnerability
	Severity      *string `json:"severity,omitempty"`
	ClearSeverity *bool   `json:"clearSeverity,omitempty"`
	// overall score such as CVSS for the vulnerability
	Score      *float64 `json:"score,omitempty"`
	ClearScore *bool    `json:"clearScore,omitempty"`
	// impact score or rating for the vulnerability
	Impact      *float64 `json:"impact,omitempty"`
	ClearImpact *bool    `json:"clearImpact,omitempty"`
	// exploitability score or rating for the vulnerability
	Exploitability      *float64 `json:"exploitability,omitempty"`
	ClearExploitability *bool    `json:"clearExploitability,omitempty"`
	// priority assigned to the vulnerability
	Priority      *string `json:"priority,omitempty"`
	ClearPriority *bool   `json:"clearPriority,omitempty"`
	// lifecycle status of the vulnerability
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// short summary of the vulnerability details
	Summary      *string `json:"summary,omitempty"`
	ClearSummary *bool   `json:"clearSummary,omitempty"`
	// long form description of the vulnerability
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// attack vector string such as a CVSS vector
	Vector      *string `json:"vector,omitempty"`
	ClearVector *bool   `json:"clearVector,omitempty"`
	// remediation service level agreement in days
	RemediationSLA      *int64 `json:"remediationSLA,omitempty"`
	ClearRemediationSLA *bool  `json:"clearRemediationSLA,omitempty"`
	// indicates if the vulnerability is still open
	Open      *bool `json:"open,omitempty"`
	ClearOpen *bool `json:"clearOpen,omitempty"`
	// true when the vulnerability blocks production changes
	Blocking      *bool `json:"blocking,omitempty"`
	ClearBlocking *bool `json:"clearBlocking,omitempty"`
	// true when the vulnerability affects production systems
	Production      *bool `json:"production,omitempty"`
	ClearProduction *bool `json:"clearProduction,omitempty"`
	// true when the vulnerability is publicly disclosed
	Public      *bool `json:"public,omitempty"`
	ClearPublic *bool `json:"clearPublic,omitempty"`
	// true when the vulnerability has been validated by the security team
	Validated      *bool `json:"validated,omitempty"`
	ClearValidated *bool `json:"clearValidated,omitempty"`
	// reference links for the vulnerability
	References       []string `json:"references,omitempty"`
	AppendReferences []string `json:"appendReferences,omitempty"`
	ClearReferences  *bool    `json:"clearReferences,omitempty"`
	// targets or assets impacted by the vulnerability
	Impacts       []string `json:"impacts,omitempty"`
	AppendImpacts []string `json:"appendImpacts,omitempty"`
	ClearImpacts  *bool    `json:"clearImpacts,omitempty"`
	// timestamp when the vulnerability was published
	PublishedAt      *models.DateTime `json:"publishedAt,omitempty"`
	ClearPublishedAt *bool            `json:"clearPublishedAt,omitempty"`
	// timestamp when the vulnerability was discovered in the environment
	DiscoveredAt      *models.DateTime `json:"discoveredAt,omitempty"`
	ClearDiscoveredAt *bool            `json:"clearDiscoveredAt,omitempty"`
	// timestamp when the source last updated the vulnerability
	SourceUpdatedAt      *models.DateTime `json:"sourceUpdatedAt,omitempty"`
	ClearSourceUpdatedAt *bool            `json:"clearSourceUpdatedAt,omitempty"`
	// link to the vulnerability in the source system
	ExternalURI      *string `json:"externalURI,omitempty"`
	ClearExternalURI *bool   `json:"clearExternalURI,omitempty"`
	// raw metadata payload for the vulnerability from the source system
	Metadata      map[string]any `json:"metadata,omitempty"`
	ClearMetadata *bool          `json:"clearMetadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload            map[string]any `json:"rawPayload,omitempty"`
	ClearRawPayload       *bool          `json:"clearRawPayload,omitempty"`
	AddBlockedGroupIDs    []string       `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string       `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool          `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string       `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string       `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool          `json:"clearEditors,omitempty"`
	AddViewerIDs          []string       `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string       `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool          `json:"clearViewers,omitempty"`
	AddIntegrationIDs     []string       `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs  []string       `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations     *bool          `json:"clearIntegrations,omitempty"`
	AddFindingIDs         []string       `json:"addFindingIDs,omitempty"`
	RemoveFindingIDs      []string       `json:"removeFindingIDs,omitempty"`
	ClearFindings         *bool          `json:"clearFindings,omitempty"`
	AddActionPlanIDs      []string       `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs   []string       `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans      *bool          `json:"clearActionPlans,omitempty"`
	AddControlIDs         []string       `json:"addControlIDs,omitempty"`
	RemoveControlIDs      []string       `json:"removeControlIDs,omitempty"`
	ClearControls         *bool          `json:"clearControls,omitempty"`
	AddSubcontrolIDs      []string       `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs   []string       `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols      *bool          `json:"clearSubcontrols,omitempty"`
	AddRiskIDs            []string       `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs         []string       `json:"removeRiskIDs,omitempty"`
	ClearRisks            *bool          `json:"clearRisks,omitempty"`
	AddProgramIDs         []string       `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs      []string       `json:"removeProgramIDs,omitempty"`
	ClearPrograms         *bool          `json:"clearPrograms,omitempty"`
	AddAssetIDs           []string       `json:"addAssetIDs,omitempty"`
	RemoveAssetIDs        []string       `json:"removeAssetIDs,omitempty"`
	ClearAssets           *bool          `json:"clearAssets,omitempty"`
	AddEntityIDs          []string       `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs       []string       `json:"removeEntityIDs,omitempty"`
	ClearEntities         *bool          `json:"clearEntities,omitempty"`
	AddScanIDs            []string       `json:"addScanIDs,omitempty"`
	RemoveScanIDs         []string       `json:"removeScanIDs,omitempty"`
	ClearScans            *bool          `json:"clearScans,omitempty"`
	AddTaskIDs            []string       `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs         []string       `json:"removeTaskIDs,omitempty"`
	ClearTasks            *bool          `json:"clearTasks,omitempty"`
	AddRemediationIDs     []string       `json:"addRemediationIDs,omitempty"`
	RemoveRemediationIDs  []string       `json:"removeRemediationIDs,omitempty"`
	ClearRemediations     *bool          `json:"clearRemediations,omitempty"`
	AddReviewIDs          []string       `json:"addReviewIDs,omitempty"`
	RemoveReviewIDs       []string       `json:"removeReviewIDs,omitempty"`
	ClearReviews          *bool          `json:"clearReviews,omitempty"`
	AddCommentIDs         []string       `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs      []string       `json:"removeCommentIDs,omitempty"`
	ClearComments         *bool          `json:"clearComments,omitempty"`
	AddFileIDs            []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs         []string       `json:"removeFileIDs,omitempty"`
	ClearFiles            *bool          `json:"clearFiles,omitempty"`
}

// UpdateWorkflowAssignmentInput is used for update WorkflowAssignment object.
// Input was generated by ent.
type UpdateWorkflowAssignmentInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// Unique key for the assignment within the workflow instance
	AssignmentKey *string `json:"assignmentKey,omitempty"`
	// Role assigned to the target, e.g. APPROVER
	Role *string `json:"role,omitempty"`
	// Optional label for the assignment
	Label      *string `json:"label,omitempty"`
	ClearLabel *bool   `json:"clearLabel,omitempty"`
	// Whether this assignment is required for workflow progression
	Required *bool `json:"required,omitempty"`
	// Current status of the assignment
	Status *enums.WorkflowAssignmentStatus `json:"status,omitempty"`
	// Optional metadata for the assignment
	Metadata      map[string]any `json:"metadata,omitempty"`
	ClearMetadata *bool          `json:"clearMetadata,omitempty"`
	// Timestamp when the assignment was decided
	DecidedAt      *time.Time `json:"decidedAt,omitempty"`
	ClearDecidedAt *bool      `json:"clearDecidedAt,omitempty"`
	// Optional notes about the assignment
	Notes                             *string  `json:"notes,omitempty"`
	ClearNotes                        *bool    `json:"clearNotes,omitempty"`
	OwnerID                           *string  `json:"ownerID,omitempty"`
	ClearOwner                        *bool    `json:"clearOwner,omitempty"`
	WorkflowInstanceID                *string  `json:"workflowInstanceID,omitempty"`
	AddWorkflowAssignmentTargetIDs    []string `json:"addWorkflowAssignmentTargetIDs,omitempty"`
	RemoveWorkflowAssignmentTargetIDs []string `json:"removeWorkflowAssignmentTargetIDs,omitempty"`
	ClearWorkflowAssignmentTargets    *bool    `json:"clearWorkflowAssignmentTargets,omitempty"`
	UserID                            *string  `json:"userID,omitempty"`
	ClearUser                         *bool    `json:"clearUser,omitempty"`
	GroupID                           *string  `json:"groupID,omitempty"`
	ClearGroup                        *bool    `json:"clearGroup,omitempty"`
}

// UpdateWorkflowAssignmentTargetInput is used for update WorkflowAssignmentTarget object.
// Input was generated by ent.
type UpdateWorkflowAssignmentTargetInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// Type of the target (USER, GROUP, ROLE, RESOLVER)
	TargetType *enums.WorkflowTargetType `json:"targetType,omitempty"`
	// Resolver key when target_type is RESOLVER
	ResolverKey          *string `json:"resolverKey,omitempty"`
	ClearResolverKey     *bool   `json:"clearResolverKey,omitempty"`
	OwnerID              *string `json:"ownerID,omitempty"`
	ClearOwner           *bool   `json:"clearOwner,omitempty"`
	WorkflowAssignmentID *string `json:"workflowAssignmentID,omitempty"`
	UserID               *string `json:"userID,omitempty"`
	ClearUser            *bool   `json:"clearUser,omitempty"`
	GroupID              *string `json:"groupID,omitempty"`
	ClearGroup           *bool   `json:"clearGroup,omitempty"`
}

// UpdateWorkflowDefinitionInput is used for update WorkflowDefinition object.
// Input was generated by ent.
type UpdateWorkflowDefinitionInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes      *string `json:"internalNotes,omitempty"`
	ClearInternalNotes *bool   `json:"clearInternalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID      *string `json:"systemInternalID,omitempty"`
	ClearSystemInternalID *bool   `json:"clearSystemInternalID,omitempty"`
	// Name of the workflow definition
	Name *string `json:"name,omitempty"`
	// Optional description of the workflow definition
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// Kind of workflow, e.g. APPROVAL, LIFECYCLE, NOTIFICATION
	WorkflowKind *enums.WorkflowKind `json:"workflowKind,omitempty"`
	// Type of schema this workflow applies to
	SchemaType *string `json:"schemaType,omitempty"`
	// Revision number for this definition
	Revision *int64 `json:"revision,omitempty"`
	// Whether this definition is a draft
	Draft *bool `json:"draft,omitempty"`
	// When this definition was published
	PublishedAt      *time.Time `json:"publishedAt,omitempty"`
	ClearPublishedAt *bool      `json:"clearPublishedAt,omitempty"`
	// Suppress duplicate triggers within this window per object/definition
	CooldownSeconds *int64 `json:"cooldownSeconds,omitempty"`
	// Whether this is the default workflow for the schema type
	IsDefault *bool `json:"isDefault,omitempty"`
	// Whether the workflow definition is active
	Active *bool `json:"active,omitempty"`
	// Derived: normalized operations from definition for prefiltering; not user editable
	TriggerOperations       []string `json:"triggerOperations,omitempty"`
	AppendTriggerOperations []string `json:"appendTriggerOperations,omitempty"`
	ClearTriggerOperations  *bool    `json:"clearTriggerOperations,omitempty"`
	// Derived: normalized fields from definition for prefiltering; not user editable
	TriggerFields       []string `json:"triggerFields,omitempty"`
	AppendTriggerFields []string `json:"appendTriggerFields,omitempty"`
	ClearTriggerFields  *bool    `json:"clearTriggerFields,omitempty"`
	// Typed document describing triggers, conditions, and actions
	DefinitionJSON      *models.WorkflowDefinitionDocument `json:"definitionJSON,omitempty"`
	ClearDefinitionJSON *bool                              `json:"clearDefinitionJSON,omitempty"`
	// Cached list of fields that should trigger workflow evaluation
	TrackedFields          []string `json:"trackedFields,omitempty"`
	AppendTrackedFields    []string `json:"appendTrackedFields,omitempty"`
	ClearTrackedFields     *bool    `json:"clearTrackedFields,omitempty"`
	OwnerID                *string  `json:"ownerID,omitempty"`
	ClearOwner             *bool    `json:"clearOwner,omitempty"`
	AddTagDefinitionIDs    []string `json:"addTagDefinitionIDs,omitempty"`
	RemoveTagDefinitionIDs []string `json:"removeTagDefinitionIDs,omitempty"`
	ClearTagDefinitions    *bool    `json:"clearTagDefinitions,omitempty"`
	AddGroupIDs            []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs         []string `json:"removeGroupIDs,omitempty"`
	ClearGroups            *bool    `json:"clearGroups,omitempty"`
}

// UpdateWorkflowEventInput is used for update WorkflowEvent object.
// Input was generated by ent.
type UpdateWorkflowEventInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// Type of event, typically the action kind
	EventType *enums.WorkflowEventType `json:"eventType,omitempty"`
	// Payload for the event; stored raw
	Payload            *models.WorkflowEventPayload `json:"payload,omitempty"`
	ClearPayload       *bool                        `json:"clearPayload,omitempty"`
	OwnerID            *string                      `json:"ownerID,omitempty"`
	ClearOwner         *bool                        `json:"clearOwner,omitempty"`
	WorkflowInstanceID *string                      `json:"workflowInstanceID,omitempty"`
}

// UpdateWorkflowInstanceInput is used for update WorkflowInstance object.
// Input was generated by ent.
type UpdateWorkflowInstanceInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// Current state of the workflow instance
	State *enums.WorkflowInstanceState `json:"state,omitempty"`
	// Optional context for the workflow instance
	Context      *models.WorkflowInstanceContext `json:"context,omitempty"`
	ClearContext *bool                           `json:"clearContext,omitempty"`
	// Timestamp when the workflow was last evaluated
	LastEvaluatedAt      *time.Time `json:"lastEvaluatedAt,omitempty"`
	ClearLastEvaluatedAt *bool      `json:"clearLastEvaluatedAt,omitempty"`
	// Copy of definition JSON used for this instance
	DefinitionSnapshot          *models.WorkflowDefinitionDocument `json:"definitionSnapshot,omitempty"`
	ClearDefinitionSnapshot     *bool                              `json:"clearDefinitionSnapshot,omitempty"`
	OwnerID                     *string                            `json:"ownerID,omitempty"`
	ClearOwner                  *bool                              `json:"clearOwner,omitempty"`
	WorkflowDefinitionID        *string                            `json:"workflowDefinitionID,omitempty"`
	AddWorkflowAssignmentIDs    []string                           `json:"addWorkflowAssignmentIDs,omitempty"`
	RemoveWorkflowAssignmentIDs []string                           `json:"removeWorkflowAssignmentIDs,omitempty"`
	ClearWorkflowAssignments    *bool                              `json:"clearWorkflowAssignments,omitempty"`
	AddWorkflowEventIDs         []string                           `json:"addWorkflowEventIDs,omitempty"`
	RemoveWorkflowEventIDs      []string                           `json:"removeWorkflowEventIDs,omitempty"`
	ClearWorkflowEvents         *bool                              `json:"clearWorkflowEvents,omitempty"`
	AddWorkflowObjectRefIDs     []string                           `json:"addWorkflowObjectRefIDs,omitempty"`
	RemoveWorkflowObjectRefIDs  []string                           `json:"removeWorkflowObjectRefIDs,omitempty"`
	ClearWorkflowObjectRefs     *bool                              `json:"clearWorkflowObjectRefs,omitempty"`
}

// UpdateWorkflowObjectRefInput is used for update WorkflowObjectRef object.
// Input was generated by ent.
type UpdateWorkflowObjectRefInput struct {
	OwnerID    *string `json:"ownerID,omitempty"`
	ClearOwner *bool   `json:"clearOwner,omitempty"`
}

type User struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the last auth provider used to login
	LastLoginProvider *enums.AuthProvider `json:"lastLoginProvider,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role *enums.Role `json:"role,omitempty"`
	// the SCIM external ID for the user
	ScimExternalID *string `json:"scimExternalID,omitempty"`
	// the SCIM username for the user
	ScimUsername *string `json:"scimUsername,omitempty"`
	// whether the SCIM user is active
	ScimActive *bool `json:"scimActive,omitempty"`
	// the SCIM preferred language for the user
	ScimPreferredLanguage *string `json:"scimPreferredLanguage,omitempty"`
	// the SCIM locale for the user
	ScimLocale           *string                        `json:"scimLocale,omitempty"`
	PersonalAccessTokens *PersonalAccessTokenConnection `json:"personalAccessTokens"`
	TfaSettings          *TFASettingConnection          `json:"tfaSettings"`
	Setting              *UserSetting                   `json:"setting"`
	Groups               *GroupConnection               `json:"groups"`
	Organizations        *OrganizationConnection        `json:"organizations"`
	Webauthns            *WebauthnConnection            `json:"webauthns"`
	AvatarFile           *File                          `json:"avatarFile,omitempty"`
	Events               *EventConnection               `json:"events"`
	ActionPlans          *ActionPlanConnection          `json:"actionPlans"`
	Subcontrols          *SubcontrolConnection          `json:"subcontrols"`
	AssignerTasks        *TaskConnection                `json:"assignerTasks"`
	AssigneeTasks        *TaskConnection                `json:"assigneeTasks"`
	Programs             *ProgramConnection             `json:"programs"`
	ProgramsOwned        *ProgramConnection             `json:"programsOwned"`
	GroupMemberships     *GroupMembershipConnection     `json:"groupMemberships"`
	OrgMemberships       *OrgMembershipConnection       `json:"orgMemberships"`
	ProgramMemberships   *ProgramMembershipConnection   `json:"programMemberships"`
}

func (User) IsNode() {}

// Return response for createBulkUser mutation
type UserBulkCreatePayload struct {
	// Created users
	Users []*User `json:"users,omitempty"`
}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User *User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the last auth provider used to login
	LastLoginProvider *enums.AuthProvider `json:"lastLoginProvider,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role *enums.Role `json:"role,omitempty"`
	// the SCIM external ID for the user
	ScimExternalID *string `json:"scimExternalID,omitempty"`
	// the SCIM username for the user
	ScimUsername *string `json:"scimUsername,omitempty"`
	// whether the SCIM user is active
	ScimActive *bool `json:"scimActive,omitempty"`
	// the SCIM preferred language for the user
	ScimPreferredLanguage *string `json:"scimPreferredLanguage,omitempty"`
	// the SCIM locale for the user
	ScimLocale *string `json:"scimLocale,omitempty"`
}

func (UserHistory) IsNode() {}

// A connection to a list of items.
type UserHistoryConnection struct {
	// A list of edges.
	Edges []*UserHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for UserHistory connections
type UserHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserHistories.
	Field UserHistoryOrderField `json:"field"`
}

// UserHistoryWhereInput is used for filtering UserHistory objects.
// Input was generated by ent.
type UserHistoryWhereInput struct {
	Not *UserHistoryWhereInput   `json:"not,omitempty"`
	And []*UserHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// last_login_provider field predicates
	LastLoginProvider       *enums.AuthProvider  `json:"lastLoginProvider,omitempty"`
	LastLoginProviderNeq    *enums.AuthProvider  `json:"lastLoginProviderNEQ,omitempty"`
	LastLoginProviderIn     []enums.AuthProvider `json:"lastLoginProviderIn,omitempty"`
	LastLoginProviderNotIn  []enums.AuthProvider `json:"lastLoginProviderNotIn,omitempty"`
	LastLoginProviderIsNil  *bool                `json:"lastLoginProviderIsNil,omitempty"`
	LastLoginProviderNotNil *bool                `json:"lastLoginProviderNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
	// scim_external_id field predicates
	ScimExternalID             *string  `json:"scimExternalID,omitempty"`
	ScimExternalIdneq          *string  `json:"scimExternalIDNEQ,omitempty"`
	ScimExternalIDIn           []string `json:"scimExternalIDIn,omitempty"`
	ScimExternalIDNotIn        []string `json:"scimExternalIDNotIn,omitempty"`
	ScimExternalIdgt           *string  `json:"scimExternalIDGT,omitempty"`
	ScimExternalIdgte          *string  `json:"scimExternalIDGTE,omitempty"`
	ScimExternalIdlt           *string  `json:"scimExternalIDLT,omitempty"`
	ScimExternalIdlte          *string  `json:"scimExternalIDLTE,omitempty"`
	ScimExternalIDContains     *string  `json:"scimExternalIDContains,omitempty"`
	ScimExternalIDHasPrefix    *string  `json:"scimExternalIDHasPrefix,omitempty"`
	ScimExternalIDHasSuffix    *string  `json:"scimExternalIDHasSuffix,omitempty"`
	ScimExternalIDIsNil        *bool    `json:"scimExternalIDIsNil,omitempty"`
	ScimExternalIDNotNil       *bool    `json:"scimExternalIDNotNil,omitempty"`
	ScimExternalIDEqualFold    *string  `json:"scimExternalIDEqualFold,omitempty"`
	ScimExternalIDContainsFold *string  `json:"scimExternalIDContainsFold,omitempty"`
	// scim_username field predicates
	ScimUsername             *string  `json:"scimUsername,omitempty"`
	ScimUsernameNeq          *string  `json:"scimUsernameNEQ,omitempty"`
	ScimUsernameIn           []string `json:"scimUsernameIn,omitempty"`
	ScimUsernameNotIn        []string `json:"scimUsernameNotIn,omitempty"`
	ScimUsernameGt           *string  `json:"scimUsernameGT,omitempty"`
	ScimUsernameGte          *string  `json:"scimUsernameGTE,omitempty"`
	ScimUsernameLt           *string  `json:"scimUsernameLT,omitempty"`
	ScimUsernameLte          *string  `json:"scimUsernameLTE,omitempty"`
	ScimUsernameContains     *string  `json:"scimUsernameContains,omitempty"`
	ScimUsernameHasPrefix    *string  `json:"scimUsernameHasPrefix,omitempty"`
	ScimUsernameHasSuffix    *string  `json:"scimUsernameHasSuffix,omitempty"`
	ScimUsernameIsNil        *bool    `json:"scimUsernameIsNil,omitempty"`
	ScimUsernameNotNil       *bool    `json:"scimUsernameNotNil,omitempty"`
	ScimUsernameEqualFold    *string  `json:"scimUsernameEqualFold,omitempty"`
	ScimUsernameContainsFold *string  `json:"scimUsernameContainsFold,omitempty"`
	// scim_active field predicates
	ScimActive       *bool `json:"scimActive,omitempty"`
	ScimActiveNeq    *bool `json:"scimActiveNEQ,omitempty"`
	ScimActiveIsNil  *bool `json:"scimActiveIsNil,omitempty"`
	ScimActiveNotNil *bool `json:"scimActiveNotNil,omitempty"`
	// scim_preferred_language field predicates
	ScimPreferredLanguage             *string  `json:"scimPreferredLanguage,omitempty"`
	ScimPreferredLanguageNeq          *string  `json:"scimPreferredLanguageNEQ,omitempty"`
	ScimPreferredLanguageIn           []string `json:"scimPreferredLanguageIn,omitempty"`
	ScimPreferredLanguageNotIn        []string `json:"scimPreferredLanguageNotIn,omitempty"`
	ScimPreferredLanguageGt           *string  `json:"scimPreferredLanguageGT,omitempty"`
	ScimPreferredLanguageGte          *string  `json:"scimPreferredLanguageGTE,omitempty"`
	ScimPreferredLanguageLt           *string  `json:"scimPreferredLanguageLT,omitempty"`
	ScimPreferredLanguageLte          *string  `json:"scimPreferredLanguageLTE,omitempty"`
	ScimPreferredLanguageContains     *string  `json:"scimPreferredLanguageContains,omitempty"`
	ScimPreferredLanguageHasPrefix    *string  `json:"scimPreferredLanguageHasPrefix,omitempty"`
	ScimPreferredLanguageHasSuffix    *string  `json:"scimPreferredLanguageHasSuffix,omitempty"`
	ScimPreferredLanguageIsNil        *bool    `json:"scimPreferredLanguageIsNil,omitempty"`
	ScimPreferredLanguageNotNil       *bool    `json:"scimPreferredLanguageNotNil,omitempty"`
	ScimPreferredLanguageEqualFold    *string  `json:"scimPreferredLanguageEqualFold,omitempty"`
	ScimPreferredLanguageContainsFold *string  `json:"scimPreferredLanguageContainsFold,omitempty"`
	// scim_locale field predicates
	ScimLocale             *string  `json:"scimLocale,omitempty"`
	ScimLocaleNeq          *string  `json:"scimLocaleNEQ,omitempty"`
	ScimLocaleIn           []string `json:"scimLocaleIn,omitempty"`
	ScimLocaleNotIn        []string `json:"scimLocaleNotIn,omitempty"`
	ScimLocaleGt           *string  `json:"scimLocaleGT,omitempty"`
	ScimLocaleGte          *string  `json:"scimLocaleGTE,omitempty"`
	ScimLocaleLt           *string  `json:"scimLocaleLT,omitempty"`
	ScimLocaleLte          *string  `json:"scimLocaleLTE,omitempty"`
	ScimLocaleContains     *string  `json:"scimLocaleContains,omitempty"`
	ScimLocaleHasPrefix    *string  `json:"scimLocaleHasPrefix,omitempty"`
	ScimLocaleHasSuffix    *string  `json:"scimLocaleHasSuffix,omitempty"`
	ScimLocaleIsNil        *bool    `json:"scimLocaleIsNil,omitempty"`
	ScimLocaleNotNil       *bool    `json:"scimLocaleNotNil,omitempty"`
	ScimLocaleEqualFold    *string  `json:"scimLocaleEqualFold,omitempty"`
	ScimLocaleContainsFold *string  `json:"scimLocaleContainsFold,omitempty"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

type UserSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags   []string `json:"tags,omitempty"`
	UserID *string  `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
	User         *User `json:"user,omitempty"`
	// organization to load on user login
	DefaultOrg *Organization `json:"defaultOrg,omitempty"`
}

func (UserSetting) IsNode() {}

// Return response for createBulkUserSetting mutation
type UserSettingBulkCreatePayload struct {
	// Created userSettings
	UserSettings []*UserSetting `json:"userSettings,omitempty"`
}

// Return response for deleteBulkUserSetting mutation
type UserSettingBulkDeletePayload struct {
	// Deleted userSetting IDs
	DeletedIDs []string `json:"deletedIDs"`
}

// A connection to a list of items.
type UserSettingConnection struct {
	// A list of edges.
	Edges []*UserSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUserSetting mutation
type UserSettingCreatePayload struct {
	// Created userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// An edge in a connection.
type UserSettingEdge struct {
	// The item at the end of the edge.
	Node *UserSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags   []string `json:"tags,omitempty"`
	UserID *string  `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
}

func (UserSettingHistory) IsNode() {}

// A connection to a list of items.
type UserSettingHistoryConnection struct {
	// A list of edges.
	Edges []*UserSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for UserSettingHistory connections
type UserSettingHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserSettingHistories.
	Field UserSettingHistoryOrderField `json:"field"`
}

// UserSettingHistoryWhereInput is used for filtering UserSettingHistory objects.
// Input was generated by ent.
type UserSettingHistoryWhereInput struct {
	Not *UserSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*UserSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
}

// Ordering options for UserSetting connections
type UserSettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserSettings.
	Field UserSettingOrderField `json:"field"`
}

// Return response for updateUserSetting mutation
type UserSettingUpdatePayload struct {
	// Updated userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// UserSettingWhereInput is used for filtering UserSetting objects.
// Input was generated by ent.
type UserSettingWhereInput struct {
	Not *UserSettingWhereInput   `json:"not,omitempty"`
	And []*UserSettingWhereInput `json:"and,omitempty"`
	Or  []*UserSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// default_org edge predicates
	HasDefaultOrg     *bool                     `json:"hasDefaultOrg,omitempty"`
	HasDefaultOrgWith []*OrganizationWhereInput `json:"hasDefaultOrgWith,omitempty"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User *User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// last_login_provider field predicates
	LastLoginProvider       *enums.AuthProvider  `json:"lastLoginProvider,omitempty"`
	LastLoginProviderNeq    *enums.AuthProvider  `json:"lastLoginProviderNEQ,omitempty"`
	LastLoginProviderIn     []enums.AuthProvider `json:"lastLoginProviderIn,omitempty"`
	LastLoginProviderNotIn  []enums.AuthProvider `json:"lastLoginProviderNotIn,omitempty"`
	LastLoginProviderIsNil  *bool                `json:"lastLoginProviderIsNil,omitempty"`
	LastLoginProviderNotNil *bool                `json:"lastLoginProviderNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
	// scim_external_id field predicates
	ScimExternalID             *string  `json:"scimExternalID,omitempty"`
	ScimExternalIdneq          *string  `json:"scimExternalIDNEQ,omitempty"`
	ScimExternalIDIn           []string `json:"scimExternalIDIn,omitempty"`
	ScimExternalIDNotIn        []string `json:"scimExternalIDNotIn,omitempty"`
	ScimExternalIdgt           *string  `json:"scimExternalIDGT,omitempty"`
	ScimExternalIdgte          *string  `json:"scimExternalIDGTE,omitempty"`
	ScimExternalIdlt           *string  `json:"scimExternalIDLT,omitempty"`
	ScimExternalIdlte          *string  `json:"scimExternalIDLTE,omitempty"`
	ScimExternalIDContains     *string  `json:"scimExternalIDContains,omitempty"`
	ScimExternalIDHasPrefix    *string  `json:"scimExternalIDHasPrefix,omitempty"`
	ScimExternalIDHasSuffix    *string  `json:"scimExternalIDHasSuffix,omitempty"`
	ScimExternalIDIsNil        *bool    `json:"scimExternalIDIsNil,omitempty"`
	ScimExternalIDNotNil       *bool    `json:"scimExternalIDNotNil,omitempty"`
	ScimExternalIDEqualFold    *string  `json:"scimExternalIDEqualFold,omitempty"`
	ScimExternalIDContainsFold *string  `json:"scimExternalIDContainsFold,omitempty"`
	// scim_username field predicates
	ScimUsername             *string  `json:"scimUsername,omitempty"`
	ScimUsernameNeq          *string  `json:"scimUsernameNEQ,omitempty"`
	ScimUsernameIn           []string `json:"scimUsernameIn,omitempty"`
	ScimUsernameNotIn        []string `json:"scimUsernameNotIn,omitempty"`
	ScimUsernameGt           *string  `json:"scimUsernameGT,omitempty"`
	ScimUsernameGte          *string  `json:"scimUsernameGTE,omitempty"`
	ScimUsernameLt           *string  `json:"scimUsernameLT,omitempty"`
	ScimUsernameLte          *string  `json:"scimUsernameLTE,omitempty"`
	ScimUsernameContains     *string  `json:"scimUsernameContains,omitempty"`
	ScimUsernameHasPrefix    *string  `json:"scimUsernameHasPrefix,omitempty"`
	ScimUsernameHasSuffix    *string  `json:"scimUsernameHasSuffix,omitempty"`
	ScimUsernameIsNil        *bool    `json:"scimUsernameIsNil,omitempty"`
	ScimUsernameNotNil       *bool    `json:"scimUsernameNotNil,omitempty"`
	ScimUsernameEqualFold    *string  `json:"scimUsernameEqualFold,omitempty"`
	ScimUsernameContainsFold *string  `json:"scimUsernameContainsFold,omitempty"`
	// scim_active field predicates
	ScimActive       *bool `json:"scimActive,omitempty"`
	ScimActiveNeq    *bool `json:"scimActiveNEQ,omitempty"`
	ScimActiveIsNil  *bool `json:"scimActiveIsNil,omitempty"`
	ScimActiveNotNil *bool `json:"scimActiveNotNil,omitempty"`
	// scim_preferred_language field predicates
	ScimPreferredLanguage             *string  `json:"scimPreferredLanguage,omitempty"`
	ScimPreferredLanguageNeq          *string  `json:"scimPreferredLanguageNEQ,omitempty"`
	ScimPreferredLanguageIn           []string `json:"scimPreferredLanguageIn,omitempty"`
	ScimPreferredLanguageNotIn        []string `json:"scimPreferredLanguageNotIn,omitempty"`
	ScimPreferredLanguageGt           *string  `json:"scimPreferredLanguageGT,omitempty"`
	ScimPreferredLanguageGte          *string  `json:"scimPreferredLanguageGTE,omitempty"`
	ScimPreferredLanguageLt           *string  `json:"scimPreferredLanguageLT,omitempty"`
	ScimPreferredLanguageLte          *string  `json:"scimPreferredLanguageLTE,omitempty"`
	ScimPreferredLanguageContains     *string  `json:"scimPreferredLanguageContains,omitempty"`
	ScimPreferredLanguageHasPrefix    *string  `json:"scimPreferredLanguageHasPrefix,omitempty"`
	ScimPreferredLanguageHasSuffix    *string  `json:"scimPreferredLanguageHasSuffix,omitempty"`
	ScimPreferredLanguageIsNil        *bool    `json:"scimPreferredLanguageIsNil,omitempty"`
	ScimPreferredLanguageNotNil       *bool    `json:"scimPreferredLanguageNotNil,omitempty"`
	ScimPreferredLanguageEqualFold    *string  `json:"scimPreferredLanguageEqualFold,omitempty"`
	ScimPreferredLanguageContainsFold *string  `json:"scimPreferredLanguageContainsFold,omitempty"`
	// scim_locale field predicates
	ScimLocale             *string  `json:"scimLocale,omitempty"`
	ScimLocaleNeq          *string  `json:"scimLocaleNEQ,omitempty"`
	ScimLocaleIn           []string `json:"scimLocaleIn,omitempty"`
	ScimLocaleNotIn        []string `json:"scimLocaleNotIn,omitempty"`
	ScimLocaleGt           *string  `json:"scimLocaleGT,omitempty"`
	ScimLocaleGte          *string  `json:"scimLocaleGTE,omitempty"`
	ScimLocaleLt           *string  `json:"scimLocaleLT,omitempty"`
	ScimLocaleLte          *string  `json:"scimLocaleLTE,omitempty"`
	ScimLocaleContains     *string  `json:"scimLocaleContains,omitempty"`
	ScimLocaleHasPrefix    *string  `json:"scimLocaleHasPrefix,omitempty"`
	ScimLocaleHasSuffix    *string  `json:"scimLocaleHasSuffix,omitempty"`
	ScimLocaleIsNil        *bool    `json:"scimLocaleIsNil,omitempty"`
	ScimLocaleNotNil       *bool    `json:"scimLocaleNotNil,omitempty"`
	ScimLocaleEqualFold    *string  `json:"scimLocaleEqualFold,omitempty"`
	ScimLocaleContainsFold *string  `json:"scimLocaleContainsFold,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// tfa_settings edge predicates
	HasTfaSettings     *bool                   `json:"hasTfaSettings,omitempty"`
	HasTfaSettingsWith []*TFASettingWhereInput `json:"hasTfaSettingsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                    `json:"hasSetting,omitempty"`
	HasSettingWith []*UserSettingWhereInput `json:"hasSettingWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// webauthns edge predicates
	HasWebauthns     *bool                 `json:"hasWebauthns,omitempty"`
	HasWebauthnsWith []*WebauthnWhereInput `json:"hasWebauthnsWith,omitempty"`
	// avatar_file edge predicates
	HasAvatarFile     *bool             `json:"hasAvatarFile,omitempty"`
	HasAvatarFileWith []*FileWhereInput `json:"hasAvatarFileWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// assigner_tasks edge predicates
	HasAssignerTasks     *bool             `json:"hasAssignerTasks,omitempty"`
	HasAssignerTasksWith []*TaskWhereInput `json:"hasAssignerTasksWith,omitempty"`
	// assignee_tasks edge predicates
	HasAssigneeTasks     *bool             `json:"hasAssigneeTasks,omitempty"`
	HasAssigneeTasksWith []*TaskWhereInput `json:"hasAssigneeTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// programs_owned edge predicates
	HasProgramsOwned     *bool                `json:"hasProgramsOwned,omitempty"`
	HasProgramsOwnedWith []*ProgramWhereInput `json:"hasProgramsOwnedWith,omitempty"`
	// group_memberships edge predicates
	HasGroupMemberships     *bool                        `json:"hasGroupMemberships,omitempty"`
	HasGroupMembershipsWith []*GroupMembershipWhereInput `json:"hasGroupMembershipsWith,omitempty"`
	// org_memberships edge predicates
	HasOrgMemberships     *bool                      `json:"hasOrgMemberships,omitempty"`
	HasOrgMembershipsWith []*OrgMembershipWhereInput `json:"hasOrgMembershipsWith,omitempty"`
	// program_memberships edge predicates
	HasProgramMemberships     *bool                          `json:"hasProgramMemberships,omitempty"`
	HasProgramMembershipsWith []*ProgramMembershipWhereInput `json:"hasProgramMembershipsWith,omitempty"`
}

type Vulnerability struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// owner of the vulnerability
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// external identifier from the integration source for the vulnerability
	ExternalID string `json:"externalID"`
	// CVE identifier for the vulnerability when applicable
	CveID *string `json:"cveID,omitempty"`
	// system that produced the vulnerability record
	Source *string `json:"source,omitempty"`
	// display name for the vulnerability when provided
	DisplayName *string `json:"displayName,omitempty"`
	// category of the vulnerability such as application or infrastructure
	Category *string `json:"category,omitempty"`
	// severity label for the vulnerability
	Severity *string `json:"severity,omitempty"`
	// overall score such as CVSS for the vulnerability
	Score *float64 `json:"score,omitempty"`
	// impact score or rating for the vulnerability
	Impact *float64 `json:"impact,omitempty"`
	// exploitability score or rating for the vulnerability
	Exploitability *float64 `json:"exploitability,omitempty"`
	// priority assigned to the vulnerability
	Priority *string `json:"priority,omitempty"`
	// lifecycle status of the vulnerability
	Status *string `json:"status,omitempty"`
	// short summary of the vulnerability details
	Summary *string `json:"summary,omitempty"`
	// long form description of the vulnerability
	Description *string `json:"description,omitempty"`
	// attack vector string such as a CVSS vector
	Vector *string `json:"vector,omitempty"`
	// remediation service level agreement in days
	RemediationSLA *int64 `json:"remediationSLA,omitempty"`
	// indicates if the vulnerability is still open
	Open *bool `json:"open,omitempty"`
	// true when the vulnerability blocks production changes
	Blocking *bool `json:"blocking,omitempty"`
	// true when the vulnerability affects production systems
	Production *bool `json:"production,omitempty"`
	// true when the vulnerability is publicly disclosed
	Public *bool `json:"public,omitempty"`
	// true when the vulnerability has been validated by the security team
	Validated *bool `json:"validated,omitempty"`
	// reference links for the vulnerability
	References []string `json:"references,omitempty"`
	// targets or assets impacted by the vulnerability
	Impacts []string `json:"impacts,omitempty"`
	// timestamp when the vulnerability was published
	PublishedAt *models.DateTime `json:"publishedAt,omitempty"`
	// timestamp when the vulnerability was discovered in the environment
	DiscoveredAt *models.DateTime `json:"discoveredAt,omitempty"`
	// timestamp when the source last updated the vulnerability
	SourceUpdatedAt *models.DateTime `json:"sourceUpdatedAt,omitempty"`
	// link to the vulnerability in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the vulnerability from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload    map[string]any         `json:"rawPayload,omitempty"`
	Owner         *Organization          `json:"owner,omitempty"`
	BlockedGroups *GroupConnection       `json:"blockedGroups"`
	Editors       *GroupConnection       `json:"editors"`
	Viewers       *GroupConnection       `json:"viewers"`
	Integrations  *IntegrationConnection `json:"integrations"`
	Findings      *FindingConnection     `json:"findings"`
	ActionPlans   *ActionPlanConnection  `json:"actionPlans"`
	Controls      *ControlConnection     `json:"controls"`
	Subcontrols   *SubcontrolConnection  `json:"subcontrols"`
	Risks         *RiskConnection        `json:"risks"`
	Programs      *ProgramConnection     `json:"programs"`
	Assets        *AssetConnection       `json:"assets"`
	Entities      *EntityConnection      `json:"entities"`
	Scans         *ScanConnection        `json:"scans"`
	Tasks         *TaskConnection        `json:"tasks"`
	Remediations  *RemediationConnection `json:"remediations"`
	Reviews       *ReviewConnection      `json:"reviews"`
	Comments      *NoteConnection        `json:"comments"`
	Files         *FileConnection        `json:"files"`
}

func (Vulnerability) IsNode() {}

// Return response for createBulkVulnerability mutation
type VulnerabilityBulkCreatePayload struct {
	// Created vulnerabilitys
	Vulnerabilities []*Vulnerability `json:"vulnerabilities,omitempty"`
}

// A connection to a list of items.
type VulnerabilityConnection struct {
	// A list of edges.
	Edges []*VulnerabilityEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createVulnerability mutation
type VulnerabilityCreatePayload struct {
	// Created vulnerability
	Vulnerability *Vulnerability `json:"vulnerability"`
}

// Return response for deleteVulnerability mutation
type VulnerabilityDeletePayload struct {
	// Deleted vulnerability ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type VulnerabilityEdge struct {
	// The item at the end of the edge.
	Node *Vulnerability `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type VulnerabilityHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// owner of the vulnerability
	ExternalOwnerID *string `json:"externalOwnerID,omitempty"`
	// external identifier from the integration source for the vulnerability
	ExternalID string `json:"externalID"`
	// CVE identifier for the vulnerability when applicable
	CveID *string `json:"cveID,omitempty"`
	// system that produced the vulnerability record
	Source *string `json:"source,omitempty"`
	// display name for the vulnerability when provided
	DisplayName *string `json:"displayName,omitempty"`
	// category of the vulnerability such as application or infrastructure
	Category *string `json:"category,omitempty"`
	// severity label for the vulnerability
	Severity *string `json:"severity,omitempty"`
	// overall score such as CVSS for the vulnerability
	Score *float64 `json:"score,omitempty"`
	// impact score or rating for the vulnerability
	Impact *float64 `json:"impact,omitempty"`
	// exploitability score or rating for the vulnerability
	Exploitability *float64 `json:"exploitability,omitempty"`
	// priority assigned to the vulnerability
	Priority *string `json:"priority,omitempty"`
	// lifecycle status of the vulnerability
	Status *string `json:"status,omitempty"`
	// short summary of the vulnerability details
	Summary *string `json:"summary,omitempty"`
	// long form description of the vulnerability
	Description *string `json:"description,omitempty"`
	// attack vector string such as a CVSS vector
	Vector *string `json:"vector,omitempty"`
	// remediation service level agreement in days
	RemediationSLA *int64 `json:"remediationSLA,omitempty"`
	// indicates if the vulnerability is still open
	Open *bool `json:"open,omitempty"`
	// true when the vulnerability blocks production changes
	Blocking *bool `json:"blocking,omitempty"`
	// true when the vulnerability affects production systems
	Production *bool `json:"production,omitempty"`
	// true when the vulnerability is publicly disclosed
	Public *bool `json:"public,omitempty"`
	// true when the vulnerability has been validated by the security team
	Validated *bool `json:"validated,omitempty"`
	// reference links for the vulnerability
	References []string `json:"references,omitempty"`
	// targets or assets impacted by the vulnerability
	Impacts []string `json:"impacts,omitempty"`
	// timestamp when the vulnerability was published
	PublishedAt *models.DateTime `json:"publishedAt,omitempty"`
	// timestamp when the vulnerability was discovered in the environment
	DiscoveredAt *models.DateTime `json:"discoveredAt,omitempty"`
	// timestamp when the source last updated the vulnerability
	SourceUpdatedAt *models.DateTime `json:"sourceUpdatedAt,omitempty"`
	// link to the vulnerability in the source system
	ExternalURI *string `json:"externalURI,omitempty"`
	// raw metadata payload for the vulnerability from the source system
	Metadata map[string]any `json:"metadata,omitempty"`
	// raw payload received from the integration for auditing and troubleshooting
	RawPayload map[string]any `json:"rawPayload,omitempty"`
}

func (VulnerabilityHistory) IsNode() {}

// A connection to a list of items.
type VulnerabilityHistoryConnection struct {
	// A list of edges.
	Edges []*VulnerabilityHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type VulnerabilityHistoryEdge struct {
	// The item at the end of the edge.
	Node *VulnerabilityHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for VulnerabilityHistory connections
type VulnerabilityHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order VulnerabilityHistories.
	Field VulnerabilityHistoryOrderField `json:"field"`
}

// VulnerabilityHistoryWhereInput is used for filtering VulnerabilityHistory objects.
// Input was generated by ent.
type VulnerabilityHistoryWhereInput struct {
	Not *VulnerabilityHistoryWhereInput   `json:"not,omitempty"`
	And []*VulnerabilityHistoryWhereInput `json:"and,omitempty"`
	Or  []*VulnerabilityHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// external_owner_id field predicates
	ExternalOwnerID             *string  `json:"externalOwnerID,omitempty"`
	ExternalOwnerIdneq          *string  `json:"externalOwnerIDNEQ,omitempty"`
	ExternalOwnerIDIn           []string `json:"externalOwnerIDIn,omitempty"`
	ExternalOwnerIDNotIn        []string `json:"externalOwnerIDNotIn,omitempty"`
	ExternalOwnerIdgt           *string  `json:"externalOwnerIDGT,omitempty"`
	ExternalOwnerIdgte          *string  `json:"externalOwnerIDGTE,omitempty"`
	ExternalOwnerIdlt           *string  `json:"externalOwnerIDLT,omitempty"`
	ExternalOwnerIdlte          *string  `json:"externalOwnerIDLTE,omitempty"`
	ExternalOwnerIDContains     *string  `json:"externalOwnerIDContains,omitempty"`
	ExternalOwnerIDHasPrefix    *string  `json:"externalOwnerIDHasPrefix,omitempty"`
	ExternalOwnerIDHasSuffix    *string  `json:"externalOwnerIDHasSuffix,omitempty"`
	ExternalOwnerIDIsNil        *bool    `json:"externalOwnerIDIsNil,omitempty"`
	ExternalOwnerIDNotNil       *bool    `json:"externalOwnerIDNotNil,omitempty"`
	ExternalOwnerIDEqualFold    *string  `json:"externalOwnerIDEqualFold,omitempty"`
	ExternalOwnerIDContainsFold *string  `json:"externalOwnerIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// cve_id field predicates
	CveID             *string  `json:"cveID,omitempty"`
	CveIdneq          *string  `json:"cveIDNEQ,omitempty"`
	CveIDIn           []string `json:"cveIDIn,omitempty"`
	CveIDNotIn        []string `json:"cveIDNotIn,omitempty"`
	CveIdgt           *string  `json:"cveIDGT,omitempty"`
	CveIdgte          *string  `json:"cveIDGTE,omitempty"`
	CveIdlt           *string  `json:"cveIDLT,omitempty"`
	CveIdlte          *string  `json:"cveIDLTE,omitempty"`
	CveIDContains     *string  `json:"cveIDContains,omitempty"`
	CveIDHasPrefix    *string  `json:"cveIDHasPrefix,omitempty"`
	CveIDHasSuffix    *string  `json:"cveIDHasSuffix,omitempty"`
	CveIDIsNil        *bool    `json:"cveIDIsNil,omitempty"`
	CveIDNotNil       *bool    `json:"cveIDNotNil,omitempty"`
	CveIDEqualFold    *string  `json:"cveIDEqualFold,omitempty"`
	CveIDContainsFold *string  `json:"cveIDContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// severity field predicates
	Severity             *string  `json:"severity,omitempty"`
	SeverityNeq          *string  `json:"severityNEQ,omitempty"`
	SeverityIn           []string `json:"severityIn,omitempty"`
	SeverityNotIn        []string `json:"severityNotIn,omitempty"`
	SeverityGt           *string  `json:"severityGT,omitempty"`
	SeverityGte          *string  `json:"severityGTE,omitempty"`
	SeverityLt           *string  `json:"severityLT,omitempty"`
	SeverityLte          *string  `json:"severityLTE,omitempty"`
	SeverityContains     *string  `json:"severityContains,omitempty"`
	SeverityHasPrefix    *string  `json:"severityHasPrefix,omitempty"`
	SeverityHasSuffix    *string  `json:"severityHasSuffix,omitempty"`
	SeverityIsNil        *bool    `json:"severityIsNil,omitempty"`
	SeverityNotNil       *bool    `json:"severityNotNil,omitempty"`
	SeverityEqualFold    *string  `json:"severityEqualFold,omitempty"`
	SeverityContainsFold *string  `json:"severityContainsFold,omitempty"`
	// score field predicates
	Score       *float64  `json:"score,omitempty"`
	ScoreNeq    *float64  `json:"scoreNEQ,omitempty"`
	ScoreIn     []float64 `json:"scoreIn,omitempty"`
	ScoreNotIn  []float64 `json:"scoreNotIn,omitempty"`
	ScoreGt     *float64  `json:"scoreGT,omitempty"`
	ScoreGte    *float64  `json:"scoreGTE,omitempty"`
	ScoreLt     *float64  `json:"scoreLT,omitempty"`
	ScoreLte    *float64  `json:"scoreLTE,omitempty"`
	ScoreIsNil  *bool     `json:"scoreIsNil,omitempty"`
	ScoreNotNil *bool     `json:"scoreNotNil,omitempty"`
	// impact field predicates
	Impact       *float64  `json:"impact,omitempty"`
	ImpactNeq    *float64  `json:"impactNEQ,omitempty"`
	ImpactIn     []float64 `json:"impactIn,omitempty"`
	ImpactNotIn  []float64 `json:"impactNotIn,omitempty"`
	ImpactGt     *float64  `json:"impactGT,omitempty"`
	ImpactGte    *float64  `json:"impactGTE,omitempty"`
	ImpactLt     *float64  `json:"impactLT,omitempty"`
	ImpactLte    *float64  `json:"impactLTE,omitempty"`
	ImpactIsNil  *bool     `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool     `json:"impactNotNil,omitempty"`
	// exploitability field predicates
	Exploitability       *float64  `json:"exploitability,omitempty"`
	ExploitabilityNeq    *float64  `json:"exploitabilityNEQ,omitempty"`
	ExploitabilityIn     []float64 `json:"exploitabilityIn,omitempty"`
	ExploitabilityNotIn  []float64 `json:"exploitabilityNotIn,omitempty"`
	ExploitabilityGt     *float64  `json:"exploitabilityGT,omitempty"`
	ExploitabilityGte    *float64  `json:"exploitabilityGTE,omitempty"`
	ExploitabilityLt     *float64  `json:"exploitabilityLT,omitempty"`
	ExploitabilityLte    *float64  `json:"exploitabilityLTE,omitempty"`
	ExploitabilityIsNil  *bool     `json:"exploitabilityIsNil,omitempty"`
	ExploitabilityNotNil *bool     `json:"exploitabilityNotNil,omitempty"`
	// priority field predicates
	Priority             *string  `json:"priority,omitempty"`
	PriorityNeq          *string  `json:"priorityNEQ,omitempty"`
	PriorityIn           []string `json:"priorityIn,omitempty"`
	PriorityNotIn        []string `json:"priorityNotIn,omitempty"`
	PriorityGt           *string  `json:"priorityGT,omitempty"`
	PriorityGte          *string  `json:"priorityGTE,omitempty"`
	PriorityLt           *string  `json:"priorityLT,omitempty"`
	PriorityLte          *string  `json:"priorityLTE,omitempty"`
	PriorityContains     *string  `json:"priorityContains,omitempty"`
	PriorityHasPrefix    *string  `json:"priorityHasPrefix,omitempty"`
	PriorityHasSuffix    *string  `json:"priorityHasSuffix,omitempty"`
	PriorityIsNil        *bool    `json:"priorityIsNil,omitempty"`
	PriorityNotNil       *bool    `json:"priorityNotNil,omitempty"`
	PriorityEqualFold    *string  `json:"priorityEqualFold,omitempty"`
	PriorityContainsFold *string  `json:"priorityContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// summary field predicates
	Summary             *string  `json:"summary,omitempty"`
	SummaryNeq          *string  `json:"summaryNEQ,omitempty"`
	SummaryIn           []string `json:"summaryIn,omitempty"`
	SummaryNotIn        []string `json:"summaryNotIn,omitempty"`
	SummaryGt           *string  `json:"summaryGT,omitempty"`
	SummaryGte          *string  `json:"summaryGTE,omitempty"`
	SummaryLt           *string  `json:"summaryLT,omitempty"`
	SummaryLte          *string  `json:"summaryLTE,omitempty"`
	SummaryContains     *string  `json:"summaryContains,omitempty"`
	SummaryHasPrefix    *string  `json:"summaryHasPrefix,omitempty"`
	SummaryHasSuffix    *string  `json:"summaryHasSuffix,omitempty"`
	SummaryIsNil        *bool    `json:"summaryIsNil,omitempty"`
	SummaryNotNil       *bool    `json:"summaryNotNil,omitempty"`
	SummaryEqualFold    *string  `json:"summaryEqualFold,omitempty"`
	SummaryContainsFold *string  `json:"summaryContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// vector field predicates
	Vector             *string  `json:"vector,omitempty"`
	VectorNeq          *string  `json:"vectorNEQ,omitempty"`
	VectorIn           []string `json:"vectorIn,omitempty"`
	VectorNotIn        []string `json:"vectorNotIn,omitempty"`
	VectorGt           *string  `json:"vectorGT,omitempty"`
	VectorGte          *string  `json:"vectorGTE,omitempty"`
	VectorLt           *string  `json:"vectorLT,omitempty"`
	VectorLte          *string  `json:"vectorLTE,omitempty"`
	VectorContains     *string  `json:"vectorContains,omitempty"`
	VectorHasPrefix    *string  `json:"vectorHasPrefix,omitempty"`
	VectorHasSuffix    *string  `json:"vectorHasSuffix,omitempty"`
	VectorIsNil        *bool    `json:"vectorIsNil,omitempty"`
	VectorNotNil       *bool    `json:"vectorNotNil,omitempty"`
	VectorEqualFold    *string  `json:"vectorEqualFold,omitempty"`
	VectorContainsFold *string  `json:"vectorContainsFold,omitempty"`
	// remediation_sla field predicates
	RemediationSLA       *int64  `json:"remediationSLA,omitempty"`
	RemediationSLANeq    *int64  `json:"remediationSLANEQ,omitempty"`
	RemediationSLAIn     []int64 `json:"remediationSLAIn,omitempty"`
	RemediationSLANotIn  []int64 `json:"remediationSLANotIn,omitempty"`
	RemediationSLAGt     *int64  `json:"remediationSLAGT,omitempty"`
	RemediationSLAGte    *int64  `json:"remediationSLAGTE,omitempty"`
	RemediationSLALt     *int64  `json:"remediationSLALT,omitempty"`
	RemediationSLALte    *int64  `json:"remediationSLALTE,omitempty"`
	RemediationSLAIsNil  *bool   `json:"remediationSLAIsNil,omitempty"`
	RemediationSLANotNil *bool   `json:"remediationSLANotNil,omitempty"`
	// open field predicates
	Open       *bool `json:"open,omitempty"`
	OpenNeq    *bool `json:"openNEQ,omitempty"`
	OpenIsNil  *bool `json:"openIsNil,omitempty"`
	OpenNotNil *bool `json:"openNotNil,omitempty"`
	// blocking field predicates
	Blocking       *bool `json:"blocking,omitempty"`
	BlockingNeq    *bool `json:"blockingNEQ,omitempty"`
	BlockingIsNil  *bool `json:"blockingIsNil,omitempty"`
	BlockingNotNil *bool `json:"blockingNotNil,omitempty"`
	// production field predicates
	Production       *bool `json:"production,omitempty"`
	ProductionNeq    *bool `json:"productionNEQ,omitempty"`
	ProductionIsNil  *bool `json:"productionIsNil,omitempty"`
	ProductionNotNil *bool `json:"productionNotNil,omitempty"`
	// public field predicates
	Public       *bool `json:"public,omitempty"`
	PublicNeq    *bool `json:"publicNEQ,omitempty"`
	PublicIsNil  *bool `json:"publicIsNil,omitempty"`
	PublicNotNil *bool `json:"publicNotNil,omitempty"`
	// validated field predicates
	Validated       *bool `json:"validated,omitempty"`
	ValidatedNeq    *bool `json:"validatedNEQ,omitempty"`
	ValidatedIsNil  *bool `json:"validatedIsNil,omitempty"`
	ValidatedNotNil *bool `json:"validatedNotNil,omitempty"`
	// published_at field predicates
	PublishedAt       *models.DateTime   `json:"publishedAt,omitempty"`
	PublishedAtNeq    *models.DateTime   `json:"publishedAtNEQ,omitempty"`
	PublishedAtIn     []*models.DateTime `json:"publishedAtIn,omitempty"`
	PublishedAtNotIn  []*models.DateTime `json:"publishedAtNotIn,omitempty"`
	PublishedAtGt     *models.DateTime   `json:"publishedAtGT,omitempty"`
	PublishedAtGte    *models.DateTime   `json:"publishedAtGTE,omitempty"`
	PublishedAtLt     *models.DateTime   `json:"publishedAtLT,omitempty"`
	PublishedAtLte    *models.DateTime   `json:"publishedAtLTE,omitempty"`
	PublishedAtIsNil  *bool              `json:"publishedAtIsNil,omitempty"`
	PublishedAtNotNil *bool              `json:"publishedAtNotNil,omitempty"`
	// discovered_at field predicates
	DiscoveredAt       *models.DateTime   `json:"discoveredAt,omitempty"`
	DiscoveredAtNeq    *models.DateTime   `json:"discoveredAtNEQ,omitempty"`
	DiscoveredAtIn     []*models.DateTime `json:"discoveredAtIn,omitempty"`
	DiscoveredAtNotIn  []*models.DateTime `json:"discoveredAtNotIn,omitempty"`
	DiscoveredAtGt     *models.DateTime   `json:"discoveredAtGT,omitempty"`
	DiscoveredAtGte    *models.DateTime   `json:"discoveredAtGTE,omitempty"`
	DiscoveredAtLt     *models.DateTime   `json:"discoveredAtLT,omitempty"`
	DiscoveredAtLte    *models.DateTime   `json:"discoveredAtLTE,omitempty"`
	DiscoveredAtIsNil  *bool              `json:"discoveredAtIsNil,omitempty"`
	DiscoveredAtNotNil *bool              `json:"discoveredAtNotNil,omitempty"`
	// source_updated_at field predicates
	SourceUpdatedAt       *models.DateTime   `json:"sourceUpdatedAt,omitempty"`
	SourceUpdatedAtNeq    *models.DateTime   `json:"sourceUpdatedAtNEQ,omitempty"`
	SourceUpdatedAtIn     []*models.DateTime `json:"sourceUpdatedAtIn,omitempty"`
	SourceUpdatedAtNotIn  []*models.DateTime `json:"sourceUpdatedAtNotIn,omitempty"`
	SourceUpdatedAtGt     *models.DateTime   `json:"sourceUpdatedAtGT,omitempty"`
	SourceUpdatedAtGte    *models.DateTime   `json:"sourceUpdatedAtGTE,omitempty"`
	SourceUpdatedAtLt     *models.DateTime   `json:"sourceUpdatedAtLT,omitempty"`
	SourceUpdatedAtLte    *models.DateTime   `json:"sourceUpdatedAtLTE,omitempty"`
	SourceUpdatedAtIsNil  *bool              `json:"sourceUpdatedAtIsNil,omitempty"`
	SourceUpdatedAtNotNil *bool              `json:"sourceUpdatedAtNotNil,omitempty"`
	// external_uri field predicates
	ExternalURI             *string  `json:"externalURI,omitempty"`
	ExternalURINeq          *string  `json:"externalURINEQ,omitempty"`
	ExternalURIIn           []string `json:"externalURIIn,omitempty"`
	ExternalURINotIn        []string `json:"externalURINotIn,omitempty"`
	ExternalURIGt           *string  `json:"externalURIGT,omitempty"`
	ExternalURIGte          *string  `json:"externalURIGTE,omitempty"`
	ExternalURILt           *string  `json:"externalURILT,omitempty"`
	ExternalURILte          *string  `json:"externalURILTE,omitempty"`
	ExternalURIContains     *string  `json:"externalURIContains,omitempty"`
	ExternalURIHasPrefix    *string  `json:"externalURIHasPrefix,omitempty"`
	ExternalURIHasSuffix    *string  `json:"externalURIHasSuffix,omitempty"`
	ExternalURIIsNil        *bool    `json:"externalURIIsNil,omitempty"`
	ExternalURINotNil       *bool    `json:"externalURINotNil,omitempty"`
	ExternalURIEqualFold    *string  `json:"externalURIEqualFold,omitempty"`
	ExternalURIContainsFold *string  `json:"externalURIContainsFold,omitempty"`
}

// Ordering options for Vulnerability connections
type VulnerabilityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Vulnerabilities.
	Field VulnerabilityOrderField `json:"field"`
}

// Return response for updateVulnerability mutation
type VulnerabilityUpdatePayload struct {
	// Updated vulnerability
	Vulnerability *Vulnerability `json:"vulnerability"`
}

// VulnerabilityWhereInput is used for filtering Vulnerability objects.
// Input was generated by ent.
type VulnerabilityWhereInput struct {
	Not *VulnerabilityWhereInput   `json:"not,omitempty"`
	And []*VulnerabilityWhereInput `json:"and,omitempty"`
	Or  []*VulnerabilityWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// external_owner_id field predicates
	ExternalOwnerID             *string  `json:"externalOwnerID,omitempty"`
	ExternalOwnerIdneq          *string  `json:"externalOwnerIDNEQ,omitempty"`
	ExternalOwnerIDIn           []string `json:"externalOwnerIDIn,omitempty"`
	ExternalOwnerIDNotIn        []string `json:"externalOwnerIDNotIn,omitempty"`
	ExternalOwnerIdgt           *string  `json:"externalOwnerIDGT,omitempty"`
	ExternalOwnerIdgte          *string  `json:"externalOwnerIDGTE,omitempty"`
	ExternalOwnerIdlt           *string  `json:"externalOwnerIDLT,omitempty"`
	ExternalOwnerIdlte          *string  `json:"externalOwnerIDLTE,omitempty"`
	ExternalOwnerIDContains     *string  `json:"externalOwnerIDContains,omitempty"`
	ExternalOwnerIDHasPrefix    *string  `json:"externalOwnerIDHasPrefix,omitempty"`
	ExternalOwnerIDHasSuffix    *string  `json:"externalOwnerIDHasSuffix,omitempty"`
	ExternalOwnerIDIsNil        *bool    `json:"externalOwnerIDIsNil,omitempty"`
	ExternalOwnerIDNotNil       *bool    `json:"externalOwnerIDNotNil,omitempty"`
	ExternalOwnerIDEqualFold    *string  `json:"externalOwnerIDEqualFold,omitempty"`
	ExternalOwnerIDContainsFold *string  `json:"externalOwnerIDContainsFold,omitempty"`
	// external_id field predicates
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIdneq          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIdgt           *string  `json:"externalIDGT,omitempty"`
	ExternalIdgte          *string  `json:"externalIDGTE,omitempty"`
	ExternalIdlt           *string  `json:"externalIDLT,omitempty"`
	ExternalIdlte          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`
	// cve_id field predicates
	CveID             *string  `json:"cveID,omitempty"`
	CveIdneq          *string  `json:"cveIDNEQ,omitempty"`
	CveIDIn           []string `json:"cveIDIn,omitempty"`
	CveIDNotIn        []string `json:"cveIDNotIn,omitempty"`
	CveIdgt           *string  `json:"cveIDGT,omitempty"`
	CveIdgte          *string  `json:"cveIDGTE,omitempty"`
	CveIdlt           *string  `json:"cveIDLT,omitempty"`
	CveIdlte          *string  `json:"cveIDLTE,omitempty"`
	CveIDContains     *string  `json:"cveIDContains,omitempty"`
	CveIDHasPrefix    *string  `json:"cveIDHasPrefix,omitempty"`
	CveIDHasSuffix    *string  `json:"cveIDHasSuffix,omitempty"`
	CveIDIsNil        *bool    `json:"cveIDIsNil,omitempty"`
	CveIDNotNil       *bool    `json:"cveIDNotNil,omitempty"`
	CveIDEqualFold    *string  `json:"cveIDEqualFold,omitempty"`
	CveIDContainsFold *string  `json:"cveIDContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// severity field predicates
	Severity             *string  `json:"severity,omitempty"`
	SeverityNeq          *string  `json:"severityNEQ,omitempty"`
	SeverityIn           []string `json:"severityIn,omitempty"`
	SeverityNotIn        []string `json:"severityNotIn,omitempty"`
	SeverityGt           *string  `json:"severityGT,omitempty"`
	SeverityGte          *string  `json:"severityGTE,omitempty"`
	SeverityLt           *string  `json:"severityLT,omitempty"`
	SeverityLte          *string  `json:"severityLTE,omitempty"`
	SeverityContains     *string  `json:"severityContains,omitempty"`
	SeverityHasPrefix    *string  `json:"severityHasPrefix,omitempty"`
	SeverityHasSuffix    *string  `json:"severityHasSuffix,omitempty"`
	SeverityIsNil        *bool    `json:"severityIsNil,omitempty"`
	SeverityNotNil       *bool    `json:"severityNotNil,omitempty"`
	SeverityEqualFold    *string  `json:"severityEqualFold,omitempty"`
	SeverityContainsFold *string  `json:"severityContainsFold,omitempty"`
	// score field predicates
	Score       *float64  `json:"score,omitempty"`
	ScoreNeq    *float64  `json:"scoreNEQ,omitempty"`
	ScoreIn     []float64 `json:"scoreIn,omitempty"`
	ScoreNotIn  []float64 `json:"scoreNotIn,omitempty"`
	ScoreGt     *float64  `json:"scoreGT,omitempty"`
	ScoreGte    *float64  `json:"scoreGTE,omitempty"`
	ScoreLt     *float64  `json:"scoreLT,omitempty"`
	ScoreLte    *float64  `json:"scoreLTE,omitempty"`
	ScoreIsNil  *bool     `json:"scoreIsNil,omitempty"`
	ScoreNotNil *bool     `json:"scoreNotNil,omitempty"`
	// impact field predicates
	Impact       *float64  `json:"impact,omitempty"`
	ImpactNeq    *float64  `json:"impactNEQ,omitempty"`
	ImpactIn     []float64 `json:"impactIn,omitempty"`
	ImpactNotIn  []float64 `json:"impactNotIn,omitempty"`
	ImpactGt     *float64  `json:"impactGT,omitempty"`
	ImpactGte    *float64  `json:"impactGTE,omitempty"`
	ImpactLt     *float64  `json:"impactLT,omitempty"`
	ImpactLte    *float64  `json:"impactLTE,omitempty"`
	ImpactIsNil  *bool     `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool     `json:"impactNotNil,omitempty"`
	// exploitability field predicates
	Exploitability       *float64  `json:"exploitability,omitempty"`
	ExploitabilityNeq    *float64  `json:"exploitabilityNEQ,omitempty"`
	ExploitabilityIn     []float64 `json:"exploitabilityIn,omitempty"`
	ExploitabilityNotIn  []float64 `json:"exploitabilityNotIn,omitempty"`
	ExploitabilityGt     *float64  `json:"exploitabilityGT,omitempty"`
	ExploitabilityGte    *float64  `json:"exploitabilityGTE,omitempty"`
	ExploitabilityLt     *float64  `json:"exploitabilityLT,omitempty"`
	ExploitabilityLte    *float64  `json:"exploitabilityLTE,omitempty"`
	ExploitabilityIsNil  *bool     `json:"exploitabilityIsNil,omitempty"`
	ExploitabilityNotNil *bool     `json:"exploitabilityNotNil,omitempty"`
	// priority field predicates
	Priority             *string  `json:"priority,omitempty"`
	PriorityNeq          *string  `json:"priorityNEQ,omitempty"`
	PriorityIn           []string `json:"priorityIn,omitempty"`
	PriorityNotIn        []string `json:"priorityNotIn,omitempty"`
	PriorityGt           *string  `json:"priorityGT,omitempty"`
	PriorityGte          *string  `json:"priorityGTE,omitempty"`
	PriorityLt           *string  `json:"priorityLT,omitempty"`
	PriorityLte          *string  `json:"priorityLTE,omitempty"`
	PriorityContains     *string  `json:"priorityContains,omitempty"`
	PriorityHasPrefix    *string  `json:"priorityHasPrefix,omitempty"`
	PriorityHasSuffix    *string  `json:"priorityHasSuffix,omitempty"`
	PriorityIsNil        *bool    `json:"priorityIsNil,omitempty"`
	PriorityNotNil       *bool    `json:"priorityNotNil,omitempty"`
	PriorityEqualFold    *string  `json:"priorityEqualFold,omitempty"`
	PriorityContainsFold *string  `json:"priorityContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// summary field predicates
	Summary             *string  `json:"summary,omitempty"`
	SummaryNeq          *string  `json:"summaryNEQ,omitempty"`
	SummaryIn           []string `json:"summaryIn,omitempty"`
	SummaryNotIn        []string `json:"summaryNotIn,omitempty"`
	SummaryGt           *string  `json:"summaryGT,omitempty"`
	SummaryGte          *string  `json:"summaryGTE,omitempty"`
	SummaryLt           *string  `json:"summaryLT,omitempty"`
	SummaryLte          *string  `json:"summaryLTE,omitempty"`
	SummaryContains     *string  `json:"summaryContains,omitempty"`
	SummaryHasPrefix    *string  `json:"summaryHasPrefix,omitempty"`
	SummaryHasSuffix    *string  `json:"summaryHasSuffix,omitempty"`
	SummaryIsNil        *bool    `json:"summaryIsNil,omitempty"`
	SummaryNotNil       *bool    `json:"summaryNotNil,omitempty"`
	SummaryEqualFold    *string  `json:"summaryEqualFold,omitempty"`
	SummaryContainsFold *string  `json:"summaryContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// vector field predicates
	Vector             *string  `json:"vector,omitempty"`
	VectorNeq          *string  `json:"vectorNEQ,omitempty"`
	VectorIn           []string `json:"vectorIn,omitempty"`
	VectorNotIn        []string `json:"vectorNotIn,omitempty"`
	VectorGt           *string  `json:"vectorGT,omitempty"`
	VectorGte          *string  `json:"vectorGTE,omitempty"`
	VectorLt           *string  `json:"vectorLT,omitempty"`
	VectorLte          *string  `json:"vectorLTE,omitempty"`
	VectorContains     *string  `json:"vectorContains,omitempty"`
	VectorHasPrefix    *string  `json:"vectorHasPrefix,omitempty"`
	VectorHasSuffix    *string  `json:"vectorHasSuffix,omitempty"`
	VectorIsNil        *bool    `json:"vectorIsNil,omitempty"`
	VectorNotNil       *bool    `json:"vectorNotNil,omitempty"`
	VectorEqualFold    *string  `json:"vectorEqualFold,omitempty"`
	VectorContainsFold *string  `json:"vectorContainsFold,omitempty"`
	// remediation_sla field predicates
	RemediationSLA       *int64  `json:"remediationSLA,omitempty"`
	RemediationSLANeq    *int64  `json:"remediationSLANEQ,omitempty"`
	RemediationSLAIn     []int64 `json:"remediationSLAIn,omitempty"`
	RemediationSLANotIn  []int64 `json:"remediationSLANotIn,omitempty"`
	RemediationSLAGt     *int64  `json:"remediationSLAGT,omitempty"`
	RemediationSLAGte    *int64  `json:"remediationSLAGTE,omitempty"`
	RemediationSLALt     *int64  `json:"remediationSLALT,omitempty"`
	RemediationSLALte    *int64  `json:"remediationSLALTE,omitempty"`
	RemediationSLAIsNil  *bool   `json:"remediationSLAIsNil,omitempty"`
	RemediationSLANotNil *bool   `json:"remediationSLANotNil,omitempty"`
	// open field predicates
	Open       *bool `json:"open,omitempty"`
	OpenNeq    *bool `json:"openNEQ,omitempty"`
	OpenIsNil  *bool `json:"openIsNil,omitempty"`
	OpenNotNil *bool `json:"openNotNil,omitempty"`
	// blocking field predicates
	Blocking       *bool `json:"blocking,omitempty"`
	BlockingNeq    *bool `json:"blockingNEQ,omitempty"`
	BlockingIsNil  *bool `json:"blockingIsNil,omitempty"`
	BlockingNotNil *bool `json:"blockingNotNil,omitempty"`
	// production field predicates
	Production       *bool `json:"production,omitempty"`
	ProductionNeq    *bool `json:"productionNEQ,omitempty"`
	ProductionIsNil  *bool `json:"productionIsNil,omitempty"`
	ProductionNotNil *bool `json:"productionNotNil,omitempty"`
	// public field predicates
	Public       *bool `json:"public,omitempty"`
	PublicNeq    *bool `json:"publicNEQ,omitempty"`
	PublicIsNil  *bool `json:"publicIsNil,omitempty"`
	PublicNotNil *bool `json:"publicNotNil,omitempty"`
	// validated field predicates
	Validated       *bool `json:"validated,omitempty"`
	ValidatedNeq    *bool `json:"validatedNEQ,omitempty"`
	ValidatedIsNil  *bool `json:"validatedIsNil,omitempty"`
	ValidatedNotNil *bool `json:"validatedNotNil,omitempty"`
	// published_at field predicates
	PublishedAt       *models.DateTime   `json:"publishedAt,omitempty"`
	PublishedAtNeq    *models.DateTime   `json:"publishedAtNEQ,omitempty"`
	PublishedAtIn     []*models.DateTime `json:"publishedAtIn,omitempty"`
	PublishedAtNotIn  []*models.DateTime `json:"publishedAtNotIn,omitempty"`
	PublishedAtGt     *models.DateTime   `json:"publishedAtGT,omitempty"`
	PublishedAtGte    *models.DateTime   `json:"publishedAtGTE,omitempty"`
	PublishedAtLt     *models.DateTime   `json:"publishedAtLT,omitempty"`
	PublishedAtLte    *models.DateTime   `json:"publishedAtLTE,omitempty"`
	PublishedAtIsNil  *bool              `json:"publishedAtIsNil,omitempty"`
	PublishedAtNotNil *bool              `json:"publishedAtNotNil,omitempty"`
	// discovered_at field predicates
	DiscoveredAt       *models.DateTime   `json:"discoveredAt,omitempty"`
	DiscoveredAtNeq    *models.DateTime   `json:"discoveredAtNEQ,omitempty"`
	DiscoveredAtIn     []*models.DateTime `json:"discoveredAtIn,omitempty"`
	DiscoveredAtNotIn  []*models.DateTime `json:"discoveredAtNotIn,omitempty"`
	DiscoveredAtGt     *models.DateTime   `json:"discoveredAtGT,omitempty"`
	DiscoveredAtGte    *models.DateTime   `json:"discoveredAtGTE,omitempty"`
	DiscoveredAtLt     *models.DateTime   `json:"discoveredAtLT,omitempty"`
	DiscoveredAtLte    *models.DateTime   `json:"discoveredAtLTE,omitempty"`
	DiscoveredAtIsNil  *bool              `json:"discoveredAtIsNil,omitempty"`
	DiscoveredAtNotNil *bool              `json:"discoveredAtNotNil,omitempty"`
	// source_updated_at field predicates
	SourceUpdatedAt       *models.DateTime   `json:"sourceUpdatedAt,omitempty"`
	SourceUpdatedAtNeq    *models.DateTime   `json:"sourceUpdatedAtNEQ,omitempty"`
	SourceUpdatedAtIn     []*models.DateTime `json:"sourceUpdatedAtIn,omitempty"`
	SourceUpdatedAtNotIn  []*models.DateTime `json:"sourceUpdatedAtNotIn,omitempty"`
	SourceUpdatedAtGt     *models.DateTime   `json:"sourceUpdatedAtGT,omitempty"`
	SourceUpdatedAtGte    *models.DateTime   `json:"sourceUpdatedAtGTE,omitempty"`
	SourceUpdatedAtLt     *models.DateTime   `json:"sourceUpdatedAtLT,omitempty"`
	SourceUpdatedAtLte    *models.DateTime   `json:"sourceUpdatedAtLTE,omitempty"`
	SourceUpdatedAtIsNil  *bool              `json:"sourceUpdatedAtIsNil,omitempty"`
	SourceUpdatedAtNotNil *bool              `json:"sourceUpdatedAtNotNil,omitempty"`
	// external_uri field predicates
	ExternalURI             *string  `json:"externalURI,omitempty"`
	ExternalURINeq          *string  `json:"externalURINEQ,omitempty"`
	ExternalURIIn           []string `json:"externalURIIn,omitempty"`
	ExternalURINotIn        []string `json:"externalURINotIn,omitempty"`
	ExternalURIGt           *string  `json:"externalURIGT,omitempty"`
	ExternalURIGte          *string  `json:"externalURIGTE,omitempty"`
	ExternalURILt           *string  `json:"externalURILT,omitempty"`
	ExternalURILte          *string  `json:"externalURILTE,omitempty"`
	ExternalURIContains     *string  `json:"externalURIContains,omitempty"`
	ExternalURIHasPrefix    *string  `json:"externalURIHasPrefix,omitempty"`
	ExternalURIHasSuffix    *string  `json:"externalURIHasSuffix,omitempty"`
	ExternalURIIsNil        *bool    `json:"externalURIIsNil,omitempty"`
	ExternalURINotNil       *bool    `json:"externalURINotNil,omitempty"`
	ExternalURIEqualFold    *string  `json:"externalURIEqualFold,omitempty"`
	ExternalURIContainsFold *string  `json:"externalURIContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// findings edge predicates
	HasFindings     *bool                `json:"hasFindings,omitempty"`
	HasFindingsWith []*FindingWhereInput `json:"hasFindingsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// assets edge predicates
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// scans edge predicates
	HasScans     *bool             `json:"hasScans,omitempty"`
	HasScansWith []*ScanWhereInput `json:"hasScansWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// remediations edge predicates
	HasRemediations     *bool                    `json:"hasRemediations,omitempty"`
	HasRemediationsWith []*RemediationWhereInput `json:"hasRemediationsWith,omitempty"`
	// reviews edge predicates
	HasReviews     *bool               `json:"hasReviews,omitempty"`
	HasReviewsWith []*ReviewWhereInput `json:"hasReviewsWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Webauthn struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The AAGUID of the authenticator; AAGUID is defined as an array containing the globally unique identifier of the authenticator model being sought
	Aaguid models.AAGUID `json:"aaguid"`
	// Flag backup eligible indicates the credential is able to be backed up and/or sync'd between devices. This should NEVER change
	BackupEligible bool `json:"backupEligible"`
	// Flag backup state indicates the credential has been backed up and/or sync'd
	BackupState bool  `json:"backupState"`
	Owner       *User `json:"owner"`
}

func (Webauthn) IsNode() {}

// A connection to a list of items.
type WebauthnConnection struct {
	// A list of edges.
	Edges []*WebauthnEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for deleteWebauthn mutation
type WebauthnDeletePayload struct {
	// Deleted webauthn ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WebauthnEdge struct {
	// The item at the end of the edge.
	Node *Webauthn `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Webauthn connections
type WebauthnOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Webauthns.
	Field WebauthnOrderField `json:"field"`
}

// WebauthnWhereInput is used for filtering Webauthn objects.
// Input was generated by ent.
type WebauthnWhereInput struct {
	Not *WebauthnWhereInput   `json:"not,omitempty"`
	And []*WebauthnWhereInput `json:"and,omitempty"`
	Or  []*WebauthnWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type WorkflowAssignment struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// ID of the workflow instance this assignment belongs to
	WorkflowInstanceID string `json:"workflowInstanceID"`
	// Unique key for the assignment within the workflow instance
	AssignmentKey string `json:"assignmentKey"`
	// Role assigned to the target, e.g. APPROVER
	Role string `json:"role"`
	// Optional label for the assignment
	Label *string `json:"label,omitempty"`
	// Whether this assignment is required for workflow progression
	Required bool `json:"required"`
	// Current status of the assignment
	Status enums.WorkflowAssignmentStatus `json:"status"`
	// Optional metadata for the assignment
	Metadata map[string]any `json:"metadata,omitempty"`
	// Timestamp when the assignment was decided
	DecidedAt *time.Time `json:"decidedAt,omitempty"`
	// User who made the decision
	ActorUserID *string `json:"actorUserID,omitempty"`
	// Group that acted on the decision (if applicable)
	ActorGroupID *string `json:"actorGroupID,omitempty"`
	// Optional notes about the assignment
	Notes *string       `json:"notes,omitempty"`
	Owner *Organization `json:"owner,omitempty"`
	// Instance this assignment belongs to
	WorkflowInstance          *WorkflowInstance                   `json:"workflowInstance"`
	WorkflowAssignmentTargets *WorkflowAssignmentTargetConnection `json:"workflowAssignmentTargets"`
	// User who acted on this assignment
	User *User `json:"user,omitempty"`
	// Group that acted on this assignment
	Group *Group `json:"group,omitempty"`
}

func (WorkflowAssignment) IsNode() {}

// Return response for createBulkWorkflowAssignment mutation
type WorkflowAssignmentBulkCreatePayload struct {
	// Created workflowAssignments
	WorkflowAssignments []*WorkflowAssignment `json:"workflowAssignments,omitempty"`
}

// A connection to a list of items.
type WorkflowAssignmentConnection struct {
	// A list of edges.
	Edges []*WorkflowAssignmentEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createWorkflowAssignment mutation
type WorkflowAssignmentCreatePayload struct {
	// Created workflowAssignment
	WorkflowAssignment *WorkflowAssignment `json:"workflowAssignment"`
}

// Return response for deleteWorkflowAssignment mutation
type WorkflowAssignmentDeletePayload struct {
	// Deleted workflowAssignment ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WorkflowAssignmentEdge struct {
	// The item at the end of the edge.
	Node *WorkflowAssignment `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type WorkflowAssignmentHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// ID of the workflow instance this assignment belongs to
	WorkflowInstanceID string `json:"workflowInstanceID"`
	// Unique key for the assignment within the workflow instance
	AssignmentKey string `json:"assignmentKey"`
	// Role assigned to the target, e.g. APPROVER
	Role string `json:"role"`
	// Optional label for the assignment
	Label *string `json:"label,omitempty"`
	// Whether this assignment is required for workflow progression
	Required bool `json:"required"`
	// Current status of the assignment
	Status enums.WorkflowAssignmentStatus `json:"status"`
	// Optional metadata for the assignment
	Metadata map[string]any `json:"metadata,omitempty"`
	// Timestamp when the assignment was decided
	DecidedAt *time.Time `json:"decidedAt,omitempty"`
	// User who made the decision
	ActorUserID *string `json:"actorUserID,omitempty"`
	// Group that acted on the decision (if applicable)
	ActorGroupID *string `json:"actorGroupID,omitempty"`
	// Optional notes about the assignment
	Notes *string `json:"notes,omitempty"`
}

func (WorkflowAssignmentHistory) IsNode() {}

// A connection to a list of items.
type WorkflowAssignmentHistoryConnection struct {
	// A list of edges.
	Edges []*WorkflowAssignmentHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type WorkflowAssignmentHistoryEdge struct {
	// The item at the end of the edge.
	Node *WorkflowAssignmentHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for WorkflowAssignmentHistory connections
type WorkflowAssignmentHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowAssignmentHistories.
	Field WorkflowAssignmentHistoryOrderField `json:"field"`
}

// WorkflowAssignmentHistoryWhereInput is used for filtering WorkflowAssignmentHistory objects.
// Input was generated by ent.
type WorkflowAssignmentHistoryWhereInput struct {
	Not *WorkflowAssignmentHistoryWhereInput   `json:"not,omitempty"`
	And []*WorkflowAssignmentHistoryWhereInput `json:"and,omitempty"`
	Or  []*WorkflowAssignmentHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_instance_id field predicates
	WorkflowInstanceID             *string  `json:"workflowInstanceID,omitempty"`
	WorkflowInstanceIdneq          *string  `json:"workflowInstanceIDNEQ,omitempty"`
	WorkflowInstanceIDIn           []string `json:"workflowInstanceIDIn,omitempty"`
	WorkflowInstanceIDNotIn        []string `json:"workflowInstanceIDNotIn,omitempty"`
	WorkflowInstanceIdgt           *string  `json:"workflowInstanceIDGT,omitempty"`
	WorkflowInstanceIdgte          *string  `json:"workflowInstanceIDGTE,omitempty"`
	WorkflowInstanceIdlt           *string  `json:"workflowInstanceIDLT,omitempty"`
	WorkflowInstanceIdlte          *string  `json:"workflowInstanceIDLTE,omitempty"`
	WorkflowInstanceIDContains     *string  `json:"workflowInstanceIDContains,omitempty"`
	WorkflowInstanceIDHasPrefix    *string  `json:"workflowInstanceIDHasPrefix,omitempty"`
	WorkflowInstanceIDHasSuffix    *string  `json:"workflowInstanceIDHasSuffix,omitempty"`
	WorkflowInstanceIDEqualFold    *string  `json:"workflowInstanceIDEqualFold,omitempty"`
	WorkflowInstanceIDContainsFold *string  `json:"workflowInstanceIDContainsFold,omitempty"`
	// assignment_key field predicates
	AssignmentKey             *string  `json:"assignmentKey,omitempty"`
	AssignmentKeyNeq          *string  `json:"assignmentKeyNEQ,omitempty"`
	AssignmentKeyIn           []string `json:"assignmentKeyIn,omitempty"`
	AssignmentKeyNotIn        []string `json:"assignmentKeyNotIn,omitempty"`
	AssignmentKeyGt           *string  `json:"assignmentKeyGT,omitempty"`
	AssignmentKeyGte          *string  `json:"assignmentKeyGTE,omitempty"`
	AssignmentKeyLt           *string  `json:"assignmentKeyLT,omitempty"`
	AssignmentKeyLte          *string  `json:"assignmentKeyLTE,omitempty"`
	AssignmentKeyContains     *string  `json:"assignmentKeyContains,omitempty"`
	AssignmentKeyHasPrefix    *string  `json:"assignmentKeyHasPrefix,omitempty"`
	AssignmentKeyHasSuffix    *string  `json:"assignmentKeyHasSuffix,omitempty"`
	AssignmentKeyEqualFold    *string  `json:"assignmentKeyEqualFold,omitempty"`
	AssignmentKeyContainsFold *string  `json:"assignmentKeyContainsFold,omitempty"`
	// role field predicates
	Role             *string  `json:"role,omitempty"`
	RoleNeq          *string  `json:"roleNEQ,omitempty"`
	RoleIn           []string `json:"roleIn,omitempty"`
	RoleNotIn        []string `json:"roleNotIn,omitempty"`
	RoleGt           *string  `json:"roleGT,omitempty"`
	RoleGte          *string  `json:"roleGTE,omitempty"`
	RoleLt           *string  `json:"roleLT,omitempty"`
	RoleLte          *string  `json:"roleLTE,omitempty"`
	RoleContains     *string  `json:"roleContains,omitempty"`
	RoleHasPrefix    *string  `json:"roleHasPrefix,omitempty"`
	RoleHasSuffix    *string  `json:"roleHasSuffix,omitempty"`
	RoleEqualFold    *string  `json:"roleEqualFold,omitempty"`
	RoleContainsFold *string  `json:"roleContainsFold,omitempty"`
	// label field predicates
	Label             *string  `json:"label,omitempty"`
	LabelNeq          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGt           *string  `json:"labelGT,omitempty"`
	LabelGte          *string  `json:"labelGTE,omitempty"`
	LabelLt           *string  `json:"labelLT,omitempty"`
	LabelLte          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelIsNil        *bool    `json:"labelIsNil,omitempty"`
	LabelNotNil       *bool    `json:"labelNotNil,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`
	// required field predicates
	Required    *bool `json:"required,omitempty"`
	RequiredNeq *bool `json:"requiredNEQ,omitempty"`
	// status field predicates
	Status      *enums.WorkflowAssignmentStatus  `json:"status,omitempty"`
	StatusNeq   *enums.WorkflowAssignmentStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.WorkflowAssignmentStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.WorkflowAssignmentStatus `json:"statusNotIn,omitempty"`
	// decided_at field predicates
	DecidedAt       *time.Time   `json:"decidedAt,omitempty"`
	DecidedAtNeq    *time.Time   `json:"decidedAtNEQ,omitempty"`
	DecidedAtIn     []*time.Time `json:"decidedAtIn,omitempty"`
	DecidedAtNotIn  []*time.Time `json:"decidedAtNotIn,omitempty"`
	DecidedAtGt     *time.Time   `json:"decidedAtGT,omitempty"`
	DecidedAtGte    *time.Time   `json:"decidedAtGTE,omitempty"`
	DecidedAtLt     *time.Time   `json:"decidedAtLT,omitempty"`
	DecidedAtLte    *time.Time   `json:"decidedAtLTE,omitempty"`
	DecidedAtIsNil  *bool        `json:"decidedAtIsNil,omitempty"`
	DecidedAtNotNil *bool        `json:"decidedAtNotNil,omitempty"`
	// actor_user_id field predicates
	ActorUserID             *string  `json:"actorUserID,omitempty"`
	ActorUserIdneq          *string  `json:"actorUserIDNEQ,omitempty"`
	ActorUserIDIn           []string `json:"actorUserIDIn,omitempty"`
	ActorUserIDNotIn        []string `json:"actorUserIDNotIn,omitempty"`
	ActorUserIdgt           *string  `json:"actorUserIDGT,omitempty"`
	ActorUserIdgte          *string  `json:"actorUserIDGTE,omitempty"`
	ActorUserIdlt           *string  `json:"actorUserIDLT,omitempty"`
	ActorUserIdlte          *string  `json:"actorUserIDLTE,omitempty"`
	ActorUserIDContains     *string  `json:"actorUserIDContains,omitempty"`
	ActorUserIDHasPrefix    *string  `json:"actorUserIDHasPrefix,omitempty"`
	ActorUserIDHasSuffix    *string  `json:"actorUserIDHasSuffix,omitempty"`
	ActorUserIDIsNil        *bool    `json:"actorUserIDIsNil,omitempty"`
	ActorUserIDNotNil       *bool    `json:"actorUserIDNotNil,omitempty"`
	ActorUserIDEqualFold    *string  `json:"actorUserIDEqualFold,omitempty"`
	ActorUserIDContainsFold *string  `json:"actorUserIDContainsFold,omitempty"`
	// actor_group_id field predicates
	ActorGroupID             *string  `json:"actorGroupID,omitempty"`
	ActorGroupIdneq          *string  `json:"actorGroupIDNEQ,omitempty"`
	ActorGroupIDIn           []string `json:"actorGroupIDIn,omitempty"`
	ActorGroupIDNotIn        []string `json:"actorGroupIDNotIn,omitempty"`
	ActorGroupIdgt           *string  `json:"actorGroupIDGT,omitempty"`
	ActorGroupIdgte          *string  `json:"actorGroupIDGTE,omitempty"`
	ActorGroupIdlt           *string  `json:"actorGroupIDLT,omitempty"`
	ActorGroupIdlte          *string  `json:"actorGroupIDLTE,omitempty"`
	ActorGroupIDContains     *string  `json:"actorGroupIDContains,omitempty"`
	ActorGroupIDHasPrefix    *string  `json:"actorGroupIDHasPrefix,omitempty"`
	ActorGroupIDHasSuffix    *string  `json:"actorGroupIDHasSuffix,omitempty"`
	ActorGroupIDIsNil        *bool    `json:"actorGroupIDIsNil,omitempty"`
	ActorGroupIDNotNil       *bool    `json:"actorGroupIDNotNil,omitempty"`
	ActorGroupIDEqualFold    *string  `json:"actorGroupIDEqualFold,omitempty"`
	ActorGroupIDContainsFold *string  `json:"actorGroupIDContainsFold,omitempty"`
	// notes field predicates
	Notes             *string  `json:"notes,omitempty"`
	NotesNeq          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGt           *string  `json:"notesGT,omitempty"`
	NotesGte          *string  `json:"notesGTE,omitempty"`
	NotesLt           *string  `json:"notesLT,omitempty"`
	NotesLte          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        *bool    `json:"notesIsNil,omitempty"`
	NotesNotNil       *bool    `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`
}

// Ordering options for WorkflowAssignment connections
type WorkflowAssignmentOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowAssignments.
	Field WorkflowAssignmentOrderField `json:"field"`
}

type WorkflowAssignmentTarget struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// Assignment this target belongs to
	WorkflowAssignmentID string `json:"workflowAssignmentID"`
	// Type of the target (USER, GROUP, ROLE, RESOLVER)
	TargetType enums.WorkflowTargetType `json:"targetType"`
	// User target when target_type is USER
	TargetUserID *string `json:"targetUserID,omitempty"`
	// Group target when target_type is GROUP
	TargetGroupID *string `json:"targetGroupID,omitempty"`
	// Resolver key when target_type is RESOLVER
	ResolverKey *string       `json:"resolverKey,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	// Assignment this target belongs to
	WorkflowAssignment *WorkflowAssignment `json:"workflowAssignment"`
	// User target when target_type is USER
	User *User `json:"user,omitempty"`
	// Group target when target_type is GROUP
	Group *Group `json:"group,omitempty"`
}

func (WorkflowAssignmentTarget) IsNode() {}

// Return response for createBulkWorkflowAssignmentTarget mutation
type WorkflowAssignmentTargetBulkCreatePayload struct {
	// Created workflowAssignmentTargets
	WorkflowAssignmentTargets []*WorkflowAssignmentTarget `json:"workflowAssignmentTargets,omitempty"`
}

// A connection to a list of items.
type WorkflowAssignmentTargetConnection struct {
	// A list of edges.
	Edges []*WorkflowAssignmentTargetEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createWorkflowAssignmentTarget mutation
type WorkflowAssignmentTargetCreatePayload struct {
	// Created workflowAssignmentTarget
	WorkflowAssignmentTarget *WorkflowAssignmentTarget `json:"workflowAssignmentTarget"`
}

// Return response for deleteWorkflowAssignmentTarget mutation
type WorkflowAssignmentTargetDeletePayload struct {
	// Deleted workflowAssignmentTarget ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WorkflowAssignmentTargetEdge struct {
	// The item at the end of the edge.
	Node *WorkflowAssignmentTarget `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type WorkflowAssignmentTargetHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// Assignment this target belongs to
	WorkflowAssignmentID string `json:"workflowAssignmentID"`
	// Type of the target (USER, GROUP, ROLE, RESOLVER)
	TargetType enums.WorkflowTargetType `json:"targetType"`
	// User target when target_type is USER
	TargetUserID *string `json:"targetUserID,omitempty"`
	// Group target when target_type is GROUP
	TargetGroupID *string `json:"targetGroupID,omitempty"`
	// Resolver key when target_type is RESOLVER
	ResolverKey *string `json:"resolverKey,omitempty"`
}

func (WorkflowAssignmentTargetHistory) IsNode() {}

// A connection to a list of items.
type WorkflowAssignmentTargetHistoryConnection struct {
	// A list of edges.
	Edges []*WorkflowAssignmentTargetHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type WorkflowAssignmentTargetHistoryEdge struct {
	// The item at the end of the edge.
	Node *WorkflowAssignmentTargetHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for WorkflowAssignmentTargetHistory connections
type WorkflowAssignmentTargetHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowAssignmentTargetHistories.
	Field WorkflowAssignmentTargetHistoryOrderField `json:"field"`
}

// WorkflowAssignmentTargetHistoryWhereInput is used for filtering WorkflowAssignmentTargetHistory objects.
// Input was generated by ent.
type WorkflowAssignmentTargetHistoryWhereInput struct {
	Not *WorkflowAssignmentTargetHistoryWhereInput   `json:"not,omitempty"`
	And []*WorkflowAssignmentTargetHistoryWhereInput `json:"and,omitempty"`
	Or  []*WorkflowAssignmentTargetHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_assignment_id field predicates
	WorkflowAssignmentID             *string  `json:"workflowAssignmentID,omitempty"`
	WorkflowAssignmentIdneq          *string  `json:"workflowAssignmentIDNEQ,omitempty"`
	WorkflowAssignmentIDIn           []string `json:"workflowAssignmentIDIn,omitempty"`
	WorkflowAssignmentIDNotIn        []string `json:"workflowAssignmentIDNotIn,omitempty"`
	WorkflowAssignmentIdgt           *string  `json:"workflowAssignmentIDGT,omitempty"`
	WorkflowAssignmentIdgte          *string  `json:"workflowAssignmentIDGTE,omitempty"`
	WorkflowAssignmentIdlt           *string  `json:"workflowAssignmentIDLT,omitempty"`
	WorkflowAssignmentIdlte          *string  `json:"workflowAssignmentIDLTE,omitempty"`
	WorkflowAssignmentIDContains     *string  `json:"workflowAssignmentIDContains,omitempty"`
	WorkflowAssignmentIDHasPrefix    *string  `json:"workflowAssignmentIDHasPrefix,omitempty"`
	WorkflowAssignmentIDHasSuffix    *string  `json:"workflowAssignmentIDHasSuffix,omitempty"`
	WorkflowAssignmentIDEqualFold    *string  `json:"workflowAssignmentIDEqualFold,omitempty"`
	WorkflowAssignmentIDContainsFold *string  `json:"workflowAssignmentIDContainsFold,omitempty"`
	// target_type field predicates
	TargetType      *enums.WorkflowTargetType  `json:"targetType,omitempty"`
	TargetTypeNeq   *enums.WorkflowTargetType  `json:"targetTypeNEQ,omitempty"`
	TargetTypeIn    []enums.WorkflowTargetType `json:"targetTypeIn,omitempty"`
	TargetTypeNotIn []enums.WorkflowTargetType `json:"targetTypeNotIn,omitempty"`
	// target_user_id field predicates
	TargetUserID             *string  `json:"targetUserID,omitempty"`
	TargetUserIdneq          *string  `json:"targetUserIDNEQ,omitempty"`
	TargetUserIDIn           []string `json:"targetUserIDIn,omitempty"`
	TargetUserIDNotIn        []string `json:"targetUserIDNotIn,omitempty"`
	TargetUserIdgt           *string  `json:"targetUserIDGT,omitempty"`
	TargetUserIdgte          *string  `json:"targetUserIDGTE,omitempty"`
	TargetUserIdlt           *string  `json:"targetUserIDLT,omitempty"`
	TargetUserIdlte          *string  `json:"targetUserIDLTE,omitempty"`
	TargetUserIDContains     *string  `json:"targetUserIDContains,omitempty"`
	TargetUserIDHasPrefix    *string  `json:"targetUserIDHasPrefix,omitempty"`
	TargetUserIDHasSuffix    *string  `json:"targetUserIDHasSuffix,omitempty"`
	TargetUserIDIsNil        *bool    `json:"targetUserIDIsNil,omitempty"`
	TargetUserIDNotNil       *bool    `json:"targetUserIDNotNil,omitempty"`
	TargetUserIDEqualFold    *string  `json:"targetUserIDEqualFold,omitempty"`
	TargetUserIDContainsFold *string  `json:"targetUserIDContainsFold,omitempty"`
	// target_group_id field predicates
	TargetGroupID             *string  `json:"targetGroupID,omitempty"`
	TargetGroupIdneq          *string  `json:"targetGroupIDNEQ,omitempty"`
	TargetGroupIDIn           []string `json:"targetGroupIDIn,omitempty"`
	TargetGroupIDNotIn        []string `json:"targetGroupIDNotIn,omitempty"`
	TargetGroupIdgt           *string  `json:"targetGroupIDGT,omitempty"`
	TargetGroupIdgte          *string  `json:"targetGroupIDGTE,omitempty"`
	TargetGroupIdlt           *string  `json:"targetGroupIDLT,omitempty"`
	TargetGroupIdlte          *string  `json:"targetGroupIDLTE,omitempty"`
	TargetGroupIDContains     *string  `json:"targetGroupIDContains,omitempty"`
	TargetGroupIDHasPrefix    *string  `json:"targetGroupIDHasPrefix,omitempty"`
	TargetGroupIDHasSuffix    *string  `json:"targetGroupIDHasSuffix,omitempty"`
	TargetGroupIDIsNil        *bool    `json:"targetGroupIDIsNil,omitempty"`
	TargetGroupIDNotNil       *bool    `json:"targetGroupIDNotNil,omitempty"`
	TargetGroupIDEqualFold    *string  `json:"targetGroupIDEqualFold,omitempty"`
	TargetGroupIDContainsFold *string  `json:"targetGroupIDContainsFold,omitempty"`
	// resolver_key field predicates
	ResolverKey             *string  `json:"resolverKey,omitempty"`
	ResolverKeyNeq          *string  `json:"resolverKeyNEQ,omitempty"`
	ResolverKeyIn           []string `json:"resolverKeyIn,omitempty"`
	ResolverKeyNotIn        []string `json:"resolverKeyNotIn,omitempty"`
	ResolverKeyGt           *string  `json:"resolverKeyGT,omitempty"`
	ResolverKeyGte          *string  `json:"resolverKeyGTE,omitempty"`
	ResolverKeyLt           *string  `json:"resolverKeyLT,omitempty"`
	ResolverKeyLte          *string  `json:"resolverKeyLTE,omitempty"`
	ResolverKeyContains     *string  `json:"resolverKeyContains,omitempty"`
	ResolverKeyHasPrefix    *string  `json:"resolverKeyHasPrefix,omitempty"`
	ResolverKeyHasSuffix    *string  `json:"resolverKeyHasSuffix,omitempty"`
	ResolverKeyIsNil        *bool    `json:"resolverKeyIsNil,omitempty"`
	ResolverKeyNotNil       *bool    `json:"resolverKeyNotNil,omitempty"`
	ResolverKeyEqualFold    *string  `json:"resolverKeyEqualFold,omitempty"`
	ResolverKeyContainsFold *string  `json:"resolverKeyContainsFold,omitempty"`
}

// Ordering options for WorkflowAssignmentTarget connections
type WorkflowAssignmentTargetOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowAssignmentTargets.
	Field WorkflowAssignmentTargetOrderField `json:"field"`
}

// Return response for updateWorkflowAssignmentTarget mutation
type WorkflowAssignmentTargetUpdatePayload struct {
	// Updated workflowAssignmentTarget
	WorkflowAssignmentTarget *WorkflowAssignmentTarget `json:"workflowAssignmentTarget"`
}

// WorkflowAssignmentTargetWhereInput is used for filtering WorkflowAssignmentTarget objects.
// Input was generated by ent.
type WorkflowAssignmentTargetWhereInput struct {
	Not *WorkflowAssignmentTargetWhereInput   `json:"not,omitempty"`
	And []*WorkflowAssignmentTargetWhereInput `json:"and,omitempty"`
	Or  []*WorkflowAssignmentTargetWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_assignment_id field predicates
	WorkflowAssignmentID             *string  `json:"workflowAssignmentID,omitempty"`
	WorkflowAssignmentIdneq          *string  `json:"workflowAssignmentIDNEQ,omitempty"`
	WorkflowAssignmentIDIn           []string `json:"workflowAssignmentIDIn,omitempty"`
	WorkflowAssignmentIDNotIn        []string `json:"workflowAssignmentIDNotIn,omitempty"`
	WorkflowAssignmentIdgt           *string  `json:"workflowAssignmentIDGT,omitempty"`
	WorkflowAssignmentIdgte          *string  `json:"workflowAssignmentIDGTE,omitempty"`
	WorkflowAssignmentIdlt           *string  `json:"workflowAssignmentIDLT,omitempty"`
	WorkflowAssignmentIdlte          *string  `json:"workflowAssignmentIDLTE,omitempty"`
	WorkflowAssignmentIDContains     *string  `json:"workflowAssignmentIDContains,omitempty"`
	WorkflowAssignmentIDHasPrefix    *string  `json:"workflowAssignmentIDHasPrefix,omitempty"`
	WorkflowAssignmentIDHasSuffix    *string  `json:"workflowAssignmentIDHasSuffix,omitempty"`
	WorkflowAssignmentIDEqualFold    *string  `json:"workflowAssignmentIDEqualFold,omitempty"`
	WorkflowAssignmentIDContainsFold *string  `json:"workflowAssignmentIDContainsFold,omitempty"`
	// target_type field predicates
	TargetType      *enums.WorkflowTargetType  `json:"targetType,omitempty"`
	TargetTypeNeq   *enums.WorkflowTargetType  `json:"targetTypeNEQ,omitempty"`
	TargetTypeIn    []enums.WorkflowTargetType `json:"targetTypeIn,omitempty"`
	TargetTypeNotIn []enums.WorkflowTargetType `json:"targetTypeNotIn,omitempty"`
	// target_user_id field predicates
	TargetUserID             *string  `json:"targetUserID,omitempty"`
	TargetUserIdneq          *string  `json:"targetUserIDNEQ,omitempty"`
	TargetUserIDIn           []string `json:"targetUserIDIn,omitempty"`
	TargetUserIDNotIn        []string `json:"targetUserIDNotIn,omitempty"`
	TargetUserIdgt           *string  `json:"targetUserIDGT,omitempty"`
	TargetUserIdgte          *string  `json:"targetUserIDGTE,omitempty"`
	TargetUserIdlt           *string  `json:"targetUserIDLT,omitempty"`
	TargetUserIdlte          *string  `json:"targetUserIDLTE,omitempty"`
	TargetUserIDContains     *string  `json:"targetUserIDContains,omitempty"`
	TargetUserIDHasPrefix    *string  `json:"targetUserIDHasPrefix,omitempty"`
	TargetUserIDHasSuffix    *string  `json:"targetUserIDHasSuffix,omitempty"`
	TargetUserIDIsNil        *bool    `json:"targetUserIDIsNil,omitempty"`
	TargetUserIDNotNil       *bool    `json:"targetUserIDNotNil,omitempty"`
	TargetUserIDEqualFold    *string  `json:"targetUserIDEqualFold,omitempty"`
	TargetUserIDContainsFold *string  `json:"targetUserIDContainsFold,omitempty"`
	// target_group_id field predicates
	TargetGroupID             *string  `json:"targetGroupID,omitempty"`
	TargetGroupIdneq          *string  `json:"targetGroupIDNEQ,omitempty"`
	TargetGroupIDIn           []string `json:"targetGroupIDIn,omitempty"`
	TargetGroupIDNotIn        []string `json:"targetGroupIDNotIn,omitempty"`
	TargetGroupIdgt           *string  `json:"targetGroupIDGT,omitempty"`
	TargetGroupIdgte          *string  `json:"targetGroupIDGTE,omitempty"`
	TargetGroupIdlt           *string  `json:"targetGroupIDLT,omitempty"`
	TargetGroupIdlte          *string  `json:"targetGroupIDLTE,omitempty"`
	TargetGroupIDContains     *string  `json:"targetGroupIDContains,omitempty"`
	TargetGroupIDHasPrefix    *string  `json:"targetGroupIDHasPrefix,omitempty"`
	TargetGroupIDHasSuffix    *string  `json:"targetGroupIDHasSuffix,omitempty"`
	TargetGroupIDIsNil        *bool    `json:"targetGroupIDIsNil,omitempty"`
	TargetGroupIDNotNil       *bool    `json:"targetGroupIDNotNil,omitempty"`
	TargetGroupIDEqualFold    *string  `json:"targetGroupIDEqualFold,omitempty"`
	TargetGroupIDContainsFold *string  `json:"targetGroupIDContainsFold,omitempty"`
	// resolver_key field predicates
	ResolverKey             *string  `json:"resolverKey,omitempty"`
	ResolverKeyNeq          *string  `json:"resolverKeyNEQ,omitempty"`
	ResolverKeyIn           []string `json:"resolverKeyIn,omitempty"`
	ResolverKeyNotIn        []string `json:"resolverKeyNotIn,omitempty"`
	ResolverKeyGt           *string  `json:"resolverKeyGT,omitempty"`
	ResolverKeyGte          *string  `json:"resolverKeyGTE,omitempty"`
	ResolverKeyLt           *string  `json:"resolverKeyLT,omitempty"`
	ResolverKeyLte          *string  `json:"resolverKeyLTE,omitempty"`
	ResolverKeyContains     *string  `json:"resolverKeyContains,omitempty"`
	ResolverKeyHasPrefix    *string  `json:"resolverKeyHasPrefix,omitempty"`
	ResolverKeyHasSuffix    *string  `json:"resolverKeyHasSuffix,omitempty"`
	ResolverKeyIsNil        *bool    `json:"resolverKeyIsNil,omitempty"`
	ResolverKeyNotNil       *bool    `json:"resolverKeyNotNil,omitempty"`
	ResolverKeyEqualFold    *string  `json:"resolverKeyEqualFold,omitempty"`
	ResolverKeyContainsFold *string  `json:"resolverKeyContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// workflow_assignment edge predicates
	HasWorkflowAssignment     *bool                           `json:"hasWorkflowAssignment,omitempty"`
	HasWorkflowAssignmentWith []*WorkflowAssignmentWhereInput `json:"hasWorkflowAssignmentWith,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

// Return response for updateWorkflowAssignment mutation
type WorkflowAssignmentUpdatePayload struct {
	// Updated workflowAssignment
	WorkflowAssignment *WorkflowAssignment `json:"workflowAssignment"`
}

// WorkflowAssignmentWhereInput is used for filtering WorkflowAssignment objects.
// Input was generated by ent.
type WorkflowAssignmentWhereInput struct {
	Not *WorkflowAssignmentWhereInput   `json:"not,omitempty"`
	And []*WorkflowAssignmentWhereInput `json:"and,omitempty"`
	Or  []*WorkflowAssignmentWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_instance_id field predicates
	WorkflowInstanceID             *string  `json:"workflowInstanceID,omitempty"`
	WorkflowInstanceIdneq          *string  `json:"workflowInstanceIDNEQ,omitempty"`
	WorkflowInstanceIDIn           []string `json:"workflowInstanceIDIn,omitempty"`
	WorkflowInstanceIDNotIn        []string `json:"workflowInstanceIDNotIn,omitempty"`
	WorkflowInstanceIdgt           *string  `json:"workflowInstanceIDGT,omitempty"`
	WorkflowInstanceIdgte          *string  `json:"workflowInstanceIDGTE,omitempty"`
	WorkflowInstanceIdlt           *string  `json:"workflowInstanceIDLT,omitempty"`
	WorkflowInstanceIdlte          *string  `json:"workflowInstanceIDLTE,omitempty"`
	WorkflowInstanceIDContains     *string  `json:"workflowInstanceIDContains,omitempty"`
	WorkflowInstanceIDHasPrefix    *string  `json:"workflowInstanceIDHasPrefix,omitempty"`
	WorkflowInstanceIDHasSuffix    *string  `json:"workflowInstanceIDHasSuffix,omitempty"`
	WorkflowInstanceIDEqualFold    *string  `json:"workflowInstanceIDEqualFold,omitempty"`
	WorkflowInstanceIDContainsFold *string  `json:"workflowInstanceIDContainsFold,omitempty"`
	// assignment_key field predicates
	AssignmentKey             *string  `json:"assignmentKey,omitempty"`
	AssignmentKeyNeq          *string  `json:"assignmentKeyNEQ,omitempty"`
	AssignmentKeyIn           []string `json:"assignmentKeyIn,omitempty"`
	AssignmentKeyNotIn        []string `json:"assignmentKeyNotIn,omitempty"`
	AssignmentKeyGt           *string  `json:"assignmentKeyGT,omitempty"`
	AssignmentKeyGte          *string  `json:"assignmentKeyGTE,omitempty"`
	AssignmentKeyLt           *string  `json:"assignmentKeyLT,omitempty"`
	AssignmentKeyLte          *string  `json:"assignmentKeyLTE,omitempty"`
	AssignmentKeyContains     *string  `json:"assignmentKeyContains,omitempty"`
	AssignmentKeyHasPrefix    *string  `json:"assignmentKeyHasPrefix,omitempty"`
	AssignmentKeyHasSuffix    *string  `json:"assignmentKeyHasSuffix,omitempty"`
	AssignmentKeyEqualFold    *string  `json:"assignmentKeyEqualFold,omitempty"`
	AssignmentKeyContainsFold *string  `json:"assignmentKeyContainsFold,omitempty"`
	// role field predicates
	Role             *string  `json:"role,omitempty"`
	RoleNeq          *string  `json:"roleNEQ,omitempty"`
	RoleIn           []string `json:"roleIn,omitempty"`
	RoleNotIn        []string `json:"roleNotIn,omitempty"`
	RoleGt           *string  `json:"roleGT,omitempty"`
	RoleGte          *string  `json:"roleGTE,omitempty"`
	RoleLt           *string  `json:"roleLT,omitempty"`
	RoleLte          *string  `json:"roleLTE,omitempty"`
	RoleContains     *string  `json:"roleContains,omitempty"`
	RoleHasPrefix    *string  `json:"roleHasPrefix,omitempty"`
	RoleHasSuffix    *string  `json:"roleHasSuffix,omitempty"`
	RoleEqualFold    *string  `json:"roleEqualFold,omitempty"`
	RoleContainsFold *string  `json:"roleContainsFold,omitempty"`
	// label field predicates
	Label             *string  `json:"label,omitempty"`
	LabelNeq          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGt           *string  `json:"labelGT,omitempty"`
	LabelGte          *string  `json:"labelGTE,omitempty"`
	LabelLt           *string  `json:"labelLT,omitempty"`
	LabelLte          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelIsNil        *bool    `json:"labelIsNil,omitempty"`
	LabelNotNil       *bool    `json:"labelNotNil,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`
	// required field predicates
	Required    *bool `json:"required,omitempty"`
	RequiredNeq *bool `json:"requiredNEQ,omitempty"`
	// status field predicates
	Status      *enums.WorkflowAssignmentStatus  `json:"status,omitempty"`
	StatusNeq   *enums.WorkflowAssignmentStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.WorkflowAssignmentStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.WorkflowAssignmentStatus `json:"statusNotIn,omitempty"`
	// decided_at field predicates
	DecidedAt       *time.Time   `json:"decidedAt,omitempty"`
	DecidedAtNeq    *time.Time   `json:"decidedAtNEQ,omitempty"`
	DecidedAtIn     []*time.Time `json:"decidedAtIn,omitempty"`
	DecidedAtNotIn  []*time.Time `json:"decidedAtNotIn,omitempty"`
	DecidedAtGt     *time.Time   `json:"decidedAtGT,omitempty"`
	DecidedAtGte    *time.Time   `json:"decidedAtGTE,omitempty"`
	DecidedAtLt     *time.Time   `json:"decidedAtLT,omitempty"`
	DecidedAtLte    *time.Time   `json:"decidedAtLTE,omitempty"`
	DecidedAtIsNil  *bool        `json:"decidedAtIsNil,omitempty"`
	DecidedAtNotNil *bool        `json:"decidedAtNotNil,omitempty"`
	// actor_user_id field predicates
	ActorUserID             *string  `json:"actorUserID,omitempty"`
	ActorUserIdneq          *string  `json:"actorUserIDNEQ,omitempty"`
	ActorUserIDIn           []string `json:"actorUserIDIn,omitempty"`
	ActorUserIDNotIn        []string `json:"actorUserIDNotIn,omitempty"`
	ActorUserIdgt           *string  `json:"actorUserIDGT,omitempty"`
	ActorUserIdgte          *string  `json:"actorUserIDGTE,omitempty"`
	ActorUserIdlt           *string  `json:"actorUserIDLT,omitempty"`
	ActorUserIdlte          *string  `json:"actorUserIDLTE,omitempty"`
	ActorUserIDContains     *string  `json:"actorUserIDContains,omitempty"`
	ActorUserIDHasPrefix    *string  `json:"actorUserIDHasPrefix,omitempty"`
	ActorUserIDHasSuffix    *string  `json:"actorUserIDHasSuffix,omitempty"`
	ActorUserIDIsNil        *bool    `json:"actorUserIDIsNil,omitempty"`
	ActorUserIDNotNil       *bool    `json:"actorUserIDNotNil,omitempty"`
	ActorUserIDEqualFold    *string  `json:"actorUserIDEqualFold,omitempty"`
	ActorUserIDContainsFold *string  `json:"actorUserIDContainsFold,omitempty"`
	// actor_group_id field predicates
	ActorGroupID             *string  `json:"actorGroupID,omitempty"`
	ActorGroupIdneq          *string  `json:"actorGroupIDNEQ,omitempty"`
	ActorGroupIDIn           []string `json:"actorGroupIDIn,omitempty"`
	ActorGroupIDNotIn        []string `json:"actorGroupIDNotIn,omitempty"`
	ActorGroupIdgt           *string  `json:"actorGroupIDGT,omitempty"`
	ActorGroupIdgte          *string  `json:"actorGroupIDGTE,omitempty"`
	ActorGroupIdlt           *string  `json:"actorGroupIDLT,omitempty"`
	ActorGroupIdlte          *string  `json:"actorGroupIDLTE,omitempty"`
	ActorGroupIDContains     *string  `json:"actorGroupIDContains,omitempty"`
	ActorGroupIDHasPrefix    *string  `json:"actorGroupIDHasPrefix,omitempty"`
	ActorGroupIDHasSuffix    *string  `json:"actorGroupIDHasSuffix,omitempty"`
	ActorGroupIDIsNil        *bool    `json:"actorGroupIDIsNil,omitempty"`
	ActorGroupIDNotNil       *bool    `json:"actorGroupIDNotNil,omitempty"`
	ActorGroupIDEqualFold    *string  `json:"actorGroupIDEqualFold,omitempty"`
	ActorGroupIDContainsFold *string  `json:"actorGroupIDContainsFold,omitempty"`
	// notes field predicates
	Notes             *string  `json:"notes,omitempty"`
	NotesNeq          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGt           *string  `json:"notesGT,omitempty"`
	NotesGte          *string  `json:"notesGTE,omitempty"`
	NotesLt           *string  `json:"notesLT,omitempty"`
	NotesLte          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        *bool    `json:"notesIsNil,omitempty"`
	NotesNotNil       *bool    `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// workflow_instance edge predicates
	HasWorkflowInstance     *bool                         `json:"hasWorkflowInstance,omitempty"`
	HasWorkflowInstanceWith []*WorkflowInstanceWhereInput `json:"hasWorkflowInstanceWith,omitempty"`
	// workflow_assignment_targets edge predicates
	HasWorkflowAssignmentTargets     *bool                                 `json:"hasWorkflowAssignmentTargets,omitempty"`
	HasWorkflowAssignmentTargetsWith []*WorkflowAssignmentTargetWhereInput `json:"hasWorkflowAssignmentTargetsWith,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

type WorkflowDefinition struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// Name of the workflow definition
	Name string `json:"name"`
	// Optional description of the workflow definition
	Description *string `json:"description,omitempty"`
	// Kind of workflow, e.g. APPROVAL, LIFECYCLE, NOTIFICATION
	WorkflowKind enums.WorkflowKind `json:"workflowKind"`
	// Type of schema this workflow applies to
	SchemaType string `json:"schemaType"`
	// Revision number for this definition
	Revision int64 `json:"revision"`
	// Whether this definition is a draft
	Draft bool `json:"draft"`
	// When this definition was published
	PublishedAt *time.Time `json:"publishedAt,omitempty"`
	// Suppress duplicate triggers within this window per object/definition
	CooldownSeconds int64 `json:"cooldownSeconds"`
	// Whether this is the default workflow for the schema type
	IsDefault bool `json:"isDefault"`
	// Whether the workflow definition is active
	Active bool `json:"active"`
	// Derived: normalized operations from definition for prefiltering; not user editable
	TriggerOperations []string `json:"triggerOperations,omitempty"`
	// Derived: normalized fields from definition for prefiltering; not user editable
	TriggerFields []string `json:"triggerFields,omitempty"`
	// Typed document describing triggers, conditions, and actions
	DefinitionJSON *models.WorkflowDefinitionDocument `json:"definitionJSON,omitempty"`
	// Cached list of fields that should trigger workflow evaluation
	TrackedFields  []string                 `json:"trackedFields,omitempty"`
	Owner          *Organization            `json:"owner,omitempty"`
	TagDefinitions *TagDefinitionConnection `json:"tagDefinitions"`
	Groups         *GroupConnection         `json:"groups"`
}

func (WorkflowDefinition) IsNode() {}

// Return response for createBulkWorkflowDefinition mutation
type WorkflowDefinitionBulkCreatePayload struct {
	// Created workflowDefinitions
	WorkflowDefinitions []*WorkflowDefinition `json:"workflowDefinitions,omitempty"`
}

// A connection to a list of items.
type WorkflowDefinitionConnection struct {
	// A list of edges.
	Edges []*WorkflowDefinitionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createWorkflowDefinition mutation
type WorkflowDefinitionCreatePayload struct {
	// Created workflowDefinition
	WorkflowDefinition *WorkflowDefinition `json:"workflowDefinition"`
}

// Return response for deleteWorkflowDefinition mutation
type WorkflowDefinitionDeletePayload struct {
	// Deleted workflowDefinition ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WorkflowDefinitionEdge struct {
	// The item at the end of the edge.
	Node *WorkflowDefinition `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type WorkflowDefinitionHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internalNotes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"systemInternalID,omitempty"`
	// Name of the workflow definition
	Name string `json:"name"`
	// Optional description of the workflow definition
	Description *string `json:"description,omitempty"`
	// Kind of workflow, e.g. APPROVAL, LIFECYCLE, NOTIFICATION
	WorkflowKind enums.WorkflowKind `json:"workflowKind"`
	// Type of schema this workflow applies to
	SchemaType string `json:"schemaType"`
	// Revision number for this definition
	Revision int64 `json:"revision"`
	// Whether this definition is a draft
	Draft bool `json:"draft"`
	// When this definition was published
	PublishedAt *time.Time `json:"publishedAt,omitempty"`
	// Suppress duplicate triggers within this window per object/definition
	CooldownSeconds int64 `json:"cooldownSeconds"`
	// Whether this is the default workflow for the schema type
	IsDefault bool `json:"isDefault"`
	// Whether the workflow definition is active
	Active bool `json:"active"`
	// Derived: normalized operations from definition for prefiltering; not user editable
	TriggerOperations []string `json:"triggerOperations,omitempty"`
	// Derived: normalized fields from definition for prefiltering; not user editable
	TriggerFields []string `json:"triggerFields,omitempty"`
	// Typed document describing triggers, conditions, and actions
	DefinitionJSON *models.WorkflowDefinitionDocument `json:"definitionJSON,omitempty"`
	// Cached list of fields that should trigger workflow evaluation
	TrackedFields []string `json:"trackedFields,omitempty"`
}

func (WorkflowDefinitionHistory) IsNode() {}

// A connection to a list of items.
type WorkflowDefinitionHistoryConnection struct {
	// A list of edges.
	Edges []*WorkflowDefinitionHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type WorkflowDefinitionHistoryEdge struct {
	// The item at the end of the edge.
	Node *WorkflowDefinitionHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for WorkflowDefinitionHistory connections
type WorkflowDefinitionHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowDefinitionHistories.
	Field WorkflowDefinitionHistoryOrderField `json:"field"`
}

// WorkflowDefinitionHistoryWhereInput is used for filtering WorkflowDefinitionHistory objects.
// Input was generated by ent.
type WorkflowDefinitionHistoryWhereInput struct {
	Not *WorkflowDefinitionHistoryWhereInput   `json:"not,omitempty"`
	And []*WorkflowDefinitionHistoryWhereInput `json:"and,omitempty"`
	Or  []*WorkflowDefinitionHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// workflow_kind field predicates
	WorkflowKind      *enums.WorkflowKind  `json:"workflowKind,omitempty"`
	WorkflowKindNeq   *enums.WorkflowKind  `json:"workflowKindNEQ,omitempty"`
	WorkflowKindIn    []enums.WorkflowKind `json:"workflowKindIn,omitempty"`
	WorkflowKindNotIn []enums.WorkflowKind `json:"workflowKindNotIn,omitempty"`
	// schema_type field predicates
	SchemaType             *string  `json:"schemaType,omitempty"`
	SchemaTypeNeq          *string  `json:"schemaTypeNEQ,omitempty"`
	SchemaTypeIn           []string `json:"schemaTypeIn,omitempty"`
	SchemaTypeNotIn        []string `json:"schemaTypeNotIn,omitempty"`
	SchemaTypeGt           *string  `json:"schemaTypeGT,omitempty"`
	SchemaTypeGte          *string  `json:"schemaTypeGTE,omitempty"`
	SchemaTypeLt           *string  `json:"schemaTypeLT,omitempty"`
	SchemaTypeLte          *string  `json:"schemaTypeLTE,omitempty"`
	SchemaTypeContains     *string  `json:"schemaTypeContains,omitempty"`
	SchemaTypeHasPrefix    *string  `json:"schemaTypeHasPrefix,omitempty"`
	SchemaTypeHasSuffix    *string  `json:"schemaTypeHasSuffix,omitempty"`
	SchemaTypeEqualFold    *string  `json:"schemaTypeEqualFold,omitempty"`
	SchemaTypeContainsFold *string  `json:"schemaTypeContainsFold,omitempty"`
	// revision field predicates
	Revision      *int64  `json:"revision,omitempty"`
	RevisionNeq   *int64  `json:"revisionNEQ,omitempty"`
	RevisionIn    []int64 `json:"revisionIn,omitempty"`
	RevisionNotIn []int64 `json:"revisionNotIn,omitempty"`
	RevisionGt    *int64  `json:"revisionGT,omitempty"`
	RevisionGte   *int64  `json:"revisionGTE,omitempty"`
	RevisionLt    *int64  `json:"revisionLT,omitempty"`
	RevisionLte   *int64  `json:"revisionLTE,omitempty"`
	// draft field predicates
	Draft    *bool `json:"draft,omitempty"`
	DraftNeq *bool `json:"draftNEQ,omitempty"`
	// published_at field predicates
	PublishedAt       *time.Time   `json:"publishedAt,omitempty"`
	PublishedAtNeq    *time.Time   `json:"publishedAtNEQ,omitempty"`
	PublishedAtIn     []*time.Time `json:"publishedAtIn,omitempty"`
	PublishedAtNotIn  []*time.Time `json:"publishedAtNotIn,omitempty"`
	PublishedAtGt     *time.Time   `json:"publishedAtGT,omitempty"`
	PublishedAtGte    *time.Time   `json:"publishedAtGTE,omitempty"`
	PublishedAtLt     *time.Time   `json:"publishedAtLT,omitempty"`
	PublishedAtLte    *time.Time   `json:"publishedAtLTE,omitempty"`
	PublishedAtIsNil  *bool        `json:"publishedAtIsNil,omitempty"`
	PublishedAtNotNil *bool        `json:"publishedAtNotNil,omitempty"`
	// cooldown_seconds field predicates
	CooldownSeconds      *int64  `json:"cooldownSeconds,omitempty"`
	CooldownSecondsNeq   *int64  `json:"cooldownSecondsNEQ,omitempty"`
	CooldownSecondsIn    []int64 `json:"cooldownSecondsIn,omitempty"`
	CooldownSecondsNotIn []int64 `json:"cooldownSecondsNotIn,omitempty"`
	CooldownSecondsGt    *int64  `json:"cooldownSecondsGT,omitempty"`
	CooldownSecondsGte   *int64  `json:"cooldownSecondsGTE,omitempty"`
	CooldownSecondsLt    *int64  `json:"cooldownSecondsLT,omitempty"`
	CooldownSecondsLte   *int64  `json:"cooldownSecondsLTE,omitempty"`
	// is_default field predicates
	IsDefault    *bool `json:"isDefault,omitempty"`
	IsDefaultNeq *bool `json:"isDefaultNEQ,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
}

// Ordering options for WorkflowDefinition connections
type WorkflowDefinitionOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowDefinitions.
	Field WorkflowDefinitionOrderField `json:"field"`
}

// Return response for updateWorkflowDefinition mutation
type WorkflowDefinitionUpdatePayload struct {
	// Updated workflowDefinition
	WorkflowDefinition *WorkflowDefinition `json:"workflowDefinition"`
}

// WorkflowDefinitionWhereInput is used for filtering WorkflowDefinition objects.
// Input was generated by ent.
type WorkflowDefinitionWhereInput struct {
	Not *WorkflowDefinitionWhereInput   `json:"not,omitempty"`
	And []*WorkflowDefinitionWhereInput `json:"and,omitempty"`
	Or  []*WorkflowDefinitionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// internal_notes field predicates
	InternalNotes             *string  `json:"internalNotes,omitempty"`
	InternalNotesNeq          *string  `json:"internalNotesNEQ,omitempty"`
	InternalNotesIn           []string `json:"internalNotesIn,omitempty"`
	InternalNotesNotIn        []string `json:"internalNotesNotIn,omitempty"`
	InternalNotesGt           *string  `json:"internalNotesGT,omitempty"`
	InternalNotesGte          *string  `json:"internalNotesGTE,omitempty"`
	InternalNotesLt           *string  `json:"internalNotesLT,omitempty"`
	InternalNotesLte          *string  `json:"internalNotesLTE,omitempty"`
	InternalNotesContains     *string  `json:"internalNotesContains,omitempty"`
	InternalNotesHasPrefix    *string  `json:"internalNotesHasPrefix,omitempty"`
	InternalNotesHasSuffix    *string  `json:"internalNotesHasSuffix,omitempty"`
	InternalNotesIsNil        *bool    `json:"internalNotesIsNil,omitempty"`
	InternalNotesNotNil       *bool    `json:"internalNotesNotNil,omitempty"`
	InternalNotesEqualFold    *string  `json:"internalNotesEqualFold,omitempty"`
	InternalNotesContainsFold *string  `json:"internalNotesContainsFold,omitempty"`
	// system_internal_id field predicates
	SystemInternalID             *string  `json:"systemInternalID,omitempty"`
	SystemInternalIdneq          *string  `json:"systemInternalIDNEQ,omitempty"`
	SystemInternalIDIn           []string `json:"systemInternalIDIn,omitempty"`
	SystemInternalIDNotIn        []string `json:"systemInternalIDNotIn,omitempty"`
	SystemInternalIdgt           *string  `json:"systemInternalIDGT,omitempty"`
	SystemInternalIdgte          *string  `json:"systemInternalIDGTE,omitempty"`
	SystemInternalIdlt           *string  `json:"systemInternalIDLT,omitempty"`
	SystemInternalIdlte          *string  `json:"systemInternalIDLTE,omitempty"`
	SystemInternalIDContains     *string  `json:"systemInternalIDContains,omitempty"`
	SystemInternalIDHasPrefix    *string  `json:"systemInternalIDHasPrefix,omitempty"`
	SystemInternalIDHasSuffix    *string  `json:"systemInternalIDHasSuffix,omitempty"`
	SystemInternalIDIsNil        *bool    `json:"systemInternalIDIsNil,omitempty"`
	SystemInternalIDNotNil       *bool    `json:"systemInternalIDNotNil,omitempty"`
	SystemInternalIDEqualFold    *string  `json:"systemInternalIDEqualFold,omitempty"`
	SystemInternalIDContainsFold *string  `json:"systemInternalIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// workflow_kind field predicates
	WorkflowKind      *enums.WorkflowKind  `json:"workflowKind,omitempty"`
	WorkflowKindNeq   *enums.WorkflowKind  `json:"workflowKindNEQ,omitempty"`
	WorkflowKindIn    []enums.WorkflowKind `json:"workflowKindIn,omitempty"`
	WorkflowKindNotIn []enums.WorkflowKind `json:"workflowKindNotIn,omitempty"`
	// schema_type field predicates
	SchemaType             *string  `json:"schemaType,omitempty"`
	SchemaTypeNeq          *string  `json:"schemaTypeNEQ,omitempty"`
	SchemaTypeIn           []string `json:"schemaTypeIn,omitempty"`
	SchemaTypeNotIn        []string `json:"schemaTypeNotIn,omitempty"`
	SchemaTypeGt           *string  `json:"schemaTypeGT,omitempty"`
	SchemaTypeGte          *string  `json:"schemaTypeGTE,omitempty"`
	SchemaTypeLt           *string  `json:"schemaTypeLT,omitempty"`
	SchemaTypeLte          *string  `json:"schemaTypeLTE,omitempty"`
	SchemaTypeContains     *string  `json:"schemaTypeContains,omitempty"`
	SchemaTypeHasPrefix    *string  `json:"schemaTypeHasPrefix,omitempty"`
	SchemaTypeHasSuffix    *string  `json:"schemaTypeHasSuffix,omitempty"`
	SchemaTypeEqualFold    *string  `json:"schemaTypeEqualFold,omitempty"`
	SchemaTypeContainsFold *string  `json:"schemaTypeContainsFold,omitempty"`
	// revision field predicates
	Revision      *int64  `json:"revision,omitempty"`
	RevisionNeq   *int64  `json:"revisionNEQ,omitempty"`
	RevisionIn    []int64 `json:"revisionIn,omitempty"`
	RevisionNotIn []int64 `json:"revisionNotIn,omitempty"`
	RevisionGt    *int64  `json:"revisionGT,omitempty"`
	RevisionGte   *int64  `json:"revisionGTE,omitempty"`
	RevisionLt    *int64  `json:"revisionLT,omitempty"`
	RevisionLte   *int64  `json:"revisionLTE,omitempty"`
	// draft field predicates
	Draft    *bool `json:"draft,omitempty"`
	DraftNeq *bool `json:"draftNEQ,omitempty"`
	// published_at field predicates
	PublishedAt       *time.Time   `json:"publishedAt,omitempty"`
	PublishedAtNeq    *time.Time   `json:"publishedAtNEQ,omitempty"`
	PublishedAtIn     []*time.Time `json:"publishedAtIn,omitempty"`
	PublishedAtNotIn  []*time.Time `json:"publishedAtNotIn,omitempty"`
	PublishedAtGt     *time.Time   `json:"publishedAtGT,omitempty"`
	PublishedAtGte    *time.Time   `json:"publishedAtGTE,omitempty"`
	PublishedAtLt     *time.Time   `json:"publishedAtLT,omitempty"`
	PublishedAtLte    *time.Time   `json:"publishedAtLTE,omitempty"`
	PublishedAtIsNil  *bool        `json:"publishedAtIsNil,omitempty"`
	PublishedAtNotNil *bool        `json:"publishedAtNotNil,omitempty"`
	// cooldown_seconds field predicates
	CooldownSeconds      *int64  `json:"cooldownSeconds,omitempty"`
	CooldownSecondsNeq   *int64  `json:"cooldownSecondsNEQ,omitempty"`
	CooldownSecondsIn    []int64 `json:"cooldownSecondsIn,omitempty"`
	CooldownSecondsNotIn []int64 `json:"cooldownSecondsNotIn,omitempty"`
	CooldownSecondsGt    *int64  `json:"cooldownSecondsGT,omitempty"`
	CooldownSecondsGte   *int64  `json:"cooldownSecondsGTE,omitempty"`
	CooldownSecondsLt    *int64  `json:"cooldownSecondsLT,omitempty"`
	CooldownSecondsLte   *int64  `json:"cooldownSecondsLTE,omitempty"`
	// is_default field predicates
	IsDefault    *bool `json:"isDefault,omitempty"`
	IsDefaultNeq *bool `json:"isDefaultNEQ,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// tag_definitions edge predicates
	HasTagDefinitions     *bool                      `json:"hasTagDefinitions,omitempty"`
	HasTagDefinitionsWith []*TagDefinitionWhereInput `json:"hasTagDefinitionsWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
}

type WorkflowEvent struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// ID of the workflow instance that generated the event
	WorkflowInstanceID string `json:"workflowInstanceID"`
	// Type of event, typically the action kind
	EventType enums.WorkflowEventType `json:"eventType"`
	// Payload for the event; stored raw
	Payload          *models.WorkflowEventPayload `json:"payload,omitempty"`
	Owner            *Organization                `json:"owner,omitempty"`
	WorkflowInstance *WorkflowInstance            `json:"workflowInstance"`
}

func (WorkflowEvent) IsNode() {}

// Return response for createBulkWorkflowEvent mutation
type WorkflowEventBulkCreatePayload struct {
	// Created workflowEvents
	WorkflowEvents []*WorkflowEvent `json:"workflowEvents,omitempty"`
}

// A connection to a list of items.
type WorkflowEventConnection struct {
	// A list of edges.
	Edges []*WorkflowEventEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createWorkflowEvent mutation
type WorkflowEventCreatePayload struct {
	// Created workflowEvent
	WorkflowEvent *WorkflowEvent `json:"workflowEvent"`
}

// Return response for deleteWorkflowEvent mutation
type WorkflowEventDeletePayload struct {
	// Deleted workflowEvent ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WorkflowEventEdge struct {
	// The item at the end of the edge.
	Node *WorkflowEvent `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type WorkflowEventHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// ID of the workflow instance that generated the event
	WorkflowInstanceID string `json:"workflowInstanceID"`
	// Type of event, typically the action kind
	EventType enums.WorkflowEventType `json:"eventType"`
	// Payload for the event; stored raw
	Payload *models.WorkflowEventPayload `json:"payload,omitempty"`
}

func (WorkflowEventHistory) IsNode() {}

// A connection to a list of items.
type WorkflowEventHistoryConnection struct {
	// A list of edges.
	Edges []*WorkflowEventHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type WorkflowEventHistoryEdge struct {
	// The item at the end of the edge.
	Node *WorkflowEventHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for WorkflowEventHistory connections
type WorkflowEventHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowEventHistories.
	Field WorkflowEventHistoryOrderField `json:"field"`
}

// WorkflowEventHistoryWhereInput is used for filtering WorkflowEventHistory objects.
// Input was generated by ent.
type WorkflowEventHistoryWhereInput struct {
	Not *WorkflowEventHistoryWhereInput   `json:"not,omitempty"`
	And []*WorkflowEventHistoryWhereInput `json:"and,omitempty"`
	Or  []*WorkflowEventHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_instance_id field predicates
	WorkflowInstanceID             *string  `json:"workflowInstanceID,omitempty"`
	WorkflowInstanceIdneq          *string  `json:"workflowInstanceIDNEQ,omitempty"`
	WorkflowInstanceIDIn           []string `json:"workflowInstanceIDIn,omitempty"`
	WorkflowInstanceIDNotIn        []string `json:"workflowInstanceIDNotIn,omitempty"`
	WorkflowInstanceIdgt           *string  `json:"workflowInstanceIDGT,omitempty"`
	WorkflowInstanceIdgte          *string  `json:"workflowInstanceIDGTE,omitempty"`
	WorkflowInstanceIdlt           *string  `json:"workflowInstanceIDLT,omitempty"`
	WorkflowInstanceIdlte          *string  `json:"workflowInstanceIDLTE,omitempty"`
	WorkflowInstanceIDContains     *string  `json:"workflowInstanceIDContains,omitempty"`
	WorkflowInstanceIDHasPrefix    *string  `json:"workflowInstanceIDHasPrefix,omitempty"`
	WorkflowInstanceIDHasSuffix    *string  `json:"workflowInstanceIDHasSuffix,omitempty"`
	WorkflowInstanceIDEqualFold    *string  `json:"workflowInstanceIDEqualFold,omitempty"`
	WorkflowInstanceIDContainsFold *string  `json:"workflowInstanceIDContainsFold,omitempty"`
	// event_type field predicates
	EventType      *enums.WorkflowEventType  `json:"eventType,omitempty"`
	EventTypeNeq   *enums.WorkflowEventType  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn    []enums.WorkflowEventType `json:"eventTypeIn,omitempty"`
	EventTypeNotIn []enums.WorkflowEventType `json:"eventTypeNotIn,omitempty"`
}

// Ordering options for WorkflowEvent connections
type WorkflowEventOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowEvents.
	Field WorkflowEventOrderField `json:"field"`
}

// Return response for updateWorkflowEvent mutation
type WorkflowEventUpdatePayload struct {
	// Updated workflowEvent
	WorkflowEvent *WorkflowEvent `json:"workflowEvent"`
}

// WorkflowEventWhereInput is used for filtering WorkflowEvent objects.
// Input was generated by ent.
type WorkflowEventWhereInput struct {
	Not *WorkflowEventWhereInput   `json:"not,omitempty"`
	And []*WorkflowEventWhereInput `json:"and,omitempty"`
	Or  []*WorkflowEventWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_instance_id field predicates
	WorkflowInstanceID             *string  `json:"workflowInstanceID,omitempty"`
	WorkflowInstanceIdneq          *string  `json:"workflowInstanceIDNEQ,omitempty"`
	WorkflowInstanceIDIn           []string `json:"workflowInstanceIDIn,omitempty"`
	WorkflowInstanceIDNotIn        []string `json:"workflowInstanceIDNotIn,omitempty"`
	WorkflowInstanceIdgt           *string  `json:"workflowInstanceIDGT,omitempty"`
	WorkflowInstanceIdgte          *string  `json:"workflowInstanceIDGTE,omitempty"`
	WorkflowInstanceIdlt           *string  `json:"workflowInstanceIDLT,omitempty"`
	WorkflowInstanceIdlte          *string  `json:"workflowInstanceIDLTE,omitempty"`
	WorkflowInstanceIDContains     *string  `json:"workflowInstanceIDContains,omitempty"`
	WorkflowInstanceIDHasPrefix    *string  `json:"workflowInstanceIDHasPrefix,omitempty"`
	WorkflowInstanceIDHasSuffix    *string  `json:"workflowInstanceIDHasSuffix,omitempty"`
	WorkflowInstanceIDEqualFold    *string  `json:"workflowInstanceIDEqualFold,omitempty"`
	WorkflowInstanceIDContainsFold *string  `json:"workflowInstanceIDContainsFold,omitempty"`
	// event_type field predicates
	EventType      *enums.WorkflowEventType  `json:"eventType,omitempty"`
	EventTypeNeq   *enums.WorkflowEventType  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn    []enums.WorkflowEventType `json:"eventTypeIn,omitempty"`
	EventTypeNotIn []enums.WorkflowEventType `json:"eventTypeNotIn,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// workflow_instance edge predicates
	HasWorkflowInstance     *bool                         `json:"hasWorkflowInstance,omitempty"`
	HasWorkflowInstanceWith []*WorkflowInstanceWhereInput `json:"hasWorkflowInstanceWith,omitempty"`
}

type WorkflowInstance struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// ID of the workflow definition this instance is based on
	WorkflowDefinitionID string `json:"workflowDefinitionID"`
	// Current state of the workflow instance
	State enums.WorkflowInstanceState `json:"state"`
	// Optional context for the workflow instance
	Context *models.WorkflowInstanceContext `json:"context,omitempty"`
	// Timestamp when the workflow was last evaluated
	LastEvaluatedAt *time.Time `json:"lastEvaluatedAt,omitempty"`
	// Copy of definition JSON used for this instance
	DefinitionSnapshot *models.WorkflowDefinitionDocument `json:"definitionSnapshot,omitempty"`
	Owner              *Organization                      `json:"owner,omitempty"`
	// Definition driving this instance
	WorkflowDefinition  *WorkflowDefinition           `json:"workflowDefinition"`
	WorkflowAssignments *WorkflowAssignmentConnection `json:"workflowAssignments"`
	WorkflowEvents      *WorkflowEventConnection      `json:"workflowEvents"`
	WorkflowObjectRefs  *WorkflowObjectRefConnection  `json:"workflowObjectRefs"`
}

func (WorkflowInstance) IsNode() {}

// Return response for createBulkWorkflowInstance mutation
type WorkflowInstanceBulkCreatePayload struct {
	// Created workflowInstances
	WorkflowInstances []*WorkflowInstance `json:"workflowInstances,omitempty"`
}

// A connection to a list of items.
type WorkflowInstanceConnection struct {
	// A list of edges.
	Edges []*WorkflowInstanceEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createWorkflowInstance mutation
type WorkflowInstanceCreatePayload struct {
	// Created workflowInstance
	WorkflowInstance *WorkflowInstance `json:"workflowInstance"`
}

// Return response for deleteWorkflowInstance mutation
type WorkflowInstanceDeletePayload struct {
	// Deleted workflowInstance ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WorkflowInstanceEdge struct {
	// The item at the end of the edge.
	Node *WorkflowInstance `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type WorkflowInstanceHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// ID of the workflow definition this instance is based on
	WorkflowDefinitionID string `json:"workflowDefinitionID"`
	// Current state of the workflow instance
	State enums.WorkflowInstanceState `json:"state"`
	// Optional context for the workflow instance
	Context *models.WorkflowInstanceContext `json:"context,omitempty"`
	// Timestamp when the workflow was last evaluated
	LastEvaluatedAt *time.Time `json:"lastEvaluatedAt,omitempty"`
	// Copy of definition JSON used for this instance
	DefinitionSnapshot *models.WorkflowDefinitionDocument `json:"definitionSnapshot,omitempty"`
}

func (WorkflowInstanceHistory) IsNode() {}

// A connection to a list of items.
type WorkflowInstanceHistoryConnection struct {
	// A list of edges.
	Edges []*WorkflowInstanceHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type WorkflowInstanceHistoryEdge struct {
	// The item at the end of the edge.
	Node *WorkflowInstanceHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for WorkflowInstanceHistory connections
type WorkflowInstanceHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowInstanceHistories.
	Field WorkflowInstanceHistoryOrderField `json:"field"`
}

// WorkflowInstanceHistoryWhereInput is used for filtering WorkflowInstanceHistory objects.
// Input was generated by ent.
type WorkflowInstanceHistoryWhereInput struct {
	Not *WorkflowInstanceHistoryWhereInput   `json:"not,omitempty"`
	And []*WorkflowInstanceHistoryWhereInput `json:"and,omitempty"`
	Or  []*WorkflowInstanceHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_definition_id field predicates
	WorkflowDefinitionID             *string  `json:"workflowDefinitionID,omitempty"`
	WorkflowDefinitionIdneq          *string  `json:"workflowDefinitionIDNEQ,omitempty"`
	WorkflowDefinitionIDIn           []string `json:"workflowDefinitionIDIn,omitempty"`
	WorkflowDefinitionIDNotIn        []string `json:"workflowDefinitionIDNotIn,omitempty"`
	WorkflowDefinitionIdgt           *string  `json:"workflowDefinitionIDGT,omitempty"`
	WorkflowDefinitionIdgte          *string  `json:"workflowDefinitionIDGTE,omitempty"`
	WorkflowDefinitionIdlt           *string  `json:"workflowDefinitionIDLT,omitempty"`
	WorkflowDefinitionIdlte          *string  `json:"workflowDefinitionIDLTE,omitempty"`
	WorkflowDefinitionIDContains     *string  `json:"workflowDefinitionIDContains,omitempty"`
	WorkflowDefinitionIDHasPrefix    *string  `json:"workflowDefinitionIDHasPrefix,omitempty"`
	WorkflowDefinitionIDHasSuffix    *string  `json:"workflowDefinitionIDHasSuffix,omitempty"`
	WorkflowDefinitionIDEqualFold    *string  `json:"workflowDefinitionIDEqualFold,omitempty"`
	WorkflowDefinitionIDContainsFold *string  `json:"workflowDefinitionIDContainsFold,omitempty"`
	// state field predicates
	State      *enums.WorkflowInstanceState  `json:"state,omitempty"`
	StateNeq   *enums.WorkflowInstanceState  `json:"stateNEQ,omitempty"`
	StateIn    []enums.WorkflowInstanceState `json:"stateIn,omitempty"`
	StateNotIn []enums.WorkflowInstanceState `json:"stateNotIn,omitempty"`
	// last_evaluated_at field predicates
	LastEvaluatedAt       *time.Time   `json:"lastEvaluatedAt,omitempty"`
	LastEvaluatedAtNeq    *time.Time   `json:"lastEvaluatedAtNEQ,omitempty"`
	LastEvaluatedAtIn     []*time.Time `json:"lastEvaluatedAtIn,omitempty"`
	LastEvaluatedAtNotIn  []*time.Time `json:"lastEvaluatedAtNotIn,omitempty"`
	LastEvaluatedAtGt     *time.Time   `json:"lastEvaluatedAtGT,omitempty"`
	LastEvaluatedAtGte    *time.Time   `json:"lastEvaluatedAtGTE,omitempty"`
	LastEvaluatedAtLt     *time.Time   `json:"lastEvaluatedAtLT,omitempty"`
	LastEvaluatedAtLte    *time.Time   `json:"lastEvaluatedAtLTE,omitempty"`
	LastEvaluatedAtIsNil  *bool        `json:"lastEvaluatedAtIsNil,omitempty"`
	LastEvaluatedAtNotNil *bool        `json:"lastEvaluatedAtNotNil,omitempty"`
}

// Ordering options for WorkflowInstance connections
type WorkflowInstanceOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowInstances.
	Field WorkflowInstanceOrderField `json:"field"`
}

// Return response for updateWorkflowInstance mutation
type WorkflowInstanceUpdatePayload struct {
	// Updated workflowInstance
	WorkflowInstance *WorkflowInstance `json:"workflowInstance"`
}

// WorkflowInstanceWhereInput is used for filtering WorkflowInstance objects.
// Input was generated by ent.
type WorkflowInstanceWhereInput struct {
	Not *WorkflowInstanceWhereInput   `json:"not,omitempty"`
	And []*WorkflowInstanceWhereInput `json:"and,omitempty"`
	Or  []*WorkflowInstanceWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_definition_id field predicates
	WorkflowDefinitionID             *string  `json:"workflowDefinitionID,omitempty"`
	WorkflowDefinitionIdneq          *string  `json:"workflowDefinitionIDNEQ,omitempty"`
	WorkflowDefinitionIDIn           []string `json:"workflowDefinitionIDIn,omitempty"`
	WorkflowDefinitionIDNotIn        []string `json:"workflowDefinitionIDNotIn,omitempty"`
	WorkflowDefinitionIdgt           *string  `json:"workflowDefinitionIDGT,omitempty"`
	WorkflowDefinitionIdgte          *string  `json:"workflowDefinitionIDGTE,omitempty"`
	WorkflowDefinitionIdlt           *string  `json:"workflowDefinitionIDLT,omitempty"`
	WorkflowDefinitionIdlte          *string  `json:"workflowDefinitionIDLTE,omitempty"`
	WorkflowDefinitionIDContains     *string  `json:"workflowDefinitionIDContains,omitempty"`
	WorkflowDefinitionIDHasPrefix    *string  `json:"workflowDefinitionIDHasPrefix,omitempty"`
	WorkflowDefinitionIDHasSuffix    *string  `json:"workflowDefinitionIDHasSuffix,omitempty"`
	WorkflowDefinitionIDEqualFold    *string  `json:"workflowDefinitionIDEqualFold,omitempty"`
	WorkflowDefinitionIDContainsFold *string  `json:"workflowDefinitionIDContainsFold,omitempty"`
	// state field predicates
	State      *enums.WorkflowInstanceState  `json:"state,omitempty"`
	StateNeq   *enums.WorkflowInstanceState  `json:"stateNEQ,omitempty"`
	StateIn    []enums.WorkflowInstanceState `json:"stateIn,omitempty"`
	StateNotIn []enums.WorkflowInstanceState `json:"stateNotIn,omitempty"`
	// last_evaluated_at field predicates
	LastEvaluatedAt       *time.Time   `json:"lastEvaluatedAt,omitempty"`
	LastEvaluatedAtNeq    *time.Time   `json:"lastEvaluatedAtNEQ,omitempty"`
	LastEvaluatedAtIn     []*time.Time `json:"lastEvaluatedAtIn,omitempty"`
	LastEvaluatedAtNotIn  []*time.Time `json:"lastEvaluatedAtNotIn,omitempty"`
	LastEvaluatedAtGt     *time.Time   `json:"lastEvaluatedAtGT,omitempty"`
	LastEvaluatedAtGte    *time.Time   `json:"lastEvaluatedAtGTE,omitempty"`
	LastEvaluatedAtLt     *time.Time   `json:"lastEvaluatedAtLT,omitempty"`
	LastEvaluatedAtLte    *time.Time   `json:"lastEvaluatedAtLTE,omitempty"`
	LastEvaluatedAtIsNil  *bool        `json:"lastEvaluatedAtIsNil,omitempty"`
	LastEvaluatedAtNotNil *bool        `json:"lastEvaluatedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// workflow_definition edge predicates
	HasWorkflowDefinition     *bool                           `json:"hasWorkflowDefinition,omitempty"`
	HasWorkflowDefinitionWith []*WorkflowDefinitionWhereInput `json:"hasWorkflowDefinitionWith,omitempty"`
	// workflow_assignments edge predicates
	HasWorkflowAssignments     *bool                           `json:"hasWorkflowAssignments,omitempty"`
	HasWorkflowAssignmentsWith []*WorkflowAssignmentWhereInput `json:"hasWorkflowAssignmentsWith,omitempty"`
	// workflow_events edge predicates
	HasWorkflowEvents     *bool                      `json:"hasWorkflowEvents,omitempty"`
	HasWorkflowEventsWith []*WorkflowEventWhereInput `json:"hasWorkflowEventsWith,omitempty"`
	// workflow_object_refs edge predicates
	HasWorkflowObjectRefs     *bool                          `json:"hasWorkflowObjectRefs,omitempty"`
	HasWorkflowObjectRefsWith []*WorkflowObjectRefWhereInput `json:"hasWorkflowObjectRefsWith,omitempty"`
}

type WorkflowObjectRef struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// Workflow instance this object is associated with
	WorkflowInstanceID string `json:"workflowInstanceID"`
	// Control referenced by this workflow instance
	ControlID *string `json:"controlID,omitempty"`
	// Task referenced by this workflow instance
	TaskID *string `json:"taskID,omitempty"`
	// Policy referenced by this workflow instance
	InternalPolicyID *string `json:"internalPolicyID,omitempty"`
	// Finding referenced by this workflow instance
	FindingID *string `json:"findingID,omitempty"`
	// Directory account referenced by this workflow instance
	DirectoryAccountID *string `json:"directoryAccountID,omitempty"`
	// Directory group referenced by this workflow instance
	DirectoryGroupID *string `json:"directoryGroupID,omitempty"`
	// Directory membership referenced by this workflow instance
	DirectoryMembershipID *string       `json:"directoryMembershipID,omitempty"`
	Owner                 *Organization `json:"owner,omitempty"`
	// Workflow instance this object is associated with
	WorkflowInstance *WorkflowInstance `json:"workflowInstance"`
	// Control referenced by this workflow instance
	Control *Control `json:"control,omitempty"`
	// Task referenced by this workflow instance
	Task *Task `json:"task,omitempty"`
	// Policy referenced by this workflow instance
	InternalPolicy *InternalPolicy `json:"internalPolicy,omitempty"`
	// Finding referenced by this workflow instance
	Finding *Finding `json:"finding,omitempty"`
	// Directory account referenced by this workflow instance
	DirectoryAccount *DirectoryAccount `json:"directoryAccount,omitempty"`
	// Directory group referenced by this workflow instance
	DirectoryGroup *DirectoryGroup `json:"directoryGroup,omitempty"`
	// Directory membership referenced by this workflow instance
	DirectoryMembership *DirectoryMembership `json:"directoryMembership,omitempty"`
}

func (WorkflowObjectRef) IsNode() {}

// Return response for createBulkWorkflowObjectRef mutation
type WorkflowObjectRefBulkCreatePayload struct {
	// Created workflowObjectRefs
	WorkflowObjectRefs []*WorkflowObjectRef `json:"workflowObjectRefs,omitempty"`
}

// A connection to a list of items.
type WorkflowObjectRefConnection struct {
	// A list of edges.
	Edges []*WorkflowObjectRefEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createWorkflowObjectRef mutation
type WorkflowObjectRefCreatePayload struct {
	// Created workflowObjectRef
	WorkflowObjectRef *WorkflowObjectRef `json:"workflowObjectRef"`
}

// Return response for deleteWorkflowObjectRef mutation
type WorkflowObjectRefDeletePayload struct {
	// Deleted workflowObjectRef ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WorkflowObjectRefEdge struct {
	// The item at the end of the edge.
	Node *WorkflowObjectRef `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type WorkflowObjectRefHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// Workflow instance this object is associated with
	WorkflowInstanceID string `json:"workflowInstanceID"`
	// Control referenced by this workflow instance
	ControlID *string `json:"controlID,omitempty"`
	// Task referenced by this workflow instance
	TaskID *string `json:"taskID,omitempty"`
	// Policy referenced by this workflow instance
	InternalPolicyID *string `json:"internalPolicyID,omitempty"`
	// Finding referenced by this workflow instance
	FindingID *string `json:"findingID,omitempty"`
	// Directory account referenced by this workflow instance
	DirectoryAccountID *string `json:"directoryAccountID,omitempty"`
	// Directory group referenced by this workflow instance
	DirectoryGroupID *string `json:"directoryGroupID,omitempty"`
	// Directory membership referenced by this workflow instance
	DirectoryMembershipID *string `json:"directoryMembershipID,omitempty"`
}

func (WorkflowObjectRefHistory) IsNode() {}

// A connection to a list of items.
type WorkflowObjectRefHistoryConnection struct {
	// A list of edges.
	Edges []*WorkflowObjectRefHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type WorkflowObjectRefHistoryEdge struct {
	// The item at the end of the edge.
	Node *WorkflowObjectRefHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for WorkflowObjectRefHistory connections
type WorkflowObjectRefHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowObjectRefHistories.
	Field WorkflowObjectRefHistoryOrderField `json:"field"`
}

// WorkflowObjectRefHistoryWhereInput is used for filtering WorkflowObjectRefHistory objects.
// Input was generated by ent.
type WorkflowObjectRefHistoryWhereInput struct {
	Not *WorkflowObjectRefHistoryWhereInput   `json:"not,omitempty"`
	And []*WorkflowObjectRefHistoryWhereInput `json:"and,omitempty"`
	Or  []*WorkflowObjectRefHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_instance_id field predicates
	WorkflowInstanceID             *string  `json:"workflowInstanceID,omitempty"`
	WorkflowInstanceIdneq          *string  `json:"workflowInstanceIDNEQ,omitempty"`
	WorkflowInstanceIDIn           []string `json:"workflowInstanceIDIn,omitempty"`
	WorkflowInstanceIDNotIn        []string `json:"workflowInstanceIDNotIn,omitempty"`
	WorkflowInstanceIdgt           *string  `json:"workflowInstanceIDGT,omitempty"`
	WorkflowInstanceIdgte          *string  `json:"workflowInstanceIDGTE,omitempty"`
	WorkflowInstanceIdlt           *string  `json:"workflowInstanceIDLT,omitempty"`
	WorkflowInstanceIdlte          *string  `json:"workflowInstanceIDLTE,omitempty"`
	WorkflowInstanceIDContains     *string  `json:"workflowInstanceIDContains,omitempty"`
	WorkflowInstanceIDHasPrefix    *string  `json:"workflowInstanceIDHasPrefix,omitempty"`
	WorkflowInstanceIDHasSuffix    *string  `json:"workflowInstanceIDHasSuffix,omitempty"`
	WorkflowInstanceIDEqualFold    *string  `json:"workflowInstanceIDEqualFold,omitempty"`
	WorkflowInstanceIDContainsFold *string  `json:"workflowInstanceIDContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDIsNil        *bool    `json:"controlIDIsNil,omitempty"`
	ControlIDNotNil       *bool    `json:"controlIDNotNil,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
	// task_id field predicates
	TaskID             *string  `json:"taskID,omitempty"`
	TaskIdneq          *string  `json:"taskIDNEQ,omitempty"`
	TaskIDIn           []string `json:"taskIDIn,omitempty"`
	TaskIDNotIn        []string `json:"taskIDNotIn,omitempty"`
	TaskIdgt           *string  `json:"taskIDGT,omitempty"`
	TaskIdgte          *string  `json:"taskIDGTE,omitempty"`
	TaskIdlt           *string  `json:"taskIDLT,omitempty"`
	TaskIdlte          *string  `json:"taskIDLTE,omitempty"`
	TaskIDContains     *string  `json:"taskIDContains,omitempty"`
	TaskIDHasPrefix    *string  `json:"taskIDHasPrefix,omitempty"`
	TaskIDHasSuffix    *string  `json:"taskIDHasSuffix,omitempty"`
	TaskIDIsNil        *bool    `json:"taskIDIsNil,omitempty"`
	TaskIDNotNil       *bool    `json:"taskIDNotNil,omitempty"`
	TaskIDEqualFold    *string  `json:"taskIDEqualFold,omitempty"`
	TaskIDContainsFold *string  `json:"taskIDContainsFold,omitempty"`
	// internal_policy_id field predicates
	InternalPolicyID             *string  `json:"internalPolicyID,omitempty"`
	InternalPolicyIdneq          *string  `json:"internalPolicyIDNEQ,omitempty"`
	InternalPolicyIDIn           []string `json:"internalPolicyIDIn,omitempty"`
	InternalPolicyIDNotIn        []string `json:"internalPolicyIDNotIn,omitempty"`
	InternalPolicyIdgt           *string  `json:"internalPolicyIDGT,omitempty"`
	InternalPolicyIdgte          *string  `json:"internalPolicyIDGTE,omitempty"`
	InternalPolicyIdlt           *string  `json:"internalPolicyIDLT,omitempty"`
	InternalPolicyIdlte          *string  `json:"internalPolicyIDLTE,omitempty"`
	InternalPolicyIDContains     *string  `json:"internalPolicyIDContains,omitempty"`
	InternalPolicyIDHasPrefix    *string  `json:"internalPolicyIDHasPrefix,omitempty"`
	InternalPolicyIDHasSuffix    *string  `json:"internalPolicyIDHasSuffix,omitempty"`
	InternalPolicyIDIsNil        *bool    `json:"internalPolicyIDIsNil,omitempty"`
	InternalPolicyIDNotNil       *bool    `json:"internalPolicyIDNotNil,omitempty"`
	InternalPolicyIDEqualFold    *string  `json:"internalPolicyIDEqualFold,omitempty"`
	InternalPolicyIDContainsFold *string  `json:"internalPolicyIDContainsFold,omitempty"`
	// finding_id field predicates
	FindingID             *string  `json:"findingID,omitempty"`
	FindingIdneq          *string  `json:"findingIDNEQ,omitempty"`
	FindingIDIn           []string `json:"findingIDIn,omitempty"`
	FindingIDNotIn        []string `json:"findingIDNotIn,omitempty"`
	FindingIdgt           *string  `json:"findingIDGT,omitempty"`
	FindingIdgte          *string  `json:"findingIDGTE,omitempty"`
	FindingIdlt           *string  `json:"findingIDLT,omitempty"`
	FindingIdlte          *string  `json:"findingIDLTE,omitempty"`
	FindingIDContains     *string  `json:"findingIDContains,omitempty"`
	FindingIDHasPrefix    *string  `json:"findingIDHasPrefix,omitempty"`
	FindingIDHasSuffix    *string  `json:"findingIDHasSuffix,omitempty"`
	FindingIDIsNil        *bool    `json:"findingIDIsNil,omitempty"`
	FindingIDNotNil       *bool    `json:"findingIDNotNil,omitempty"`
	FindingIDEqualFold    *string  `json:"findingIDEqualFold,omitempty"`
	FindingIDContainsFold *string  `json:"findingIDContainsFold,omitempty"`
	// directory_account_id field predicates
	DirectoryAccountID             *string  `json:"directoryAccountID,omitempty"`
	DirectoryAccountIdneq          *string  `json:"directoryAccountIDNEQ,omitempty"`
	DirectoryAccountIDIn           []string `json:"directoryAccountIDIn,omitempty"`
	DirectoryAccountIDNotIn        []string `json:"directoryAccountIDNotIn,omitempty"`
	DirectoryAccountIdgt           *string  `json:"directoryAccountIDGT,omitempty"`
	DirectoryAccountIdgte          *string  `json:"directoryAccountIDGTE,omitempty"`
	DirectoryAccountIdlt           *string  `json:"directoryAccountIDLT,omitempty"`
	DirectoryAccountIdlte          *string  `json:"directoryAccountIDLTE,omitempty"`
	DirectoryAccountIDContains     *string  `json:"directoryAccountIDContains,omitempty"`
	DirectoryAccountIDHasPrefix    *string  `json:"directoryAccountIDHasPrefix,omitempty"`
	DirectoryAccountIDHasSuffix    *string  `json:"directoryAccountIDHasSuffix,omitempty"`
	DirectoryAccountIDIsNil        *bool    `json:"directoryAccountIDIsNil,omitempty"`
	DirectoryAccountIDNotNil       *bool    `json:"directoryAccountIDNotNil,omitempty"`
	DirectoryAccountIDEqualFold    *string  `json:"directoryAccountIDEqualFold,omitempty"`
	DirectoryAccountIDContainsFold *string  `json:"directoryAccountIDContainsFold,omitempty"`
	// directory_group_id field predicates
	DirectoryGroupID             *string  `json:"directoryGroupID,omitempty"`
	DirectoryGroupIdneq          *string  `json:"directoryGroupIDNEQ,omitempty"`
	DirectoryGroupIDIn           []string `json:"directoryGroupIDIn,omitempty"`
	DirectoryGroupIDNotIn        []string `json:"directoryGroupIDNotIn,omitempty"`
	DirectoryGroupIdgt           *string  `json:"directoryGroupIDGT,omitempty"`
	DirectoryGroupIdgte          *string  `json:"directoryGroupIDGTE,omitempty"`
	DirectoryGroupIdlt           *string  `json:"directoryGroupIDLT,omitempty"`
	DirectoryGroupIdlte          *string  `json:"directoryGroupIDLTE,omitempty"`
	DirectoryGroupIDContains     *string  `json:"directoryGroupIDContains,omitempty"`
	DirectoryGroupIDHasPrefix    *string  `json:"directoryGroupIDHasPrefix,omitempty"`
	DirectoryGroupIDHasSuffix    *string  `json:"directoryGroupIDHasSuffix,omitempty"`
	DirectoryGroupIDIsNil        *bool    `json:"directoryGroupIDIsNil,omitempty"`
	DirectoryGroupIDNotNil       *bool    `json:"directoryGroupIDNotNil,omitempty"`
	DirectoryGroupIDEqualFold    *string  `json:"directoryGroupIDEqualFold,omitempty"`
	DirectoryGroupIDContainsFold *string  `json:"directoryGroupIDContainsFold,omitempty"`
	// directory_membership_id field predicates
	DirectoryMembershipID             *string  `json:"directoryMembershipID,omitempty"`
	DirectoryMembershipIdneq          *string  `json:"directoryMembershipIDNEQ,omitempty"`
	DirectoryMembershipIDIn           []string `json:"directoryMembershipIDIn,omitempty"`
	DirectoryMembershipIDNotIn        []string `json:"directoryMembershipIDNotIn,omitempty"`
	DirectoryMembershipIdgt           *string  `json:"directoryMembershipIDGT,omitempty"`
	DirectoryMembershipIdgte          *string  `json:"directoryMembershipIDGTE,omitempty"`
	DirectoryMembershipIdlt           *string  `json:"directoryMembershipIDLT,omitempty"`
	DirectoryMembershipIdlte          *string  `json:"directoryMembershipIDLTE,omitempty"`
	DirectoryMembershipIDContains     *string  `json:"directoryMembershipIDContains,omitempty"`
	DirectoryMembershipIDHasPrefix    *string  `json:"directoryMembershipIDHasPrefix,omitempty"`
	DirectoryMembershipIDHasSuffix    *string  `json:"directoryMembershipIDHasSuffix,omitempty"`
	DirectoryMembershipIDIsNil        *bool    `json:"directoryMembershipIDIsNil,omitempty"`
	DirectoryMembershipIDNotNil       *bool    `json:"directoryMembershipIDNotNil,omitempty"`
	DirectoryMembershipIDEqualFold    *string  `json:"directoryMembershipIDEqualFold,omitempty"`
	DirectoryMembershipIDContainsFold *string  `json:"directoryMembershipIDContainsFold,omitempty"`
}

// Ordering options for WorkflowObjectRef connections
type WorkflowObjectRefOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WorkflowObjectRefs.
	Field WorkflowObjectRefOrderField `json:"field"`
}

// Return response for updateWorkflowObjectRef mutation
type WorkflowObjectRefUpdatePayload struct {
	// Updated workflowObjectRef
	WorkflowObjectRef *WorkflowObjectRef `json:"workflowObjectRef"`
}

// WorkflowObjectRefWhereInput is used for filtering WorkflowObjectRef objects.
// Input was generated by ent.
type WorkflowObjectRefWhereInput struct {
	Not *WorkflowObjectRefWhereInput   `json:"not,omitempty"`
	And []*WorkflowObjectRefWhereInput `json:"and,omitempty"`
	Or  []*WorkflowObjectRefWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// workflow_instance_id field predicates
	WorkflowInstanceID             *string  `json:"workflowInstanceID,omitempty"`
	WorkflowInstanceIdneq          *string  `json:"workflowInstanceIDNEQ,omitempty"`
	WorkflowInstanceIDIn           []string `json:"workflowInstanceIDIn,omitempty"`
	WorkflowInstanceIDNotIn        []string `json:"workflowInstanceIDNotIn,omitempty"`
	WorkflowInstanceIdgt           *string  `json:"workflowInstanceIDGT,omitempty"`
	WorkflowInstanceIdgte          *string  `json:"workflowInstanceIDGTE,omitempty"`
	WorkflowInstanceIdlt           *string  `json:"workflowInstanceIDLT,omitempty"`
	WorkflowInstanceIdlte          *string  `json:"workflowInstanceIDLTE,omitempty"`
	WorkflowInstanceIDContains     *string  `json:"workflowInstanceIDContains,omitempty"`
	WorkflowInstanceIDHasPrefix    *string  `json:"workflowInstanceIDHasPrefix,omitempty"`
	WorkflowInstanceIDHasSuffix    *string  `json:"workflowInstanceIDHasSuffix,omitempty"`
	WorkflowInstanceIDEqualFold    *string  `json:"workflowInstanceIDEqualFold,omitempty"`
	WorkflowInstanceIDContainsFold *string  `json:"workflowInstanceIDContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDIsNil        *bool    `json:"controlIDIsNil,omitempty"`
	ControlIDNotNil       *bool    `json:"controlIDNotNil,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
	// task_id field predicates
	TaskID             *string  `json:"taskID,omitempty"`
	TaskIdneq          *string  `json:"taskIDNEQ,omitempty"`
	TaskIDIn           []string `json:"taskIDIn,omitempty"`
	TaskIDNotIn        []string `json:"taskIDNotIn,omitempty"`
	TaskIdgt           *string  `json:"taskIDGT,omitempty"`
	TaskIdgte          *string  `json:"taskIDGTE,omitempty"`
	TaskIdlt           *string  `json:"taskIDLT,omitempty"`
	TaskIdlte          *string  `json:"taskIDLTE,omitempty"`
	TaskIDContains     *string  `json:"taskIDContains,omitempty"`
	TaskIDHasPrefix    *string  `json:"taskIDHasPrefix,omitempty"`
	TaskIDHasSuffix    *string  `json:"taskIDHasSuffix,omitempty"`
	TaskIDIsNil        *bool    `json:"taskIDIsNil,omitempty"`
	TaskIDNotNil       *bool    `json:"taskIDNotNil,omitempty"`
	TaskIDEqualFold    *string  `json:"taskIDEqualFold,omitempty"`
	TaskIDContainsFold *string  `json:"taskIDContainsFold,omitempty"`
	// internal_policy_id field predicates
	InternalPolicyID             *string  `json:"internalPolicyID,omitempty"`
	InternalPolicyIdneq          *string  `json:"internalPolicyIDNEQ,omitempty"`
	InternalPolicyIDIn           []string `json:"internalPolicyIDIn,omitempty"`
	InternalPolicyIDNotIn        []string `json:"internalPolicyIDNotIn,omitempty"`
	InternalPolicyIdgt           *string  `json:"internalPolicyIDGT,omitempty"`
	InternalPolicyIdgte          *string  `json:"internalPolicyIDGTE,omitempty"`
	InternalPolicyIdlt           *string  `json:"internalPolicyIDLT,omitempty"`
	InternalPolicyIdlte          *string  `json:"internalPolicyIDLTE,omitempty"`
	InternalPolicyIDContains     *string  `json:"internalPolicyIDContains,omitempty"`
	InternalPolicyIDHasPrefix    *string  `json:"internalPolicyIDHasPrefix,omitempty"`
	InternalPolicyIDHasSuffix    *string  `json:"internalPolicyIDHasSuffix,omitempty"`
	InternalPolicyIDIsNil        *bool    `json:"internalPolicyIDIsNil,omitempty"`
	InternalPolicyIDNotNil       *bool    `json:"internalPolicyIDNotNil,omitempty"`
	InternalPolicyIDEqualFold    *string  `json:"internalPolicyIDEqualFold,omitempty"`
	InternalPolicyIDContainsFold *string  `json:"internalPolicyIDContainsFold,omitempty"`
	// finding_id field predicates
	FindingID             *string  `json:"findingID,omitempty"`
	FindingIdneq          *string  `json:"findingIDNEQ,omitempty"`
	FindingIDIn           []string `json:"findingIDIn,omitempty"`
	FindingIDNotIn        []string `json:"findingIDNotIn,omitempty"`
	FindingIdgt           *string  `json:"findingIDGT,omitempty"`
	FindingIdgte          *string  `json:"findingIDGTE,omitempty"`
	FindingIdlt           *string  `json:"findingIDLT,omitempty"`
	FindingIdlte          *string  `json:"findingIDLTE,omitempty"`
	FindingIDContains     *string  `json:"findingIDContains,omitempty"`
	FindingIDHasPrefix    *string  `json:"findingIDHasPrefix,omitempty"`
	FindingIDHasSuffix    *string  `json:"findingIDHasSuffix,omitempty"`
	FindingIDIsNil        *bool    `json:"findingIDIsNil,omitempty"`
	FindingIDNotNil       *bool    `json:"findingIDNotNil,omitempty"`
	FindingIDEqualFold    *string  `json:"findingIDEqualFold,omitempty"`
	FindingIDContainsFold *string  `json:"findingIDContainsFold,omitempty"`
	// directory_account_id field predicates
	DirectoryAccountID             *string  `json:"directoryAccountID,omitempty"`
	DirectoryAccountIdneq          *string  `json:"directoryAccountIDNEQ,omitempty"`
	DirectoryAccountIDIn           []string `json:"directoryAccountIDIn,omitempty"`
	DirectoryAccountIDNotIn        []string `json:"directoryAccountIDNotIn,omitempty"`
	DirectoryAccountIdgt           *string  `json:"directoryAccountIDGT,omitempty"`
	DirectoryAccountIdgte          *string  `json:"directoryAccountIDGTE,omitempty"`
	DirectoryAccountIdlt           *string  `json:"directoryAccountIDLT,omitempty"`
	DirectoryAccountIdlte          *string  `json:"directoryAccountIDLTE,omitempty"`
	DirectoryAccountIDContains     *string  `json:"directoryAccountIDContains,omitempty"`
	DirectoryAccountIDHasPrefix    *string  `json:"directoryAccountIDHasPrefix,omitempty"`
	DirectoryAccountIDHasSuffix    *string  `json:"directoryAccountIDHasSuffix,omitempty"`
	DirectoryAccountIDIsNil        *bool    `json:"directoryAccountIDIsNil,omitempty"`
	DirectoryAccountIDNotNil       *bool    `json:"directoryAccountIDNotNil,omitempty"`
	DirectoryAccountIDEqualFold    *string  `json:"directoryAccountIDEqualFold,omitempty"`
	DirectoryAccountIDContainsFold *string  `json:"directoryAccountIDContainsFold,omitempty"`
	// directory_group_id field predicates
	DirectoryGroupID             *string  `json:"directoryGroupID,omitempty"`
	DirectoryGroupIdneq          *string  `json:"directoryGroupIDNEQ,omitempty"`
	DirectoryGroupIDIn           []string `json:"directoryGroupIDIn,omitempty"`
	DirectoryGroupIDNotIn        []string `json:"directoryGroupIDNotIn,omitempty"`
	DirectoryGroupIdgt           *string  `json:"directoryGroupIDGT,omitempty"`
	DirectoryGroupIdgte          *string  `json:"directoryGroupIDGTE,omitempty"`
	DirectoryGroupIdlt           *string  `json:"directoryGroupIDLT,omitempty"`
	DirectoryGroupIdlte          *string  `json:"directoryGroupIDLTE,omitempty"`
	DirectoryGroupIDContains     *string  `json:"directoryGroupIDContains,omitempty"`
	DirectoryGroupIDHasPrefix    *string  `json:"directoryGroupIDHasPrefix,omitempty"`
	DirectoryGroupIDHasSuffix    *string  `json:"directoryGroupIDHasSuffix,omitempty"`
	DirectoryGroupIDIsNil        *bool    `json:"directoryGroupIDIsNil,omitempty"`
	DirectoryGroupIDNotNil       *bool    `json:"directoryGroupIDNotNil,omitempty"`
	DirectoryGroupIDEqualFold    *string  `json:"directoryGroupIDEqualFold,omitempty"`
	DirectoryGroupIDContainsFold *string  `json:"directoryGroupIDContainsFold,omitempty"`
	// directory_membership_id field predicates
	DirectoryMembershipID             *string  `json:"directoryMembershipID,omitempty"`
	DirectoryMembershipIdneq          *string  `json:"directoryMembershipIDNEQ,omitempty"`
	DirectoryMembershipIDIn           []string `json:"directoryMembershipIDIn,omitempty"`
	DirectoryMembershipIDNotIn        []string `json:"directoryMembershipIDNotIn,omitempty"`
	DirectoryMembershipIdgt           *string  `json:"directoryMembershipIDGT,omitempty"`
	DirectoryMembershipIdgte          *string  `json:"directoryMembershipIDGTE,omitempty"`
	DirectoryMembershipIdlt           *string  `json:"directoryMembershipIDLT,omitempty"`
	DirectoryMembershipIdlte          *string  `json:"directoryMembershipIDLTE,omitempty"`
	DirectoryMembershipIDContains     *string  `json:"directoryMembershipIDContains,omitempty"`
	DirectoryMembershipIDHasPrefix    *string  `json:"directoryMembershipIDHasPrefix,omitempty"`
	DirectoryMembershipIDHasSuffix    *string  `json:"directoryMembershipIDHasSuffix,omitempty"`
	DirectoryMembershipIDIsNil        *bool    `json:"directoryMembershipIDIsNil,omitempty"`
	DirectoryMembershipIDNotNil       *bool    `json:"directoryMembershipIDNotNil,omitempty"`
	DirectoryMembershipIDEqualFold    *string  `json:"directoryMembershipIDEqualFold,omitempty"`
	DirectoryMembershipIDContainsFold *string  `json:"directoryMembershipIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// workflow_instance edge predicates
	HasWorkflowInstance     *bool                         `json:"hasWorkflowInstance,omitempty"`
	HasWorkflowInstanceWith []*WorkflowInstanceWhereInput `json:"hasWorkflowInstanceWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// task edge predicates
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`
	// internal_policy edge predicates
	HasInternalPolicy     *bool                       `json:"hasInternalPolicy,omitempty"`
	HasInternalPolicyWith []*InternalPolicyWhereInput `json:"hasInternalPolicyWith,omitempty"`
	// finding edge predicates
	HasFinding     *bool                `json:"hasFinding,omitempty"`
	HasFindingWith []*FindingWhereInput `json:"hasFindingWith,omitempty"`
	// directory_account edge predicates
	HasDirectoryAccount     *bool                         `json:"hasDirectoryAccount,omitempty"`
	HasDirectoryAccountWith []*DirectoryAccountWhereInput `json:"hasDirectoryAccountWith,omitempty"`
	// directory_group edge predicates
	HasDirectoryGroup     *bool                       `json:"hasDirectoryGroup,omitempty"`
	HasDirectoryGroupWith []*DirectoryGroupWhereInput `json:"hasDirectoryGroupWith,omitempty"`
	// directory_membership edge predicates
	HasDirectoryMembership     *bool                            `json:"hasDirectoryMembership,omitempty"`
	HasDirectoryMembershipWith []*DirectoryMembershipWhereInput `json:"hasDirectoryMembershipWith,omitempty"`
}

// Properties by which APIToken connections can be ordered.
type APITokenOrderField string

const (
	APITokenOrderFieldCreatedAt  APITokenOrderField = "created_at"
	APITokenOrderFieldUpdatedAt  APITokenOrderField = "updated_at"
	APITokenOrderFieldName       APITokenOrderField = "name"
	APITokenOrderFieldExpiresAt  APITokenOrderField = "expires_at"
	APITokenOrderFieldLastUsedAt APITokenOrderField = "last_used_at"
	APITokenOrderFieldIsActive   APITokenOrderField = "is_active"
)

var AllAPITokenOrderField = []APITokenOrderField{
	APITokenOrderFieldCreatedAt,
	APITokenOrderFieldUpdatedAt,
	APITokenOrderFieldName,
	APITokenOrderFieldExpiresAt,
	APITokenOrderFieldLastUsedAt,
	APITokenOrderFieldIsActive,
}

func (e APITokenOrderField) IsValid() bool {
	switch e {
	case APITokenOrderFieldCreatedAt, APITokenOrderFieldUpdatedAt, APITokenOrderFieldName, APITokenOrderFieldExpiresAt, APITokenOrderFieldLastUsedAt, APITokenOrderFieldIsActive:
		return true
	}
	return false
}

func (e APITokenOrderField) String() string {
	return string(e)
}

func (e *APITokenOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APITokenOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid APITokenOrderField", str)
	}
	return nil
}

func (e APITokenOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *APITokenOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e APITokenOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ActionPlanHistory connections can be ordered.
type ActionPlanHistoryOrderField string

const (
	ActionPlanHistoryOrderFieldHistoryTime     ActionPlanHistoryOrderField = "history_time"
	ActionPlanHistoryOrderFieldCreatedAt       ActionPlanHistoryOrderField = "created_at"
	ActionPlanHistoryOrderFieldUpdatedAt       ActionPlanHistoryOrderField = "updated_at"
	ActionPlanHistoryOrderFieldRevision        ActionPlanHistoryOrderField = "revision"
	ActionPlanHistoryOrderFieldName            ActionPlanHistoryOrderField = "name"
	ActionPlanHistoryOrderFieldStatus          ActionPlanHistoryOrderField = "STATUS"
	ActionPlanHistoryOrderFieldReviewDue       ActionPlanHistoryOrderField = "review_due"
	ActionPlanHistoryOrderFieldReviewFrequency ActionPlanHistoryOrderField = "REVIEW_FREQUENCY"
	ActionPlanHistoryOrderFieldTitle           ActionPlanHistoryOrderField = "title"
	ActionPlanHistoryOrderFieldDueDate         ActionPlanHistoryOrderField = "due_date"
	ActionPlanHistoryOrderFieldPriority        ActionPlanHistoryOrderField = "PRIORITY"
	ActionPlanHistoryOrderFieldSource          ActionPlanHistoryOrderField = "source"
)

var AllActionPlanHistoryOrderField = []ActionPlanHistoryOrderField{
	ActionPlanHistoryOrderFieldHistoryTime,
	ActionPlanHistoryOrderFieldCreatedAt,
	ActionPlanHistoryOrderFieldUpdatedAt,
	ActionPlanHistoryOrderFieldRevision,
	ActionPlanHistoryOrderFieldName,
	ActionPlanHistoryOrderFieldStatus,
	ActionPlanHistoryOrderFieldReviewDue,
	ActionPlanHistoryOrderFieldReviewFrequency,
	ActionPlanHistoryOrderFieldTitle,
	ActionPlanHistoryOrderFieldDueDate,
	ActionPlanHistoryOrderFieldPriority,
	ActionPlanHistoryOrderFieldSource,
}

func (e ActionPlanHistoryOrderField) IsValid() bool {
	switch e {
	case ActionPlanHistoryOrderFieldHistoryTime, ActionPlanHistoryOrderFieldCreatedAt, ActionPlanHistoryOrderFieldUpdatedAt, ActionPlanHistoryOrderFieldRevision, ActionPlanHistoryOrderFieldName, ActionPlanHistoryOrderFieldStatus, ActionPlanHistoryOrderFieldReviewDue, ActionPlanHistoryOrderFieldReviewFrequency, ActionPlanHistoryOrderFieldTitle, ActionPlanHistoryOrderFieldDueDate, ActionPlanHistoryOrderFieldPriority, ActionPlanHistoryOrderFieldSource:
		return true
	}
	return false
}

func (e ActionPlanHistoryOrderField) String() string {
	return string(e)
}

func (e *ActionPlanHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionPlanHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionPlanHistoryOrderField", str)
	}
	return nil
}

func (e ActionPlanHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ActionPlanHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ActionPlanHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ActionPlan connections can be ordered.
type ActionPlanOrderField string

const (
	ActionPlanOrderFieldCreatedAt       ActionPlanOrderField = "created_at"
	ActionPlanOrderFieldUpdatedAt       ActionPlanOrderField = "updated_at"
	ActionPlanOrderFieldRevision        ActionPlanOrderField = "revision"
	ActionPlanOrderFieldName            ActionPlanOrderField = "name"
	ActionPlanOrderFieldStatus          ActionPlanOrderField = "STATUS"
	ActionPlanOrderFieldReviewDue       ActionPlanOrderField = "review_due"
	ActionPlanOrderFieldReviewFrequency ActionPlanOrderField = "REVIEW_FREQUENCY"
	ActionPlanOrderFieldTitle           ActionPlanOrderField = "title"
	ActionPlanOrderFieldDueDate         ActionPlanOrderField = "due_date"
	ActionPlanOrderFieldPriority        ActionPlanOrderField = "PRIORITY"
	ActionPlanOrderFieldSource          ActionPlanOrderField = "source"
)

var AllActionPlanOrderField = []ActionPlanOrderField{
	ActionPlanOrderFieldCreatedAt,
	ActionPlanOrderFieldUpdatedAt,
	ActionPlanOrderFieldRevision,
	ActionPlanOrderFieldName,
	ActionPlanOrderFieldStatus,
	ActionPlanOrderFieldReviewDue,
	ActionPlanOrderFieldReviewFrequency,
	ActionPlanOrderFieldTitle,
	ActionPlanOrderFieldDueDate,
	ActionPlanOrderFieldPriority,
	ActionPlanOrderFieldSource,
}

func (e ActionPlanOrderField) IsValid() bool {
	switch e {
	case ActionPlanOrderFieldCreatedAt, ActionPlanOrderFieldUpdatedAt, ActionPlanOrderFieldRevision, ActionPlanOrderFieldName, ActionPlanOrderFieldStatus, ActionPlanOrderFieldReviewDue, ActionPlanOrderFieldReviewFrequency, ActionPlanOrderFieldTitle, ActionPlanOrderFieldDueDate, ActionPlanOrderFieldPriority, ActionPlanOrderFieldSource:
		return true
	}
	return false
}

func (e ActionPlanOrderField) String() string {
	return string(e)
}

func (e *ActionPlanOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionPlanOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionPlanOrderField", str)
	}
	return nil
}

func (e ActionPlanOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ActionPlanOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ActionPlanOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which AssessmentHistory connections can be ordered.
type AssessmentHistoryOrderField string

const (
	AssessmentHistoryOrderFieldHistoryTime         AssessmentHistoryOrderField = "history_time"
	AssessmentHistoryOrderFieldCreatedAt           AssessmentHistoryOrderField = "created_at"
	AssessmentHistoryOrderFieldUpdatedAt           AssessmentHistoryOrderField = "updated_at"
	AssessmentHistoryOrderFieldName                AssessmentHistoryOrderField = "name"
	AssessmentHistoryOrderFieldAssessmentType      AssessmentHistoryOrderField = "assessment_type"
	AssessmentHistoryOrderFieldResponseDueDuration AssessmentHistoryOrderField = "response_due_duration"
)

var AllAssessmentHistoryOrderField = []AssessmentHistoryOrderField{
	AssessmentHistoryOrderFieldHistoryTime,
	AssessmentHistoryOrderFieldCreatedAt,
	AssessmentHistoryOrderFieldUpdatedAt,
	AssessmentHistoryOrderFieldName,
	AssessmentHistoryOrderFieldAssessmentType,
	AssessmentHistoryOrderFieldResponseDueDuration,
}

func (e AssessmentHistoryOrderField) IsValid() bool {
	switch e {
	case AssessmentHistoryOrderFieldHistoryTime, AssessmentHistoryOrderFieldCreatedAt, AssessmentHistoryOrderFieldUpdatedAt, AssessmentHistoryOrderFieldName, AssessmentHistoryOrderFieldAssessmentType, AssessmentHistoryOrderFieldResponseDueDuration:
		return true
	}
	return false
}

func (e AssessmentHistoryOrderField) String() string {
	return string(e)
}

func (e *AssessmentHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssessmentHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssessmentHistoryOrderField", str)
	}
	return nil
}

func (e AssessmentHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AssessmentHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AssessmentHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Assessment connections can be ordered.
type AssessmentOrderField string

const (
	AssessmentOrderFieldCreatedAt           AssessmentOrderField = "created_at"
	AssessmentOrderFieldUpdatedAt           AssessmentOrderField = "updated_at"
	AssessmentOrderFieldName                AssessmentOrderField = "name"
	AssessmentOrderFieldAssessmentType      AssessmentOrderField = "assessment_type"
	AssessmentOrderFieldResponseDueDuration AssessmentOrderField = "response_due_duration"
)

var AllAssessmentOrderField = []AssessmentOrderField{
	AssessmentOrderFieldCreatedAt,
	AssessmentOrderFieldUpdatedAt,
	AssessmentOrderFieldName,
	AssessmentOrderFieldAssessmentType,
	AssessmentOrderFieldResponseDueDuration,
}

func (e AssessmentOrderField) IsValid() bool {
	switch e {
	case AssessmentOrderFieldCreatedAt, AssessmentOrderFieldUpdatedAt, AssessmentOrderFieldName, AssessmentOrderFieldAssessmentType, AssessmentOrderFieldResponseDueDuration:
		return true
	}
	return false
}

func (e AssessmentOrderField) String() string {
	return string(e)
}

func (e *AssessmentOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssessmentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssessmentOrderField", str)
	}
	return nil
}

func (e AssessmentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AssessmentOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AssessmentOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which AssessmentResponseHistory connections can be ordered.
type AssessmentResponseHistoryOrderField string

const (
	AssessmentResponseHistoryOrderFieldHistoryTime  AssessmentResponseHistoryOrderField = "history_time"
	AssessmentResponseHistoryOrderFieldCreatedAt    AssessmentResponseHistoryOrderField = "created_at"
	AssessmentResponseHistoryOrderFieldUpdatedAt    AssessmentResponseHistoryOrderField = "updated_at"
	AssessmentResponseHistoryOrderFieldEmail        AssessmentResponseHistoryOrderField = "email"
	AssessmentResponseHistoryOrderFieldSendAttempts AssessmentResponseHistoryOrderField = "send_attempts"
	AssessmentResponseHistoryOrderFieldStatus       AssessmentResponseHistoryOrderField = "status"
	AssessmentResponseHistoryOrderFieldAssignedAt   AssessmentResponseHistoryOrderField = "assigned_at"
	AssessmentResponseHistoryOrderFieldStartedAt    AssessmentResponseHistoryOrderField = "started_at"
	AssessmentResponseHistoryOrderFieldCompletedAt  AssessmentResponseHistoryOrderField = "completed_at"
	AssessmentResponseHistoryOrderFieldDueDate      AssessmentResponseHistoryOrderField = "due_date"
)

var AllAssessmentResponseHistoryOrderField = []AssessmentResponseHistoryOrderField{
	AssessmentResponseHistoryOrderFieldHistoryTime,
	AssessmentResponseHistoryOrderFieldCreatedAt,
	AssessmentResponseHistoryOrderFieldUpdatedAt,
	AssessmentResponseHistoryOrderFieldEmail,
	AssessmentResponseHistoryOrderFieldSendAttempts,
	AssessmentResponseHistoryOrderFieldStatus,
	AssessmentResponseHistoryOrderFieldAssignedAt,
	AssessmentResponseHistoryOrderFieldStartedAt,
	AssessmentResponseHistoryOrderFieldCompletedAt,
	AssessmentResponseHistoryOrderFieldDueDate,
}

func (e AssessmentResponseHistoryOrderField) IsValid() bool {
	switch e {
	case AssessmentResponseHistoryOrderFieldHistoryTime, AssessmentResponseHistoryOrderFieldCreatedAt, AssessmentResponseHistoryOrderFieldUpdatedAt, AssessmentResponseHistoryOrderFieldEmail, AssessmentResponseHistoryOrderFieldSendAttempts, AssessmentResponseHistoryOrderFieldStatus, AssessmentResponseHistoryOrderFieldAssignedAt, AssessmentResponseHistoryOrderFieldStartedAt, AssessmentResponseHistoryOrderFieldCompletedAt, AssessmentResponseHistoryOrderFieldDueDate:
		return true
	}
	return false
}

func (e AssessmentResponseHistoryOrderField) String() string {
	return string(e)
}

func (e *AssessmentResponseHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssessmentResponseHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssessmentResponseHistoryOrderField", str)
	}
	return nil
}

func (e AssessmentResponseHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AssessmentResponseHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AssessmentResponseHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which AssessmentResponse connections can be ordered.
type AssessmentResponseOrderField string

const (
	AssessmentResponseOrderFieldCreatedAt    AssessmentResponseOrderField = "created_at"
	AssessmentResponseOrderFieldUpdatedAt    AssessmentResponseOrderField = "updated_at"
	AssessmentResponseOrderFieldEmail        AssessmentResponseOrderField = "email"
	AssessmentResponseOrderFieldSendAttempts AssessmentResponseOrderField = "send_attempts"
	AssessmentResponseOrderFieldStatus       AssessmentResponseOrderField = "status"
	AssessmentResponseOrderFieldAssignedAt   AssessmentResponseOrderField = "assigned_at"
	AssessmentResponseOrderFieldStartedAt    AssessmentResponseOrderField = "started_at"
	AssessmentResponseOrderFieldCompletedAt  AssessmentResponseOrderField = "completed_at"
	AssessmentResponseOrderFieldDueDate      AssessmentResponseOrderField = "due_date"
)

var AllAssessmentResponseOrderField = []AssessmentResponseOrderField{
	AssessmentResponseOrderFieldCreatedAt,
	AssessmentResponseOrderFieldUpdatedAt,
	AssessmentResponseOrderFieldEmail,
	AssessmentResponseOrderFieldSendAttempts,
	AssessmentResponseOrderFieldStatus,
	AssessmentResponseOrderFieldAssignedAt,
	AssessmentResponseOrderFieldStartedAt,
	AssessmentResponseOrderFieldCompletedAt,
	AssessmentResponseOrderFieldDueDate,
}

func (e AssessmentResponseOrderField) IsValid() bool {
	switch e {
	case AssessmentResponseOrderFieldCreatedAt, AssessmentResponseOrderFieldUpdatedAt, AssessmentResponseOrderFieldEmail, AssessmentResponseOrderFieldSendAttempts, AssessmentResponseOrderFieldStatus, AssessmentResponseOrderFieldAssignedAt, AssessmentResponseOrderFieldStartedAt, AssessmentResponseOrderFieldCompletedAt, AssessmentResponseOrderFieldDueDate:
		return true
	}
	return false
}

func (e AssessmentResponseOrderField) String() string {
	return string(e)
}

func (e *AssessmentResponseOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssessmentResponseOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssessmentResponseOrderField", str)
	}
	return nil
}

func (e AssessmentResponseOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AssessmentResponseOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AssessmentResponseOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which AssetHistory connections can be ordered.
type AssetHistoryOrderField string

const (
	AssetHistoryOrderFieldHistoryTime AssetHistoryOrderField = "history_time"
	AssetHistoryOrderFieldCreatedAt   AssetHistoryOrderField = "created_at"
	AssetHistoryOrderFieldUpdatedAt   AssetHistoryOrderField = "updated_at"
	AssetHistoryOrderFieldAssetType   AssetHistoryOrderField = "ASSET_TYPE"
	AssetHistoryOrderFieldName        AssetHistoryOrderField = "name"
)

var AllAssetHistoryOrderField = []AssetHistoryOrderField{
	AssetHistoryOrderFieldHistoryTime,
	AssetHistoryOrderFieldCreatedAt,
	AssetHistoryOrderFieldUpdatedAt,
	AssetHistoryOrderFieldAssetType,
	AssetHistoryOrderFieldName,
}

func (e AssetHistoryOrderField) IsValid() bool {
	switch e {
	case AssetHistoryOrderFieldHistoryTime, AssetHistoryOrderFieldCreatedAt, AssetHistoryOrderFieldUpdatedAt, AssetHistoryOrderFieldAssetType, AssetHistoryOrderFieldName:
		return true
	}
	return false
}

func (e AssetHistoryOrderField) String() string {
	return string(e)
}

func (e *AssetHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssetHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssetHistoryOrderField", str)
	}
	return nil
}

func (e AssetHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AssetHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AssetHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Asset connections can be ordered.
type AssetOrderField string

const (
	AssetOrderFieldCreatedAt AssetOrderField = "created_at"
	AssetOrderFieldUpdatedAt AssetOrderField = "updated_at"
	AssetOrderFieldAssetType AssetOrderField = "ASSET_TYPE"
	AssetOrderFieldName      AssetOrderField = "name"
)

var AllAssetOrderField = []AssetOrderField{
	AssetOrderFieldCreatedAt,
	AssetOrderFieldUpdatedAt,
	AssetOrderFieldAssetType,
	AssetOrderFieldName,
}

func (e AssetOrderField) IsValid() bool {
	switch e {
	case AssetOrderFieldCreatedAt, AssetOrderFieldUpdatedAt, AssetOrderFieldAssetType, AssetOrderFieldName:
		return true
	}
	return false
}

func (e AssetOrderField) String() string {
	return string(e)
}

func (e *AssetOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AssetOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AssetOrderField", str)
	}
	return nil
}

func (e AssetOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AssetOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AssetOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ContactHistory connections can be ordered.
type ContactHistoryOrderField string

const (
	ContactHistoryOrderFieldHistoryTime ContactHistoryOrderField = "history_time"
	ContactHistoryOrderFieldCreatedAt   ContactHistoryOrderField = "created_at"
	ContactHistoryOrderFieldUpdatedAt   ContactHistoryOrderField = "updated_at"
	ContactHistoryOrderFieldFullName    ContactHistoryOrderField = "full_name"
	ContactHistoryOrderFieldTitle       ContactHistoryOrderField = "title"
	ContactHistoryOrderFieldCompany     ContactHistoryOrderField = "company"
	ContactHistoryOrderFieldEmail       ContactHistoryOrderField = "email"
	ContactHistoryOrderFieldStatus      ContactHistoryOrderField = "STATUS"
)

var AllContactHistoryOrderField = []ContactHistoryOrderField{
	ContactHistoryOrderFieldHistoryTime,
	ContactHistoryOrderFieldCreatedAt,
	ContactHistoryOrderFieldUpdatedAt,
	ContactHistoryOrderFieldFullName,
	ContactHistoryOrderFieldTitle,
	ContactHistoryOrderFieldCompany,
	ContactHistoryOrderFieldEmail,
	ContactHistoryOrderFieldStatus,
}

func (e ContactHistoryOrderField) IsValid() bool {
	switch e {
	case ContactHistoryOrderFieldHistoryTime, ContactHistoryOrderFieldCreatedAt, ContactHistoryOrderFieldUpdatedAt, ContactHistoryOrderFieldFullName, ContactHistoryOrderFieldTitle, ContactHistoryOrderFieldCompany, ContactHistoryOrderFieldEmail, ContactHistoryOrderFieldStatus:
		return true
	}
	return false
}

func (e ContactHistoryOrderField) String() string {
	return string(e)
}

func (e *ContactHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContactHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContactHistoryOrderField", str)
	}
	return nil
}

func (e ContactHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ContactHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ContactHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Contact connections can be ordered.
type ContactOrderField string

const (
	ContactOrderFieldCreatedAt ContactOrderField = "created_at"
	ContactOrderFieldUpdatedAt ContactOrderField = "updated_at"
	ContactOrderFieldFullName  ContactOrderField = "full_name"
	ContactOrderFieldTitle     ContactOrderField = "title"
	ContactOrderFieldCompany   ContactOrderField = "company"
	ContactOrderFieldEmail     ContactOrderField = "email"
	ContactOrderFieldStatus    ContactOrderField = "STATUS"
)

var AllContactOrderField = []ContactOrderField{
	ContactOrderFieldCreatedAt,
	ContactOrderFieldUpdatedAt,
	ContactOrderFieldFullName,
	ContactOrderFieldTitle,
	ContactOrderFieldCompany,
	ContactOrderFieldEmail,
	ContactOrderFieldStatus,
}

func (e ContactOrderField) IsValid() bool {
	switch e {
	case ContactOrderFieldCreatedAt, ContactOrderFieldUpdatedAt, ContactOrderFieldFullName, ContactOrderFieldTitle, ContactOrderFieldCompany, ContactOrderFieldEmail, ContactOrderFieldStatus:
		return true
	}
	return false
}

func (e ContactOrderField) String() string {
	return string(e)
}

func (e *ContactOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContactOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContactOrderField", str)
	}
	return nil
}

func (e ContactOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ContactOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ContactOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ControlCategory connections can be ordered.
type ControlCategoryOrderField string

const (
	ControlCategoryOrderFieldCategory           ControlCategoryOrderField = "category"
	ControlCategoryOrderFieldReferenceFramework ControlCategoryOrderField = "referenceFramework"
)

var AllControlCategoryOrderField = []ControlCategoryOrderField{
	ControlCategoryOrderFieldCategory,
	ControlCategoryOrderFieldReferenceFramework,
}

func (e ControlCategoryOrderField) IsValid() bool {
	switch e {
	case ControlCategoryOrderFieldCategory, ControlCategoryOrderFieldReferenceFramework:
		return true
	}
	return false
}

func (e ControlCategoryOrderField) String() string {
	return string(e)
}

func (e *ControlCategoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlCategoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlCategoryOrderField", str)
	}
	return nil
}

func (e ControlCategoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ControlCategoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ControlCategoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ControlHistory connections can be ordered.
type ControlHistoryOrderField string

const (
	ControlHistoryOrderFieldHistoryTime        ControlHistoryOrderField = "history_time"
	ControlHistoryOrderFieldCreatedAt          ControlHistoryOrderField = "created_at"
	ControlHistoryOrderFieldUpdatedAt          ControlHistoryOrderField = "updated_at"
	ControlHistoryOrderFieldTitle              ControlHistoryOrderField = "title"
	ControlHistoryOrderFieldStatus             ControlHistoryOrderField = "STATUS"
	ControlHistoryOrderFieldSource             ControlHistoryOrderField = "SOURCE"
	ControlHistoryOrderFieldReferenceFramework ControlHistoryOrderField = "REFERENCE_FRAMEWORK"
	ControlHistoryOrderFieldControlType        ControlHistoryOrderField = "CONTROL_TYPE"
	ControlHistoryOrderFieldCategory           ControlHistoryOrderField = "category"
	ControlHistoryOrderFieldSubcategory        ControlHistoryOrderField = "subcategory"
	ControlHistoryOrderFieldRefCode            ControlHistoryOrderField = "ref_code"
)

var AllControlHistoryOrderField = []ControlHistoryOrderField{
	ControlHistoryOrderFieldHistoryTime,
	ControlHistoryOrderFieldCreatedAt,
	ControlHistoryOrderFieldUpdatedAt,
	ControlHistoryOrderFieldTitle,
	ControlHistoryOrderFieldStatus,
	ControlHistoryOrderFieldSource,
	ControlHistoryOrderFieldReferenceFramework,
	ControlHistoryOrderFieldControlType,
	ControlHistoryOrderFieldCategory,
	ControlHistoryOrderFieldSubcategory,
	ControlHistoryOrderFieldRefCode,
}

func (e ControlHistoryOrderField) IsValid() bool {
	switch e {
	case ControlHistoryOrderFieldHistoryTime, ControlHistoryOrderFieldCreatedAt, ControlHistoryOrderFieldUpdatedAt, ControlHistoryOrderFieldTitle, ControlHistoryOrderFieldStatus, ControlHistoryOrderFieldSource, ControlHistoryOrderFieldReferenceFramework, ControlHistoryOrderFieldControlType, ControlHistoryOrderFieldCategory, ControlHistoryOrderFieldSubcategory, ControlHistoryOrderFieldRefCode:
		return true
	}
	return false
}

func (e ControlHistoryOrderField) String() string {
	return string(e)
}

func (e *ControlHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlHistoryOrderField", str)
	}
	return nil
}

func (e ControlHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ControlHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ControlHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ControlImplementationHistory connections can be ordered.
type ControlImplementationHistoryOrderField string

const (
	ControlImplementationHistoryOrderFieldHistoryTime        ControlImplementationHistoryOrderField = "history_time"
	ControlImplementationHistoryOrderFieldCreatedAt          ControlImplementationHistoryOrderField = "created_at"
	ControlImplementationHistoryOrderFieldUpdatedAt          ControlImplementationHistoryOrderField = "updated_at"
	ControlImplementationHistoryOrderFieldStatus             ControlImplementationHistoryOrderField = "STATUS"
	ControlImplementationHistoryOrderFieldImplementationDate ControlImplementationHistoryOrderField = "implementation_date"
	ControlImplementationHistoryOrderFieldVerified           ControlImplementationHistoryOrderField = "verified"
	ControlImplementationHistoryOrderFieldVerificationDate   ControlImplementationHistoryOrderField = "verification_date"
)

var AllControlImplementationHistoryOrderField = []ControlImplementationHistoryOrderField{
	ControlImplementationHistoryOrderFieldHistoryTime,
	ControlImplementationHistoryOrderFieldCreatedAt,
	ControlImplementationHistoryOrderFieldUpdatedAt,
	ControlImplementationHistoryOrderFieldStatus,
	ControlImplementationHistoryOrderFieldImplementationDate,
	ControlImplementationHistoryOrderFieldVerified,
	ControlImplementationHistoryOrderFieldVerificationDate,
}

func (e ControlImplementationHistoryOrderField) IsValid() bool {
	switch e {
	case ControlImplementationHistoryOrderFieldHistoryTime, ControlImplementationHistoryOrderFieldCreatedAt, ControlImplementationHistoryOrderFieldUpdatedAt, ControlImplementationHistoryOrderFieldStatus, ControlImplementationHistoryOrderFieldImplementationDate, ControlImplementationHistoryOrderFieldVerified, ControlImplementationHistoryOrderFieldVerificationDate:
		return true
	}
	return false
}

func (e ControlImplementationHistoryOrderField) String() string {
	return string(e)
}

func (e *ControlImplementationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlImplementationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlImplementationHistoryOrderField", str)
	}
	return nil
}

func (e ControlImplementationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ControlImplementationHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ControlImplementationHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ControlImplementation connections can be ordered.
type ControlImplementationOrderField string

const (
	ControlImplementationOrderFieldCreatedAt          ControlImplementationOrderField = "created_at"
	ControlImplementationOrderFieldUpdatedAt          ControlImplementationOrderField = "updated_at"
	ControlImplementationOrderFieldStatus             ControlImplementationOrderField = "STATUS"
	ControlImplementationOrderFieldImplementationDate ControlImplementationOrderField = "implementation_date"
	ControlImplementationOrderFieldVerified           ControlImplementationOrderField = "verified"
	ControlImplementationOrderFieldVerificationDate   ControlImplementationOrderField = "verification_date"
)

var AllControlImplementationOrderField = []ControlImplementationOrderField{
	ControlImplementationOrderFieldCreatedAt,
	ControlImplementationOrderFieldUpdatedAt,
	ControlImplementationOrderFieldStatus,
	ControlImplementationOrderFieldImplementationDate,
	ControlImplementationOrderFieldVerified,
	ControlImplementationOrderFieldVerificationDate,
}

func (e ControlImplementationOrderField) IsValid() bool {
	switch e {
	case ControlImplementationOrderFieldCreatedAt, ControlImplementationOrderFieldUpdatedAt, ControlImplementationOrderFieldStatus, ControlImplementationOrderFieldImplementationDate, ControlImplementationOrderFieldVerified, ControlImplementationOrderFieldVerificationDate:
		return true
	}
	return false
}

func (e ControlImplementationOrderField) String() string {
	return string(e)
}

func (e *ControlImplementationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlImplementationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlImplementationOrderField", str)
	}
	return nil
}

func (e ControlImplementationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ControlImplementationOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ControlImplementationOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ControlObjectiveHistory connections can be ordered.
type ControlObjectiveHistoryOrderField string

const (
	ControlObjectiveHistoryOrderFieldHistoryTime          ControlObjectiveHistoryOrderField = "history_time"
	ControlObjectiveHistoryOrderFieldCreatedAt            ControlObjectiveHistoryOrderField = "created_at"
	ControlObjectiveHistoryOrderFieldUpdatedAt            ControlObjectiveHistoryOrderField = "updated_at"
	ControlObjectiveHistoryOrderFieldRevision             ControlObjectiveHistoryOrderField = "revision"
	ControlObjectiveHistoryOrderFieldName                 ControlObjectiveHistoryOrderField = "name"
	ControlObjectiveHistoryOrderFieldStatus               ControlObjectiveHistoryOrderField = "status"
	ControlObjectiveHistoryOrderFieldSource               ControlObjectiveHistoryOrderField = "SOURCE"
	ControlObjectiveHistoryOrderFieldControlObjectiveType ControlObjectiveHistoryOrderField = "control_objective_type"
	ControlObjectiveHistoryOrderFieldCategory             ControlObjectiveHistoryOrderField = "category"
	ControlObjectiveHistoryOrderFieldSubcategory          ControlObjectiveHistoryOrderField = "subcategory"
)

var AllControlObjectiveHistoryOrderField = []ControlObjectiveHistoryOrderField{
	ControlObjectiveHistoryOrderFieldHistoryTime,
	ControlObjectiveHistoryOrderFieldCreatedAt,
	ControlObjectiveHistoryOrderFieldUpdatedAt,
	ControlObjectiveHistoryOrderFieldRevision,
	ControlObjectiveHistoryOrderFieldName,
	ControlObjectiveHistoryOrderFieldStatus,
	ControlObjectiveHistoryOrderFieldSource,
	ControlObjectiveHistoryOrderFieldControlObjectiveType,
	ControlObjectiveHistoryOrderFieldCategory,
	ControlObjectiveHistoryOrderFieldSubcategory,
}

func (e ControlObjectiveHistoryOrderField) IsValid() bool {
	switch e {
	case ControlObjectiveHistoryOrderFieldHistoryTime, ControlObjectiveHistoryOrderFieldCreatedAt, ControlObjectiveHistoryOrderFieldUpdatedAt, ControlObjectiveHistoryOrderFieldRevision, ControlObjectiveHistoryOrderFieldName, ControlObjectiveHistoryOrderFieldStatus, ControlObjectiveHistoryOrderFieldSource, ControlObjectiveHistoryOrderFieldControlObjectiveType, ControlObjectiveHistoryOrderFieldCategory, ControlObjectiveHistoryOrderFieldSubcategory:
		return true
	}
	return false
}

func (e ControlObjectiveHistoryOrderField) String() string {
	return string(e)
}

func (e *ControlObjectiveHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlObjectiveHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlObjectiveHistoryOrderField", str)
	}
	return nil
}

func (e ControlObjectiveHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ControlObjectiveHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ControlObjectiveHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ControlObjective connections can be ordered.
type ControlObjectiveOrderField string

const (
	ControlObjectiveOrderFieldCreatedAt            ControlObjectiveOrderField = "created_at"
	ControlObjectiveOrderFieldUpdatedAt            ControlObjectiveOrderField = "updated_at"
	ControlObjectiveOrderFieldRevision             ControlObjectiveOrderField = "revision"
	ControlObjectiveOrderFieldName                 ControlObjectiveOrderField = "name"
	ControlObjectiveOrderFieldStatus               ControlObjectiveOrderField = "status"
	ControlObjectiveOrderFieldSource               ControlObjectiveOrderField = "SOURCE"
	ControlObjectiveOrderFieldControlObjectiveType ControlObjectiveOrderField = "control_objective_type"
	ControlObjectiveOrderFieldCategory             ControlObjectiveOrderField = "category"
	ControlObjectiveOrderFieldSubcategory          ControlObjectiveOrderField = "subcategory"
)

var AllControlObjectiveOrderField = []ControlObjectiveOrderField{
	ControlObjectiveOrderFieldCreatedAt,
	ControlObjectiveOrderFieldUpdatedAt,
	ControlObjectiveOrderFieldRevision,
	ControlObjectiveOrderFieldName,
	ControlObjectiveOrderFieldStatus,
	ControlObjectiveOrderFieldSource,
	ControlObjectiveOrderFieldControlObjectiveType,
	ControlObjectiveOrderFieldCategory,
	ControlObjectiveOrderFieldSubcategory,
}

func (e ControlObjectiveOrderField) IsValid() bool {
	switch e {
	case ControlObjectiveOrderFieldCreatedAt, ControlObjectiveOrderFieldUpdatedAt, ControlObjectiveOrderFieldRevision, ControlObjectiveOrderFieldName, ControlObjectiveOrderFieldStatus, ControlObjectiveOrderFieldSource, ControlObjectiveOrderFieldControlObjectiveType, ControlObjectiveOrderFieldCategory, ControlObjectiveOrderFieldSubcategory:
		return true
	}
	return false
}

func (e ControlObjectiveOrderField) String() string {
	return string(e)
}

func (e *ControlObjectiveOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlObjectiveOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlObjectiveOrderField", str)
	}
	return nil
}

func (e ControlObjectiveOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ControlObjectiveOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ControlObjectiveOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Control connections can be ordered.
type ControlOrderField string

const (
	ControlOrderFieldCreatedAt            ControlOrderField = "created_at"
	ControlOrderFieldUpdatedAt            ControlOrderField = "updated_at"
	ControlOrderFieldTitle                ControlOrderField = "title"
	ControlOrderFieldStatus               ControlOrderField = "STATUS"
	ControlOrderFieldSource               ControlOrderField = "SOURCE"
	ControlOrderFieldReferenceFramework   ControlOrderField = "REFERENCE_FRAMEWORK"
	ControlOrderFieldControlType          ControlOrderField = "CONTROL_TYPE"
	ControlOrderFieldCategory             ControlOrderField = "category"
	ControlOrderFieldSubcategory          ControlOrderField = "subcategory"
	ControlOrderFieldRefCode              ControlOrderField = "ref_code"
	ControlOrderFieldControlOwnerName     ControlOrderField = "CONTROL_OWNER_name"
	ControlOrderFieldDelegateName         ControlOrderField = "DELEGATE_name"
	ControlOrderFieldResponsiblePartyName ControlOrderField = "RESPONSIBLE_PARTY_name"
)

var AllControlOrderField = []ControlOrderField{
	ControlOrderFieldCreatedAt,
	ControlOrderFieldUpdatedAt,
	ControlOrderFieldTitle,
	ControlOrderFieldStatus,
	ControlOrderFieldSource,
	ControlOrderFieldReferenceFramework,
	ControlOrderFieldControlType,
	ControlOrderFieldCategory,
	ControlOrderFieldSubcategory,
	ControlOrderFieldRefCode,
	ControlOrderFieldControlOwnerName,
	ControlOrderFieldDelegateName,
	ControlOrderFieldResponsiblePartyName,
}

func (e ControlOrderField) IsValid() bool {
	switch e {
	case ControlOrderFieldCreatedAt, ControlOrderFieldUpdatedAt, ControlOrderFieldTitle, ControlOrderFieldStatus, ControlOrderFieldSource, ControlOrderFieldReferenceFramework, ControlOrderFieldControlType, ControlOrderFieldCategory, ControlOrderFieldSubcategory, ControlOrderFieldRefCode, ControlOrderFieldControlOwnerName, ControlOrderFieldDelegateName, ControlOrderFieldResponsiblePartyName:
		return true
	}
	return false
}

func (e ControlOrderField) String() string {
	return string(e)
}

func (e *ControlOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlOrderField", str)
	}
	return nil
}

func (e ControlOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ControlOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ControlOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which CustomDomainHistory connections can be ordered.
type CustomDomainHistoryOrderField string

const (
	CustomDomainHistoryOrderFieldHistoryTime CustomDomainHistoryOrderField = "history_time"
	CustomDomainHistoryOrderFieldCreatedAt   CustomDomainHistoryOrderField = "created_at"
	CustomDomainHistoryOrderFieldUpdatedAt   CustomDomainHistoryOrderField = "updated_at"
	CustomDomainHistoryOrderFieldCnameRecord CustomDomainHistoryOrderField = "cname_record"
)

var AllCustomDomainHistoryOrderField = []CustomDomainHistoryOrderField{
	CustomDomainHistoryOrderFieldHistoryTime,
	CustomDomainHistoryOrderFieldCreatedAt,
	CustomDomainHistoryOrderFieldUpdatedAt,
	CustomDomainHistoryOrderFieldCnameRecord,
}

func (e CustomDomainHistoryOrderField) IsValid() bool {
	switch e {
	case CustomDomainHistoryOrderFieldHistoryTime, CustomDomainHistoryOrderFieldCreatedAt, CustomDomainHistoryOrderFieldUpdatedAt, CustomDomainHistoryOrderFieldCnameRecord:
		return true
	}
	return false
}

func (e CustomDomainHistoryOrderField) String() string {
	return string(e)
}

func (e *CustomDomainHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomDomainHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomDomainHistoryOrderField", str)
	}
	return nil
}

func (e CustomDomainHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CustomDomainHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CustomDomainHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which CustomDomain connections can be ordered.
type CustomDomainOrderField string

const (
	CustomDomainOrderFieldCreatedAt   CustomDomainOrderField = "created_at"
	CustomDomainOrderFieldUpdatedAt   CustomDomainOrderField = "updated_at"
	CustomDomainOrderFieldCnameRecord CustomDomainOrderField = "cname_record"
)

var AllCustomDomainOrderField = []CustomDomainOrderField{
	CustomDomainOrderFieldCreatedAt,
	CustomDomainOrderFieldUpdatedAt,
	CustomDomainOrderFieldCnameRecord,
}

func (e CustomDomainOrderField) IsValid() bool {
	switch e {
	case CustomDomainOrderFieldCreatedAt, CustomDomainOrderFieldUpdatedAt, CustomDomainOrderFieldCnameRecord:
		return true
	}
	return false
}

func (e CustomDomainOrderField) String() string {
	return string(e)
}

func (e *CustomDomainOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomDomainOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomDomainOrderField", str)
	}
	return nil
}

func (e CustomDomainOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CustomDomainOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CustomDomainOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which CustomTypeEnum connections can be ordered.
type CustomTypeEnumOrderField string

const (
	CustomTypeEnumOrderFieldCreatedAt CustomTypeEnumOrderField = "created_at"
	CustomTypeEnumOrderFieldUpdatedAt CustomTypeEnumOrderField = "updated_at"
)

var AllCustomTypeEnumOrderField = []CustomTypeEnumOrderField{
	CustomTypeEnumOrderFieldCreatedAt,
	CustomTypeEnumOrderFieldUpdatedAt,
}

func (e CustomTypeEnumOrderField) IsValid() bool {
	switch e {
	case CustomTypeEnumOrderFieldCreatedAt, CustomTypeEnumOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e CustomTypeEnumOrderField) String() string {
	return string(e)
}

func (e *CustomTypeEnumOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CustomTypeEnumOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CustomTypeEnumOrderField", str)
	}
	return nil
}

func (e CustomTypeEnumOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CustomTypeEnumOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CustomTypeEnumOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DNSVerificationHistory connections can be ordered.
type DNSVerificationHistoryOrderField string

const (
	DNSVerificationHistoryOrderFieldHistoryTime DNSVerificationHistoryOrderField = "history_time"
	DNSVerificationHistoryOrderFieldCreatedAt   DNSVerificationHistoryOrderField = "created_at"
	DNSVerificationHistoryOrderFieldUpdatedAt   DNSVerificationHistoryOrderField = "updated_at"
)

var AllDNSVerificationHistoryOrderField = []DNSVerificationHistoryOrderField{
	DNSVerificationHistoryOrderFieldHistoryTime,
	DNSVerificationHistoryOrderFieldCreatedAt,
	DNSVerificationHistoryOrderFieldUpdatedAt,
}

func (e DNSVerificationHistoryOrderField) IsValid() bool {
	switch e {
	case DNSVerificationHistoryOrderFieldHistoryTime, DNSVerificationHistoryOrderFieldCreatedAt, DNSVerificationHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DNSVerificationHistoryOrderField) String() string {
	return string(e)
}

func (e *DNSVerificationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSVerificationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DNSVerificationHistoryOrderField", str)
	}
	return nil
}

func (e DNSVerificationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DNSVerificationHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DNSVerificationHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DNSVerification connections can be ordered.
type DNSVerificationOrderField string

const (
	DNSVerificationOrderFieldCreatedAt DNSVerificationOrderField = "created_at"
	DNSVerificationOrderFieldUpdatedAt DNSVerificationOrderField = "updated_at"
)

var AllDNSVerificationOrderField = []DNSVerificationOrderField{
	DNSVerificationOrderFieldCreatedAt,
	DNSVerificationOrderFieldUpdatedAt,
}

func (e DNSVerificationOrderField) IsValid() bool {
	switch e {
	case DNSVerificationOrderFieldCreatedAt, DNSVerificationOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DNSVerificationOrderField) String() string {
	return string(e)
}

func (e *DNSVerificationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSVerificationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DNSVerificationOrderField", str)
	}
	return nil
}

func (e DNSVerificationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DNSVerificationOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DNSVerificationOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DirectoryAccountHistory connections can be ordered.
type DirectoryAccountHistoryOrderField string

const (
	DirectoryAccountHistoryOrderFieldHistoryTime    DirectoryAccountHistoryOrderField = "history_time"
	DirectoryAccountHistoryOrderFieldCreatedAt      DirectoryAccountHistoryOrderField = "created_at"
	DirectoryAccountHistoryOrderFieldUpdatedAt      DirectoryAccountHistoryOrderField = "updated_at"
	DirectoryAccountHistoryOrderFieldExternalID     DirectoryAccountHistoryOrderField = "external_id"
	DirectoryAccountHistoryOrderFieldCanonicalEmail DirectoryAccountHistoryOrderField = "canonical_email"
	DirectoryAccountHistoryOrderFieldDisplayName    DirectoryAccountHistoryOrderField = "display_name"
)

var AllDirectoryAccountHistoryOrderField = []DirectoryAccountHistoryOrderField{
	DirectoryAccountHistoryOrderFieldHistoryTime,
	DirectoryAccountHistoryOrderFieldCreatedAt,
	DirectoryAccountHistoryOrderFieldUpdatedAt,
	DirectoryAccountHistoryOrderFieldExternalID,
	DirectoryAccountHistoryOrderFieldCanonicalEmail,
	DirectoryAccountHistoryOrderFieldDisplayName,
}

func (e DirectoryAccountHistoryOrderField) IsValid() bool {
	switch e {
	case DirectoryAccountHistoryOrderFieldHistoryTime, DirectoryAccountHistoryOrderFieldCreatedAt, DirectoryAccountHistoryOrderFieldUpdatedAt, DirectoryAccountHistoryOrderFieldExternalID, DirectoryAccountHistoryOrderFieldCanonicalEmail, DirectoryAccountHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e DirectoryAccountHistoryOrderField) String() string {
	return string(e)
}

func (e *DirectoryAccountHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectoryAccountHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectoryAccountHistoryOrderField", str)
	}
	return nil
}

func (e DirectoryAccountHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectoryAccountHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectoryAccountHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DirectoryAccount connections can be ordered.
type DirectoryAccountOrderField string

const (
	DirectoryAccountOrderFieldCreatedAt      DirectoryAccountOrderField = "created_at"
	DirectoryAccountOrderFieldUpdatedAt      DirectoryAccountOrderField = "updated_at"
	DirectoryAccountOrderFieldExternalID     DirectoryAccountOrderField = "external_id"
	DirectoryAccountOrderFieldCanonicalEmail DirectoryAccountOrderField = "canonical_email"
	DirectoryAccountOrderFieldDisplayName    DirectoryAccountOrderField = "display_name"
)

var AllDirectoryAccountOrderField = []DirectoryAccountOrderField{
	DirectoryAccountOrderFieldCreatedAt,
	DirectoryAccountOrderFieldUpdatedAt,
	DirectoryAccountOrderFieldExternalID,
	DirectoryAccountOrderFieldCanonicalEmail,
	DirectoryAccountOrderFieldDisplayName,
}

func (e DirectoryAccountOrderField) IsValid() bool {
	switch e {
	case DirectoryAccountOrderFieldCreatedAt, DirectoryAccountOrderFieldUpdatedAt, DirectoryAccountOrderFieldExternalID, DirectoryAccountOrderFieldCanonicalEmail, DirectoryAccountOrderFieldDisplayName:
		return true
	}
	return false
}

func (e DirectoryAccountOrderField) String() string {
	return string(e)
}

func (e *DirectoryAccountOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectoryAccountOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectoryAccountOrderField", str)
	}
	return nil
}

func (e DirectoryAccountOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectoryAccountOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectoryAccountOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DirectoryGroupHistory connections can be ordered.
type DirectoryGroupHistoryOrderField string

const (
	DirectoryGroupHistoryOrderFieldHistoryTime DirectoryGroupHistoryOrderField = "history_time"
	DirectoryGroupHistoryOrderFieldCreatedAt   DirectoryGroupHistoryOrderField = "created_at"
	DirectoryGroupHistoryOrderFieldUpdatedAt   DirectoryGroupHistoryOrderField = "updated_at"
	DirectoryGroupHistoryOrderFieldExternalID  DirectoryGroupHistoryOrderField = "external_id"
	DirectoryGroupHistoryOrderFieldEmail       DirectoryGroupHistoryOrderField = "email"
	DirectoryGroupHistoryOrderFieldDisplayName DirectoryGroupHistoryOrderField = "display_name"
)

var AllDirectoryGroupHistoryOrderField = []DirectoryGroupHistoryOrderField{
	DirectoryGroupHistoryOrderFieldHistoryTime,
	DirectoryGroupHistoryOrderFieldCreatedAt,
	DirectoryGroupHistoryOrderFieldUpdatedAt,
	DirectoryGroupHistoryOrderFieldExternalID,
	DirectoryGroupHistoryOrderFieldEmail,
	DirectoryGroupHistoryOrderFieldDisplayName,
}

func (e DirectoryGroupHistoryOrderField) IsValid() bool {
	switch e {
	case DirectoryGroupHistoryOrderFieldHistoryTime, DirectoryGroupHistoryOrderFieldCreatedAt, DirectoryGroupHistoryOrderFieldUpdatedAt, DirectoryGroupHistoryOrderFieldExternalID, DirectoryGroupHistoryOrderFieldEmail, DirectoryGroupHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e DirectoryGroupHistoryOrderField) String() string {
	return string(e)
}

func (e *DirectoryGroupHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectoryGroupHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectoryGroupHistoryOrderField", str)
	}
	return nil
}

func (e DirectoryGroupHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectoryGroupHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectoryGroupHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DirectoryGroup connections can be ordered.
type DirectoryGroupOrderField string

const (
	DirectoryGroupOrderFieldCreatedAt   DirectoryGroupOrderField = "created_at"
	DirectoryGroupOrderFieldUpdatedAt   DirectoryGroupOrderField = "updated_at"
	DirectoryGroupOrderFieldExternalID  DirectoryGroupOrderField = "external_id"
	DirectoryGroupOrderFieldEmail       DirectoryGroupOrderField = "email"
	DirectoryGroupOrderFieldDisplayName DirectoryGroupOrderField = "display_name"
)

var AllDirectoryGroupOrderField = []DirectoryGroupOrderField{
	DirectoryGroupOrderFieldCreatedAt,
	DirectoryGroupOrderFieldUpdatedAt,
	DirectoryGroupOrderFieldExternalID,
	DirectoryGroupOrderFieldEmail,
	DirectoryGroupOrderFieldDisplayName,
}

func (e DirectoryGroupOrderField) IsValid() bool {
	switch e {
	case DirectoryGroupOrderFieldCreatedAt, DirectoryGroupOrderFieldUpdatedAt, DirectoryGroupOrderFieldExternalID, DirectoryGroupOrderFieldEmail, DirectoryGroupOrderFieldDisplayName:
		return true
	}
	return false
}

func (e DirectoryGroupOrderField) String() string {
	return string(e)
}

func (e *DirectoryGroupOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectoryGroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectoryGroupOrderField", str)
	}
	return nil
}

func (e DirectoryGroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectoryGroupOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectoryGroupOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DirectoryMembershipHistory connections can be ordered.
type DirectoryMembershipHistoryOrderField string

const (
	DirectoryMembershipHistoryOrderFieldHistoryTime DirectoryMembershipHistoryOrderField = "history_time"
	DirectoryMembershipHistoryOrderFieldCreatedAt   DirectoryMembershipHistoryOrderField = "created_at"
	DirectoryMembershipHistoryOrderFieldUpdatedAt   DirectoryMembershipHistoryOrderField = "updated_at"
)

var AllDirectoryMembershipHistoryOrderField = []DirectoryMembershipHistoryOrderField{
	DirectoryMembershipHistoryOrderFieldHistoryTime,
	DirectoryMembershipHistoryOrderFieldCreatedAt,
	DirectoryMembershipHistoryOrderFieldUpdatedAt,
}

func (e DirectoryMembershipHistoryOrderField) IsValid() bool {
	switch e {
	case DirectoryMembershipHistoryOrderFieldHistoryTime, DirectoryMembershipHistoryOrderFieldCreatedAt, DirectoryMembershipHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DirectoryMembershipHistoryOrderField) String() string {
	return string(e)
}

func (e *DirectoryMembershipHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectoryMembershipHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectoryMembershipHistoryOrderField", str)
	}
	return nil
}

func (e DirectoryMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectoryMembershipHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectoryMembershipHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DirectoryMembership connections can be ordered.
type DirectoryMembershipOrderField string

const (
	DirectoryMembershipOrderFieldCreatedAt DirectoryMembershipOrderField = "created_at"
	DirectoryMembershipOrderFieldUpdatedAt DirectoryMembershipOrderField = "updated_at"
)

var AllDirectoryMembershipOrderField = []DirectoryMembershipOrderField{
	DirectoryMembershipOrderFieldCreatedAt,
	DirectoryMembershipOrderFieldUpdatedAt,
}

func (e DirectoryMembershipOrderField) IsValid() bool {
	switch e {
	case DirectoryMembershipOrderFieldCreatedAt, DirectoryMembershipOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DirectoryMembershipOrderField) String() string {
	return string(e)
}

func (e *DirectoryMembershipOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectoryMembershipOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectoryMembershipOrderField", str)
	}
	return nil
}

func (e DirectoryMembershipOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectoryMembershipOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectoryMembershipOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DirectorySyncRun connections can be ordered.
type DirectorySyncRunOrderField string

const (
	DirectorySyncRunOrderFieldCreatedAt DirectorySyncRunOrderField = "created_at"
	DirectorySyncRunOrderFieldUpdatedAt DirectorySyncRunOrderField = "updated_at"
	DirectorySyncRunOrderFieldStartedAt DirectorySyncRunOrderField = "started_at"
)

var AllDirectorySyncRunOrderField = []DirectorySyncRunOrderField{
	DirectorySyncRunOrderFieldCreatedAt,
	DirectorySyncRunOrderFieldUpdatedAt,
	DirectorySyncRunOrderFieldStartedAt,
}

func (e DirectorySyncRunOrderField) IsValid() bool {
	switch e {
	case DirectorySyncRunOrderFieldCreatedAt, DirectorySyncRunOrderFieldUpdatedAt, DirectorySyncRunOrderFieldStartedAt:
		return true
	}
	return false
}

func (e DirectorySyncRunOrderField) String() string {
	return string(e)
}

func (e *DirectorySyncRunOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DirectorySyncRunOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DirectorySyncRunOrderField", str)
	}
	return nil
}

func (e DirectorySyncRunOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DirectorySyncRunOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DirectorySyncRunOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DocumentDataHistory connections can be ordered.
type DocumentDataHistoryOrderField string

const (
	DocumentDataHistoryOrderFieldHistoryTime DocumentDataHistoryOrderField = "history_time"
	DocumentDataHistoryOrderFieldCreatedAt   DocumentDataHistoryOrderField = "created_at"
	DocumentDataHistoryOrderFieldUpdatedAt   DocumentDataHistoryOrderField = "updated_at"
)

var AllDocumentDataHistoryOrderField = []DocumentDataHistoryOrderField{
	DocumentDataHistoryOrderFieldHistoryTime,
	DocumentDataHistoryOrderFieldCreatedAt,
	DocumentDataHistoryOrderFieldUpdatedAt,
}

func (e DocumentDataHistoryOrderField) IsValid() bool {
	switch e {
	case DocumentDataHistoryOrderFieldHistoryTime, DocumentDataHistoryOrderFieldCreatedAt, DocumentDataHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DocumentDataHistoryOrderField) String() string {
	return string(e)
}

func (e *DocumentDataHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DocumentDataHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DocumentDataHistoryOrderField", str)
	}
	return nil
}

func (e DocumentDataHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DocumentDataHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DocumentDataHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which DocumentData connections can be ordered.
type DocumentDataOrderField string

const (
	DocumentDataOrderFieldCreatedAt DocumentDataOrderField = "created_at"
	DocumentDataOrderFieldUpdatedAt DocumentDataOrderField = "updated_at"
)

var AllDocumentDataOrderField = []DocumentDataOrderField{
	DocumentDataOrderFieldCreatedAt,
	DocumentDataOrderFieldUpdatedAt,
}

func (e DocumentDataOrderField) IsValid() bool {
	switch e {
	case DocumentDataOrderFieldCreatedAt, DocumentDataOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DocumentDataOrderField) String() string {
	return string(e)
}

func (e *DocumentDataOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DocumentDataOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DocumentDataOrderField", str)
	}
	return nil
}

func (e DocumentDataOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DocumentDataOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DocumentDataOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which EntityHistory connections can be ordered.
type EntityHistoryOrderField string

const (
	EntityHistoryOrderFieldHistoryTime EntityHistoryOrderField = "history_time"
	EntityHistoryOrderFieldCreatedAt   EntityHistoryOrderField = "created_at"
	EntityHistoryOrderFieldUpdatedAt   EntityHistoryOrderField = "updated_at"
	EntityHistoryOrderFieldName        EntityHistoryOrderField = "name"
	EntityHistoryOrderFieldDisplayName EntityHistoryOrderField = "display_name"
	EntityHistoryOrderFieldStatus      EntityHistoryOrderField = "status"
)

var AllEntityHistoryOrderField = []EntityHistoryOrderField{
	EntityHistoryOrderFieldHistoryTime,
	EntityHistoryOrderFieldCreatedAt,
	EntityHistoryOrderFieldUpdatedAt,
	EntityHistoryOrderFieldName,
	EntityHistoryOrderFieldDisplayName,
	EntityHistoryOrderFieldStatus,
}

func (e EntityHistoryOrderField) IsValid() bool {
	switch e {
	case EntityHistoryOrderFieldHistoryTime, EntityHistoryOrderFieldCreatedAt, EntityHistoryOrderFieldUpdatedAt, EntityHistoryOrderFieldName, EntityHistoryOrderFieldDisplayName, EntityHistoryOrderFieldStatus:
		return true
	}
	return false
}

func (e EntityHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

func (e EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EntityHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EntityHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Entity connections can be ordered.
type EntityOrderField string

const (
	EntityOrderFieldCreatedAt   EntityOrderField = "created_at"
	EntityOrderFieldUpdatedAt   EntityOrderField = "updated_at"
	EntityOrderFieldName        EntityOrderField = "name"
	EntityOrderFieldDisplayName EntityOrderField = "display_name"
	EntityOrderFieldStatus      EntityOrderField = "status"
)

var AllEntityOrderField = []EntityOrderField{
	EntityOrderFieldCreatedAt,
	EntityOrderFieldUpdatedAt,
	EntityOrderFieldName,
	EntityOrderFieldDisplayName,
	EntityOrderFieldStatus,
}

func (e EntityOrderField) IsValid() bool {
	switch e {
	case EntityOrderFieldCreatedAt, EntityOrderFieldUpdatedAt, EntityOrderFieldName, EntityOrderFieldDisplayName, EntityOrderFieldStatus:
		return true
	}
	return false
}

func (e EntityOrderField) String() string {
	return string(e)
}

func (e *EntityOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

func (e EntityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EntityOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EntityOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which EntityTypeHistory connections can be ordered.
type EntityTypeHistoryOrderField string

const (
	EntityTypeHistoryOrderFieldHistoryTime EntityTypeHistoryOrderField = "history_time"
	EntityTypeHistoryOrderFieldCreatedAt   EntityTypeHistoryOrderField = "created_at"
	EntityTypeHistoryOrderFieldUpdatedAt   EntityTypeHistoryOrderField = "updated_at"
	EntityTypeHistoryOrderFieldName        EntityTypeHistoryOrderField = "name"
)

var AllEntityTypeHistoryOrderField = []EntityTypeHistoryOrderField{
	EntityTypeHistoryOrderFieldHistoryTime,
	EntityTypeHistoryOrderFieldCreatedAt,
	EntityTypeHistoryOrderFieldUpdatedAt,
	EntityTypeHistoryOrderFieldName,
}

func (e EntityTypeHistoryOrderField) IsValid() bool {
	switch e {
	case EntityTypeHistoryOrderFieldHistoryTime, EntityTypeHistoryOrderFieldCreatedAt, EntityTypeHistoryOrderFieldUpdatedAt, EntityTypeHistoryOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityTypeHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

func (e EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EntityTypeHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EntityTypeHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which EntityType connections can be ordered.
type EntityTypeOrderField string

const (
	EntityTypeOrderFieldCreatedAt EntityTypeOrderField = "created_at"
	EntityTypeOrderFieldUpdatedAt EntityTypeOrderField = "updated_at"
	EntityTypeOrderFieldName      EntityTypeOrderField = "name"
)

var AllEntityTypeOrderField = []EntityTypeOrderField{
	EntityTypeOrderFieldCreatedAt,
	EntityTypeOrderFieldUpdatedAt,
	EntityTypeOrderFieldName,
}

func (e EntityTypeOrderField) IsValid() bool {
	switch e {
	case EntityTypeOrderFieldCreatedAt, EntityTypeOrderFieldUpdatedAt, EntityTypeOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeOrderField) String() string {
	return string(e)
}

func (e *EntityTypeOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

func (e EntityTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EntityTypeOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EntityTypeOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Event connections can be ordered.
type EventOrderField string

const (
	EventOrderFieldCreatedAt EventOrderField = "created_at"
	EventOrderFieldUpdatedAt EventOrderField = "updated_at"
)

var AllEventOrderField = []EventOrderField{
	EventOrderFieldCreatedAt,
	EventOrderFieldUpdatedAt,
}

func (e EventOrderField) IsValid() bool {
	switch e {
	case EventOrderFieldCreatedAt, EventOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e EventOrderField) String() string {
	return string(e)
}

func (e *EventOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventOrderField", str)
	}
	return nil
}

func (e EventOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EventOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EventOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which EvidenceHistory connections can be ordered.
type EvidenceHistoryOrderField string

const (
	EvidenceHistoryOrderFieldHistoryTime  EvidenceHistoryOrderField = "history_time"
	EvidenceHistoryOrderFieldCreatedAt    EvidenceHistoryOrderField = "created_at"
	EvidenceHistoryOrderFieldUpdatedAt    EvidenceHistoryOrderField = "updated_at"
	EvidenceHistoryOrderFieldName         EvidenceHistoryOrderField = "name"
	EvidenceHistoryOrderFieldCreationDate EvidenceHistoryOrderField = "creation_date"
	EvidenceHistoryOrderFieldRenewalDate  EvidenceHistoryOrderField = "renewal_date"
	EvidenceHistoryOrderFieldStatus       EvidenceHistoryOrderField = "STATUS"
)

var AllEvidenceHistoryOrderField = []EvidenceHistoryOrderField{
	EvidenceHistoryOrderFieldHistoryTime,
	EvidenceHistoryOrderFieldCreatedAt,
	EvidenceHistoryOrderFieldUpdatedAt,
	EvidenceHistoryOrderFieldName,
	EvidenceHistoryOrderFieldCreationDate,
	EvidenceHistoryOrderFieldRenewalDate,
	EvidenceHistoryOrderFieldStatus,
}

func (e EvidenceHistoryOrderField) IsValid() bool {
	switch e {
	case EvidenceHistoryOrderFieldHistoryTime, EvidenceHistoryOrderFieldCreatedAt, EvidenceHistoryOrderFieldUpdatedAt, EvidenceHistoryOrderFieldName, EvidenceHistoryOrderFieldCreationDate, EvidenceHistoryOrderFieldRenewalDate, EvidenceHistoryOrderFieldStatus:
		return true
	}
	return false
}

func (e EvidenceHistoryOrderField) String() string {
	return string(e)
}

func (e *EvidenceHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EvidenceHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EvidenceHistoryOrderField", str)
	}
	return nil
}

func (e EvidenceHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EvidenceHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EvidenceHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Evidence connections can be ordered.
type EvidenceOrderField string

const (
	EvidenceOrderFieldCreatedAt    EvidenceOrderField = "created_at"
	EvidenceOrderFieldUpdatedAt    EvidenceOrderField = "updated_at"
	EvidenceOrderFieldName         EvidenceOrderField = "name"
	EvidenceOrderFieldCreationDate EvidenceOrderField = "creation_date"
	EvidenceOrderFieldRenewalDate  EvidenceOrderField = "renewal_date"
	EvidenceOrderFieldStatus       EvidenceOrderField = "STATUS"
)

var AllEvidenceOrderField = []EvidenceOrderField{
	EvidenceOrderFieldCreatedAt,
	EvidenceOrderFieldUpdatedAt,
	EvidenceOrderFieldName,
	EvidenceOrderFieldCreationDate,
	EvidenceOrderFieldRenewalDate,
	EvidenceOrderFieldStatus,
}

func (e EvidenceOrderField) IsValid() bool {
	switch e {
	case EvidenceOrderFieldCreatedAt, EvidenceOrderFieldUpdatedAt, EvidenceOrderFieldName, EvidenceOrderFieldCreationDate, EvidenceOrderFieldRenewalDate, EvidenceOrderFieldStatus:
		return true
	}
	return false
}

func (e EvidenceOrderField) String() string {
	return string(e)
}

func (e *EvidenceOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EvidenceOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EvidenceOrderField", str)
	}
	return nil
}

func (e EvidenceOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EvidenceOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EvidenceOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Export connections can be ordered.
type ExportOrderField string

const (
	ExportOrderFieldCreatedAt  ExportOrderField = "created_at"
	ExportOrderFieldUpdatedAt  ExportOrderField = "updated_at"
	ExportOrderFieldExportType ExportOrderField = "export_type"
	ExportOrderFieldFormat     ExportOrderField = "format"
	ExportOrderFieldStatus     ExportOrderField = "status"
)

var AllExportOrderField = []ExportOrderField{
	ExportOrderFieldCreatedAt,
	ExportOrderFieldUpdatedAt,
	ExportOrderFieldExportType,
	ExportOrderFieldFormat,
	ExportOrderFieldStatus,
}

func (e ExportOrderField) IsValid() bool {
	switch e {
	case ExportOrderFieldCreatedAt, ExportOrderFieldUpdatedAt, ExportOrderFieldExportType, ExportOrderFieldFormat, ExportOrderFieldStatus:
		return true
	}
	return false
}

func (e ExportOrderField) String() string {
	return string(e)
}

func (e *ExportOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExportOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExportOrderField", str)
	}
	return nil
}

func (e ExportOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExportOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExportOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which FileHistory connections can be ordered.
type FileHistoryOrderField string

const (
	FileHistoryOrderFieldHistoryTime    FileHistoryOrderField = "history_time"
	FileHistoryOrderFieldCreatedAt      FileHistoryOrderField = "created_at"
	FileHistoryOrderFieldUpdatedAt      FileHistoryOrderField = "updated_at"
	FileHistoryOrderFieldLastAccessedAt FileHistoryOrderField = "last_accessed_at"
)

var AllFileHistoryOrderField = []FileHistoryOrderField{
	FileHistoryOrderFieldHistoryTime,
	FileHistoryOrderFieldCreatedAt,
	FileHistoryOrderFieldUpdatedAt,
	FileHistoryOrderFieldLastAccessedAt,
}

func (e FileHistoryOrderField) IsValid() bool {
	switch e {
	case FileHistoryOrderFieldHistoryTime, FileHistoryOrderFieldCreatedAt, FileHistoryOrderFieldUpdatedAt, FileHistoryOrderFieldLastAccessedAt:
		return true
	}
	return false
}

func (e FileHistoryOrderField) String() string {
	return string(e)
}

func (e *FileHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileHistoryOrderField", str)
	}
	return nil
}

func (e FileHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FileHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FileHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which File connections can be ordered.
type FileOrderField string

const (
	FileOrderFieldCreatedAt      FileOrderField = "created_at"
	FileOrderFieldUpdatedAt      FileOrderField = "updated_at"
	FileOrderFieldLastAccessedAt FileOrderField = "last_accessed_at"
)

var AllFileOrderField = []FileOrderField{
	FileOrderFieldCreatedAt,
	FileOrderFieldUpdatedAt,
	FileOrderFieldLastAccessedAt,
}

func (e FileOrderField) IsValid() bool {
	switch e {
	case FileOrderFieldCreatedAt, FileOrderFieldUpdatedAt, FileOrderFieldLastAccessedAt:
		return true
	}
	return false
}

func (e FileOrderField) String() string {
	return string(e)
}

func (e *FileOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileOrderField", str)
	}
	return nil
}

func (e FileOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FileOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FileOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which FindingControlHistory connections can be ordered.
type FindingControlHistoryOrderField string

const (
	FindingControlHistoryOrderFieldHistoryTime FindingControlHistoryOrderField = "history_time"
	FindingControlHistoryOrderFieldCreatedAt   FindingControlHistoryOrderField = "created_at"
	FindingControlHistoryOrderFieldUpdatedAt   FindingControlHistoryOrderField = "updated_at"
)

var AllFindingControlHistoryOrderField = []FindingControlHistoryOrderField{
	FindingControlHistoryOrderFieldHistoryTime,
	FindingControlHistoryOrderFieldCreatedAt,
	FindingControlHistoryOrderFieldUpdatedAt,
}

func (e FindingControlHistoryOrderField) IsValid() bool {
	switch e {
	case FindingControlHistoryOrderFieldHistoryTime, FindingControlHistoryOrderFieldCreatedAt, FindingControlHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e FindingControlHistoryOrderField) String() string {
	return string(e)
}

func (e *FindingControlHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FindingControlHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FindingControlHistoryOrderField", str)
	}
	return nil
}

func (e FindingControlHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FindingControlHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FindingControlHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which FindingControl connections can be ordered.
type FindingControlOrderField string

const (
	FindingControlOrderFieldCreatedAt FindingControlOrderField = "created_at"
	FindingControlOrderFieldUpdatedAt FindingControlOrderField = "updated_at"
)

var AllFindingControlOrderField = []FindingControlOrderField{
	FindingControlOrderFieldCreatedAt,
	FindingControlOrderFieldUpdatedAt,
}

func (e FindingControlOrderField) IsValid() bool {
	switch e {
	case FindingControlOrderFieldCreatedAt, FindingControlOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e FindingControlOrderField) String() string {
	return string(e)
}

func (e *FindingControlOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FindingControlOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FindingControlOrderField", str)
	}
	return nil
}

func (e FindingControlOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FindingControlOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FindingControlOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which FindingHistory connections can be ordered.
type FindingHistoryOrderField string

const (
	FindingHistoryOrderFieldHistoryTime     FindingHistoryOrderField = "history_time"
	FindingHistoryOrderFieldCreatedAt       FindingHistoryOrderField = "created_at"
	FindingHistoryOrderFieldUpdatedAt       FindingHistoryOrderField = "updated_at"
	FindingHistoryOrderFieldExternalID      FindingHistoryOrderField = "external_id"
	FindingHistoryOrderFieldExternalOwnerID FindingHistoryOrderField = "external_owner_id"
	FindingHistoryOrderFieldCategory        FindingHistoryOrderField = "category"
	FindingHistoryOrderFieldSeverity        FindingHistoryOrderField = "severity"
)

var AllFindingHistoryOrderField = []FindingHistoryOrderField{
	FindingHistoryOrderFieldHistoryTime,
	FindingHistoryOrderFieldCreatedAt,
	FindingHistoryOrderFieldUpdatedAt,
	FindingHistoryOrderFieldExternalID,
	FindingHistoryOrderFieldExternalOwnerID,
	FindingHistoryOrderFieldCategory,
	FindingHistoryOrderFieldSeverity,
}

func (e FindingHistoryOrderField) IsValid() bool {
	switch e {
	case FindingHistoryOrderFieldHistoryTime, FindingHistoryOrderFieldCreatedAt, FindingHistoryOrderFieldUpdatedAt, FindingHistoryOrderFieldExternalID, FindingHistoryOrderFieldExternalOwnerID, FindingHistoryOrderFieldCategory, FindingHistoryOrderFieldSeverity:
		return true
	}
	return false
}

func (e FindingHistoryOrderField) String() string {
	return string(e)
}

func (e *FindingHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FindingHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FindingHistoryOrderField", str)
	}
	return nil
}

func (e FindingHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FindingHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FindingHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Finding connections can be ordered.
type FindingOrderField string

const (
	FindingOrderFieldCreatedAt       FindingOrderField = "created_at"
	FindingOrderFieldUpdatedAt       FindingOrderField = "updated_at"
	FindingOrderFieldExternalID      FindingOrderField = "external_id"
	FindingOrderFieldExternalOwnerID FindingOrderField = "external_owner_id"
	FindingOrderFieldCategory        FindingOrderField = "category"
	FindingOrderFieldSeverity        FindingOrderField = "severity"
)

var AllFindingOrderField = []FindingOrderField{
	FindingOrderFieldCreatedAt,
	FindingOrderFieldUpdatedAt,
	FindingOrderFieldExternalID,
	FindingOrderFieldExternalOwnerID,
	FindingOrderFieldCategory,
	FindingOrderFieldSeverity,
}

func (e FindingOrderField) IsValid() bool {
	switch e {
	case FindingOrderFieldCreatedAt, FindingOrderFieldUpdatedAt, FindingOrderFieldExternalID, FindingOrderFieldExternalOwnerID, FindingOrderFieldCategory, FindingOrderFieldSeverity:
		return true
	}
	return false
}

func (e FindingOrderField) String() string {
	return string(e)
}

func (e *FindingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FindingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FindingOrderField", str)
	}
	return nil
}

func (e FindingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FindingOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FindingOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which GroupHistory connections can be ordered.
type GroupHistoryOrderField string

const (
	GroupHistoryOrderFieldHistoryTime GroupHistoryOrderField = "history_time"
	GroupHistoryOrderFieldCreatedAt   GroupHistoryOrderField = "created_at"
	GroupHistoryOrderFieldUpdatedAt   GroupHistoryOrderField = "updated_at"
	GroupHistoryOrderFieldName        GroupHistoryOrderField = "name"
	GroupHistoryOrderFieldDisplayName GroupHistoryOrderField = "display_name"
)

var AllGroupHistoryOrderField = []GroupHistoryOrderField{
	GroupHistoryOrderFieldHistoryTime,
	GroupHistoryOrderFieldCreatedAt,
	GroupHistoryOrderFieldUpdatedAt,
	GroupHistoryOrderFieldName,
	GroupHistoryOrderFieldDisplayName,
}

func (e GroupHistoryOrderField) IsValid() bool {
	switch e {
	case GroupHistoryOrderFieldHistoryTime, GroupHistoryOrderFieldCreatedAt, GroupHistoryOrderFieldUpdatedAt, GroupHistoryOrderFieldName, GroupHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

func (e GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GroupHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GroupHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which GroupMembershipHistory connections can be ordered.
type GroupMembershipHistoryOrderField string

const (
	GroupMembershipHistoryOrderFieldHistoryTime GroupMembershipHistoryOrderField = "history_time"
	GroupMembershipHistoryOrderFieldCreatedAt   GroupMembershipHistoryOrderField = "created_at"
	GroupMembershipHistoryOrderFieldUpdatedAt   GroupMembershipHistoryOrderField = "updated_at"
	GroupMembershipHistoryOrderFieldRole        GroupMembershipHistoryOrderField = "ROLE"
)

var AllGroupMembershipHistoryOrderField = []GroupMembershipHistoryOrderField{
	GroupMembershipHistoryOrderFieldHistoryTime,
	GroupMembershipHistoryOrderFieldCreatedAt,
	GroupMembershipHistoryOrderFieldUpdatedAt,
	GroupMembershipHistoryOrderFieldRole,
}

func (e GroupMembershipHistoryOrderField) IsValid() bool {
	switch e {
	case GroupMembershipHistoryOrderFieldHistoryTime, GroupMembershipHistoryOrderFieldCreatedAt, GroupMembershipHistoryOrderFieldUpdatedAt, GroupMembershipHistoryOrderFieldRole:
		return true
	}
	return false
}

func (e GroupMembershipHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupMembershipHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupMembershipHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupMembershipHistoryOrderField", str)
	}
	return nil
}

func (e GroupMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GroupMembershipHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GroupMembershipHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which GroupMembership connections can be ordered.
type GroupMembershipOrderField string

const (
	GroupMembershipOrderFieldCreatedAt GroupMembershipOrderField = "created_at"
	GroupMembershipOrderFieldUpdatedAt GroupMembershipOrderField = "updated_at"
	GroupMembershipOrderFieldRole      GroupMembershipOrderField = "ROLE"
)

var AllGroupMembershipOrderField = []GroupMembershipOrderField{
	GroupMembershipOrderFieldCreatedAt,
	GroupMembershipOrderFieldUpdatedAt,
	GroupMembershipOrderFieldRole,
}

func (e GroupMembershipOrderField) IsValid() bool {
	switch e {
	case GroupMembershipOrderFieldCreatedAt, GroupMembershipOrderFieldUpdatedAt, GroupMembershipOrderFieldRole:
		return true
	}
	return false
}

func (e GroupMembershipOrderField) String() string {
	return string(e)
}

func (e *GroupMembershipOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupMembershipOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupMembershipOrderField", str)
	}
	return nil
}

func (e GroupMembershipOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GroupMembershipOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GroupMembershipOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Group connections can be ordered.
type GroupOrderField string

const (
	GroupOrderFieldCreatedAt   GroupOrderField = "created_at"
	GroupOrderFieldUpdatedAt   GroupOrderField = "updated_at"
	GroupOrderFieldName        GroupOrderField = "name"
	GroupOrderFieldDisplayName GroupOrderField = "display_name"
)

var AllGroupOrderField = []GroupOrderField{
	GroupOrderFieldCreatedAt,
	GroupOrderFieldUpdatedAt,
	GroupOrderFieldName,
	GroupOrderFieldDisplayName,
}

func (e GroupOrderField) IsValid() bool {
	switch e {
	case GroupOrderFieldCreatedAt, GroupOrderFieldUpdatedAt, GroupOrderFieldName, GroupOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupOrderField) String() string {
	return string(e)
}

func (e *GroupOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

func (e GroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GroupOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GroupOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which GroupPermission connections can be ordered.
type GroupPermissionOrderField string

const (
	GroupPermissionOrderFieldName       GroupPermissionOrderField = "name"
	GroupPermissionOrderFieldPermission GroupPermissionOrderField = "permission"
	GroupPermissionOrderFieldObjectType GroupPermissionOrderField = "objectType"
)

var AllGroupPermissionOrderField = []GroupPermissionOrderField{
	GroupPermissionOrderFieldName,
	GroupPermissionOrderFieldPermission,
	GroupPermissionOrderFieldObjectType,
}

func (e GroupPermissionOrderField) IsValid() bool {
	switch e {
	case GroupPermissionOrderFieldName, GroupPermissionOrderFieldPermission, GroupPermissionOrderFieldObjectType:
		return true
	}
	return false
}

func (e GroupPermissionOrderField) String() string {
	return string(e)
}

func (e *GroupPermissionOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupPermissionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupPermissionOrderField", str)
	}
	return nil
}

func (e GroupPermissionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GroupPermissionOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GroupPermissionOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which GroupSettingHistory connections can be ordered.
type GroupSettingHistoryOrderField string

const (
	GroupSettingHistoryOrderFieldHistoryTime GroupSettingHistoryOrderField = "history_time"
	GroupSettingHistoryOrderFieldCreatedAt   GroupSettingHistoryOrderField = "created_at"
	GroupSettingHistoryOrderFieldUpdatedAt   GroupSettingHistoryOrderField = "updated_at"
)

var AllGroupSettingHistoryOrderField = []GroupSettingHistoryOrderField{
	GroupSettingHistoryOrderFieldHistoryTime,
	GroupSettingHistoryOrderFieldCreatedAt,
	GroupSettingHistoryOrderFieldUpdatedAt,
}

func (e GroupSettingHistoryOrderField) IsValid() bool {
	switch e {
	case GroupSettingHistoryOrderFieldHistoryTime, GroupSettingHistoryOrderFieldCreatedAt, GroupSettingHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e GroupSettingHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupSettingHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupSettingHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupSettingHistoryOrderField", str)
	}
	return nil
}

func (e GroupSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GroupSettingHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GroupSettingHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which GroupSetting connections can be ordered.
type GroupSettingOrderField string

const (
	GroupSettingOrderFieldCreatedAt GroupSettingOrderField = "created_at"
	GroupSettingOrderFieldUpdatedAt GroupSettingOrderField = "updated_at"
)

var AllGroupSettingOrderField = []GroupSettingOrderField{
	GroupSettingOrderFieldCreatedAt,
	GroupSettingOrderFieldUpdatedAt,
}

func (e GroupSettingOrderField) IsValid() bool {
	switch e {
	case GroupSettingOrderFieldCreatedAt, GroupSettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e GroupSettingOrderField) String() string {
	return string(e)
}

func (e *GroupSettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupSettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupSettingOrderField", str)
	}
	return nil
}

func (e GroupSettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GroupSettingOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GroupSettingOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which HushHistory connections can be ordered.
type HushHistoryOrderField string

const (
	HushHistoryOrderFieldHistoryTime HushHistoryOrderField = "history_time"
	HushHistoryOrderFieldCreatedAt   HushHistoryOrderField = "created_at"
	HushHistoryOrderFieldUpdatedAt   HushHistoryOrderField = "updated_at"
	HushHistoryOrderFieldName        HushHistoryOrderField = "name"
	HushHistoryOrderFieldKind        HushHistoryOrderField = "kind"
	HushHistoryOrderFieldLastUsedAt  HushHistoryOrderField = "last_used_at"
	HushHistoryOrderFieldExpiresAt   HushHistoryOrderField = "expires_at"
)

var AllHushHistoryOrderField = []HushHistoryOrderField{
	HushHistoryOrderFieldHistoryTime,
	HushHistoryOrderFieldCreatedAt,
	HushHistoryOrderFieldUpdatedAt,
	HushHistoryOrderFieldName,
	HushHistoryOrderFieldKind,
	HushHistoryOrderFieldLastUsedAt,
	HushHistoryOrderFieldExpiresAt,
}

func (e HushHistoryOrderField) IsValid() bool {
	switch e {
	case HushHistoryOrderFieldHistoryTime, HushHistoryOrderFieldCreatedAt, HushHistoryOrderFieldUpdatedAt, HushHistoryOrderFieldName, HushHistoryOrderFieldKind, HushHistoryOrderFieldLastUsedAt, HushHistoryOrderFieldExpiresAt:
		return true
	}
	return false
}

func (e HushHistoryOrderField) String() string {
	return string(e)
}

func (e *HushHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

func (e HushHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HushHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HushHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Hush connections can be ordered.
type HushOrderField string

const (
	HushOrderFieldCreatedAt  HushOrderField = "created_at"
	HushOrderFieldUpdatedAt  HushOrderField = "updated_at"
	HushOrderFieldName       HushOrderField = "name"
	HushOrderFieldKind       HushOrderField = "kind"
	HushOrderFieldLastUsedAt HushOrderField = "last_used_at"
	HushOrderFieldExpiresAt  HushOrderField = "expires_at"
)

var AllHushOrderField = []HushOrderField{
	HushOrderFieldCreatedAt,
	HushOrderFieldUpdatedAt,
	HushOrderFieldName,
	HushOrderFieldKind,
	HushOrderFieldLastUsedAt,
	HushOrderFieldExpiresAt,
}

func (e HushOrderField) IsValid() bool {
	switch e {
	case HushOrderFieldCreatedAt, HushOrderFieldUpdatedAt, HushOrderFieldName, HushOrderFieldKind, HushOrderFieldLastUsedAt, HushOrderFieldExpiresAt:
		return true
	}
	return false
}

func (e HushOrderField) String() string {
	return string(e)
}

func (e *HushOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

func (e HushOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HushOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HushOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which IntegrationHistory connections can be ordered.
type IntegrationHistoryOrderField string

const (
	IntegrationHistoryOrderFieldHistoryTime     IntegrationHistoryOrderField = "history_time"
	IntegrationHistoryOrderFieldCreatedAt       IntegrationHistoryOrderField = "created_at"
	IntegrationHistoryOrderFieldUpdatedAt       IntegrationHistoryOrderField = "updated_at"
	IntegrationHistoryOrderFieldName            IntegrationHistoryOrderField = "name"
	IntegrationHistoryOrderFieldKind            IntegrationHistoryOrderField = "kind"
	IntegrationHistoryOrderFieldIntegrationType IntegrationHistoryOrderField = "integration_type"
)

var AllIntegrationHistoryOrderField = []IntegrationHistoryOrderField{
	IntegrationHistoryOrderFieldHistoryTime,
	IntegrationHistoryOrderFieldCreatedAt,
	IntegrationHistoryOrderFieldUpdatedAt,
	IntegrationHistoryOrderFieldName,
	IntegrationHistoryOrderFieldKind,
	IntegrationHistoryOrderFieldIntegrationType,
}

func (e IntegrationHistoryOrderField) IsValid() bool {
	switch e {
	case IntegrationHistoryOrderFieldHistoryTime, IntegrationHistoryOrderFieldCreatedAt, IntegrationHistoryOrderFieldUpdatedAt, IntegrationHistoryOrderFieldName, IntegrationHistoryOrderFieldKind, IntegrationHistoryOrderFieldIntegrationType:
		return true
	}
	return false
}

func (e IntegrationHistoryOrderField) String() string {
	return string(e)
}

func (e *IntegrationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

func (e IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IntegrationHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IntegrationHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Integration connections can be ordered.
type IntegrationOrderField string

const (
	IntegrationOrderFieldCreatedAt       IntegrationOrderField = "created_at"
	IntegrationOrderFieldUpdatedAt       IntegrationOrderField = "updated_at"
	IntegrationOrderFieldName            IntegrationOrderField = "name"
	IntegrationOrderFieldKind            IntegrationOrderField = "kind"
	IntegrationOrderFieldIntegrationType IntegrationOrderField = "integration_type"
)

var AllIntegrationOrderField = []IntegrationOrderField{
	IntegrationOrderFieldCreatedAt,
	IntegrationOrderFieldUpdatedAt,
	IntegrationOrderFieldName,
	IntegrationOrderFieldKind,
	IntegrationOrderFieldIntegrationType,
}

func (e IntegrationOrderField) IsValid() bool {
	switch e {
	case IntegrationOrderFieldCreatedAt, IntegrationOrderFieldUpdatedAt, IntegrationOrderFieldName, IntegrationOrderFieldKind, IntegrationOrderFieldIntegrationType:
		return true
	}
	return false
}

func (e IntegrationOrderField) String() string {
	return string(e)
}

func (e *IntegrationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

func (e IntegrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IntegrationOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IntegrationOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which InternalPolicyHistory connections can be ordered.
type InternalPolicyHistoryOrderField string

const (
	InternalPolicyHistoryOrderFieldHistoryTime     InternalPolicyHistoryOrderField = "history_time"
	InternalPolicyHistoryOrderFieldCreatedAt       InternalPolicyHistoryOrderField = "created_at"
	InternalPolicyHistoryOrderFieldUpdatedAt       InternalPolicyHistoryOrderField = "updated_at"
	InternalPolicyHistoryOrderFieldRevision        InternalPolicyHistoryOrderField = "revision"
	InternalPolicyHistoryOrderFieldName            InternalPolicyHistoryOrderField = "name"
	InternalPolicyHistoryOrderFieldStatus          InternalPolicyHistoryOrderField = "STATUS"
	InternalPolicyHistoryOrderFieldReviewDue       InternalPolicyHistoryOrderField = "review_due"
	InternalPolicyHistoryOrderFieldReviewFrequency InternalPolicyHistoryOrderField = "REVIEW_FREQUENCY"
)

var AllInternalPolicyHistoryOrderField = []InternalPolicyHistoryOrderField{
	InternalPolicyHistoryOrderFieldHistoryTime,
	InternalPolicyHistoryOrderFieldCreatedAt,
	InternalPolicyHistoryOrderFieldUpdatedAt,
	InternalPolicyHistoryOrderFieldRevision,
	InternalPolicyHistoryOrderFieldName,
	InternalPolicyHistoryOrderFieldStatus,
	InternalPolicyHistoryOrderFieldReviewDue,
	InternalPolicyHistoryOrderFieldReviewFrequency,
}

func (e InternalPolicyHistoryOrderField) IsValid() bool {
	switch e {
	case InternalPolicyHistoryOrderFieldHistoryTime, InternalPolicyHistoryOrderFieldCreatedAt, InternalPolicyHistoryOrderFieldUpdatedAt, InternalPolicyHistoryOrderFieldRevision, InternalPolicyHistoryOrderFieldName, InternalPolicyHistoryOrderFieldStatus, InternalPolicyHistoryOrderFieldReviewDue, InternalPolicyHistoryOrderFieldReviewFrequency:
		return true
	}
	return false
}

func (e InternalPolicyHistoryOrderField) String() string {
	return string(e)
}

func (e *InternalPolicyHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InternalPolicyHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InternalPolicyHistoryOrderField", str)
	}
	return nil
}

func (e InternalPolicyHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InternalPolicyHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InternalPolicyHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which InternalPolicy connections can be ordered.
type InternalPolicyOrderField string

const (
	InternalPolicyOrderFieldCreatedAt       InternalPolicyOrderField = "created_at"
	InternalPolicyOrderFieldUpdatedAt       InternalPolicyOrderField = "updated_at"
	InternalPolicyOrderFieldRevision        InternalPolicyOrderField = "revision"
	InternalPolicyOrderFieldName            InternalPolicyOrderField = "name"
	InternalPolicyOrderFieldStatus          InternalPolicyOrderField = "STATUS"
	InternalPolicyOrderFieldReviewDue       InternalPolicyOrderField = "review_due"
	InternalPolicyOrderFieldReviewFrequency InternalPolicyOrderField = "REVIEW_FREQUENCY"
)

var AllInternalPolicyOrderField = []InternalPolicyOrderField{
	InternalPolicyOrderFieldCreatedAt,
	InternalPolicyOrderFieldUpdatedAt,
	InternalPolicyOrderFieldRevision,
	InternalPolicyOrderFieldName,
	InternalPolicyOrderFieldStatus,
	InternalPolicyOrderFieldReviewDue,
	InternalPolicyOrderFieldReviewFrequency,
}

func (e InternalPolicyOrderField) IsValid() bool {
	switch e {
	case InternalPolicyOrderFieldCreatedAt, InternalPolicyOrderFieldUpdatedAt, InternalPolicyOrderFieldRevision, InternalPolicyOrderFieldName, InternalPolicyOrderFieldStatus, InternalPolicyOrderFieldReviewDue, InternalPolicyOrderFieldReviewFrequency:
		return true
	}
	return false
}

func (e InternalPolicyOrderField) String() string {
	return string(e)
}

func (e *InternalPolicyOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InternalPolicyOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InternalPolicyOrderField", str)
	}
	return nil
}

func (e InternalPolicyOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InternalPolicyOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InternalPolicyOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Invite connections can be ordered.
type InviteOrderField string

const (
	InviteOrderFieldCreatedAt    InviteOrderField = "created_at"
	InviteOrderFieldUpdatedAt    InviteOrderField = "updated_at"
	InviteOrderFieldExpires      InviteOrderField = "expires"
	InviteOrderFieldStatus       InviteOrderField = "STATUS"
	InviteOrderFieldSendAttempts InviteOrderField = "send_attempts"
)

var AllInviteOrderField = []InviteOrderField{
	InviteOrderFieldCreatedAt,
	InviteOrderFieldUpdatedAt,
	InviteOrderFieldExpires,
	InviteOrderFieldStatus,
	InviteOrderFieldSendAttempts,
}

func (e InviteOrderField) IsValid() bool {
	switch e {
	case InviteOrderFieldCreatedAt, InviteOrderFieldUpdatedAt, InviteOrderFieldExpires, InviteOrderFieldStatus, InviteOrderFieldSendAttempts:
		return true
	}
	return false
}

func (e InviteOrderField) String() string {
	return string(e)
}

func (e *InviteOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InviteOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InviteOrderField", str)
	}
	return nil
}

func (e InviteOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InviteOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InviteOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which JobResult connections can be ordered.
type JobResultOrderField string

const (
	JobResultOrderFieldCreatedAt  JobResultOrderField = "created_at"
	JobResultOrderFieldUpdatedAt  JobResultOrderField = "updated_at"
	JobResultOrderFieldStatus     JobResultOrderField = "STATUS"
	JobResultOrderFieldExitCode   JobResultOrderField = "exit_code"
	JobResultOrderFieldFinishedAt JobResultOrderField = "finished_at"
	JobResultOrderFieldStartedAt  JobResultOrderField = "started_at"
)

var AllJobResultOrderField = []JobResultOrderField{
	JobResultOrderFieldCreatedAt,
	JobResultOrderFieldUpdatedAt,
	JobResultOrderFieldStatus,
	JobResultOrderFieldExitCode,
	JobResultOrderFieldFinishedAt,
	JobResultOrderFieldStartedAt,
}

func (e JobResultOrderField) IsValid() bool {
	switch e {
	case JobResultOrderFieldCreatedAt, JobResultOrderFieldUpdatedAt, JobResultOrderFieldStatus, JobResultOrderFieldExitCode, JobResultOrderFieldFinishedAt, JobResultOrderFieldStartedAt:
		return true
	}
	return false
}

func (e JobResultOrderField) String() string {
	return string(e)
}

func (e *JobResultOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobResultOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobResultOrderField", str)
	}
	return nil
}

func (e JobResultOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobResultOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobResultOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which JobRunner connections can be ordered.
type JobRunnerOrderField string

const (
	JobRunnerOrderFieldCreatedAt JobRunnerOrderField = "created_at"
	JobRunnerOrderFieldUpdatedAt JobRunnerOrderField = "updated_at"
	JobRunnerOrderFieldName      JobRunnerOrderField = "name"
)

var AllJobRunnerOrderField = []JobRunnerOrderField{
	JobRunnerOrderFieldCreatedAt,
	JobRunnerOrderFieldUpdatedAt,
	JobRunnerOrderFieldName,
}

func (e JobRunnerOrderField) IsValid() bool {
	switch e {
	case JobRunnerOrderFieldCreatedAt, JobRunnerOrderFieldUpdatedAt, JobRunnerOrderFieldName:
		return true
	}
	return false
}

func (e JobRunnerOrderField) String() string {
	return string(e)
}

func (e *JobRunnerOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobRunnerOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobRunnerOrderField", str)
	}
	return nil
}

func (e JobRunnerOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobRunnerOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobRunnerOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which JobRunnerRegistrationToken connections can be ordered.
type JobRunnerRegistrationTokenOrderField string

const (
	JobRunnerRegistrationTokenOrderFieldCreatedAt  JobRunnerRegistrationTokenOrderField = "created_at"
	JobRunnerRegistrationTokenOrderFieldUpdatedAt  JobRunnerRegistrationTokenOrderField = "updated_at"
	JobRunnerRegistrationTokenOrderFieldLastUsedAt JobRunnerRegistrationTokenOrderField = "last_used_at"
)

var AllJobRunnerRegistrationTokenOrderField = []JobRunnerRegistrationTokenOrderField{
	JobRunnerRegistrationTokenOrderFieldCreatedAt,
	JobRunnerRegistrationTokenOrderFieldUpdatedAt,
	JobRunnerRegistrationTokenOrderFieldLastUsedAt,
}

func (e JobRunnerRegistrationTokenOrderField) IsValid() bool {
	switch e {
	case JobRunnerRegistrationTokenOrderFieldCreatedAt, JobRunnerRegistrationTokenOrderFieldUpdatedAt, JobRunnerRegistrationTokenOrderFieldLastUsedAt:
		return true
	}
	return false
}

func (e JobRunnerRegistrationTokenOrderField) String() string {
	return string(e)
}

func (e *JobRunnerRegistrationTokenOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobRunnerRegistrationTokenOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobRunnerRegistrationTokenOrderField", str)
	}
	return nil
}

func (e JobRunnerRegistrationTokenOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobRunnerRegistrationTokenOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobRunnerRegistrationTokenOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which JobRunnerToken connections can be ordered.
type JobRunnerTokenOrderField string

const (
	JobRunnerTokenOrderFieldCreatedAt  JobRunnerTokenOrderField = "created_at"
	JobRunnerTokenOrderFieldUpdatedAt  JobRunnerTokenOrderField = "updated_at"
	JobRunnerTokenOrderFieldExpiresAt  JobRunnerTokenOrderField = "expires_at"
	JobRunnerTokenOrderFieldLastUsedAt JobRunnerTokenOrderField = "last_used_at"
)

var AllJobRunnerTokenOrderField = []JobRunnerTokenOrderField{
	JobRunnerTokenOrderFieldCreatedAt,
	JobRunnerTokenOrderFieldUpdatedAt,
	JobRunnerTokenOrderFieldExpiresAt,
	JobRunnerTokenOrderFieldLastUsedAt,
}

func (e JobRunnerTokenOrderField) IsValid() bool {
	switch e {
	case JobRunnerTokenOrderFieldCreatedAt, JobRunnerTokenOrderFieldUpdatedAt, JobRunnerTokenOrderFieldExpiresAt, JobRunnerTokenOrderFieldLastUsedAt:
		return true
	}
	return false
}

func (e JobRunnerTokenOrderField) String() string {
	return string(e)
}

func (e *JobRunnerTokenOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobRunnerTokenOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobRunnerTokenOrderField", str)
	}
	return nil
}

func (e JobRunnerTokenOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobRunnerTokenOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobRunnerTokenOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which JobTemplateHistory connections can be ordered.
type JobTemplateHistoryOrderField string

const (
	JobTemplateHistoryOrderFieldHistoryTime JobTemplateHistoryOrderField = "history_time"
	JobTemplateHistoryOrderFieldCreatedAt   JobTemplateHistoryOrderField = "created_at"
	JobTemplateHistoryOrderFieldUpdatedAt   JobTemplateHistoryOrderField = "updated_at"
	JobTemplateHistoryOrderFieldTitle       JobTemplateHistoryOrderField = "title"
	JobTemplateHistoryOrderFieldPlatform    JobTemplateHistoryOrderField = "PLATFORM"
)

var AllJobTemplateHistoryOrderField = []JobTemplateHistoryOrderField{
	JobTemplateHistoryOrderFieldHistoryTime,
	JobTemplateHistoryOrderFieldCreatedAt,
	JobTemplateHistoryOrderFieldUpdatedAt,
	JobTemplateHistoryOrderFieldTitle,
	JobTemplateHistoryOrderFieldPlatform,
}

func (e JobTemplateHistoryOrderField) IsValid() bool {
	switch e {
	case JobTemplateHistoryOrderFieldHistoryTime, JobTemplateHistoryOrderFieldCreatedAt, JobTemplateHistoryOrderFieldUpdatedAt, JobTemplateHistoryOrderFieldTitle, JobTemplateHistoryOrderFieldPlatform:
		return true
	}
	return false
}

func (e JobTemplateHistoryOrderField) String() string {
	return string(e)
}

func (e *JobTemplateHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobTemplateHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobTemplateHistoryOrderField", str)
	}
	return nil
}

func (e JobTemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobTemplateHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobTemplateHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which JobTemplate connections can be ordered.
type JobTemplateOrderField string

const (
	JobTemplateOrderFieldCreatedAt JobTemplateOrderField = "created_at"
	JobTemplateOrderFieldUpdatedAt JobTemplateOrderField = "updated_at"
	JobTemplateOrderFieldTitle     JobTemplateOrderField = "title"
	JobTemplateOrderFieldPlatform  JobTemplateOrderField = "PLATFORM"
)

var AllJobTemplateOrderField = []JobTemplateOrderField{
	JobTemplateOrderFieldCreatedAt,
	JobTemplateOrderFieldUpdatedAt,
	JobTemplateOrderFieldTitle,
	JobTemplateOrderFieldPlatform,
}

func (e JobTemplateOrderField) IsValid() bool {
	switch e {
	case JobTemplateOrderFieldCreatedAt, JobTemplateOrderFieldUpdatedAt, JobTemplateOrderFieldTitle, JobTemplateOrderFieldPlatform:
		return true
	}
	return false
}

func (e JobTemplateOrderField) String() string {
	return string(e)
}

func (e *JobTemplateOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobTemplateOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobTemplateOrderField", str)
	}
	return nil
}

func (e JobTemplateOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobTemplateOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobTemplateOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which MappableDomainHistory connections can be ordered.
type MappableDomainHistoryOrderField string

const (
	MappableDomainHistoryOrderFieldHistoryTime MappableDomainHistoryOrderField = "history_time"
	MappableDomainHistoryOrderFieldCreatedAt   MappableDomainHistoryOrderField = "created_at"
	MappableDomainHistoryOrderFieldUpdatedAt   MappableDomainHistoryOrderField = "updated_at"
	MappableDomainHistoryOrderFieldName        MappableDomainHistoryOrderField = "name"
)

var AllMappableDomainHistoryOrderField = []MappableDomainHistoryOrderField{
	MappableDomainHistoryOrderFieldHistoryTime,
	MappableDomainHistoryOrderFieldCreatedAt,
	MappableDomainHistoryOrderFieldUpdatedAt,
	MappableDomainHistoryOrderFieldName,
}

func (e MappableDomainHistoryOrderField) IsValid() bool {
	switch e {
	case MappableDomainHistoryOrderFieldHistoryTime, MappableDomainHistoryOrderFieldCreatedAt, MappableDomainHistoryOrderFieldUpdatedAt, MappableDomainHistoryOrderFieldName:
		return true
	}
	return false
}

func (e MappableDomainHistoryOrderField) String() string {
	return string(e)
}

func (e *MappableDomainHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MappableDomainHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MappableDomainHistoryOrderField", str)
	}
	return nil
}

func (e MappableDomainHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MappableDomainHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MappableDomainHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which MappableDomain connections can be ordered.
type MappableDomainOrderField string

const (
	MappableDomainOrderFieldCreatedAt MappableDomainOrderField = "created_at"
	MappableDomainOrderFieldUpdatedAt MappableDomainOrderField = "updated_at"
	MappableDomainOrderFieldName      MappableDomainOrderField = "name"
)

var AllMappableDomainOrderField = []MappableDomainOrderField{
	MappableDomainOrderFieldCreatedAt,
	MappableDomainOrderFieldUpdatedAt,
	MappableDomainOrderFieldName,
}

func (e MappableDomainOrderField) IsValid() bool {
	switch e {
	case MappableDomainOrderFieldCreatedAt, MappableDomainOrderFieldUpdatedAt, MappableDomainOrderFieldName:
		return true
	}
	return false
}

func (e MappableDomainOrderField) String() string {
	return string(e)
}

func (e *MappableDomainOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MappableDomainOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MappableDomainOrderField", str)
	}
	return nil
}

func (e MappableDomainOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MappableDomainOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MappableDomainOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which MappedControlHistory connections can be ordered.
type MappedControlHistoryOrderField string

const (
	MappedControlHistoryOrderFieldHistoryTime MappedControlHistoryOrderField = "history_time"
	MappedControlHistoryOrderFieldCreatedAt   MappedControlHistoryOrderField = "created_at"
	MappedControlHistoryOrderFieldUpdatedAt   MappedControlHistoryOrderField = "updated_at"
	MappedControlHistoryOrderFieldMappingType MappedControlHistoryOrderField = "MAPPING_TYPE"
	MappedControlHistoryOrderFieldSource      MappedControlHistoryOrderField = "SOURCE"
)

var AllMappedControlHistoryOrderField = []MappedControlHistoryOrderField{
	MappedControlHistoryOrderFieldHistoryTime,
	MappedControlHistoryOrderFieldCreatedAt,
	MappedControlHistoryOrderFieldUpdatedAt,
	MappedControlHistoryOrderFieldMappingType,
	MappedControlHistoryOrderFieldSource,
}

func (e MappedControlHistoryOrderField) IsValid() bool {
	switch e {
	case MappedControlHistoryOrderFieldHistoryTime, MappedControlHistoryOrderFieldCreatedAt, MappedControlHistoryOrderFieldUpdatedAt, MappedControlHistoryOrderFieldMappingType, MappedControlHistoryOrderFieldSource:
		return true
	}
	return false
}

func (e MappedControlHistoryOrderField) String() string {
	return string(e)
}

func (e *MappedControlHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MappedControlHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MappedControlHistoryOrderField", str)
	}
	return nil
}

func (e MappedControlHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MappedControlHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MappedControlHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which MappedControl connections can be ordered.
type MappedControlOrderField string

const (
	MappedControlOrderFieldCreatedAt   MappedControlOrderField = "created_at"
	MappedControlOrderFieldUpdatedAt   MappedControlOrderField = "updated_at"
	MappedControlOrderFieldMappingType MappedControlOrderField = "MAPPING_TYPE"
	MappedControlOrderFieldSource      MappedControlOrderField = "SOURCE"
)

var AllMappedControlOrderField = []MappedControlOrderField{
	MappedControlOrderFieldCreatedAt,
	MappedControlOrderFieldUpdatedAt,
	MappedControlOrderFieldMappingType,
	MappedControlOrderFieldSource,
}

func (e MappedControlOrderField) IsValid() bool {
	switch e {
	case MappedControlOrderFieldCreatedAt, MappedControlOrderFieldUpdatedAt, MappedControlOrderFieldMappingType, MappedControlOrderFieldSource:
		return true
	}
	return false
}

func (e MappedControlOrderField) String() string {
	return string(e)
}

func (e *MappedControlOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MappedControlOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MappedControlOrderField", str)
	}
	return nil
}

func (e MappedControlOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MappedControlOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MappedControlOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which NarrativeHistory connections can be ordered.
type NarrativeHistoryOrderField string

const (
	NarrativeHistoryOrderFieldHistoryTime NarrativeHistoryOrderField = "history_time"
	NarrativeHistoryOrderFieldCreatedAt   NarrativeHistoryOrderField = "created_at"
	NarrativeHistoryOrderFieldUpdatedAt   NarrativeHistoryOrderField = "updated_at"
	NarrativeHistoryOrderFieldName        NarrativeHistoryOrderField = "name"
)

var AllNarrativeHistoryOrderField = []NarrativeHistoryOrderField{
	NarrativeHistoryOrderFieldHistoryTime,
	NarrativeHistoryOrderFieldCreatedAt,
	NarrativeHistoryOrderFieldUpdatedAt,
	NarrativeHistoryOrderFieldName,
}

func (e NarrativeHistoryOrderField) IsValid() bool {
	switch e {
	case NarrativeHistoryOrderFieldHistoryTime, NarrativeHistoryOrderFieldCreatedAt, NarrativeHistoryOrderFieldUpdatedAt, NarrativeHistoryOrderFieldName:
		return true
	}
	return false
}

func (e NarrativeHistoryOrderField) String() string {
	return string(e)
}

func (e *NarrativeHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NarrativeHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NarrativeHistoryOrderField", str)
	}
	return nil
}

func (e NarrativeHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NarrativeHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NarrativeHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Narrative connections can be ordered.
type NarrativeOrderField string

const (
	NarrativeOrderFieldCreatedAt NarrativeOrderField = "created_at"
	NarrativeOrderFieldUpdatedAt NarrativeOrderField = "updated_at"
	NarrativeOrderFieldName      NarrativeOrderField = "name"
)

var AllNarrativeOrderField = []NarrativeOrderField{
	NarrativeOrderFieldCreatedAt,
	NarrativeOrderFieldUpdatedAt,
	NarrativeOrderFieldName,
}

func (e NarrativeOrderField) IsValid() bool {
	switch e {
	case NarrativeOrderFieldCreatedAt, NarrativeOrderFieldUpdatedAt, NarrativeOrderFieldName:
		return true
	}
	return false
}

func (e NarrativeOrderField) String() string {
	return string(e)
}

func (e *NarrativeOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NarrativeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NarrativeOrderField", str)
	}
	return nil
}

func (e NarrativeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NarrativeOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NarrativeOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which NoteHistory connections can be ordered.
type NoteHistoryOrderField string

const (
	NoteHistoryOrderFieldHistoryTime NoteHistoryOrderField = "history_time"
	NoteHistoryOrderFieldCreatedAt   NoteHistoryOrderField = "created_at"
	NoteHistoryOrderFieldUpdatedAt   NoteHistoryOrderField = "updated_at"
)

var AllNoteHistoryOrderField = []NoteHistoryOrderField{
	NoteHistoryOrderFieldHistoryTime,
	NoteHistoryOrderFieldCreatedAt,
	NoteHistoryOrderFieldUpdatedAt,
}

func (e NoteHistoryOrderField) IsValid() bool {
	switch e {
	case NoteHistoryOrderFieldHistoryTime, NoteHistoryOrderFieldCreatedAt, NoteHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e NoteHistoryOrderField) String() string {
	return string(e)
}

func (e *NoteHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NoteHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NoteHistoryOrderField", str)
	}
	return nil
}

func (e NoteHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NoteHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NoteHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Note connections can be ordered.
type NoteOrderField string

const (
	NoteOrderFieldCreatedAt NoteOrderField = "created_at"
	NoteOrderFieldUpdatedAt NoteOrderField = "updated_at"
)

var AllNoteOrderField = []NoteOrderField{
	NoteOrderFieldCreatedAt,
	NoteOrderFieldUpdatedAt,
}

func (e NoteOrderField) IsValid() bool {
	switch e {
	case NoteOrderFieldCreatedAt, NoteOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e NoteOrderField) String() string {
	return string(e)
}

func (e *NoteOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NoteOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NoteOrderField", str)
	}
	return nil
}

func (e NoteOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NoteOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NoteOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which OrgMembershipHistory connections can be ordered.
type OrgMembershipHistoryOrderField string

const (
	OrgMembershipHistoryOrderFieldHistoryTime OrgMembershipHistoryOrderField = "history_time"
	OrgMembershipHistoryOrderFieldCreatedAt   OrgMembershipHistoryOrderField = "created_at"
	OrgMembershipHistoryOrderFieldUpdatedAt   OrgMembershipHistoryOrderField = "updated_at"
	OrgMembershipHistoryOrderFieldRole        OrgMembershipHistoryOrderField = "ROLE"
)

var AllOrgMembershipHistoryOrderField = []OrgMembershipHistoryOrderField{
	OrgMembershipHistoryOrderFieldHistoryTime,
	OrgMembershipHistoryOrderFieldCreatedAt,
	OrgMembershipHistoryOrderFieldUpdatedAt,
	OrgMembershipHistoryOrderFieldRole,
}

func (e OrgMembershipHistoryOrderField) IsValid() bool {
	switch e {
	case OrgMembershipHistoryOrderFieldHistoryTime, OrgMembershipHistoryOrderFieldCreatedAt, OrgMembershipHistoryOrderFieldUpdatedAt, OrgMembershipHistoryOrderFieldRole:
		return true
	}
	return false
}

func (e OrgMembershipHistoryOrderField) String() string {
	return string(e)
}

func (e *OrgMembershipHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgMembershipHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgMembershipHistoryOrderField", str)
	}
	return nil
}

func (e OrgMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrgMembershipHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrgMembershipHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which OrgMembership connections can be ordered.
type OrgMembershipOrderField string

const (
	OrgMembershipOrderFieldCreatedAt OrgMembershipOrderField = "created_at"
	OrgMembershipOrderFieldUpdatedAt OrgMembershipOrderField = "updated_at"
	OrgMembershipOrderFieldRole      OrgMembershipOrderField = "ROLE"
)

var AllOrgMembershipOrderField = []OrgMembershipOrderField{
	OrgMembershipOrderFieldCreatedAt,
	OrgMembershipOrderFieldUpdatedAt,
	OrgMembershipOrderFieldRole,
}

func (e OrgMembershipOrderField) IsValid() bool {
	switch e {
	case OrgMembershipOrderFieldCreatedAt, OrgMembershipOrderFieldUpdatedAt, OrgMembershipOrderFieldRole:
		return true
	}
	return false
}

func (e OrgMembershipOrderField) String() string {
	return string(e)
}

func (e *OrgMembershipOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgMembershipOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgMembershipOrderField", str)
	}
	return nil
}

func (e OrgMembershipOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrgMembershipOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrgMembershipOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which OrgSubscriptionHistory connections can be ordered.
type OrgSubscriptionHistoryOrderField string

const (
	OrgSubscriptionHistoryOrderFieldHistoryTime              OrgSubscriptionHistoryOrderField = "history_time"
	OrgSubscriptionHistoryOrderFieldCreatedAt                OrgSubscriptionHistoryOrderField = "created_at"
	OrgSubscriptionHistoryOrderFieldUpdatedAt                OrgSubscriptionHistoryOrderField = "updated_at"
	OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus OrgSubscriptionHistoryOrderField = "stripe_subscription_status"
	OrgSubscriptionHistoryOrderFieldActive                   OrgSubscriptionHistoryOrderField = "active"
	OrgSubscriptionHistoryOrderFieldExpiresAt                OrgSubscriptionHistoryOrderField = "expires_at"
	OrgSubscriptionHistoryOrderFieldTrialExpiresAt           OrgSubscriptionHistoryOrderField = "trial_expires_at"
	OrgSubscriptionHistoryOrderFieldDaysUntilDue             OrgSubscriptionHistoryOrderField = "days_until_due"
)

var AllOrgSubscriptionHistoryOrderField = []OrgSubscriptionHistoryOrderField{
	OrgSubscriptionHistoryOrderFieldHistoryTime,
	OrgSubscriptionHistoryOrderFieldCreatedAt,
	OrgSubscriptionHistoryOrderFieldUpdatedAt,
	OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus,
	OrgSubscriptionHistoryOrderFieldActive,
	OrgSubscriptionHistoryOrderFieldExpiresAt,
	OrgSubscriptionHistoryOrderFieldTrialExpiresAt,
	OrgSubscriptionHistoryOrderFieldDaysUntilDue,
}

func (e OrgSubscriptionHistoryOrderField) IsValid() bool {
	switch e {
	case OrgSubscriptionHistoryOrderFieldHistoryTime, OrgSubscriptionHistoryOrderFieldCreatedAt, OrgSubscriptionHistoryOrderFieldUpdatedAt, OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus, OrgSubscriptionHistoryOrderFieldActive, OrgSubscriptionHistoryOrderFieldExpiresAt, OrgSubscriptionHistoryOrderFieldTrialExpiresAt, OrgSubscriptionHistoryOrderFieldDaysUntilDue:
		return true
	}
	return false
}

func (e OrgSubscriptionHistoryOrderField) String() string {
	return string(e)
}

func (e *OrgSubscriptionHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgSubscriptionHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgSubscriptionHistoryOrderField", str)
	}
	return nil
}

func (e OrgSubscriptionHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrgSubscriptionHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrgSubscriptionHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which OrgSubscription connections can be ordered.
type OrgSubscriptionOrderField string

const (
	OrgSubscriptionOrderFieldCreatedAt                OrgSubscriptionOrderField = "created_at"
	OrgSubscriptionOrderFieldUpdatedAt                OrgSubscriptionOrderField = "updated_at"
	OrgSubscriptionOrderFieldStripeSubscriptionStatus OrgSubscriptionOrderField = "stripe_subscription_status"
	OrgSubscriptionOrderFieldActive                   OrgSubscriptionOrderField = "active"
	OrgSubscriptionOrderFieldExpiresAt                OrgSubscriptionOrderField = "expires_at"
	OrgSubscriptionOrderFieldTrialExpiresAt           OrgSubscriptionOrderField = "trial_expires_at"
	OrgSubscriptionOrderFieldDaysUntilDue             OrgSubscriptionOrderField = "days_until_due"
)

var AllOrgSubscriptionOrderField = []OrgSubscriptionOrderField{
	OrgSubscriptionOrderFieldCreatedAt,
	OrgSubscriptionOrderFieldUpdatedAt,
	OrgSubscriptionOrderFieldStripeSubscriptionStatus,
	OrgSubscriptionOrderFieldActive,
	OrgSubscriptionOrderFieldExpiresAt,
	OrgSubscriptionOrderFieldTrialExpiresAt,
	OrgSubscriptionOrderFieldDaysUntilDue,
}

func (e OrgSubscriptionOrderField) IsValid() bool {
	switch e {
	case OrgSubscriptionOrderFieldCreatedAt, OrgSubscriptionOrderFieldUpdatedAt, OrgSubscriptionOrderFieldStripeSubscriptionStatus, OrgSubscriptionOrderFieldActive, OrgSubscriptionOrderFieldExpiresAt, OrgSubscriptionOrderFieldTrialExpiresAt, OrgSubscriptionOrderFieldDaysUntilDue:
		return true
	}
	return false
}

func (e OrgSubscriptionOrderField) String() string {
	return string(e)
}

func (e *OrgSubscriptionOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgSubscriptionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgSubscriptionOrderField", str)
	}
	return nil
}

func (e OrgSubscriptionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrgSubscriptionOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrgSubscriptionOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which OrganizationHistory connections can be ordered.
type OrganizationHistoryOrderField string

const (
	OrganizationHistoryOrderFieldHistoryTime OrganizationHistoryOrderField = "history_time"
	OrganizationHistoryOrderFieldCreatedAt   OrganizationHistoryOrderField = "created_at"
	OrganizationHistoryOrderFieldUpdatedAt   OrganizationHistoryOrderField = "updated_at"
	OrganizationHistoryOrderFieldName        OrganizationHistoryOrderField = "name"
	OrganizationHistoryOrderFieldDisplayName OrganizationHistoryOrderField = "display_name"
)

var AllOrganizationHistoryOrderField = []OrganizationHistoryOrderField{
	OrganizationHistoryOrderFieldHistoryTime,
	OrganizationHistoryOrderFieldCreatedAt,
	OrganizationHistoryOrderFieldUpdatedAt,
	OrganizationHistoryOrderFieldName,
	OrganizationHistoryOrderFieldDisplayName,
}

func (e OrganizationHistoryOrderField) IsValid() bool {
	switch e {
	case OrganizationHistoryOrderFieldHistoryTime, OrganizationHistoryOrderFieldCreatedAt, OrganizationHistoryOrderFieldUpdatedAt, OrganizationHistoryOrderFieldName, OrganizationHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationHistoryOrderField) String() string {
	return string(e)
}

func (e *OrganizationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

func (e OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Organization connections can be ordered.
type OrganizationOrderField string

const (
	OrganizationOrderFieldCreatedAt   OrganizationOrderField = "created_at"
	OrganizationOrderFieldUpdatedAt   OrganizationOrderField = "updated_at"
	OrganizationOrderFieldName        OrganizationOrderField = "name"
	OrganizationOrderFieldDisplayName OrganizationOrderField = "display_name"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldCreatedAt,
	OrganizationOrderFieldUpdatedAt,
	OrganizationOrderFieldName,
	OrganizationOrderFieldDisplayName,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldCreatedAt, OrganizationOrderFieldUpdatedAt, OrganizationOrderFieldName, OrganizationOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which OrganizationSettingHistory connections can be ordered.
type OrganizationSettingHistoryOrderField string

const (
	OrganizationSettingHistoryOrderFieldHistoryTime OrganizationSettingHistoryOrderField = "history_time"
	OrganizationSettingHistoryOrderFieldCreatedAt   OrganizationSettingHistoryOrderField = "created_at"
	OrganizationSettingHistoryOrderFieldUpdatedAt   OrganizationSettingHistoryOrderField = "updated_at"
)

var AllOrganizationSettingHistoryOrderField = []OrganizationSettingHistoryOrderField{
	OrganizationSettingHistoryOrderFieldHistoryTime,
	OrganizationSettingHistoryOrderFieldCreatedAt,
	OrganizationSettingHistoryOrderFieldUpdatedAt,
}

func (e OrganizationSettingHistoryOrderField) IsValid() bool {
	switch e {
	case OrganizationSettingHistoryOrderFieldHistoryTime, OrganizationSettingHistoryOrderFieldCreatedAt, OrganizationSettingHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e OrganizationSettingHistoryOrderField) String() string {
	return string(e)
}

func (e *OrganizationSettingHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationSettingHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationSettingHistoryOrderField", str)
	}
	return nil
}

func (e OrganizationSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationSettingHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationSettingHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which OrganizationSetting connections can be ordered.
type OrganizationSettingOrderField string

const (
	OrganizationSettingOrderFieldCreatedAt OrganizationSettingOrderField = "created_at"
	OrganizationSettingOrderFieldUpdatedAt OrganizationSettingOrderField = "updated_at"
)

var AllOrganizationSettingOrderField = []OrganizationSettingOrderField{
	OrganizationSettingOrderFieldCreatedAt,
	OrganizationSettingOrderFieldUpdatedAt,
}

func (e OrganizationSettingOrderField) IsValid() bool {
	switch e {
	case OrganizationSettingOrderFieldCreatedAt, OrganizationSettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e OrganizationSettingOrderField) String() string {
	return string(e)
}

func (e *OrganizationSettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationSettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationSettingOrderField", str)
	}
	return nil
}

func (e OrganizationSettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationSettingOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationSettingOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which PersonalAccessToken connections can be ordered.
type PersonalAccessTokenOrderField string

const (
	PersonalAccessTokenOrderFieldCreatedAt  PersonalAccessTokenOrderField = "created_at"
	PersonalAccessTokenOrderFieldUpdatedAt  PersonalAccessTokenOrderField = "updated_at"
	PersonalAccessTokenOrderFieldName       PersonalAccessTokenOrderField = "name"
	PersonalAccessTokenOrderFieldExpiresAt  PersonalAccessTokenOrderField = "expires_at"
	PersonalAccessTokenOrderFieldLastUsedAt PersonalAccessTokenOrderField = "last_used_at"
	PersonalAccessTokenOrderFieldIsActive   PersonalAccessTokenOrderField = "is_active"
)

var AllPersonalAccessTokenOrderField = []PersonalAccessTokenOrderField{
	PersonalAccessTokenOrderFieldCreatedAt,
	PersonalAccessTokenOrderFieldUpdatedAt,
	PersonalAccessTokenOrderFieldName,
	PersonalAccessTokenOrderFieldExpiresAt,
	PersonalAccessTokenOrderFieldLastUsedAt,
	PersonalAccessTokenOrderFieldIsActive,
}

func (e PersonalAccessTokenOrderField) IsValid() bool {
	switch e {
	case PersonalAccessTokenOrderFieldCreatedAt, PersonalAccessTokenOrderFieldUpdatedAt, PersonalAccessTokenOrderFieldName, PersonalAccessTokenOrderFieldExpiresAt, PersonalAccessTokenOrderFieldLastUsedAt, PersonalAccessTokenOrderFieldIsActive:
		return true
	}
	return false
}

func (e PersonalAccessTokenOrderField) String() string {
	return string(e)
}

func (e *PersonalAccessTokenOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PersonalAccessTokenOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PersonalAccessTokenOrderField", str)
	}
	return nil
}

func (e PersonalAccessTokenOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PersonalAccessTokenOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PersonalAccessTokenOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ProcedureHistory connections can be ordered.
type ProcedureHistoryOrderField string

const (
	ProcedureHistoryOrderFieldHistoryTime     ProcedureHistoryOrderField = "history_time"
	ProcedureHistoryOrderFieldCreatedAt       ProcedureHistoryOrderField = "created_at"
	ProcedureHistoryOrderFieldUpdatedAt       ProcedureHistoryOrderField = "updated_at"
	ProcedureHistoryOrderFieldRevision        ProcedureHistoryOrderField = "revision"
	ProcedureHistoryOrderFieldName            ProcedureHistoryOrderField = "name"
	ProcedureHistoryOrderFieldStatus          ProcedureHistoryOrderField = "STATUS"
	ProcedureHistoryOrderFieldReviewDue       ProcedureHistoryOrderField = "review_due"
	ProcedureHistoryOrderFieldReviewFrequency ProcedureHistoryOrderField = "REVIEW_FREQUENCY"
)

var AllProcedureHistoryOrderField = []ProcedureHistoryOrderField{
	ProcedureHistoryOrderFieldHistoryTime,
	ProcedureHistoryOrderFieldCreatedAt,
	ProcedureHistoryOrderFieldUpdatedAt,
	ProcedureHistoryOrderFieldRevision,
	ProcedureHistoryOrderFieldName,
	ProcedureHistoryOrderFieldStatus,
	ProcedureHistoryOrderFieldReviewDue,
	ProcedureHistoryOrderFieldReviewFrequency,
}

func (e ProcedureHistoryOrderField) IsValid() bool {
	switch e {
	case ProcedureHistoryOrderFieldHistoryTime, ProcedureHistoryOrderFieldCreatedAt, ProcedureHistoryOrderFieldUpdatedAt, ProcedureHistoryOrderFieldRevision, ProcedureHistoryOrderFieldName, ProcedureHistoryOrderFieldStatus, ProcedureHistoryOrderFieldReviewDue, ProcedureHistoryOrderFieldReviewFrequency:
		return true
	}
	return false
}

func (e ProcedureHistoryOrderField) String() string {
	return string(e)
}

func (e *ProcedureHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProcedureHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProcedureHistoryOrderField", str)
	}
	return nil
}

func (e ProcedureHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProcedureHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProcedureHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Procedure connections can be ordered.
type ProcedureOrderField string

const (
	ProcedureOrderFieldCreatedAt       ProcedureOrderField = "created_at"
	ProcedureOrderFieldUpdatedAt       ProcedureOrderField = "updated_at"
	ProcedureOrderFieldRevision        ProcedureOrderField = "revision"
	ProcedureOrderFieldName            ProcedureOrderField = "name"
	ProcedureOrderFieldStatus          ProcedureOrderField = "STATUS"
	ProcedureOrderFieldReviewDue       ProcedureOrderField = "review_due"
	ProcedureOrderFieldReviewFrequency ProcedureOrderField = "REVIEW_FREQUENCY"
)

var AllProcedureOrderField = []ProcedureOrderField{
	ProcedureOrderFieldCreatedAt,
	ProcedureOrderFieldUpdatedAt,
	ProcedureOrderFieldRevision,
	ProcedureOrderFieldName,
	ProcedureOrderFieldStatus,
	ProcedureOrderFieldReviewDue,
	ProcedureOrderFieldReviewFrequency,
}

func (e ProcedureOrderField) IsValid() bool {
	switch e {
	case ProcedureOrderFieldCreatedAt, ProcedureOrderFieldUpdatedAt, ProcedureOrderFieldRevision, ProcedureOrderFieldName, ProcedureOrderFieldStatus, ProcedureOrderFieldReviewDue, ProcedureOrderFieldReviewFrequency:
		return true
	}
	return false
}

func (e ProcedureOrderField) String() string {
	return string(e)
}

func (e *ProcedureOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProcedureOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProcedureOrderField", str)
	}
	return nil
}

func (e ProcedureOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProcedureOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProcedureOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ProgramHistory connections can be ordered.
type ProgramHistoryOrderField string

const (
	ProgramHistoryOrderFieldHistoryTime ProgramHistoryOrderField = "history_time"
	ProgramHistoryOrderFieldCreatedAt   ProgramHistoryOrderField = "created_at"
	ProgramHistoryOrderFieldUpdatedAt   ProgramHistoryOrderField = "updated_at"
	ProgramHistoryOrderFieldName        ProgramHistoryOrderField = "name"
	ProgramHistoryOrderFieldStatus      ProgramHistoryOrderField = "STATUS"
	ProgramHistoryOrderFieldProgramType ProgramHistoryOrderField = "PROGRAM_TYPE"
	ProgramHistoryOrderFieldFramework   ProgramHistoryOrderField = "framework"
	ProgramHistoryOrderFieldStartDate   ProgramHistoryOrderField = "start_date"
	ProgramHistoryOrderFieldEndDate     ProgramHistoryOrderField = "end_date"
)

var AllProgramHistoryOrderField = []ProgramHistoryOrderField{
	ProgramHistoryOrderFieldHistoryTime,
	ProgramHistoryOrderFieldCreatedAt,
	ProgramHistoryOrderFieldUpdatedAt,
	ProgramHistoryOrderFieldName,
	ProgramHistoryOrderFieldStatus,
	ProgramHistoryOrderFieldProgramType,
	ProgramHistoryOrderFieldFramework,
	ProgramHistoryOrderFieldStartDate,
	ProgramHistoryOrderFieldEndDate,
}

func (e ProgramHistoryOrderField) IsValid() bool {
	switch e {
	case ProgramHistoryOrderFieldHistoryTime, ProgramHistoryOrderFieldCreatedAt, ProgramHistoryOrderFieldUpdatedAt, ProgramHistoryOrderFieldName, ProgramHistoryOrderFieldStatus, ProgramHistoryOrderFieldProgramType, ProgramHistoryOrderFieldFramework, ProgramHistoryOrderFieldStartDate, ProgramHistoryOrderFieldEndDate:
		return true
	}
	return false
}

func (e ProgramHistoryOrderField) String() string {
	return string(e)
}

func (e *ProgramHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgramHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgramHistoryOrderField", str)
	}
	return nil
}

func (e ProgramHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProgramHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProgramHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ProgramMembershipHistory connections can be ordered.
type ProgramMembershipHistoryOrderField string

const (
	ProgramMembershipHistoryOrderFieldHistoryTime ProgramMembershipHistoryOrderField = "history_time"
	ProgramMembershipHistoryOrderFieldCreatedAt   ProgramMembershipHistoryOrderField = "created_at"
	ProgramMembershipHistoryOrderFieldUpdatedAt   ProgramMembershipHistoryOrderField = "updated_at"
	ProgramMembershipHistoryOrderFieldRole        ProgramMembershipHistoryOrderField = "ROLE"
)

var AllProgramMembershipHistoryOrderField = []ProgramMembershipHistoryOrderField{
	ProgramMembershipHistoryOrderFieldHistoryTime,
	ProgramMembershipHistoryOrderFieldCreatedAt,
	ProgramMembershipHistoryOrderFieldUpdatedAt,
	ProgramMembershipHistoryOrderFieldRole,
}

func (e ProgramMembershipHistoryOrderField) IsValid() bool {
	switch e {
	case ProgramMembershipHistoryOrderFieldHistoryTime, ProgramMembershipHistoryOrderFieldCreatedAt, ProgramMembershipHistoryOrderFieldUpdatedAt, ProgramMembershipHistoryOrderFieldRole:
		return true
	}
	return false
}

func (e ProgramMembershipHistoryOrderField) String() string {
	return string(e)
}

func (e *ProgramMembershipHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgramMembershipHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgramMembershipHistoryOrderField", str)
	}
	return nil
}

func (e ProgramMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProgramMembershipHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProgramMembershipHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ProgramMembership connections can be ordered.
type ProgramMembershipOrderField string

const (
	ProgramMembershipOrderFieldCreatedAt ProgramMembershipOrderField = "created_at"
	ProgramMembershipOrderFieldUpdatedAt ProgramMembershipOrderField = "updated_at"
	ProgramMembershipOrderFieldRole      ProgramMembershipOrderField = "ROLE"
)

var AllProgramMembershipOrderField = []ProgramMembershipOrderField{
	ProgramMembershipOrderFieldCreatedAt,
	ProgramMembershipOrderFieldUpdatedAt,
	ProgramMembershipOrderFieldRole,
}

func (e ProgramMembershipOrderField) IsValid() bool {
	switch e {
	case ProgramMembershipOrderFieldCreatedAt, ProgramMembershipOrderFieldUpdatedAt, ProgramMembershipOrderFieldRole:
		return true
	}
	return false
}

func (e ProgramMembershipOrderField) String() string {
	return string(e)
}

func (e *ProgramMembershipOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgramMembershipOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgramMembershipOrderField", str)
	}
	return nil
}

func (e ProgramMembershipOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProgramMembershipOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProgramMembershipOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Program connections can be ordered.
type ProgramOrderField string

const (
	ProgramOrderFieldCreatedAt   ProgramOrderField = "created_at"
	ProgramOrderFieldUpdatedAt   ProgramOrderField = "updated_at"
	ProgramOrderFieldName        ProgramOrderField = "name"
	ProgramOrderFieldStatus      ProgramOrderField = "STATUS"
	ProgramOrderFieldProgramType ProgramOrderField = "PROGRAM_TYPE"
	ProgramOrderFieldFramework   ProgramOrderField = "framework"
	ProgramOrderFieldStartDate   ProgramOrderField = "start_date"
	ProgramOrderFieldEndDate     ProgramOrderField = "end_date"
)

var AllProgramOrderField = []ProgramOrderField{
	ProgramOrderFieldCreatedAt,
	ProgramOrderFieldUpdatedAt,
	ProgramOrderFieldName,
	ProgramOrderFieldStatus,
	ProgramOrderFieldProgramType,
	ProgramOrderFieldFramework,
	ProgramOrderFieldStartDate,
	ProgramOrderFieldEndDate,
}

func (e ProgramOrderField) IsValid() bool {
	switch e {
	case ProgramOrderFieldCreatedAt, ProgramOrderFieldUpdatedAt, ProgramOrderFieldName, ProgramOrderFieldStatus, ProgramOrderFieldProgramType, ProgramOrderFieldFramework, ProgramOrderFieldStartDate, ProgramOrderFieldEndDate:
		return true
	}
	return false
}

func (e ProgramOrderField) String() string {
	return string(e)
}

func (e *ProgramOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgramOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgramOrderField", str)
	}
	return nil
}

func (e ProgramOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProgramOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProgramOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which RemediationHistory connections can be ordered.
type RemediationHistoryOrderField string

const (
	RemediationHistoryOrderFieldHistoryTime     RemediationHistoryOrderField = "history_time"
	RemediationHistoryOrderFieldCreatedAt       RemediationHistoryOrderField = "created_at"
	RemediationHistoryOrderFieldUpdatedAt       RemediationHistoryOrderField = "updated_at"
	RemediationHistoryOrderFieldExternalID      RemediationHistoryOrderField = "external_id"
	RemediationHistoryOrderFieldExternalOwnerID RemediationHistoryOrderField = "external_owner_id"
	RemediationHistoryOrderFieldTitle           RemediationHistoryOrderField = "title"
	RemediationHistoryOrderFieldState           RemediationHistoryOrderField = "state"
)

var AllRemediationHistoryOrderField = []RemediationHistoryOrderField{
	RemediationHistoryOrderFieldHistoryTime,
	RemediationHistoryOrderFieldCreatedAt,
	RemediationHistoryOrderFieldUpdatedAt,
	RemediationHistoryOrderFieldExternalID,
	RemediationHistoryOrderFieldExternalOwnerID,
	RemediationHistoryOrderFieldTitle,
	RemediationHistoryOrderFieldState,
}

func (e RemediationHistoryOrderField) IsValid() bool {
	switch e {
	case RemediationHistoryOrderFieldHistoryTime, RemediationHistoryOrderFieldCreatedAt, RemediationHistoryOrderFieldUpdatedAt, RemediationHistoryOrderFieldExternalID, RemediationHistoryOrderFieldExternalOwnerID, RemediationHistoryOrderFieldTitle, RemediationHistoryOrderFieldState:
		return true
	}
	return false
}

func (e RemediationHistoryOrderField) String() string {
	return string(e)
}

func (e *RemediationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemediationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemediationHistoryOrderField", str)
	}
	return nil
}

func (e RemediationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RemediationHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RemediationHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Remediation connections can be ordered.
type RemediationOrderField string

const (
	RemediationOrderFieldCreatedAt       RemediationOrderField = "created_at"
	RemediationOrderFieldUpdatedAt       RemediationOrderField = "updated_at"
	RemediationOrderFieldExternalID      RemediationOrderField = "external_id"
	RemediationOrderFieldExternalOwnerID RemediationOrderField = "external_owner_id"
	RemediationOrderFieldTitle           RemediationOrderField = "title"
	RemediationOrderFieldState           RemediationOrderField = "state"
)

var AllRemediationOrderField = []RemediationOrderField{
	RemediationOrderFieldCreatedAt,
	RemediationOrderFieldUpdatedAt,
	RemediationOrderFieldExternalID,
	RemediationOrderFieldExternalOwnerID,
	RemediationOrderFieldTitle,
	RemediationOrderFieldState,
}

func (e RemediationOrderField) IsValid() bool {
	switch e {
	case RemediationOrderFieldCreatedAt, RemediationOrderFieldUpdatedAt, RemediationOrderFieldExternalID, RemediationOrderFieldExternalOwnerID, RemediationOrderFieldTitle, RemediationOrderFieldState:
		return true
	}
	return false
}

func (e RemediationOrderField) String() string {
	return string(e)
}

func (e *RemediationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RemediationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RemediationOrderField", str)
	}
	return nil
}

func (e RemediationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RemediationOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RemediationOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ReviewHistory connections can be ordered.
type ReviewHistoryOrderField string

const (
	ReviewHistoryOrderFieldHistoryTime     ReviewHistoryOrderField = "history_time"
	ReviewHistoryOrderFieldCreatedAt       ReviewHistoryOrderField = "created_at"
	ReviewHistoryOrderFieldUpdatedAt       ReviewHistoryOrderField = "updated_at"
	ReviewHistoryOrderFieldExternalID      ReviewHistoryOrderField = "external_id"
	ReviewHistoryOrderFieldExternalOwnerID ReviewHistoryOrderField = "external_owner_id"
	ReviewHistoryOrderFieldTitle           ReviewHistoryOrderField = "title"
	ReviewHistoryOrderFieldState           ReviewHistoryOrderField = "state"
)

var AllReviewHistoryOrderField = []ReviewHistoryOrderField{
	ReviewHistoryOrderFieldHistoryTime,
	ReviewHistoryOrderFieldCreatedAt,
	ReviewHistoryOrderFieldUpdatedAt,
	ReviewHistoryOrderFieldExternalID,
	ReviewHistoryOrderFieldExternalOwnerID,
	ReviewHistoryOrderFieldTitle,
	ReviewHistoryOrderFieldState,
}

func (e ReviewHistoryOrderField) IsValid() bool {
	switch e {
	case ReviewHistoryOrderFieldHistoryTime, ReviewHistoryOrderFieldCreatedAt, ReviewHistoryOrderFieldUpdatedAt, ReviewHistoryOrderFieldExternalID, ReviewHistoryOrderFieldExternalOwnerID, ReviewHistoryOrderFieldTitle, ReviewHistoryOrderFieldState:
		return true
	}
	return false
}

func (e ReviewHistoryOrderField) String() string {
	return string(e)
}

func (e *ReviewHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReviewHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReviewHistoryOrderField", str)
	}
	return nil
}

func (e ReviewHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ReviewHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ReviewHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Review connections can be ordered.
type ReviewOrderField string

const (
	ReviewOrderFieldCreatedAt       ReviewOrderField = "created_at"
	ReviewOrderFieldUpdatedAt       ReviewOrderField = "updated_at"
	ReviewOrderFieldExternalID      ReviewOrderField = "external_id"
	ReviewOrderFieldExternalOwnerID ReviewOrderField = "external_owner_id"
	ReviewOrderFieldTitle           ReviewOrderField = "title"
	ReviewOrderFieldState           ReviewOrderField = "state"
)

var AllReviewOrderField = []ReviewOrderField{
	ReviewOrderFieldCreatedAt,
	ReviewOrderFieldUpdatedAt,
	ReviewOrderFieldExternalID,
	ReviewOrderFieldExternalOwnerID,
	ReviewOrderFieldTitle,
	ReviewOrderFieldState,
}

func (e ReviewOrderField) IsValid() bool {
	switch e {
	case ReviewOrderFieldCreatedAt, ReviewOrderFieldUpdatedAt, ReviewOrderFieldExternalID, ReviewOrderFieldExternalOwnerID, ReviewOrderFieldTitle, ReviewOrderFieldState:
		return true
	}
	return false
}

func (e ReviewOrderField) String() string {
	return string(e)
}

func (e *ReviewOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReviewOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReviewOrderField", str)
	}
	return nil
}

func (e ReviewOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ReviewOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ReviewOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which RiskHistory connections can be ordered.
type RiskHistoryOrderField string

const (
	RiskHistoryOrderFieldHistoryTime   RiskHistoryOrderField = "history_time"
	RiskHistoryOrderFieldCreatedAt     RiskHistoryOrderField = "created_at"
	RiskHistoryOrderFieldUpdatedAt     RiskHistoryOrderField = "updated_at"
	RiskHistoryOrderFieldName          RiskHistoryOrderField = "name"
	RiskHistoryOrderFieldStatus        RiskHistoryOrderField = "STATUS"
	RiskHistoryOrderFieldRiskType      RiskHistoryOrderField = "risk_type"
	RiskHistoryOrderFieldCategory      RiskHistoryOrderField = "category"
	RiskHistoryOrderFieldImpact        RiskHistoryOrderField = "IMPACT"
	RiskHistoryOrderFieldLikelihood    RiskHistoryOrderField = "LIKELIHOOD"
	RiskHistoryOrderFieldScore         RiskHistoryOrderField = "score"
	RiskHistoryOrderFieldBusinessCosts RiskHistoryOrderField = "business_costs"
)

var AllRiskHistoryOrderField = []RiskHistoryOrderField{
	RiskHistoryOrderFieldHistoryTime,
	RiskHistoryOrderFieldCreatedAt,
	RiskHistoryOrderFieldUpdatedAt,
	RiskHistoryOrderFieldName,
	RiskHistoryOrderFieldStatus,
	RiskHistoryOrderFieldRiskType,
	RiskHistoryOrderFieldCategory,
	RiskHistoryOrderFieldImpact,
	RiskHistoryOrderFieldLikelihood,
	RiskHistoryOrderFieldScore,
	RiskHistoryOrderFieldBusinessCosts,
}

func (e RiskHistoryOrderField) IsValid() bool {
	switch e {
	case RiskHistoryOrderFieldHistoryTime, RiskHistoryOrderFieldCreatedAt, RiskHistoryOrderFieldUpdatedAt, RiskHistoryOrderFieldName, RiskHistoryOrderFieldStatus, RiskHistoryOrderFieldRiskType, RiskHistoryOrderFieldCategory, RiskHistoryOrderFieldImpact, RiskHistoryOrderFieldLikelihood, RiskHistoryOrderFieldScore, RiskHistoryOrderFieldBusinessCosts:
		return true
	}
	return false
}

func (e RiskHistoryOrderField) String() string {
	return string(e)
}

func (e *RiskHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskHistoryOrderField", str)
	}
	return nil
}

func (e RiskHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RiskHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RiskHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Risk connections can be ordered.
type RiskOrderField string

const (
	RiskOrderFieldCreatedAt     RiskOrderField = "created_at"
	RiskOrderFieldUpdatedAt     RiskOrderField = "updated_at"
	RiskOrderFieldName          RiskOrderField = "name"
	RiskOrderFieldStatus        RiskOrderField = "STATUS"
	RiskOrderFieldRiskType      RiskOrderField = "risk_type"
	RiskOrderFieldCategory      RiskOrderField = "category"
	RiskOrderFieldImpact        RiskOrderField = "IMPACT"
	RiskOrderFieldLikelihood    RiskOrderField = "LIKELIHOOD"
	RiskOrderFieldScore         RiskOrderField = "score"
	RiskOrderFieldBusinessCosts RiskOrderField = "business_costs"
)

var AllRiskOrderField = []RiskOrderField{
	RiskOrderFieldCreatedAt,
	RiskOrderFieldUpdatedAt,
	RiskOrderFieldName,
	RiskOrderFieldStatus,
	RiskOrderFieldRiskType,
	RiskOrderFieldCategory,
	RiskOrderFieldImpact,
	RiskOrderFieldLikelihood,
	RiskOrderFieldScore,
	RiskOrderFieldBusinessCosts,
}

func (e RiskOrderField) IsValid() bool {
	switch e {
	case RiskOrderFieldCreatedAt, RiskOrderFieldUpdatedAt, RiskOrderFieldName, RiskOrderFieldStatus, RiskOrderFieldRiskType, RiskOrderFieldCategory, RiskOrderFieldImpact, RiskOrderFieldLikelihood, RiskOrderFieldScore, RiskOrderFieldBusinessCosts:
		return true
	}
	return false
}

func (e RiskOrderField) String() string {
	return string(e)
}

func (e *RiskOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskOrderField", str)
	}
	return nil
}

func (e RiskOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RiskOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RiskOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ScanHistory connections can be ordered.
type ScanHistoryOrderField string

const (
	ScanHistoryOrderFieldHistoryTime ScanHistoryOrderField = "history_time"
	ScanHistoryOrderFieldCreatedAt   ScanHistoryOrderField = "created_at"
	ScanHistoryOrderFieldUpdatedAt   ScanHistoryOrderField = "updated_at"
	ScanHistoryOrderFieldScanType    ScanHistoryOrderField = "SCAN_TYPE"
	ScanHistoryOrderFieldStatus      ScanHistoryOrderField = "STATUS"
)

var AllScanHistoryOrderField = []ScanHistoryOrderField{
	ScanHistoryOrderFieldHistoryTime,
	ScanHistoryOrderFieldCreatedAt,
	ScanHistoryOrderFieldUpdatedAt,
	ScanHistoryOrderFieldScanType,
	ScanHistoryOrderFieldStatus,
}

func (e ScanHistoryOrderField) IsValid() bool {
	switch e {
	case ScanHistoryOrderFieldHistoryTime, ScanHistoryOrderFieldCreatedAt, ScanHistoryOrderFieldUpdatedAt, ScanHistoryOrderFieldScanType, ScanHistoryOrderFieldStatus:
		return true
	}
	return false
}

func (e ScanHistoryOrderField) String() string {
	return string(e)
}

func (e *ScanHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanHistoryOrderField", str)
	}
	return nil
}

func (e ScanHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScanHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScanHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Scan connections can be ordered.
type ScanOrderField string

const (
	ScanOrderFieldCreatedAt ScanOrderField = "created_at"
	ScanOrderFieldUpdatedAt ScanOrderField = "updated_at"
	ScanOrderFieldScanType  ScanOrderField = "SCAN_TYPE"
	ScanOrderFieldStatus    ScanOrderField = "STATUS"
)

var AllScanOrderField = []ScanOrderField{
	ScanOrderFieldCreatedAt,
	ScanOrderFieldUpdatedAt,
	ScanOrderFieldScanType,
	ScanOrderFieldStatus,
}

func (e ScanOrderField) IsValid() bool {
	switch e {
	case ScanOrderFieldCreatedAt, ScanOrderFieldUpdatedAt, ScanOrderFieldScanType, ScanOrderFieldStatus:
		return true
	}
	return false
}

func (e ScanOrderField) String() string {
	return string(e)
}

func (e *ScanOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanOrderField", str)
	}
	return nil
}

func (e ScanOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScanOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScanOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ScheduledJobHistory connections can be ordered.
type ScheduledJobHistoryOrderField string

const (
	ScheduledJobHistoryOrderFieldHistoryTime ScheduledJobHistoryOrderField = "history_time"
	ScheduledJobHistoryOrderFieldCreatedAt   ScheduledJobHistoryOrderField = "created_at"
	ScheduledJobHistoryOrderFieldUpdatedAt   ScheduledJobHistoryOrderField = "updated_at"
)

var AllScheduledJobHistoryOrderField = []ScheduledJobHistoryOrderField{
	ScheduledJobHistoryOrderFieldHistoryTime,
	ScheduledJobHistoryOrderFieldCreatedAt,
	ScheduledJobHistoryOrderFieldUpdatedAt,
}

func (e ScheduledJobHistoryOrderField) IsValid() bool {
	switch e {
	case ScheduledJobHistoryOrderFieldHistoryTime, ScheduledJobHistoryOrderFieldCreatedAt, ScheduledJobHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e ScheduledJobHistoryOrderField) String() string {
	return string(e)
}

func (e *ScheduledJobHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduledJobHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduledJobHistoryOrderField", str)
	}
	return nil
}

func (e ScheduledJobHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScheduledJobHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScheduledJobHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ScheduledJob connections can be ordered.
type ScheduledJobOrderField string

const (
	ScheduledJobOrderFieldCreatedAt ScheduledJobOrderField = "created_at"
	ScheduledJobOrderFieldUpdatedAt ScheduledJobOrderField = "updated_at"
)

var AllScheduledJobOrderField = []ScheduledJobOrderField{
	ScheduledJobOrderFieldCreatedAt,
	ScheduledJobOrderFieldUpdatedAt,
}

func (e ScheduledJobOrderField) IsValid() bool {
	switch e {
	case ScheduledJobOrderFieldCreatedAt, ScheduledJobOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e ScheduledJobOrderField) String() string {
	return string(e)
}

func (e *ScheduledJobOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduledJobOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduledJobOrderField", str)
	}
	return nil
}

func (e ScheduledJobOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScheduledJobOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScheduledJobOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which ScheduledJobRun connections can be ordered.
type ScheduledJobRunOrderField string

const (
	ScheduledJobRunOrderFieldCreatedAt ScheduledJobRunOrderField = "created_at"
	ScheduledJobRunOrderFieldUpdatedAt ScheduledJobRunOrderField = "updated_at"
)

var AllScheduledJobRunOrderField = []ScheduledJobRunOrderField{
	ScheduledJobRunOrderFieldCreatedAt,
	ScheduledJobRunOrderFieldUpdatedAt,
}

func (e ScheduledJobRunOrderField) IsValid() bool {
	switch e {
	case ScheduledJobRunOrderFieldCreatedAt, ScheduledJobRunOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e ScheduledJobRunOrderField) String() string {
	return string(e)
}

func (e *ScheduledJobRunOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScheduledJobRunOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScheduledJobRunOrderField", str)
	}
	return nil
}

func (e ScheduledJobRunOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScheduledJobRunOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScheduledJobRunOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which StandardHistory connections can be ordered.
type StandardHistoryOrderField string

const (
	StandardHistoryOrderFieldHistoryTime   StandardHistoryOrderField = "history_time"
	StandardHistoryOrderFieldCreatedAt     StandardHistoryOrderField = "created_at"
	StandardHistoryOrderFieldUpdatedAt     StandardHistoryOrderField = "updated_at"
	StandardHistoryOrderFieldRevision      StandardHistoryOrderField = "revision"
	StandardHistoryOrderFieldName          StandardHistoryOrderField = "name"
	StandardHistoryOrderFieldShortName     StandardHistoryOrderField = "short_name"
	StandardHistoryOrderFieldFramework     StandardHistoryOrderField = "framework"
	StandardHistoryOrderFieldGoverningBody StandardHistoryOrderField = "governing_body"
	StandardHistoryOrderFieldStatus        StandardHistoryOrderField = "STATUS"
	StandardHistoryOrderFieldStandardType  StandardHistoryOrderField = "standard_type"
)

var AllStandardHistoryOrderField = []StandardHistoryOrderField{
	StandardHistoryOrderFieldHistoryTime,
	StandardHistoryOrderFieldCreatedAt,
	StandardHistoryOrderFieldUpdatedAt,
	StandardHistoryOrderFieldRevision,
	StandardHistoryOrderFieldName,
	StandardHistoryOrderFieldShortName,
	StandardHistoryOrderFieldFramework,
	StandardHistoryOrderFieldGoverningBody,
	StandardHistoryOrderFieldStatus,
	StandardHistoryOrderFieldStandardType,
}

func (e StandardHistoryOrderField) IsValid() bool {
	switch e {
	case StandardHistoryOrderFieldHistoryTime, StandardHistoryOrderFieldCreatedAt, StandardHistoryOrderFieldUpdatedAt, StandardHistoryOrderFieldRevision, StandardHistoryOrderFieldName, StandardHistoryOrderFieldShortName, StandardHistoryOrderFieldFramework, StandardHistoryOrderFieldGoverningBody, StandardHistoryOrderFieldStatus, StandardHistoryOrderFieldStandardType:
		return true
	}
	return false
}

func (e StandardHistoryOrderField) String() string {
	return string(e)
}

func (e *StandardHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StandardHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StandardHistoryOrderField", str)
	}
	return nil
}

func (e StandardHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StandardHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StandardHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Standard connections can be ordered.
type StandardOrderField string

const (
	StandardOrderFieldCreatedAt     StandardOrderField = "created_at"
	StandardOrderFieldUpdatedAt     StandardOrderField = "updated_at"
	StandardOrderFieldRevision      StandardOrderField = "revision"
	StandardOrderFieldName          StandardOrderField = "name"
	StandardOrderFieldShortName     StandardOrderField = "short_name"
	StandardOrderFieldFramework     StandardOrderField = "framework"
	StandardOrderFieldGoverningBody StandardOrderField = "governing_body"
	StandardOrderFieldStatus        StandardOrderField = "STATUS"
	StandardOrderFieldStandardType  StandardOrderField = "standard_type"
)

var AllStandardOrderField = []StandardOrderField{
	StandardOrderFieldCreatedAt,
	StandardOrderFieldUpdatedAt,
	StandardOrderFieldRevision,
	StandardOrderFieldName,
	StandardOrderFieldShortName,
	StandardOrderFieldFramework,
	StandardOrderFieldGoverningBody,
	StandardOrderFieldStatus,
	StandardOrderFieldStandardType,
}

func (e StandardOrderField) IsValid() bool {
	switch e {
	case StandardOrderFieldCreatedAt, StandardOrderFieldUpdatedAt, StandardOrderFieldRevision, StandardOrderFieldName, StandardOrderFieldShortName, StandardOrderFieldFramework, StandardOrderFieldGoverningBody, StandardOrderFieldStatus, StandardOrderFieldStandardType:
		return true
	}
	return false
}

func (e StandardOrderField) String() string {
	return string(e)
}

func (e *StandardOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StandardOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StandardOrderField", str)
	}
	return nil
}

func (e StandardOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StandardOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StandardOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which SubcontrolHistory connections can be ordered.
type SubcontrolHistoryOrderField string

const (
	SubcontrolHistoryOrderFieldHistoryTime        SubcontrolHistoryOrderField = "history_time"
	SubcontrolHistoryOrderFieldCreatedAt          SubcontrolHistoryOrderField = "created_at"
	SubcontrolHistoryOrderFieldUpdatedAt          SubcontrolHistoryOrderField = "updated_at"
	SubcontrolHistoryOrderFieldTitle              SubcontrolHistoryOrderField = "title"
	SubcontrolHistoryOrderFieldStatus             SubcontrolHistoryOrderField = "STATUS"
	SubcontrolHistoryOrderFieldSource             SubcontrolHistoryOrderField = "SOURCE"
	SubcontrolHistoryOrderFieldReferenceFramework SubcontrolHistoryOrderField = "REFERENCE_FRAMEWORK"
	SubcontrolHistoryOrderFieldControlType        SubcontrolHistoryOrderField = "CONTROL_TYPE"
	SubcontrolHistoryOrderFieldCategory           SubcontrolHistoryOrderField = "category"
	SubcontrolHistoryOrderFieldSubcategory        SubcontrolHistoryOrderField = "subcategory"
	SubcontrolHistoryOrderFieldRefCode            SubcontrolHistoryOrderField = "ref_code"
)

var AllSubcontrolHistoryOrderField = []SubcontrolHistoryOrderField{
	SubcontrolHistoryOrderFieldHistoryTime,
	SubcontrolHistoryOrderFieldCreatedAt,
	SubcontrolHistoryOrderFieldUpdatedAt,
	SubcontrolHistoryOrderFieldTitle,
	SubcontrolHistoryOrderFieldStatus,
	SubcontrolHistoryOrderFieldSource,
	SubcontrolHistoryOrderFieldReferenceFramework,
	SubcontrolHistoryOrderFieldControlType,
	SubcontrolHistoryOrderFieldCategory,
	SubcontrolHistoryOrderFieldSubcategory,
	SubcontrolHistoryOrderFieldRefCode,
}

func (e SubcontrolHistoryOrderField) IsValid() bool {
	switch e {
	case SubcontrolHistoryOrderFieldHistoryTime, SubcontrolHistoryOrderFieldCreatedAt, SubcontrolHistoryOrderFieldUpdatedAt, SubcontrolHistoryOrderFieldTitle, SubcontrolHistoryOrderFieldStatus, SubcontrolHistoryOrderFieldSource, SubcontrolHistoryOrderFieldReferenceFramework, SubcontrolHistoryOrderFieldControlType, SubcontrolHistoryOrderFieldCategory, SubcontrolHistoryOrderFieldSubcategory, SubcontrolHistoryOrderFieldRefCode:
		return true
	}
	return false
}

func (e SubcontrolHistoryOrderField) String() string {
	return string(e)
}

func (e *SubcontrolHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubcontrolHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubcontrolHistoryOrderField", str)
	}
	return nil
}

func (e SubcontrolHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubcontrolHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubcontrolHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Subcontrol connections can be ordered.
type SubcontrolOrderField string

const (
	SubcontrolOrderFieldCreatedAt            SubcontrolOrderField = "created_at"
	SubcontrolOrderFieldUpdatedAt            SubcontrolOrderField = "updated_at"
	SubcontrolOrderFieldTitle                SubcontrolOrderField = "title"
	SubcontrolOrderFieldStatus               SubcontrolOrderField = "STATUS"
	SubcontrolOrderFieldSource               SubcontrolOrderField = "SOURCE"
	SubcontrolOrderFieldReferenceFramework   SubcontrolOrderField = "REFERENCE_FRAMEWORK"
	SubcontrolOrderFieldControlType          SubcontrolOrderField = "CONTROL_TYPE"
	SubcontrolOrderFieldCategory             SubcontrolOrderField = "category"
	SubcontrolOrderFieldSubcategory          SubcontrolOrderField = "subcategory"
	SubcontrolOrderFieldRefCode              SubcontrolOrderField = "ref_code"
	SubcontrolOrderFieldControlOwnerName     SubcontrolOrderField = "CONTROL_OWNER_name"
	SubcontrolOrderFieldDelegateName         SubcontrolOrderField = "DELEGATE_name"
	SubcontrolOrderFieldResponsiblePartyName SubcontrolOrderField = "RESPONSIBLE_PARTY_name"
)

var AllSubcontrolOrderField = []SubcontrolOrderField{
	SubcontrolOrderFieldCreatedAt,
	SubcontrolOrderFieldUpdatedAt,
	SubcontrolOrderFieldTitle,
	SubcontrolOrderFieldStatus,
	SubcontrolOrderFieldSource,
	SubcontrolOrderFieldReferenceFramework,
	SubcontrolOrderFieldControlType,
	SubcontrolOrderFieldCategory,
	SubcontrolOrderFieldSubcategory,
	SubcontrolOrderFieldRefCode,
	SubcontrolOrderFieldControlOwnerName,
	SubcontrolOrderFieldDelegateName,
	SubcontrolOrderFieldResponsiblePartyName,
}

func (e SubcontrolOrderField) IsValid() bool {
	switch e {
	case SubcontrolOrderFieldCreatedAt, SubcontrolOrderFieldUpdatedAt, SubcontrolOrderFieldTitle, SubcontrolOrderFieldStatus, SubcontrolOrderFieldSource, SubcontrolOrderFieldReferenceFramework, SubcontrolOrderFieldControlType, SubcontrolOrderFieldCategory, SubcontrolOrderFieldSubcategory, SubcontrolOrderFieldRefCode, SubcontrolOrderFieldControlOwnerName, SubcontrolOrderFieldDelegateName, SubcontrolOrderFieldResponsiblePartyName:
		return true
	}
	return false
}

func (e SubcontrolOrderField) String() string {
	return string(e)
}

func (e *SubcontrolOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubcontrolOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubcontrolOrderField", str)
	}
	return nil
}

func (e SubcontrolOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubcontrolOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubcontrolOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which SubprocessorHistory connections can be ordered.
type SubprocessorHistoryOrderField string

const (
	SubprocessorHistoryOrderFieldHistoryTime SubprocessorHistoryOrderField = "history_time"
	SubprocessorHistoryOrderFieldCreatedAt   SubprocessorHistoryOrderField = "created_at"
	SubprocessorHistoryOrderFieldUpdatedAt   SubprocessorHistoryOrderField = "updated_at"
	SubprocessorHistoryOrderFieldName        SubprocessorHistoryOrderField = "name"
)

var AllSubprocessorHistoryOrderField = []SubprocessorHistoryOrderField{
	SubprocessorHistoryOrderFieldHistoryTime,
	SubprocessorHistoryOrderFieldCreatedAt,
	SubprocessorHistoryOrderFieldUpdatedAt,
	SubprocessorHistoryOrderFieldName,
}

func (e SubprocessorHistoryOrderField) IsValid() bool {
	switch e {
	case SubprocessorHistoryOrderFieldHistoryTime, SubprocessorHistoryOrderFieldCreatedAt, SubprocessorHistoryOrderFieldUpdatedAt, SubprocessorHistoryOrderFieldName:
		return true
	}
	return false
}

func (e SubprocessorHistoryOrderField) String() string {
	return string(e)
}

func (e *SubprocessorHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubprocessorHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubprocessorHistoryOrderField", str)
	}
	return nil
}

func (e SubprocessorHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubprocessorHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubprocessorHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Subprocessor connections can be ordered.
type SubprocessorOrderField string

const (
	SubprocessorOrderFieldCreatedAt SubprocessorOrderField = "created_at"
	SubprocessorOrderFieldUpdatedAt SubprocessorOrderField = "updated_at"
	SubprocessorOrderFieldName      SubprocessorOrderField = "name"
)

var AllSubprocessorOrderField = []SubprocessorOrderField{
	SubprocessorOrderFieldCreatedAt,
	SubprocessorOrderFieldUpdatedAt,
	SubprocessorOrderFieldName,
}

func (e SubprocessorOrderField) IsValid() bool {
	switch e {
	case SubprocessorOrderFieldCreatedAt, SubprocessorOrderFieldUpdatedAt, SubprocessorOrderFieldName:
		return true
	}
	return false
}

func (e SubprocessorOrderField) String() string {
	return string(e)
}

func (e *SubprocessorOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubprocessorOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubprocessorOrderField", str)
	}
	return nil
}

func (e SubprocessorOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubprocessorOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubprocessorOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Subscriber connections can be ordered.
type SubscriberOrderField string

const (
	SubscriberOrderFieldCreatedAt    SubscriberOrderField = "created_at"
	SubscriberOrderFieldUpdatedAt    SubscriberOrderField = "updated_at"
	SubscriberOrderFieldEmail        SubscriberOrderField = "email"
	SubscriberOrderFieldActive       SubscriberOrderField = "active"
	SubscriberOrderFieldUnsubscribed SubscriberOrderField = "unsubscribed"
	SubscriberOrderFieldSendAttempts SubscriberOrderField = "send_attempts"
)

var AllSubscriberOrderField = []SubscriberOrderField{
	SubscriberOrderFieldCreatedAt,
	SubscriberOrderFieldUpdatedAt,
	SubscriberOrderFieldEmail,
	SubscriberOrderFieldActive,
	SubscriberOrderFieldUnsubscribed,
	SubscriberOrderFieldSendAttempts,
}

func (e SubscriberOrderField) IsValid() bool {
	switch e {
	case SubscriberOrderFieldCreatedAt, SubscriberOrderFieldUpdatedAt, SubscriberOrderFieldEmail, SubscriberOrderFieldActive, SubscriberOrderFieldUnsubscribed, SubscriberOrderFieldSendAttempts:
		return true
	}
	return false
}

func (e SubscriberOrderField) String() string {
	return string(e)
}

func (e *SubscriberOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriberOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriberOrderField", str)
	}
	return nil
}

func (e SubscriberOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubscriberOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubscriberOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TFASetting connections can be ordered.
type TFASettingOrderField string

const (
	TFASettingOrderFieldCreatedAt TFASettingOrderField = "created_at"
	TFASettingOrderFieldUpdatedAt TFASettingOrderField = "updated_at"
)

var AllTFASettingOrderField = []TFASettingOrderField{
	TFASettingOrderFieldCreatedAt,
	TFASettingOrderFieldUpdatedAt,
}

func (e TFASettingOrderField) IsValid() bool {
	switch e {
	case TFASettingOrderFieldCreatedAt, TFASettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TFASettingOrderField) String() string {
	return string(e)
}

func (e *TFASettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TFASettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TFASettingOrderField", str)
	}
	return nil
}

func (e TFASettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TFASettingOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TFASettingOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TagDefinition connections can be ordered.
type TagDefinitionOrderField string

const (
	TagDefinitionOrderFieldCreatedAt TagDefinitionOrderField = "created_at"
	TagDefinitionOrderFieldUpdatedAt TagDefinitionOrderField = "updated_at"
)

var AllTagDefinitionOrderField = []TagDefinitionOrderField{
	TagDefinitionOrderFieldCreatedAt,
	TagDefinitionOrderFieldUpdatedAt,
}

func (e TagDefinitionOrderField) IsValid() bool {
	switch e {
	case TagDefinitionOrderFieldCreatedAt, TagDefinitionOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TagDefinitionOrderField) String() string {
	return string(e)
}

func (e *TagDefinitionOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagDefinitionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagDefinitionOrderField", str)
	}
	return nil
}

func (e TagDefinitionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TagDefinitionOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TagDefinitionOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TaskHistory connections can be ordered.
type TaskHistoryOrderField string

const (
	TaskHistoryOrderFieldHistoryTime TaskHistoryOrderField = "history_time"
	TaskHistoryOrderFieldCreatedAt   TaskHistoryOrderField = "created_at"
	TaskHistoryOrderFieldUpdatedAt   TaskHistoryOrderField = "updated_at"
	TaskHistoryOrderFieldTitle       TaskHistoryOrderField = "title"
	TaskHistoryOrderFieldStatus      TaskHistoryOrderField = "STATUS"
	TaskHistoryOrderFieldCategory    TaskHistoryOrderField = "category"
	TaskHistoryOrderFieldDue         TaskHistoryOrderField = "due"
	TaskHistoryOrderFieldCompleted   TaskHistoryOrderField = "completed"
)

var AllTaskHistoryOrderField = []TaskHistoryOrderField{
	TaskHistoryOrderFieldHistoryTime,
	TaskHistoryOrderFieldCreatedAt,
	TaskHistoryOrderFieldUpdatedAt,
	TaskHistoryOrderFieldTitle,
	TaskHistoryOrderFieldStatus,
	TaskHistoryOrderFieldCategory,
	TaskHistoryOrderFieldDue,
	TaskHistoryOrderFieldCompleted,
}

func (e TaskHistoryOrderField) IsValid() bool {
	switch e {
	case TaskHistoryOrderFieldHistoryTime, TaskHistoryOrderFieldCreatedAt, TaskHistoryOrderFieldUpdatedAt, TaskHistoryOrderFieldTitle, TaskHistoryOrderFieldStatus, TaskHistoryOrderFieldCategory, TaskHistoryOrderFieldDue, TaskHistoryOrderFieldCompleted:
		return true
	}
	return false
}

func (e TaskHistoryOrderField) String() string {
	return string(e)
}

func (e *TaskHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskHistoryOrderField", str)
	}
	return nil
}

func (e TaskHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TaskHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TaskHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Task connections can be ordered.
type TaskOrderField string

const (
	TaskOrderFieldCreatedAt TaskOrderField = "created_at"
	TaskOrderFieldUpdatedAt TaskOrderField = "updated_at"
	TaskOrderFieldTitle     TaskOrderField = "title"
	TaskOrderFieldStatus    TaskOrderField = "STATUS"
	TaskOrderFieldCategory  TaskOrderField = "category"
	TaskOrderFieldDue       TaskOrderField = "due"
	TaskOrderFieldCompleted TaskOrderField = "completed"
)

var AllTaskOrderField = []TaskOrderField{
	TaskOrderFieldCreatedAt,
	TaskOrderFieldUpdatedAt,
	TaskOrderFieldTitle,
	TaskOrderFieldStatus,
	TaskOrderFieldCategory,
	TaskOrderFieldDue,
	TaskOrderFieldCompleted,
}

func (e TaskOrderField) IsValid() bool {
	switch e {
	case TaskOrderFieldCreatedAt, TaskOrderFieldUpdatedAt, TaskOrderFieldTitle, TaskOrderFieldStatus, TaskOrderFieldCategory, TaskOrderFieldDue, TaskOrderFieldCompleted:
		return true
	}
	return false
}

func (e TaskOrderField) String() string {
	return string(e)
}

func (e *TaskOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskOrderField", str)
	}
	return nil
}

func (e TaskOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TaskOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TaskOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TemplateHistory connections can be ordered.
type TemplateHistoryOrderField string

const (
	TemplateHistoryOrderFieldHistoryTime  TemplateHistoryOrderField = "history_time"
	TemplateHistoryOrderFieldCreatedAt    TemplateHistoryOrderField = "created_at"
	TemplateHistoryOrderFieldUpdatedAt    TemplateHistoryOrderField = "updated_at"
	TemplateHistoryOrderFieldName         TemplateHistoryOrderField = "name"
	TemplateHistoryOrderFieldTemplateType TemplateHistoryOrderField = "TEMPLATE_TYPE"
	TemplateHistoryOrderFieldKind         TemplateHistoryOrderField = "KIND"
)

var AllTemplateHistoryOrderField = []TemplateHistoryOrderField{
	TemplateHistoryOrderFieldHistoryTime,
	TemplateHistoryOrderFieldCreatedAt,
	TemplateHistoryOrderFieldUpdatedAt,
	TemplateHistoryOrderFieldName,
	TemplateHistoryOrderFieldTemplateType,
	TemplateHistoryOrderFieldKind,
}

func (e TemplateHistoryOrderField) IsValid() bool {
	switch e {
	case TemplateHistoryOrderFieldHistoryTime, TemplateHistoryOrderFieldCreatedAt, TemplateHistoryOrderFieldUpdatedAt, TemplateHistoryOrderFieldName, TemplateHistoryOrderFieldTemplateType, TemplateHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e TemplateHistoryOrderField) String() string {
	return string(e)
}

func (e *TemplateHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

func (e TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TemplateHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TemplateHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Template connections can be ordered.
type TemplateOrderField string

const (
	TemplateOrderFieldCreatedAt    TemplateOrderField = "created_at"
	TemplateOrderFieldUpdatedAt    TemplateOrderField = "updated_at"
	TemplateOrderFieldName         TemplateOrderField = "name"
	TemplateOrderFieldTemplateType TemplateOrderField = "TEMPLATE_TYPE"
	TemplateOrderFieldKind         TemplateOrderField = "KIND"
)

var AllTemplateOrderField = []TemplateOrderField{
	TemplateOrderFieldCreatedAt,
	TemplateOrderFieldUpdatedAt,
	TemplateOrderFieldName,
	TemplateOrderFieldTemplateType,
	TemplateOrderFieldKind,
}

func (e TemplateOrderField) IsValid() bool {
	switch e {
	case TemplateOrderFieldCreatedAt, TemplateOrderFieldUpdatedAt, TemplateOrderFieldName, TemplateOrderFieldTemplateType, TemplateOrderFieldKind:
		return true
	}
	return false
}

func (e TemplateOrderField) String() string {
	return string(e)
}

func (e *TemplateOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

func (e TemplateOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TemplateOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TemplateOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterComplianceHistory connections can be ordered.
type TrustCenterComplianceHistoryOrderField string

const (
	TrustCenterComplianceHistoryOrderFieldHistoryTime TrustCenterComplianceHistoryOrderField = "history_time"
	TrustCenterComplianceHistoryOrderFieldCreatedAt   TrustCenterComplianceHistoryOrderField = "created_at"
	TrustCenterComplianceHistoryOrderFieldUpdatedAt   TrustCenterComplianceHistoryOrderField = "updated_at"
)

var AllTrustCenterComplianceHistoryOrderField = []TrustCenterComplianceHistoryOrderField{
	TrustCenterComplianceHistoryOrderFieldHistoryTime,
	TrustCenterComplianceHistoryOrderFieldCreatedAt,
	TrustCenterComplianceHistoryOrderFieldUpdatedAt,
}

func (e TrustCenterComplianceHistoryOrderField) IsValid() bool {
	switch e {
	case TrustCenterComplianceHistoryOrderFieldHistoryTime, TrustCenterComplianceHistoryOrderFieldCreatedAt, TrustCenterComplianceHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterComplianceHistoryOrderField) String() string {
	return string(e)
}

func (e *TrustCenterComplianceHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterComplianceHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterComplianceHistoryOrderField", str)
	}
	return nil
}

func (e TrustCenterComplianceHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterComplianceHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterComplianceHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterCompliance connections can be ordered.
type TrustCenterComplianceOrderField string

const (
	TrustCenterComplianceOrderFieldCreatedAt TrustCenterComplianceOrderField = "created_at"
	TrustCenterComplianceOrderFieldUpdatedAt TrustCenterComplianceOrderField = "updated_at"
)

var AllTrustCenterComplianceOrderField = []TrustCenterComplianceOrderField{
	TrustCenterComplianceOrderFieldCreatedAt,
	TrustCenterComplianceOrderFieldUpdatedAt,
}

func (e TrustCenterComplianceOrderField) IsValid() bool {
	switch e {
	case TrustCenterComplianceOrderFieldCreatedAt, TrustCenterComplianceOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterComplianceOrderField) String() string {
	return string(e)
}

func (e *TrustCenterComplianceOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterComplianceOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterComplianceOrderField", str)
	}
	return nil
}

func (e TrustCenterComplianceOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterComplianceOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterComplianceOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterDocHistory connections can be ordered.
type TrustCenterDocHistoryOrderField string

const (
	TrustCenterDocHistoryOrderFieldHistoryTime TrustCenterDocHistoryOrderField = "history_time"
	TrustCenterDocHistoryOrderFieldCreatedAt   TrustCenterDocHistoryOrderField = "created_at"
	TrustCenterDocHistoryOrderFieldUpdatedAt   TrustCenterDocHistoryOrderField = "updated_at"
)

var AllTrustCenterDocHistoryOrderField = []TrustCenterDocHistoryOrderField{
	TrustCenterDocHistoryOrderFieldHistoryTime,
	TrustCenterDocHistoryOrderFieldCreatedAt,
	TrustCenterDocHistoryOrderFieldUpdatedAt,
}

func (e TrustCenterDocHistoryOrderField) IsValid() bool {
	switch e {
	case TrustCenterDocHistoryOrderFieldHistoryTime, TrustCenterDocHistoryOrderFieldCreatedAt, TrustCenterDocHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterDocHistoryOrderField) String() string {
	return string(e)
}

func (e *TrustCenterDocHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterDocHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterDocHistoryOrderField", str)
	}
	return nil
}

func (e TrustCenterDocHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterDocHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterDocHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterDoc connections can be ordered.
type TrustCenterDocOrderField string

const (
	TrustCenterDocOrderFieldCreatedAt TrustCenterDocOrderField = "created_at"
	TrustCenterDocOrderFieldUpdatedAt TrustCenterDocOrderField = "updated_at"
)

var AllTrustCenterDocOrderField = []TrustCenterDocOrderField{
	TrustCenterDocOrderFieldCreatedAt,
	TrustCenterDocOrderFieldUpdatedAt,
}

func (e TrustCenterDocOrderField) IsValid() bool {
	switch e {
	case TrustCenterDocOrderFieldCreatedAt, TrustCenterDocOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterDocOrderField) String() string {
	return string(e)
}

func (e *TrustCenterDocOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterDocOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterDocOrderField", str)
	}
	return nil
}

func (e TrustCenterDocOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterDocOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterDocOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterHistory connections can be ordered.
type TrustCenterHistoryOrderField string

const (
	TrustCenterHistoryOrderFieldHistoryTime TrustCenterHistoryOrderField = "history_time"
	TrustCenterHistoryOrderFieldCreatedAt   TrustCenterHistoryOrderField = "created_at"
	TrustCenterHistoryOrderFieldUpdatedAt   TrustCenterHistoryOrderField = "updated_at"
)

var AllTrustCenterHistoryOrderField = []TrustCenterHistoryOrderField{
	TrustCenterHistoryOrderFieldHistoryTime,
	TrustCenterHistoryOrderFieldCreatedAt,
	TrustCenterHistoryOrderFieldUpdatedAt,
}

func (e TrustCenterHistoryOrderField) IsValid() bool {
	switch e {
	case TrustCenterHistoryOrderFieldHistoryTime, TrustCenterHistoryOrderFieldCreatedAt, TrustCenterHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterHistoryOrderField) String() string {
	return string(e)
}

func (e *TrustCenterHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterHistoryOrderField", str)
	}
	return nil
}

func (e TrustCenterHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenter connections can be ordered.
type TrustCenterOrderField string

const (
	TrustCenterOrderFieldCreatedAt TrustCenterOrderField = "created_at"
	TrustCenterOrderFieldUpdatedAt TrustCenterOrderField = "updated_at"
)

var AllTrustCenterOrderField = []TrustCenterOrderField{
	TrustCenterOrderFieldCreatedAt,
	TrustCenterOrderFieldUpdatedAt,
}

func (e TrustCenterOrderField) IsValid() bool {
	switch e {
	case TrustCenterOrderFieldCreatedAt, TrustCenterOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterOrderField) String() string {
	return string(e)
}

func (e *TrustCenterOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterOrderField", str)
	}
	return nil
}

func (e TrustCenterOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterSettingHistory connections can be ordered.
type TrustCenterSettingHistoryOrderField string

const (
	TrustCenterSettingHistoryOrderFieldHistoryTime TrustCenterSettingHistoryOrderField = "history_time"
	TrustCenterSettingHistoryOrderFieldCreatedAt   TrustCenterSettingHistoryOrderField = "created_at"
	TrustCenterSettingHistoryOrderFieldUpdatedAt   TrustCenterSettingHistoryOrderField = "updated_at"
)

var AllTrustCenterSettingHistoryOrderField = []TrustCenterSettingHistoryOrderField{
	TrustCenterSettingHistoryOrderFieldHistoryTime,
	TrustCenterSettingHistoryOrderFieldCreatedAt,
	TrustCenterSettingHistoryOrderFieldUpdatedAt,
}

func (e TrustCenterSettingHistoryOrderField) IsValid() bool {
	switch e {
	case TrustCenterSettingHistoryOrderFieldHistoryTime, TrustCenterSettingHistoryOrderFieldCreatedAt, TrustCenterSettingHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterSettingHistoryOrderField) String() string {
	return string(e)
}

func (e *TrustCenterSettingHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterSettingHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterSettingHistoryOrderField", str)
	}
	return nil
}

func (e TrustCenterSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterSettingHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterSettingHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterSetting connections can be ordered.
type TrustCenterSettingOrderField string

const (
	TrustCenterSettingOrderFieldCreatedAt TrustCenterSettingOrderField = "created_at"
	TrustCenterSettingOrderFieldUpdatedAt TrustCenterSettingOrderField = "updated_at"
)

var AllTrustCenterSettingOrderField = []TrustCenterSettingOrderField{
	TrustCenterSettingOrderFieldCreatedAt,
	TrustCenterSettingOrderFieldUpdatedAt,
}

func (e TrustCenterSettingOrderField) IsValid() bool {
	switch e {
	case TrustCenterSettingOrderFieldCreatedAt, TrustCenterSettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterSettingOrderField) String() string {
	return string(e)
}

func (e *TrustCenterSettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterSettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterSettingOrderField", str)
	}
	return nil
}

func (e TrustCenterSettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterSettingOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterSettingOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterSubprocessorHistory connections can be ordered.
type TrustCenterSubprocessorHistoryOrderField string

const (
	TrustCenterSubprocessorHistoryOrderFieldHistoryTime TrustCenterSubprocessorHistoryOrderField = "history_time"
	TrustCenterSubprocessorHistoryOrderFieldCreatedAt   TrustCenterSubprocessorHistoryOrderField = "created_at"
	TrustCenterSubprocessorHistoryOrderFieldUpdatedAt   TrustCenterSubprocessorHistoryOrderField = "updated_at"
)

var AllTrustCenterSubprocessorHistoryOrderField = []TrustCenterSubprocessorHistoryOrderField{
	TrustCenterSubprocessorHistoryOrderFieldHistoryTime,
	TrustCenterSubprocessorHistoryOrderFieldCreatedAt,
	TrustCenterSubprocessorHistoryOrderFieldUpdatedAt,
}

func (e TrustCenterSubprocessorHistoryOrderField) IsValid() bool {
	switch e {
	case TrustCenterSubprocessorHistoryOrderFieldHistoryTime, TrustCenterSubprocessorHistoryOrderFieldCreatedAt, TrustCenterSubprocessorHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterSubprocessorHistoryOrderField) String() string {
	return string(e)
}

func (e *TrustCenterSubprocessorHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterSubprocessorHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterSubprocessorHistoryOrderField", str)
	}
	return nil
}

func (e TrustCenterSubprocessorHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterSubprocessorHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterSubprocessorHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterSubprocessor connections can be ordered.
type TrustCenterSubprocessorOrderField string

const (
	TrustCenterSubprocessorOrderFieldCreatedAt TrustCenterSubprocessorOrderField = "created_at"
	TrustCenterSubprocessorOrderFieldUpdatedAt TrustCenterSubprocessorOrderField = "updated_at"
)

var AllTrustCenterSubprocessorOrderField = []TrustCenterSubprocessorOrderField{
	TrustCenterSubprocessorOrderFieldCreatedAt,
	TrustCenterSubprocessorOrderFieldUpdatedAt,
}

func (e TrustCenterSubprocessorOrderField) IsValid() bool {
	switch e {
	case TrustCenterSubprocessorOrderFieldCreatedAt, TrustCenterSubprocessorOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterSubprocessorOrderField) String() string {
	return string(e)
}

func (e *TrustCenterSubprocessorOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterSubprocessorOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterSubprocessorOrderField", str)
	}
	return nil
}

func (e TrustCenterSubprocessorOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterSubprocessorOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterSubprocessorOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterWatermarkConfigHistory connections can be ordered.
type TrustCenterWatermarkConfigHistoryOrderField string

const (
	TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime TrustCenterWatermarkConfigHistoryOrderField = "history_time"
	TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt   TrustCenterWatermarkConfigHistoryOrderField = "created_at"
	TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt   TrustCenterWatermarkConfigHistoryOrderField = "updated_at"
)

var AllTrustCenterWatermarkConfigHistoryOrderField = []TrustCenterWatermarkConfigHistoryOrderField{
	TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime,
	TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt,
	TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt,
}

func (e TrustCenterWatermarkConfigHistoryOrderField) IsValid() bool {
	switch e {
	case TrustCenterWatermarkConfigHistoryOrderFieldHistoryTime, TrustCenterWatermarkConfigHistoryOrderFieldCreatedAt, TrustCenterWatermarkConfigHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterWatermarkConfigHistoryOrderField) String() string {
	return string(e)
}

func (e *TrustCenterWatermarkConfigHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterWatermarkConfigHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterWatermarkConfigHistoryOrderField", str)
	}
	return nil
}

func (e TrustCenterWatermarkConfigHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterWatermarkConfigHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterWatermarkConfigHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustCenterWatermarkConfig connections can be ordered.
type TrustCenterWatermarkConfigOrderField string

const (
	TrustCenterWatermarkConfigOrderFieldCreatedAt TrustCenterWatermarkConfigOrderField = "created_at"
	TrustCenterWatermarkConfigOrderFieldUpdatedAt TrustCenterWatermarkConfigOrderField = "updated_at"
)

var AllTrustCenterWatermarkConfigOrderField = []TrustCenterWatermarkConfigOrderField{
	TrustCenterWatermarkConfigOrderFieldCreatedAt,
	TrustCenterWatermarkConfigOrderFieldUpdatedAt,
}

func (e TrustCenterWatermarkConfigOrderField) IsValid() bool {
	switch e {
	case TrustCenterWatermarkConfigOrderFieldCreatedAt, TrustCenterWatermarkConfigOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TrustCenterWatermarkConfigOrderField) String() string {
	return string(e)
}

func (e *TrustCenterWatermarkConfigOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustCenterWatermarkConfigOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustCenterWatermarkConfigOrderField", str)
	}
	return nil
}

func (e TrustCenterWatermarkConfigOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustCenterWatermarkConfigOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustCenterWatermarkConfigOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustcenterEntityHistory connections can be ordered.
type TrustcenterEntityHistoryOrderField string

const (
	TrustcenterEntityHistoryOrderFieldHistoryTime TrustcenterEntityHistoryOrderField = "history_time"
	TrustcenterEntityHistoryOrderFieldCreatedAt   TrustcenterEntityHistoryOrderField = "created_at"
	TrustcenterEntityHistoryOrderFieldUpdatedAt   TrustcenterEntityHistoryOrderField = "updated_at"
	TrustcenterEntityHistoryOrderFieldName        TrustcenterEntityHistoryOrderField = "NAME"
)

var AllTrustcenterEntityHistoryOrderField = []TrustcenterEntityHistoryOrderField{
	TrustcenterEntityHistoryOrderFieldHistoryTime,
	TrustcenterEntityHistoryOrderFieldCreatedAt,
	TrustcenterEntityHistoryOrderFieldUpdatedAt,
	TrustcenterEntityHistoryOrderFieldName,
}

func (e TrustcenterEntityHistoryOrderField) IsValid() bool {
	switch e {
	case TrustcenterEntityHistoryOrderFieldHistoryTime, TrustcenterEntityHistoryOrderFieldCreatedAt, TrustcenterEntityHistoryOrderFieldUpdatedAt, TrustcenterEntityHistoryOrderFieldName:
		return true
	}
	return false
}

func (e TrustcenterEntityHistoryOrderField) String() string {
	return string(e)
}

func (e *TrustcenterEntityHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustcenterEntityHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustcenterEntityHistoryOrderField", str)
	}
	return nil
}

func (e TrustcenterEntityHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustcenterEntityHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustcenterEntityHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which TrustcenterEntity connections can be ordered.
type TrustcenterEntityOrderField string

const (
	TrustcenterEntityOrderFieldCreatedAt TrustcenterEntityOrderField = "created_at"
	TrustcenterEntityOrderFieldUpdatedAt TrustcenterEntityOrderField = "updated_at"
	TrustcenterEntityOrderFieldName      TrustcenterEntityOrderField = "NAME"
)

var AllTrustcenterEntityOrderField = []TrustcenterEntityOrderField{
	TrustcenterEntityOrderFieldCreatedAt,
	TrustcenterEntityOrderFieldUpdatedAt,
	TrustcenterEntityOrderFieldName,
}

func (e TrustcenterEntityOrderField) IsValid() bool {
	switch e {
	case TrustcenterEntityOrderFieldCreatedAt, TrustcenterEntityOrderFieldUpdatedAt, TrustcenterEntityOrderFieldName:
		return true
	}
	return false
}

func (e TrustcenterEntityOrderField) String() string {
	return string(e)
}

func (e *TrustcenterEntityOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrustcenterEntityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrustcenterEntityOrderField", str)
	}
	return nil
}

func (e TrustcenterEntityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrustcenterEntityOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrustcenterEntityOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which UserHistory connections can be ordered.
type UserHistoryOrderField string

const (
	UserHistoryOrderFieldHistoryTime UserHistoryOrderField = "history_time"
	UserHistoryOrderFieldCreatedAt   UserHistoryOrderField = "created_at"
	UserHistoryOrderFieldUpdatedAt   UserHistoryOrderField = "updated_at"
	UserHistoryOrderFieldFirstName   UserHistoryOrderField = "first_name"
	UserHistoryOrderFieldLastName    UserHistoryOrderField = "last_name"
	UserHistoryOrderFieldDisplayName UserHistoryOrderField = "display_name"
)

var AllUserHistoryOrderField = []UserHistoryOrderField{
	UserHistoryOrderFieldHistoryTime,
	UserHistoryOrderFieldCreatedAt,
	UserHistoryOrderFieldUpdatedAt,
	UserHistoryOrderFieldFirstName,
	UserHistoryOrderFieldLastName,
	UserHistoryOrderFieldDisplayName,
}

func (e UserHistoryOrderField) IsValid() bool {
	switch e {
	case UserHistoryOrderFieldHistoryTime, UserHistoryOrderFieldCreatedAt, UserHistoryOrderFieldUpdatedAt, UserHistoryOrderFieldFirstName, UserHistoryOrderFieldLastName, UserHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserHistoryOrderField) String() string {
	return string(e)
}

func (e *UserHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

func (e UserHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldCreatedAt   UserOrderField = "created_at"
	UserOrderFieldUpdatedAt   UserOrderField = "updated_at"
	UserOrderFieldFirstName   UserOrderField = "first_name"
	UserOrderFieldLastName    UserOrderField = "last_name"
	UserOrderFieldDisplayName UserOrderField = "display_name"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldCreatedAt,
	UserOrderFieldUpdatedAt,
	UserOrderFieldFirstName,
	UserOrderFieldLastName,
	UserOrderFieldDisplayName,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldCreatedAt, UserOrderFieldUpdatedAt, UserOrderFieldFirstName, UserOrderFieldLastName, UserOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which UserSettingHistory connections can be ordered.
type UserSettingHistoryOrderField string

const (
	UserSettingHistoryOrderFieldHistoryTime UserSettingHistoryOrderField = "history_time"
	UserSettingHistoryOrderFieldCreatedAt   UserSettingHistoryOrderField = "created_at"
	UserSettingHistoryOrderFieldUpdatedAt   UserSettingHistoryOrderField = "updated_at"
)

var AllUserSettingHistoryOrderField = []UserSettingHistoryOrderField{
	UserSettingHistoryOrderFieldHistoryTime,
	UserSettingHistoryOrderFieldCreatedAt,
	UserSettingHistoryOrderFieldUpdatedAt,
}

func (e UserSettingHistoryOrderField) IsValid() bool {
	switch e {
	case UserSettingHistoryOrderFieldHistoryTime, UserSettingHistoryOrderFieldCreatedAt, UserSettingHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e UserSettingHistoryOrderField) String() string {
	return string(e)
}

func (e *UserSettingHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserSettingHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserSettingHistoryOrderField", str)
	}
	return nil
}

func (e UserSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserSettingHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserSettingHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which UserSetting connections can be ordered.
type UserSettingOrderField string

const (
	UserSettingOrderFieldCreatedAt UserSettingOrderField = "created_at"
	UserSettingOrderFieldUpdatedAt UserSettingOrderField = "updated_at"
)

var AllUserSettingOrderField = []UserSettingOrderField{
	UserSettingOrderFieldCreatedAt,
	UserSettingOrderFieldUpdatedAt,
}

func (e UserSettingOrderField) IsValid() bool {
	switch e {
	case UserSettingOrderFieldCreatedAt, UserSettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e UserSettingOrderField) String() string {
	return string(e)
}

func (e *UserSettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserSettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserSettingOrderField", str)
	}
	return nil
}

func (e UserSettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserSettingOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserSettingOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which VulnerabilityHistory connections can be ordered.
type VulnerabilityHistoryOrderField string

const (
	VulnerabilityHistoryOrderFieldHistoryTime     VulnerabilityHistoryOrderField = "history_time"
	VulnerabilityHistoryOrderFieldCreatedAt       VulnerabilityHistoryOrderField = "created_at"
	VulnerabilityHistoryOrderFieldUpdatedAt       VulnerabilityHistoryOrderField = "updated_at"
	VulnerabilityHistoryOrderFieldExternalOwnerID VulnerabilityHistoryOrderField = "external_owner_id"
	VulnerabilityHistoryOrderFieldExternalID      VulnerabilityHistoryOrderField = "external_id"
	VulnerabilityHistoryOrderFieldCveID           VulnerabilityHistoryOrderField = "cve_id"
	VulnerabilityHistoryOrderFieldCategory        VulnerabilityHistoryOrderField = "category"
	VulnerabilityHistoryOrderFieldSeverity        VulnerabilityHistoryOrderField = "severity"
)

var AllVulnerabilityHistoryOrderField = []VulnerabilityHistoryOrderField{
	VulnerabilityHistoryOrderFieldHistoryTime,
	VulnerabilityHistoryOrderFieldCreatedAt,
	VulnerabilityHistoryOrderFieldUpdatedAt,
	VulnerabilityHistoryOrderFieldExternalOwnerID,
	VulnerabilityHistoryOrderFieldExternalID,
	VulnerabilityHistoryOrderFieldCveID,
	VulnerabilityHistoryOrderFieldCategory,
	VulnerabilityHistoryOrderFieldSeverity,
}

func (e VulnerabilityHistoryOrderField) IsValid() bool {
	switch e {
	case VulnerabilityHistoryOrderFieldHistoryTime, VulnerabilityHistoryOrderFieldCreatedAt, VulnerabilityHistoryOrderFieldUpdatedAt, VulnerabilityHistoryOrderFieldExternalOwnerID, VulnerabilityHistoryOrderFieldExternalID, VulnerabilityHistoryOrderFieldCveID, VulnerabilityHistoryOrderFieldCategory, VulnerabilityHistoryOrderFieldSeverity:
		return true
	}
	return false
}

func (e VulnerabilityHistoryOrderField) String() string {
	return string(e)
}

func (e *VulnerabilityHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnerabilityHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnerabilityHistoryOrderField", str)
	}
	return nil
}

func (e VulnerabilityHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VulnerabilityHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VulnerabilityHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Vulnerability connections can be ordered.
type VulnerabilityOrderField string

const (
	VulnerabilityOrderFieldCreatedAt       VulnerabilityOrderField = "created_at"
	VulnerabilityOrderFieldUpdatedAt       VulnerabilityOrderField = "updated_at"
	VulnerabilityOrderFieldExternalOwnerID VulnerabilityOrderField = "external_owner_id"
	VulnerabilityOrderFieldExternalID      VulnerabilityOrderField = "external_id"
	VulnerabilityOrderFieldCveID           VulnerabilityOrderField = "cve_id"
	VulnerabilityOrderFieldCategory        VulnerabilityOrderField = "category"
	VulnerabilityOrderFieldSeverity        VulnerabilityOrderField = "severity"
)

var AllVulnerabilityOrderField = []VulnerabilityOrderField{
	VulnerabilityOrderFieldCreatedAt,
	VulnerabilityOrderFieldUpdatedAt,
	VulnerabilityOrderFieldExternalOwnerID,
	VulnerabilityOrderFieldExternalID,
	VulnerabilityOrderFieldCveID,
	VulnerabilityOrderFieldCategory,
	VulnerabilityOrderFieldSeverity,
}

func (e VulnerabilityOrderField) IsValid() bool {
	switch e {
	case VulnerabilityOrderFieldCreatedAt, VulnerabilityOrderFieldUpdatedAt, VulnerabilityOrderFieldExternalOwnerID, VulnerabilityOrderFieldExternalID, VulnerabilityOrderFieldCveID, VulnerabilityOrderFieldCategory, VulnerabilityOrderFieldSeverity:
		return true
	}
	return false
}

func (e VulnerabilityOrderField) String() string {
	return string(e)
}

func (e *VulnerabilityOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VulnerabilityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VulnerabilityOrderField", str)
	}
	return nil
}

func (e VulnerabilityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VulnerabilityOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VulnerabilityOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Webauthn connections can be ordered.
type WebauthnOrderField string

const (
	WebauthnOrderFieldCreatedAt WebauthnOrderField = "created_at"
	WebauthnOrderFieldUpdatedAt WebauthnOrderField = "updated_at"
)

var AllWebauthnOrderField = []WebauthnOrderField{
	WebauthnOrderFieldCreatedAt,
	WebauthnOrderFieldUpdatedAt,
}

func (e WebauthnOrderField) IsValid() bool {
	switch e {
	case WebauthnOrderFieldCreatedAt, WebauthnOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WebauthnOrderField) String() string {
	return string(e)
}

func (e *WebauthnOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebauthnOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebauthnOrderField", str)
	}
	return nil
}

func (e WebauthnOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WebauthnOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WebauthnOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowAssignmentHistory connections can be ordered.
type WorkflowAssignmentHistoryOrderField string

const (
	WorkflowAssignmentHistoryOrderFieldHistoryTime WorkflowAssignmentHistoryOrderField = "history_time"
	WorkflowAssignmentHistoryOrderFieldCreatedAt   WorkflowAssignmentHistoryOrderField = "created_at"
	WorkflowAssignmentHistoryOrderFieldUpdatedAt   WorkflowAssignmentHistoryOrderField = "updated_at"
)

var AllWorkflowAssignmentHistoryOrderField = []WorkflowAssignmentHistoryOrderField{
	WorkflowAssignmentHistoryOrderFieldHistoryTime,
	WorkflowAssignmentHistoryOrderFieldCreatedAt,
	WorkflowAssignmentHistoryOrderFieldUpdatedAt,
}

func (e WorkflowAssignmentHistoryOrderField) IsValid() bool {
	switch e {
	case WorkflowAssignmentHistoryOrderFieldHistoryTime, WorkflowAssignmentHistoryOrderFieldCreatedAt, WorkflowAssignmentHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowAssignmentHistoryOrderField) String() string {
	return string(e)
}

func (e *WorkflowAssignmentHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowAssignmentHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowAssignmentHistoryOrderField", str)
	}
	return nil
}

func (e WorkflowAssignmentHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowAssignmentHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowAssignmentHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowAssignment connections can be ordered.
type WorkflowAssignmentOrderField string

const (
	WorkflowAssignmentOrderFieldCreatedAt WorkflowAssignmentOrderField = "created_at"
	WorkflowAssignmentOrderFieldUpdatedAt WorkflowAssignmentOrderField = "updated_at"
)

var AllWorkflowAssignmentOrderField = []WorkflowAssignmentOrderField{
	WorkflowAssignmentOrderFieldCreatedAt,
	WorkflowAssignmentOrderFieldUpdatedAt,
}

func (e WorkflowAssignmentOrderField) IsValid() bool {
	switch e {
	case WorkflowAssignmentOrderFieldCreatedAt, WorkflowAssignmentOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowAssignmentOrderField) String() string {
	return string(e)
}

func (e *WorkflowAssignmentOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowAssignmentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowAssignmentOrderField", str)
	}
	return nil
}

func (e WorkflowAssignmentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowAssignmentOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowAssignmentOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowAssignmentTargetHistory connections can be ordered.
type WorkflowAssignmentTargetHistoryOrderField string

const (
	WorkflowAssignmentTargetHistoryOrderFieldHistoryTime WorkflowAssignmentTargetHistoryOrderField = "history_time"
	WorkflowAssignmentTargetHistoryOrderFieldCreatedAt   WorkflowAssignmentTargetHistoryOrderField = "created_at"
	WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt   WorkflowAssignmentTargetHistoryOrderField = "updated_at"
)

var AllWorkflowAssignmentTargetHistoryOrderField = []WorkflowAssignmentTargetHistoryOrderField{
	WorkflowAssignmentTargetHistoryOrderFieldHistoryTime,
	WorkflowAssignmentTargetHistoryOrderFieldCreatedAt,
	WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt,
}

func (e WorkflowAssignmentTargetHistoryOrderField) IsValid() bool {
	switch e {
	case WorkflowAssignmentTargetHistoryOrderFieldHistoryTime, WorkflowAssignmentTargetHistoryOrderFieldCreatedAt, WorkflowAssignmentTargetHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowAssignmentTargetHistoryOrderField) String() string {
	return string(e)
}

func (e *WorkflowAssignmentTargetHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowAssignmentTargetHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowAssignmentTargetHistoryOrderField", str)
	}
	return nil
}

func (e WorkflowAssignmentTargetHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowAssignmentTargetHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowAssignmentTargetHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowAssignmentTarget connections can be ordered.
type WorkflowAssignmentTargetOrderField string

const (
	WorkflowAssignmentTargetOrderFieldCreatedAt WorkflowAssignmentTargetOrderField = "created_at"
	WorkflowAssignmentTargetOrderFieldUpdatedAt WorkflowAssignmentTargetOrderField = "updated_at"
)

var AllWorkflowAssignmentTargetOrderField = []WorkflowAssignmentTargetOrderField{
	WorkflowAssignmentTargetOrderFieldCreatedAt,
	WorkflowAssignmentTargetOrderFieldUpdatedAt,
}

func (e WorkflowAssignmentTargetOrderField) IsValid() bool {
	switch e {
	case WorkflowAssignmentTargetOrderFieldCreatedAt, WorkflowAssignmentTargetOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowAssignmentTargetOrderField) String() string {
	return string(e)
}

func (e *WorkflowAssignmentTargetOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowAssignmentTargetOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowAssignmentTargetOrderField", str)
	}
	return nil
}

func (e WorkflowAssignmentTargetOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowAssignmentTargetOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowAssignmentTargetOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowDefinitionHistory connections can be ordered.
type WorkflowDefinitionHistoryOrderField string

const (
	WorkflowDefinitionHistoryOrderFieldHistoryTime WorkflowDefinitionHistoryOrderField = "history_time"
	WorkflowDefinitionHistoryOrderFieldCreatedAt   WorkflowDefinitionHistoryOrderField = "created_at"
	WorkflowDefinitionHistoryOrderFieldUpdatedAt   WorkflowDefinitionHistoryOrderField = "updated_at"
)

var AllWorkflowDefinitionHistoryOrderField = []WorkflowDefinitionHistoryOrderField{
	WorkflowDefinitionHistoryOrderFieldHistoryTime,
	WorkflowDefinitionHistoryOrderFieldCreatedAt,
	WorkflowDefinitionHistoryOrderFieldUpdatedAt,
}

func (e WorkflowDefinitionHistoryOrderField) IsValid() bool {
	switch e {
	case WorkflowDefinitionHistoryOrderFieldHistoryTime, WorkflowDefinitionHistoryOrderFieldCreatedAt, WorkflowDefinitionHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowDefinitionHistoryOrderField) String() string {
	return string(e)
}

func (e *WorkflowDefinitionHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowDefinitionHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowDefinitionHistoryOrderField", str)
	}
	return nil
}

func (e WorkflowDefinitionHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowDefinitionHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowDefinitionHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowDefinition connections can be ordered.
type WorkflowDefinitionOrderField string

const (
	WorkflowDefinitionOrderFieldCreatedAt WorkflowDefinitionOrderField = "created_at"
	WorkflowDefinitionOrderFieldUpdatedAt WorkflowDefinitionOrderField = "updated_at"
)

var AllWorkflowDefinitionOrderField = []WorkflowDefinitionOrderField{
	WorkflowDefinitionOrderFieldCreatedAt,
	WorkflowDefinitionOrderFieldUpdatedAt,
}

func (e WorkflowDefinitionOrderField) IsValid() bool {
	switch e {
	case WorkflowDefinitionOrderFieldCreatedAt, WorkflowDefinitionOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowDefinitionOrderField) String() string {
	return string(e)
}

func (e *WorkflowDefinitionOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowDefinitionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowDefinitionOrderField", str)
	}
	return nil
}

func (e WorkflowDefinitionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowDefinitionOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowDefinitionOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowEventHistory connections can be ordered.
type WorkflowEventHistoryOrderField string

const (
	WorkflowEventHistoryOrderFieldHistoryTime WorkflowEventHistoryOrderField = "history_time"
	WorkflowEventHistoryOrderFieldCreatedAt   WorkflowEventHistoryOrderField = "created_at"
	WorkflowEventHistoryOrderFieldUpdatedAt   WorkflowEventHistoryOrderField = "updated_at"
)

var AllWorkflowEventHistoryOrderField = []WorkflowEventHistoryOrderField{
	WorkflowEventHistoryOrderFieldHistoryTime,
	WorkflowEventHistoryOrderFieldCreatedAt,
	WorkflowEventHistoryOrderFieldUpdatedAt,
}

func (e WorkflowEventHistoryOrderField) IsValid() bool {
	switch e {
	case WorkflowEventHistoryOrderFieldHistoryTime, WorkflowEventHistoryOrderFieldCreatedAt, WorkflowEventHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowEventHistoryOrderField) String() string {
	return string(e)
}

func (e *WorkflowEventHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowEventHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowEventHistoryOrderField", str)
	}
	return nil
}

func (e WorkflowEventHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowEventHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowEventHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowEvent connections can be ordered.
type WorkflowEventOrderField string

const (
	WorkflowEventOrderFieldCreatedAt WorkflowEventOrderField = "created_at"
	WorkflowEventOrderFieldUpdatedAt WorkflowEventOrderField = "updated_at"
)

var AllWorkflowEventOrderField = []WorkflowEventOrderField{
	WorkflowEventOrderFieldCreatedAt,
	WorkflowEventOrderFieldUpdatedAt,
}

func (e WorkflowEventOrderField) IsValid() bool {
	switch e {
	case WorkflowEventOrderFieldCreatedAt, WorkflowEventOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowEventOrderField) String() string {
	return string(e)
}

func (e *WorkflowEventOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowEventOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowEventOrderField", str)
	}
	return nil
}

func (e WorkflowEventOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowEventOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowEventOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowInstanceHistory connections can be ordered.
type WorkflowInstanceHistoryOrderField string

const (
	WorkflowInstanceHistoryOrderFieldHistoryTime WorkflowInstanceHistoryOrderField = "history_time"
	WorkflowInstanceHistoryOrderFieldCreatedAt   WorkflowInstanceHistoryOrderField = "created_at"
	WorkflowInstanceHistoryOrderFieldUpdatedAt   WorkflowInstanceHistoryOrderField = "updated_at"
)

var AllWorkflowInstanceHistoryOrderField = []WorkflowInstanceHistoryOrderField{
	WorkflowInstanceHistoryOrderFieldHistoryTime,
	WorkflowInstanceHistoryOrderFieldCreatedAt,
	WorkflowInstanceHistoryOrderFieldUpdatedAt,
}

func (e WorkflowInstanceHistoryOrderField) IsValid() bool {
	switch e {
	case WorkflowInstanceHistoryOrderFieldHistoryTime, WorkflowInstanceHistoryOrderFieldCreatedAt, WorkflowInstanceHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowInstanceHistoryOrderField) String() string {
	return string(e)
}

func (e *WorkflowInstanceHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowInstanceHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowInstanceHistoryOrderField", str)
	}
	return nil
}

func (e WorkflowInstanceHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowInstanceHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowInstanceHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowInstance connections can be ordered.
type WorkflowInstanceOrderField string

const (
	WorkflowInstanceOrderFieldCreatedAt WorkflowInstanceOrderField = "created_at"
	WorkflowInstanceOrderFieldUpdatedAt WorkflowInstanceOrderField = "updated_at"
)

var AllWorkflowInstanceOrderField = []WorkflowInstanceOrderField{
	WorkflowInstanceOrderFieldCreatedAt,
	WorkflowInstanceOrderFieldUpdatedAt,
}

func (e WorkflowInstanceOrderField) IsValid() bool {
	switch e {
	case WorkflowInstanceOrderFieldCreatedAt, WorkflowInstanceOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowInstanceOrderField) String() string {
	return string(e)
}

func (e *WorkflowInstanceOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowInstanceOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowInstanceOrderField", str)
	}
	return nil
}

func (e WorkflowInstanceOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowInstanceOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowInstanceOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowObjectRefHistory connections can be ordered.
type WorkflowObjectRefHistoryOrderField string

const (
	WorkflowObjectRefHistoryOrderFieldHistoryTime WorkflowObjectRefHistoryOrderField = "history_time"
	WorkflowObjectRefHistoryOrderFieldCreatedAt   WorkflowObjectRefHistoryOrderField = "created_at"
	WorkflowObjectRefHistoryOrderFieldUpdatedAt   WorkflowObjectRefHistoryOrderField = "updated_at"
)

var AllWorkflowObjectRefHistoryOrderField = []WorkflowObjectRefHistoryOrderField{
	WorkflowObjectRefHistoryOrderFieldHistoryTime,
	WorkflowObjectRefHistoryOrderFieldCreatedAt,
	WorkflowObjectRefHistoryOrderFieldUpdatedAt,
}

func (e WorkflowObjectRefHistoryOrderField) IsValid() bool {
	switch e {
	case WorkflowObjectRefHistoryOrderFieldHistoryTime, WorkflowObjectRefHistoryOrderFieldCreatedAt, WorkflowObjectRefHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowObjectRefHistoryOrderField) String() string {
	return string(e)
}

func (e *WorkflowObjectRefHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowObjectRefHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowObjectRefHistoryOrderField", str)
	}
	return nil
}

func (e WorkflowObjectRefHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowObjectRefHistoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowObjectRefHistoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which WorkflowObjectRef connections can be ordered.
type WorkflowObjectRefOrderField string

const (
	WorkflowObjectRefOrderFieldCreatedAt WorkflowObjectRefOrderField = "created_at"
	WorkflowObjectRefOrderFieldUpdatedAt WorkflowObjectRefOrderField = "updated_at"
)

var AllWorkflowObjectRefOrderField = []WorkflowObjectRefOrderField{
	WorkflowObjectRefOrderFieldCreatedAt,
	WorkflowObjectRefOrderFieldUpdatedAt,
}

func (e WorkflowObjectRefOrderField) IsValid() bool {
	switch e {
	case WorkflowObjectRefOrderFieldCreatedAt, WorkflowObjectRefOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e WorkflowObjectRefOrderField) String() string {
	return string(e)
}

func (e *WorkflowObjectRefOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowObjectRefOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowObjectRefOrderField", str)
	}
	return nil
}

func (e WorkflowObjectRefOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkflowObjectRefOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkflowObjectRefOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
