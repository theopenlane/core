// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package openlaneclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/core/pkg/models"
	"github.com/theopenlane/entx/history"
)

type SearchResult interface {
	IsSearchResult()
}

type APIToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt *time.Time    `json:"revokedAt,omitempty"`
	Owner     *Organization `json:"owner,omitempty"`
}

func (APIToken) IsNode() {}

// Return response for createBulkAPIToken mutation
type APITokenBulkCreatePayload struct {
	// Created apiTokens
	APITokens []*APIToken `json:"apiTokens,omitempty"`
}

// A connection to a list of items.
type APITokenConnection struct {
	// A list of edges.
	Edges []*APITokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createAPIToken mutation
type APITokenCreatePayload struct {
	// Created apiToken
	APIToken *APIToken `json:"apiToken"`
}

// Return response for deleteAPIToken mutation
type APITokenDeletePayload struct {
	// Deleted apiToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type APITokenEdge struct {
	// The item at the end of the edge.
	Node *APIToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for APIToken connections
type APITokenOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order APITokens.
	Field APITokenOrderField `json:"field"`
}

type APITokenSearchResult struct {
	APITokens []*APIToken `json:"apiTokens,omitempty"`
}

func (APITokenSearchResult) IsSearchResult() {}

// Return response for updateAPIToken mutation
type APITokenUpdatePayload struct {
	// Updated apiToken
	APIToken *APIToken `json:"apiToken"`
}

// APITokenWhereInput is used for filtering APIToken objects.
// Input was generated by ent.
type APITokenWhereInput struct {
	Not *APITokenWhereInput   `json:"not,omitempty"`
	And []*APITokenWhereInput `json:"and,omitempty"`
	Or  []*APITokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// is_active field predicates
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNeq    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  *bool `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil *bool `json:"isActiveNotNil,omitempty"`
	// revoked_reason field predicates
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNeq          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGt           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGte          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLt           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLte          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        *bool    `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       *bool    `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`
	// revoked_by field predicates
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNeq          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGt           *string  `json:"revokedByGT,omitempty"`
	RevokedByGte          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLt           *string  `json:"revokedByLT,omitempty"`
	RevokedByLte          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        *bool    `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       *bool    `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`
	// revoked_at field predicates
	RevokedAt       *time.Time   `json:"revokedAt,omitempty"`
	RevokedAtNeq    *time.Time   `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []*time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []*time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGt     *time.Time   `json:"revokedAtGT,omitempty"`
	RevokedAtGte    *time.Time   `json:"revokedAtGTE,omitempty"`
	RevokedAtLt     *time.Time   `json:"revokedAtLT,omitempty"`
	RevokedAtLte    *time.Time   `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  *bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil *bool        `json:"revokedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type ActionPlan struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the action_plan
	Name string `json:"name"`
	// status of the action_plan, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the action_plan, e.g. compliance, operational, health and safety, etc.
	ActionPlanType *string `json:"actionPlanType,omitempty"`
	// details of the action_plan
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the action_plan
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the action_plan should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the action_plan should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *enums.Priority `json:"priority,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
	// the group of users who are responsible for approving the action_plan
	Approver *Group `json:"approver,omitempty"`
	// temporary delegates for the action_plan, used for temporary approval
	Delegate *Group             `json:"delegate,omitempty"`
	Owner    *Organization      `json:"owner,omitempty"`
	Risks    *RiskConnection    `json:"risks"`
	Controls *ControlConnection `json:"controls"`
	Users    *UserConnection    `json:"users"`
	Programs *ProgramConnection `json:"programs"`
}

func (ActionPlan) IsNode() {}

// Return response for createBulkActionPlan mutation
type ActionPlanBulkCreatePayload struct {
	// Created actionPlans
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
}

// A connection to a list of items.
type ActionPlanConnection struct {
	// A list of edges.
	Edges []*ActionPlanEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createActionPlan mutation
type ActionPlanCreatePayload struct {
	// Created actionPlan
	ActionPlan *ActionPlan `json:"actionPlan"`
}

// Return response for deleteActionPlan mutation
type ActionPlanDeletePayload struct {
	// Deleted actionPlan ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ActionPlanEdge struct {
	// The item at the end of the edge.
	Node *ActionPlan `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ActionPlanHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the action_plan
	Name string `json:"name"`
	// status of the action_plan, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the action_plan, e.g. compliance, operational, health and safety, etc.
	ActionPlanType *string `json:"actionPlanType,omitempty"`
	// details of the action_plan
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the action_plan
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the action_plan should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the action_plan should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *enums.Priority `json:"priority,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
}

func (ActionPlanHistory) IsNode() {}

// A connection to a list of items.
type ActionPlanHistoryConnection struct {
	// A list of edges.
	Edges []*ActionPlanHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ActionPlanHistoryEdge struct {
	// The item at the end of the edge.
	Node *ActionPlanHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ActionPlanHistory connections
type ActionPlanHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ActionPlanHistories.
	Field ActionPlanHistoryOrderField `json:"field"`
}

// ActionPlanHistoryWhereInput is used for filtering ActionPlanHistory objects.
// Input was generated by ent.
type ActionPlanHistoryWhereInput struct {
	Not *ActionPlanHistoryWhereInput   `json:"not,omitempty"`
	And []*ActionPlanHistoryWhereInput `json:"and,omitempty"`
	Or  []*ActionPlanHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// action_plan_type field predicates
	ActionPlanType             *string  `json:"actionPlanType,omitempty"`
	ActionPlanTypeNeq          *string  `json:"actionPlanTypeNEQ,omitempty"`
	ActionPlanTypeIn           []string `json:"actionPlanTypeIn,omitempty"`
	ActionPlanTypeNotIn        []string `json:"actionPlanTypeNotIn,omitempty"`
	ActionPlanTypeGt           *string  `json:"actionPlanTypeGT,omitempty"`
	ActionPlanTypeGte          *string  `json:"actionPlanTypeGTE,omitempty"`
	ActionPlanTypeLt           *string  `json:"actionPlanTypeLT,omitempty"`
	ActionPlanTypeLte          *string  `json:"actionPlanTypeLTE,omitempty"`
	ActionPlanTypeContains     *string  `json:"actionPlanTypeContains,omitempty"`
	ActionPlanTypeHasPrefix    *string  `json:"actionPlanTypeHasPrefix,omitempty"`
	ActionPlanTypeHasSuffix    *string  `json:"actionPlanTypeHasSuffix,omitempty"`
	ActionPlanTypeIsNil        *bool    `json:"actionPlanTypeIsNil,omitempty"`
	ActionPlanTypeNotNil       *bool    `json:"actionPlanTypeNotNil,omitempty"`
	ActionPlanTypeEqualFold    *string  `json:"actionPlanTypeEqualFold,omitempty"`
	ActionPlanTypeContainsFold *string  `json:"actionPlanTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// priority field predicates
	Priority       *enums.Priority  `json:"priority,omitempty"`
	PriorityNeq    *enums.Priority  `json:"priorityNEQ,omitempty"`
	PriorityIn     []enums.Priority `json:"priorityIn,omitempty"`
	PriorityNotIn  []enums.Priority `json:"priorityNotIn,omitempty"`
	PriorityIsNil  *bool            `json:"priorityIsNil,omitempty"`
	PriorityNotNil *bool            `json:"priorityNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
}

// Ordering options for ActionPlan connections
type ActionPlanOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ActionPlans.
	Field ActionPlanOrderField `json:"field"`
}

type ActionPlanSearchResult struct {
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
}

func (ActionPlanSearchResult) IsSearchResult() {}

// Return response for updateActionPlan mutation
type ActionPlanUpdatePayload struct {
	// Updated actionPlan
	ActionPlan *ActionPlan `json:"actionPlan"`
}

// ActionPlanWhereInput is used for filtering ActionPlan objects.
// Input was generated by ent.
type ActionPlanWhereInput struct {
	Not *ActionPlanWhereInput   `json:"not,omitempty"`
	And []*ActionPlanWhereInput `json:"and,omitempty"`
	Or  []*ActionPlanWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// action_plan_type field predicates
	ActionPlanType             *string  `json:"actionPlanType,omitempty"`
	ActionPlanTypeNeq          *string  `json:"actionPlanTypeNEQ,omitempty"`
	ActionPlanTypeIn           []string `json:"actionPlanTypeIn,omitempty"`
	ActionPlanTypeNotIn        []string `json:"actionPlanTypeNotIn,omitempty"`
	ActionPlanTypeGt           *string  `json:"actionPlanTypeGT,omitempty"`
	ActionPlanTypeGte          *string  `json:"actionPlanTypeGTE,omitempty"`
	ActionPlanTypeLt           *string  `json:"actionPlanTypeLT,omitempty"`
	ActionPlanTypeLte          *string  `json:"actionPlanTypeLTE,omitempty"`
	ActionPlanTypeContains     *string  `json:"actionPlanTypeContains,omitempty"`
	ActionPlanTypeHasPrefix    *string  `json:"actionPlanTypeHasPrefix,omitempty"`
	ActionPlanTypeHasSuffix    *string  `json:"actionPlanTypeHasSuffix,omitempty"`
	ActionPlanTypeIsNil        *bool    `json:"actionPlanTypeIsNil,omitempty"`
	ActionPlanTypeNotNil       *bool    `json:"actionPlanTypeNotNil,omitempty"`
	ActionPlanTypeEqualFold    *string  `json:"actionPlanTypeEqualFold,omitempty"`
	ActionPlanTypeContainsFold *string  `json:"actionPlanTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// priority field predicates
	Priority       *enums.Priority  `json:"priority,omitempty"`
	PriorityNeq    *enums.Priority  `json:"priorityNEQ,omitempty"`
	PriorityIn     []enums.Priority `json:"priorityIn,omitempty"`
	PriorityNotIn  []enums.Priority `json:"priorityNotIn,omitempty"`
	PriorityIsNil  *bool            `json:"priorityIsNil,omitempty"`
	PriorityNotNil *bool            `json:"priorityNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// approver edge predicates
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type AuditLog struct {
	Table     *string    `json:"table,omitempty"`
	Time      *time.Time `json:"time,omitempty"`
	ID        string     `json:"id"`
	Operation *string    `json:"operation,omitempty"`
	Changes   []string   `json:"changes,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
}

func (AuditLog) IsNode() {}

// A connection to a list of items.
type AuditLogConnection struct {
	// A list of edges.
	Edges []*AuditLogEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type AuditLogEdge struct {
	// The item at the end of the edge.
	Node *AuditLog `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type AuditLogWhereInput struct {
	RefID     *string    `json:"refID,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Operation *string    `json:"operation,omitempty"`
	Table     *string    `json:"table,omitempty"`
	Before    *time.Time `json:"before,omitempty"`
	After     *time.Time `json:"after,omitempty"`
}

type Contact struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status   enums.UserStatus  `json:"status"`
	Owner    *Organization     `json:"owner,omitempty"`
	Entities *EntityConnection `json:"entities"`
	Files    *FileConnection   `json:"files"`
}

func (Contact) IsNode() {}

// Return response for createBulkContact mutation
type ContactBulkCreatePayload struct {
	// Created contacts
	Contacts []*Contact `json:"contacts,omitempty"`
}

// A connection to a list of items.
type ContactConnection struct {
	// A list of edges.
	Edges []*ContactEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createContact mutation
type ContactCreatePayload struct {
	// Created contact
	Contact *Contact `json:"contact"`
}

// Return response for deleteContact mutation
type ContactDeletePayload struct {
	// Deleted contact ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ContactEdge struct {
	// The item at the end of the edge.
	Node *Contact `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ContactHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status enums.UserStatus `json:"status"`
}

func (ContactHistory) IsNode() {}

// A connection to a list of items.
type ContactHistoryConnection struct {
	// A list of edges.
	Edges []*ContactHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ContactHistoryEdge struct {
	// The item at the end of the edge.
	Node *ContactHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ContactHistory connections
type ContactHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ContactHistories.
	Field ContactHistoryOrderField `json:"field"`
}

// ContactHistoryWhereInput is used for filtering ContactHistory objects.
// Input was generated by ent.
type ContactHistoryWhereInput struct {
	Not *ContactHistoryWhereInput   `json:"not,omitempty"`
	And []*ContactHistoryWhereInput `json:"and,omitempty"`
	Or  []*ContactHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
}

// Ordering options for Contact connections
type ContactOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Contacts.
	Field ContactOrderField `json:"field"`
}

type ContactSearchResult struct {
	Contacts []*Contact `json:"contacts,omitempty"`
}

func (ContactSearchResult) IsSearchResult() {}

// Return response for updateContact mutation
type ContactUpdatePayload struct {
	// Updated contact
	Contact *Contact `json:"contact"`
}

// ContactWhereInput is used for filtering Contact objects.
// Input was generated by ent.
type ContactWhereInput struct {
	Not *ContactWhereInput   `json:"not,omitempty"`
	And []*ContactWhereInput `json:"and,omitempty"`
	Or  []*ContactWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Control struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the standard that the control belongs to, if applicable
	StandardID *string       `json:"standardID,omitempty"`
	Owner      *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers                []*Group                         `json:"viewers,omitempty"`
	Standard               *Standard                        `json:"standard,omitempty"`
	Programs               *ProgramConnection               `json:"programs"`
	Evidence               *EvidenceConnection              `json:"evidence"`
	ControlImplementations *ControlImplementationConnection `json:"controlImplementations"`
	MappedControls         *MappedControlConnection         `json:"mappedControls"`
	ControlObjectives      *ControlObjectiveConnection      `json:"controlObjectives"`
	Subcontrols            *SubcontrolConnection            `json:"subcontrols"`
	Tasks                  *TaskConnection                  `json:"tasks"`
	Narratives             *NarrativeConnection             `json:"narratives"`
	Risks                  *RiskConnection                  `json:"risks"`
	ActionPlans            *ActionPlanConnection            `json:"actionPlans"`
	Procedures             *ProcedureConnection             `json:"procedures"`
	InternalPolicies       *InternalPolicyConnection        `json:"internalPolicies"`
	// the group of users who are responsible for the control, will be assigned tasks, approval, etc.
	ControlOwner *Group `json:"controlOwner,omitempty"`
	// temporary delegate for the control, used for temporary control ownership
	Delegate *Group `json:"delegate,omitempty"`
}

func (Control) IsNode() {}

// Return response for createBulkControl mutation
type ControlBulkCreatePayload struct {
	// Created controls
	Controls []*Control `json:"controls,omitempty"`
}

// A connection to a list of items.
type ControlConnection struct {
	// A list of edges.
	Edges []*ControlEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControl mutation
type ControlCreatePayload struct {
	// Created control
	Control *Control `json:"control"`
}

// Return response for deleteControl mutation
type ControlDeletePayload struct {
	// Deleted control ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlEdge struct {
	// The item at the end of the edge.
	Node *Control `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the standard that the control belongs to, if applicable
	StandardID *string `json:"standardID,omitempty"`
}

func (ControlHistory) IsNode() {}

// A connection to a list of items.
type ControlHistoryConnection struct {
	// A list of edges.
	Edges []*ControlHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ControlHistory connections
type ControlHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlHistories.
	Field ControlHistoryOrderField `json:"field"`
}

// ControlHistoryWhereInput is used for filtering ControlHistory objects.
// Input was generated by ent.
type ControlHistoryWhereInput struct {
	Not *ControlHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
}

type ControlImplementation struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// status of the %s, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details  *string            `json:"details,omitempty"`
	Controls *ControlConnection `json:"controls"`
}

func (ControlImplementation) IsNode() {}

// Return response for createBulkControlImplementation mutation
type ControlImplementationBulkCreatePayload struct {
	// Created controlImplementations
	ControlImplementations []*ControlImplementation `json:"controlImplementations,omitempty"`
}

// A connection to a list of items.
type ControlImplementationConnection struct {
	// A list of edges.
	Edges []*ControlImplementationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControlImplementation mutation
type ControlImplementationCreatePayload struct {
	// Created controlImplementation
	ControlImplementation *ControlImplementation `json:"controlImplementation"`
}

// Return response for deleteControlImplementation mutation
type ControlImplementationDeletePayload struct {
	// Deleted controlImplementation ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlImplementationEdge struct {
	// The item at the end of the edge.
	Node *ControlImplementation `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlImplementationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// status of the %s, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details *string `json:"details,omitempty"`
}

func (ControlImplementationHistory) IsNode() {}

// A connection to a list of items.
type ControlImplementationHistoryConnection struct {
	// A list of edges.
	Edges []*ControlImplementationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlImplementationHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlImplementationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ControlImplementationHistory connections
type ControlImplementationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlImplementationHistories.
	Field ControlImplementationHistoryOrderField `json:"field"`
}

// ControlImplementationHistoryWhereInput is used for filtering ControlImplementationHistory objects.
// Input was generated by ent.
type ControlImplementationHistoryWhereInput struct {
	Not *ControlImplementationHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlImplementationHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlImplementationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// implementation_date field predicates
	ImplementationDate       *time.Time   `json:"implementationDate,omitempty"`
	ImplementationDateNeq    *time.Time   `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []*time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []*time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGt     *time.Time   `json:"implementationDateGT,omitempty"`
	ImplementationDateGte    *time.Time   `json:"implementationDateGTE,omitempty"`
	ImplementationDateLt     *time.Time   `json:"implementationDateLT,omitempty"`
	ImplementationDateLte    *time.Time   `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  *bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil *bool        `json:"implementationDateNotNil,omitempty"`
	// verified field predicates
	Verified       *bool `json:"verified,omitempty"`
	VerifiedNeq    *bool `json:"verifiedNEQ,omitempty"`
	VerifiedIsNil  *bool `json:"verifiedIsNil,omitempty"`
	VerifiedNotNil *bool `json:"verifiedNotNil,omitempty"`
	// verification_date field predicates
	VerificationDate       *time.Time   `json:"verificationDate,omitempty"`
	VerificationDateNeq    *time.Time   `json:"verificationDateNEQ,omitempty"`
	VerificationDateIn     []*time.Time `json:"verificationDateIn,omitempty"`
	VerificationDateNotIn  []*time.Time `json:"verificationDateNotIn,omitempty"`
	VerificationDateGt     *time.Time   `json:"verificationDateGT,omitempty"`
	VerificationDateGte    *time.Time   `json:"verificationDateGTE,omitempty"`
	VerificationDateLt     *time.Time   `json:"verificationDateLT,omitempty"`
	VerificationDateLte    *time.Time   `json:"verificationDateLTE,omitempty"`
	VerificationDateIsNil  *bool        `json:"verificationDateIsNil,omitempty"`
	VerificationDateNotNil *bool        `json:"verificationDateNotNil,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
}

// Ordering options for ControlImplementation connections
type ControlImplementationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlImplementations.
	Field ControlImplementationOrderField `json:"field"`
}

type ControlImplementationSearchResult struct {
	ControlImplementations []*ControlImplementation `json:"controlImplementations,omitempty"`
}

func (ControlImplementationSearchResult) IsSearchResult() {}

// Return response for updateControlImplementation mutation
type ControlImplementationUpdatePayload struct {
	// Updated controlImplementation
	ControlImplementation *ControlImplementation `json:"controlImplementation"`
}

// ControlImplementationWhereInput is used for filtering ControlImplementation objects.
// Input was generated by ent.
type ControlImplementationWhereInput struct {
	Not *ControlImplementationWhereInput   `json:"not,omitempty"`
	And []*ControlImplementationWhereInput `json:"and,omitempty"`
	Or  []*ControlImplementationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// implementation_date field predicates
	ImplementationDate       *time.Time   `json:"implementationDate,omitempty"`
	ImplementationDateNeq    *time.Time   `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []*time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []*time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGt     *time.Time   `json:"implementationDateGT,omitempty"`
	ImplementationDateGte    *time.Time   `json:"implementationDateGTE,omitempty"`
	ImplementationDateLt     *time.Time   `json:"implementationDateLT,omitempty"`
	ImplementationDateLte    *time.Time   `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  *bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil *bool        `json:"implementationDateNotNil,omitempty"`
	// verified field predicates
	Verified       *bool `json:"verified,omitempty"`
	VerifiedNeq    *bool `json:"verifiedNEQ,omitempty"`
	VerifiedIsNil  *bool `json:"verifiedIsNil,omitempty"`
	VerifiedNotNil *bool `json:"verifiedNotNil,omitempty"`
	// verification_date field predicates
	VerificationDate       *time.Time   `json:"verificationDate,omitempty"`
	VerificationDateNeq    *time.Time   `json:"verificationDateNEQ,omitempty"`
	VerificationDateIn     []*time.Time `json:"verificationDateIn,omitempty"`
	VerificationDateNotIn  []*time.Time `json:"verificationDateNotIn,omitempty"`
	VerificationDateGt     *time.Time   `json:"verificationDateGT,omitempty"`
	VerificationDateGte    *time.Time   `json:"verificationDateGTE,omitempty"`
	VerificationDateLt     *time.Time   `json:"verificationDateLT,omitempty"`
	VerificationDateLte    *time.Time   `json:"verificationDateLTE,omitempty"`
	VerificationDateIsNil  *bool        `json:"verificationDateIsNil,omitempty"`
	VerificationDateNotNil *bool        `json:"verificationDateNotNil,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
}

type ControlObjective struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory *string       `json:"subcategory,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers          []*Group                  `json:"viewers,omitempty"`
	Programs         *ProgramConnection        `json:"programs"`
	Evidence         *EvidenceConnection       `json:"evidence"`
	Controls         *ControlConnection        `json:"controls"`
	Subcontrols      *SubcontrolConnection     `json:"subcontrols"`
	InternalPolicies *InternalPolicyConnection `json:"internalPolicies"`
	Procedures       *ProcedureConnection      `json:"procedures"`
	Risks            *RiskConnection           `json:"risks"`
	Narratives       *NarrativeConnection      `json:"narratives"`
	Tasks            *TaskConnection           `json:"tasks"`
}

func (ControlObjective) IsNode() {}

// Return response for createBulkControlObjective mutation
type ControlObjectiveBulkCreatePayload struct {
	// Created controlObjectives
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
}

// A connection to a list of items.
type ControlObjectiveConnection struct {
	// A list of edges.
	Edges []*ControlObjectiveEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControlObjective mutation
type ControlObjectiveCreatePayload struct {
	// Created controlObjective
	ControlObjective *ControlObjective `json:"controlObjective"`
}

// Return response for deleteControlObjective mutation
type ControlObjectiveDeletePayload struct {
	// Deleted controlObjective ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlObjectiveEdge struct {
	// The item at the end of the edge.
	Node *ControlObjective `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlObjectiveHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
}

func (ControlObjectiveHistory) IsNode() {}

// A connection to a list of items.
type ControlObjectiveHistoryConnection struct {
	// A list of edges.
	Edges []*ControlObjectiveHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlObjectiveHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlObjectiveHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ControlObjectiveHistory connections
type ControlObjectiveHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlObjectiveHistories.
	Field ControlObjectiveHistoryOrderField `json:"field"`
}

// ControlObjectiveHistoryWhereInput is used for filtering ControlObjectiveHistory objects.
// Input was generated by ent.
type ControlObjectiveHistoryWhereInput struct {
	Not *ControlObjectiveHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlObjectiveHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlObjectiveHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// desired_outcome field predicates
	DesiredOutcome             *string  `json:"desiredOutcome,omitempty"`
	DesiredOutcomeNeq          *string  `json:"desiredOutcomeNEQ,omitempty"`
	DesiredOutcomeIn           []string `json:"desiredOutcomeIn,omitempty"`
	DesiredOutcomeNotIn        []string `json:"desiredOutcomeNotIn,omitempty"`
	DesiredOutcomeGt           *string  `json:"desiredOutcomeGT,omitempty"`
	DesiredOutcomeGte          *string  `json:"desiredOutcomeGTE,omitempty"`
	DesiredOutcomeLt           *string  `json:"desiredOutcomeLT,omitempty"`
	DesiredOutcomeLte          *string  `json:"desiredOutcomeLTE,omitempty"`
	DesiredOutcomeContains     *string  `json:"desiredOutcomeContains,omitempty"`
	DesiredOutcomeHasPrefix    *string  `json:"desiredOutcomeHasPrefix,omitempty"`
	DesiredOutcomeHasSuffix    *string  `json:"desiredOutcomeHasSuffix,omitempty"`
	DesiredOutcomeIsNil        *bool    `json:"desiredOutcomeIsNil,omitempty"`
	DesiredOutcomeNotNil       *bool    `json:"desiredOutcomeNotNil,omitempty"`
	DesiredOutcomeEqualFold    *string  `json:"desiredOutcomeEqualFold,omitempty"`
	DesiredOutcomeContainsFold *string  `json:"desiredOutcomeContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_objective_type field predicates
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNeq          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGt           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGte          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLt           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLte          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        *bool    `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       *bool    `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
}

// Ordering options for ControlObjective connections
type ControlObjectiveOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ControlObjectives.
	Field ControlObjectiveOrderField `json:"field"`
}

type ControlObjectiveSearchResult struct {
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
}

func (ControlObjectiveSearchResult) IsSearchResult() {}

// Return response for updateControlObjective mutation
type ControlObjectiveUpdatePayload struct {
	// Updated controlObjective
	ControlObjective *ControlObjective `json:"controlObjective"`
}

// ControlObjectiveWhereInput is used for filtering ControlObjective objects.
// Input was generated by ent.
type ControlObjectiveWhereInput struct {
	Not *ControlObjectiveWhereInput   `json:"not,omitempty"`
	And []*ControlObjectiveWhereInput `json:"and,omitempty"`
	Or  []*ControlObjectiveWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// desired_outcome field predicates
	DesiredOutcome             *string  `json:"desiredOutcome,omitempty"`
	DesiredOutcomeNeq          *string  `json:"desiredOutcomeNEQ,omitempty"`
	DesiredOutcomeIn           []string `json:"desiredOutcomeIn,omitempty"`
	DesiredOutcomeNotIn        []string `json:"desiredOutcomeNotIn,omitempty"`
	DesiredOutcomeGt           *string  `json:"desiredOutcomeGT,omitempty"`
	DesiredOutcomeGte          *string  `json:"desiredOutcomeGTE,omitempty"`
	DesiredOutcomeLt           *string  `json:"desiredOutcomeLT,omitempty"`
	DesiredOutcomeLte          *string  `json:"desiredOutcomeLTE,omitempty"`
	DesiredOutcomeContains     *string  `json:"desiredOutcomeContains,omitempty"`
	DesiredOutcomeHasPrefix    *string  `json:"desiredOutcomeHasPrefix,omitempty"`
	DesiredOutcomeHasSuffix    *string  `json:"desiredOutcomeHasSuffix,omitempty"`
	DesiredOutcomeIsNil        *bool    `json:"desiredOutcomeIsNil,omitempty"`
	DesiredOutcomeNotNil       *bool    `json:"desiredOutcomeNotNil,omitempty"`
	DesiredOutcomeEqualFold    *string  `json:"desiredOutcomeEqualFold,omitempty"`
	DesiredOutcomeContainsFold *string  `json:"desiredOutcomeContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_objective_type field predicates
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNeq          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGt           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGte          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLt           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLte          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        *bool    `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       *bool    `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

// Ordering options for Control connections
type ControlOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Controls.
	Field ControlOrderField `json:"field"`
}

type ControlSearchResult struct {
	Controls []*Control `json:"controls,omitempty"`
}

func (ControlSearchResult) IsSearchResult() {}

// Return response for updateControl mutation
type ControlUpdatePayload struct {
	// Updated control
	Control *Control `json:"control"`
}

// ControlWhereInput is used for filtering Control objects.
// Input was generated by ent.
type ControlWhereInput struct {
	Not *ControlWhereInput   `json:"not,omitempty"`
	And []*ControlWhereInput `json:"and,omitempty"`
	Or  []*ControlWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// standard edge predicates
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// control_implementations edge predicates
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`
	// mapped_controls edge predicates
	HasMappedControls     *bool                      `json:"hasMappedControls,omitempty"`
	HasMappedControlsWith []*MappedControlWhereInput `json:"hasMappedControlsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// control_owner edge predicates
	HasControlOwner     *bool              `json:"hasControlOwner,omitempty"`
	HasControlOwnerWith []*GroupWhereInput `json:"hasControlOwnerWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
}

// CreateAPITokenInput is used for create APIToken object.
// Input was generated by ent.
type CreateAPITokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt *time.Time `json:"revokedAt,omitempty"`
	OwnerID   *string    `json:"ownerID,omitempty"`
}

// CreateActionPlanInput is used for create ActionPlan object.
// Input was generated by ent.
type CreateActionPlanInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the action_plan
	Name string `json:"name"`
	// status of the action_plan, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the action_plan, e.g. compliance, operational, health and safety, etc.
	ActionPlanType *string `json:"actionPlanType,omitempty"`
	// details of the action_plan
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the action_plan
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the action_plan should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the action_plan should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *enums.Priority `json:"priority,omitempty"`
	// source of the action plan
	Source     *string  `json:"source,omitempty"`
	ApproverID *string  `json:"approverID,omitempty"`
	DelegateID *string  `json:"delegateID,omitempty"`
	OwnerID    *string  `json:"ownerID,omitempty"`
	RiskIDs    []string `json:"riskIDs,omitempty"`
	ControlIDs []string `json:"controlIDs,omitempty"`
	UserIDs    []string `json:"userIDs,omitempty"`
	ProgramIDs []string `json:"programIDs,omitempty"`
}

// CreateContactInput is used for create Contact object.
// Input was generated by ent.
type CreateContactInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status    *enums.UserStatus `json:"status,omitempty"`
	OwnerID   *string           `json:"ownerID,omitempty"`
	EntityIDs []string          `json:"entityIDs,omitempty"`
	FileIDs   []string          `json:"fileIDs,omitempty"`
}

// CreateControlImplementationInput is used for create ControlImplementation object.
// Input was generated by ent.
type CreateControlImplementationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// status of the %s, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details    *string  `json:"details,omitempty"`
	ControlIDs []string `json:"controlIDs,omitempty"`
}

// CreateControlInput is used for create Control object.
// Input was generated by ent.
type CreateControlInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode                  string   `json:"refCode"`
	OwnerID                  *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs          []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs                []string `json:"editorIDs,omitempty"`
	ViewerIDs                []string `json:"viewerIDs,omitempty"`
	StandardID               *string  `json:"standardID,omitempty"`
	ProgramIDs               []string `json:"programIDs,omitempty"`
	EvidenceIDs              []string `json:"evidenceIDs,omitempty"`
	ControlImplementationIDs []string `json:"controlImplementationIDs,omitempty"`
	MappedControlIDs         []string `json:"mappedControlIDs,omitempty"`
	ControlObjectiveIDs      []string `json:"controlObjectiveIDs,omitempty"`
	SubcontrolIDs            []string `json:"subcontrolIDs,omitempty"`
	TaskIDs                  []string `json:"taskIDs,omitempty"`
	NarrativeIDs             []string `json:"narrativeIDs,omitempty"`
	RiskIDs                  []string `json:"riskIDs,omitempty"`
	ActionPlanIDs            []string `json:"actionPlanIDs,omitempty"`
	ProcedureIDs             []string `json:"procedureIDs,omitempty"`
	InternalPolicyIDs        []string `json:"internalPolicyIDs,omitempty"`
	ControlOwnerID           *string  `json:"controlOwnerID,omitempty"`
	DelegateID               *string  `json:"delegateID,omitempty"`
}

// CreateControlObjectiveInput is used for create ControlObjective object.
// Input was generated by ent.
type CreateControlObjectiveInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory       *string  `json:"subcategory,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string `json:"editorIDs,omitempty"`
	ViewerIDs         []string `json:"viewerIDs,omitempty"`
	ProgramIDs        []string `json:"programIDs,omitempty"`
	EvidenceIDs       []string `json:"evidenceIDs,omitempty"`
	ControlIDs        []string `json:"controlIDs,omitempty"`
	SubcontrolIDs     []string `json:"subcontrolIDs,omitempty"`
	InternalPolicyIDs []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs      []string `json:"procedureIDs,omitempty"`
	RiskIDs           []string `json:"riskIDs,omitempty"`
	NarrativeIDs      []string `json:"narrativeIDs,omitempty"`
	TaskIDs           []string `json:"taskIDs,omitempty"`
}

type CreateControlWithSubcontrolsInput struct {
	Control     *CreateControlInput      `json:"control,omitempty"`
	Subcontrols []*CreateSubcontrolInput `json:"subcontrols,omitempty"`
}

// CreateDocumentDataInput is used for create DocumentData object.
// Input was generated by ent.
type CreateDocumentDataInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the json data of the document
	Data       map[string]any `json:"data"`
	OwnerID    *string        `json:"ownerID,omitempty"`
	TemplateID string         `json:"templateID"`
	EntityIDs  []string       `json:"entityIDs,omitempty"`
	FileIDs    []string       `json:"fileIDs,omitempty"`
}

// CreateEntityInput is used for create Entity object.
// Input was generated by ent.
type CreateEntityInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// status of the entity
	Status       *string          `json:"status,omitempty"`
	OwnerID      *string          `json:"ownerID,omitempty"`
	ContactIDs   []string         `json:"contactIDs,omitempty"`
	DocumentIDs  []string         `json:"documentIDs,omitempty"`
	NoteIDs      []string         `json:"noteIDs,omitempty"`
	FileIDs      []string         `json:"fileIDs,omitempty"`
	EntityTypeID *string          `json:"entityTypeID,omitempty"`
	Note         *CreateNoteInput `json:"note,omitempty"`
}

// CreateEntityTypeInput is used for create EntityType object.
// Input was generated by ent.
type CreateEntityTypeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the entity
	Name      string   `json:"name"`
	OwnerID   *string  `json:"ownerID,omitempty"`
	EntityIDs []string `json:"entityIDs,omitempty"`
}

// CreateEventInput is used for create Event object.
// Input was generated by ent.
type CreateEventInput struct {
	// tags associated with the object
	Tags                   []string       `json:"tags,omitempty"`
	EventID                *string        `json:"eventID,omitempty"`
	CorrelationID          *string        `json:"correlationID,omitempty"`
	EventType              string         `json:"eventType"`
	Metadata               map[string]any `json:"metadata,omitempty"`
	UserIDs                []string       `json:"userIDs,omitempty"`
	GroupIDs               []string       `json:"groupIDs,omitempty"`
	IntegrationIDs         []string       `json:"integrationIDs,omitempty"`
	OrganizationIDs        []string       `json:"organizationIDs,omitempty"`
	InviteIDs              []string       `json:"inviteIDs,omitempty"`
	PersonalAccessTokenIDs []string       `json:"personalAccessTokenIDs,omitempty"`
	SecretIDs              []string       `json:"secretIDs,omitempty"`
	SubscriberIDs          []string       `json:"subscriberIDs,omitempty"`
	FileIDs                []string       `json:"fileIDs,omitempty"`
	OrgSubscriptionIDs     []string       `json:"orgSubscriptionIDs,omitempty"`
}

// CreateEvidenceInput is used for create Evidence object.
// Input was generated by ent.
type CreateEvidenceInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate *time.Time `json:"creationDate,omitempty"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL *string `json:"url,omitempty"`
	// the status of the evidence, ready, approved, needs renewal, missing artifact, rejected
	Status              *enums.EvidenceStatus `json:"status,omitempty"`
	OwnerID             *string               `json:"ownerID,omitempty"`
	ControlObjectiveIDs []string              `json:"controlObjectiveIDs,omitempty"`
	ControlIDs          []string              `json:"controlIDs,omitempty"`
	SubcontrolIDs       []string              `json:"subcontrolIDs,omitempty"`
	FileIDs             []string              `json:"fileIDs,omitempty"`
	ProgramIDs          []string              `json:"programIDs,omitempty"`
	TaskIDs             []string              `json:"taskIDs,omitempty"`
}

// CreateFileInput is used for create File object.
// Input was generated by ent.
type CreateFileInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath            *string  `json:"storagePath,omitempty"`
	UserIDs                []string `json:"userIDs,omitempty"`
	OrganizationIDs        []string `json:"organizationIDs,omitempty"`
	GroupIDs               []string `json:"groupIDs,omitempty"`
	ContactIDs             []string `json:"contactIDs,omitempty"`
	EntityIDs              []string `json:"entityIDs,omitempty"`
	UserSettingIDs         []string `json:"userSettingIDs,omitempty"`
	OrganizationSettingIDs []string `json:"organizationSettingIDs,omitempty"`
	TemplateIDs            []string `json:"templateIDs,omitempty"`
	DocumentIDs            []string `json:"documentIDs,omitempty"`
	ProgramIDs             []string `json:"programIDs,omitempty"`
	EvidenceIDs            []string `json:"evidenceIDs,omitempty"`
	EventIDs               []string `json:"eventIDs,omitempty"`
}

type CreateFullProgramInput struct {
	Program          *CreateProgramInput                  `json:"program"`
	Controls         []*CreateControlWithSubcontrolsInput `json:"controls,omitempty"`
	Risks            []*CreateRiskInput                   `json:"risks,omitempty"`
	InternalPolicies []*CreateInternalPolicyInput         `json:"internalPolicies,omitempty"`
	Procedures       []*CreateProcedureInput              `json:"procedures,omitempty"`
	Members          []*CreateMemberWithProgramInput      `json:"members,omitempty"`
}

// CreateGroupInput is used for create Group object.
// Input was generated by ent.
type CreateGroupInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName                     *string                  `json:"displayName,omitempty"`
	OwnerID                         *string                  `json:"ownerID,omitempty"`
	ProgramEditorIDs                []string                 `json:"programEditorIDs,omitempty"`
	ProgramBlockedGroupIDs          []string                 `json:"programBlockedGroupIDs,omitempty"`
	ProgramViewerIDs                []string                 `json:"programViewerIDs,omitempty"`
	RiskEditorIDs                   []string                 `json:"riskEditorIDs,omitempty"`
	RiskBlockedGroupIDs             []string                 `json:"riskBlockedGroupIDs,omitempty"`
	RiskViewerIDs                   []string                 `json:"riskViewerIDs,omitempty"`
	ControlObjectiveEditorIDs       []string                 `json:"controlObjectiveEditorIDs,omitempty"`
	ControlObjectiveBlockedGroupIDs []string                 `json:"controlObjectiveBlockedGroupIDs,omitempty"`
	ControlObjectiveViewerIDs       []string                 `json:"controlObjectiveViewerIDs,omitempty"`
	ControlEditorIDs                []string                 `json:"controlEditorIDs,omitempty"`
	ControlBlockedGroupIDs          []string                 `json:"controlBlockedGroupIDs,omitempty"`
	ControlViewerIDs                []string                 `json:"controlViewerIDs,omitempty"`
	NarrativeEditorIDs              []string                 `json:"narrativeEditorIDs,omitempty"`
	NarrativeBlockedGroupIDs        []string                 `json:"narrativeBlockedGroupIDs,omitempty"`
	NarrativeViewerIDs              []string                 `json:"narrativeViewerIDs,omitempty"`
	ProcedureEditorIDs              []string                 `json:"procedureEditorIDs,omitempty"`
	ProcedureBlockedGroupIDs        []string                 `json:"procedureBlockedGroupIDs,omitempty"`
	InternalPolicyEditorIDs         []string                 `json:"internalPolicyEditorIDs,omitempty"`
	InternalPolicyBlockedGroupIDs   []string                 `json:"internalPolicyBlockedGroupIDs,omitempty"`
	SettingID                       *string                  `json:"settingID,omitempty"`
	EventIDs                        []string                 `json:"eventIDs,omitempty"`
	IntegrationIDs                  []string                 `json:"integrationIDs,omitempty"`
	FileIDs                         []string                 `json:"fileIDs,omitempty"`
	TaskIDs                         []string                 `json:"taskIDs,omitempty"`
	CreateGroupSettings             *CreateGroupSettingInput `json:"createGroupSettings,omitempty"`
}

// CreateGroupMembershipInput is used for create GroupMembership object.
// Input was generated by ent.
type CreateGroupMembershipInput struct {
	Role     *enums.Role `json:"role,omitempty"`
	GroupID  string      `json:"groupID"`
	UserID   string      `json:"userID"`
	EventIDs []string    `json:"eventIDs,omitempty"`
}

// CreateGroupSettingInput is used for create GroupSetting object.
// Input was generated by ent.
type CreateGroupSettingInput struct {
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool   `json:"syncToGithub,omitempty"`
	GroupID      *string `json:"groupID,omitempty"`
}

// CreateHushInput is used for create Hush object.
// Input was generated by ent.
type CreateHushInput struct {
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// the secret value
	SecretValue     *string  `json:"secretValue,omitempty"`
	IntegrationIDs  []string `json:"integrationIDs,omitempty"`
	OrganizationIDs []string `json:"organizationIDs,omitempty"`
	EventIDs        []string `json:"eventIDs,omitempty"`
}

// CreateIntegrationInput is used for create Integration object.
// Input was generated by ent.
type CreateIntegrationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string  `json:"description,omitempty"`
	Kind        *string  `json:"kind,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	SecretIDs   []string `json:"secretIDs,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateInternalPolicyInput is used for create InternalPolicy object.
// Input was generated by ent.
type CreateInternalPolicyInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// status of the policy, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the policy, e.g. compliance, operational, health and safety, etc.
	PolicyType *string `json:"policyType,omitempty"`
	// details of the policy
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the policy
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the policy should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the policy should be reviewed, used to calculate the review_due date
	ReviewFrequency     *enums.Frequency `json:"reviewFrequency,omitempty"`
	OwnerID             *string          `json:"ownerID,omitempty"`
	BlockedGroupIDs     []string         `json:"blockedGroupIDs,omitempty"`
	EditorIDs           []string         `json:"editorIDs,omitempty"`
	ApproverID          *string          `json:"approverID,omitempty"`
	DelegateID          *string          `json:"delegateID,omitempty"`
	ControlObjectiveIDs []string         `json:"controlObjectiveIDs,omitempty"`
	ControlIDs          []string         `json:"controlIDs,omitempty"`
	ProcedureIDs        []string         `json:"procedureIDs,omitempty"`
	NarrativeIDs        []string         `json:"narrativeIDs,omitempty"`
	TaskIDs             []string         `json:"taskIDs,omitempty"`
	ProgramIDs          []string         `json:"programIDs,omitempty"`
}

// CreateInviteInput is used for create Invite object.
// Input was generated by ent.
type CreateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts *int64 `json:"sendAttempts,omitempty"`
	// the user who initiated the invitation
	RequestorID *string  `json:"requestorID,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateMappedControlInput is used for create MappedControl object.
// Input was generated by ent.
type CreateMappedControlInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType *string `json:"mappingType,omitempty"`
	// description of how the two controls are related
	Relation      *string  `json:"relation,omitempty"`
	ControlIDs    []string `json:"controlIDs,omitempty"`
	SubcontrolIDs []string `json:"subcontrolIDs,omitempty"`
}

type CreateMemberWithProgramInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

// CreateNarrativeInput is used for create Narrative object.
// Input was generated by ent.
type CreateNarrativeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details         *string  `json:"details,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string `json:"editorIDs,omitempty"`
	ViewerIDs       []string `json:"viewerIDs,omitempty"`
	SatisfyIDs      []string `json:"satisfyIDs,omitempty"`
	ProgramIDs      []string `json:"programIDs,omitempty"`
}

// CreateNoteInput is used for create Note object.
// Input was generated by ent.
type CreateNoteInput struct {
	// the text of the note
	Text    string  `json:"text"`
	OwnerID *string `json:"ownerID,omitempty"`
	TaskID  *string `json:"taskID,omitempty"`
}

// CreateOnboardingInput is used for create Onboarding object.
// Input was generated by ent.
type CreateOnboardingInput struct {
	// name of the company
	CompanyName string `json:"companyName"`
	// domains associated with the company
	Domains []string `json:"domains,omitempty"`
	// details given about the company during the onboarding process, including things such as company size, sector, etc
	CompanyDetails map[string]any `json:"companyDetails,omitempty"`
	// details given about the user during the onboarding process, including things such as name, job title, department, etc
	UserDetails map[string]any `json:"userDetails,omitempty"`
	// details given about the compliance requirements during the onboarding process, such as coming with existing policies, controls, risk assessments, etc
	Compliance     map[string]any `json:"compliance,omitempty"`
	OrganizationID *string        `json:"organizationID,omitempty"`
}

// CreateOrgMembershipInput is used for create OrgMembership object.
// Input was generated by ent.
type CreateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	OrganizationID string      `json:"organizationID"`
	UserID         string      `json:"userID"`
	EventIDs       []string    `json:"eventIDs,omitempty"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb                *bool                           `json:"dedicatedDb,omitempty"`
	ControlCreatorIDs          []string                        `json:"controlCreatorIDs,omitempty"`
	ControlObjectiveCreatorIDs []string                        `json:"controlObjectiveCreatorIDs,omitempty"`
	GroupCreatorIDs            []string                        `json:"groupCreatorIDs,omitempty"`
	InternalPolicyCreatorIDs   []string                        `json:"internalPolicyCreatorIDs,omitempty"`
	NarrativeCreatorIDs        []string                        `json:"narrativeCreatorIDs,omitempty"`
	ProcedureCreatorIDs        []string                        `json:"procedureCreatorIDs,omitempty"`
	ProgramCreatorIDs          []string                        `json:"programCreatorIDs,omitempty"`
	RiskCreatorIDs             []string                        `json:"riskCreatorIDs,omitempty"`
	TemplateCreatorIDs         []string                        `json:"templateCreatorIDs,omitempty"`
	ParentID                   *string                         `json:"parentID,omitempty"`
	SettingID                  *string                         `json:"settingID,omitempty"`
	PersonalAccessTokenIDs     []string                        `json:"personalAccessTokenIDs,omitempty"`
	APITokenIDs                []string                        `json:"apiTokenIDs,omitempty"`
	FileIDs                    []string                        `json:"fileIDs,omitempty"`
	EventIDs                   []string                        `json:"eventIDs,omitempty"`
	SecretIDs                  []string                        `json:"secretIDs,omitempty"`
	AvatarFileID               *string                         `json:"avatarFileID,omitempty"`
	GroupIDs                   []string                        `json:"groupIDs,omitempty"`
	TemplateIDs                []string                        `json:"templateIDs,omitempty"`
	IntegrationIDs             []string                        `json:"integrationIDs,omitempty"`
	DocumentIDs                []string                        `json:"documentIDs,omitempty"`
	OrgSubscriptionIDs         []string                        `json:"orgSubscriptionIDs,omitempty"`
	InviteIDs                  []string                        `json:"inviteIDs,omitempty"`
	SubscriberIDs              []string                        `json:"subscriberIDs,omitempty"`
	EntityIDs                  []string                        `json:"entityIDs,omitempty"`
	EntityTypeIDs              []string                        `json:"entityTypeIDs,omitempty"`
	ContactIDs                 []string                        `json:"contactIDs,omitempty"`
	NoteIDs                    []string                        `json:"noteIDs,omitempty"`
	TaskIDs                    []string                        `json:"taskIDs,omitempty"`
	ProgramIDs                 []string                        `json:"programIDs,omitempty"`
	ProcedureIDs               []string                        `json:"procedureIDs,omitempty"`
	InternalPolicyIDs          []string                        `json:"internalPolicyIDs,omitempty"`
	RiskIDs                    []string                        `json:"riskIDs,omitempty"`
	ControlObjectiveIDs        []string                        `json:"controlObjectiveIDs,omitempty"`
	NarrativeIDs               []string                        `json:"narrativeIDs,omitempty"`
	ControlIDs                 []string                        `json:"controlIDs,omitempty"`
	SubcontrolIDs              []string                        `json:"subcontrolIDs,omitempty"`
	EvidenceIDs                []string                        `json:"evidenceIDs,omitempty"`
	StandardIDs                []string                        `json:"standardIDs,omitempty"`
	ActionPlanIDs              []string                        `json:"actionPlanIDs,omitempty"`
	CreateOrgSettings          *CreateOrganizationSettingInput `json:"createOrgSettings,omitempty"`
}

// CreateOrganizationSettingInput is used for create OrganizationSetting object.
// Input was generated by ent.
type CreateOrganizationSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled *bool `json:"billingNotificationsEnabled,omitempty"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string `json:"allowedEmailDomains,omitempty"`
	OrganizationID      *string  `json:"organizationID,omitempty"`
	FileIDs             []string `json:"fileIDs,omitempty"`
}

// CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
// Input was generated by ent.
type CreatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive        *bool    `json:"isActive,omitempty"`
	OrganizationIDs []string `json:"organizationIDs,omitempty"`
	EventIDs        []string `json:"eventIDs,omitempty"`
}

// CreateProcedureInput is used for create Procedure object.
// Input was generated by ent.
type CreateProcedureInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// status of the procedure, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the procedure, e.g. compliance, operational, health and safety, etc.
	ProcedureType *string `json:"procedureType,omitempty"`
	// details of the procedure
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the procedure
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the procedure should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the procedure should be reviewed, used to calculate the review_due date
	ReviewFrequency   *enums.Frequency `json:"reviewFrequency,omitempty"`
	OwnerID           *string          `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string         `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string         `json:"editorIDs,omitempty"`
	ApproverID        *string          `json:"approverID,omitempty"`
	DelegateID        *string          `json:"delegateID,omitempty"`
	ControlIDs        []string         `json:"controlIDs,omitempty"`
	InternalPolicyIDs []string         `json:"internalPolicyIDs,omitempty"`
	ProgramIDs        []string         `json:"programIDs,omitempty"`
	NarrativeIDs      []string         `json:"narrativeIDs,omitempty"`
	RiskIDs           []string         `json:"riskIDs,omitempty"`
	TaskIDs           []string         `json:"taskIDs,omitempty"`
}

// CreateProgramInput is used for create Program object.
// Input was generated by ent.
type CreateProgramInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status *enums.ProgramStatus `json:"status,omitempty"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady *bool `json:"auditorReady,omitempty"`
	// can the auditor write comments
	AuditorWriteComments *bool `json:"auditorWriteComments,omitempty"`
	// can the auditor read comments
	AuditorReadComments *bool    `json:"auditorReadComments,omitempty"`
	OwnerID             *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs     []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs           []string `json:"editorIDs,omitempty"`
	ViewerIDs           []string `json:"viewerIDs,omitempty"`
	ControlIDs          []string `json:"controlIDs,omitempty"`
	SubcontrolIDs       []string `json:"subcontrolIDs,omitempty"`
	ControlObjectiveIDs []string `json:"controlObjectiveIDs,omitempty"`
	InternalPolicyIDs   []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs        []string `json:"procedureIDs,omitempty"`
	RiskIDs             []string `json:"riskIDs,omitempty"`
	TaskIDs             []string `json:"taskIDs,omitempty"`
	NoteIDs             []string `json:"noteIDs,omitempty"`
	FileIDs             []string `json:"fileIDs,omitempty"`
	EvidenceIDs         []string `json:"evidenceIDs,omitempty"`
	NarrativeIDs        []string `json:"narrativeIDs,omitempty"`
	ActionPlanIDs       []string `json:"actionPlanIDs,omitempty"`
}

// CreateProgramMembershipInput is used for create ProgramMembership object.
// Input was generated by ent.
type CreateProgramMembershipInput struct {
	Role      *enums.Role `json:"role,omitempty"`
	ProgramID string      `json:"programID"`
	UserID    string      `json:"userID"`
}

type CreateProgramWithMembersInput struct {
	Program *CreateProgramInput             `json:"program"`
	Members []*CreateMemberWithProgramInput `json:"members,omitempty"`
}

// CreateRiskInput is used for create Risk object.
// Input was generated by ent.
type CreateRiskInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// status of the risk - open, mitigated, ongoing, in-progress, and archived.
	Status *enums.RiskStatus `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// category of the risk, e.g. human resources, operations, IT, etc.
	Category *string `json:"category,omitempty"`
	// impact of the risk -critical, high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// score of the risk based on impact and likelihood (1-4 unlikely, 5-9 likely, 10-16 highly likely, 17-20 critical)
	Score *int64 `json:"score,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// details of the risk
	Details *string `json:"details,omitempty"`
	// business costs associated with the risk
	BusinessCosts   *string  `json:"businessCosts,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string `json:"editorIDs,omitempty"`
	ViewerIDs       []string `json:"viewerIDs,omitempty"`
	ControlIDs      []string `json:"controlIDs,omitempty"`
	ProcedureIDs    []string `json:"procedureIDs,omitempty"`
	ProgramIDs      []string `json:"programIDs,omitempty"`
	ActionPlanIDs   []string `json:"actionPlanIDs,omitempty"`
	StakeholderID   *string  `json:"stakeholderID,omitempty"`
	DelegateID      *string  `json:"delegateID,omitempty"`
}

// CreateStandardInput is used for create Standard object.
// Input was generated by ent.
type CreateStandardInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// long description of the standard with details of what is covered
	Description *string `json:"description,omitempty"`
	// URL to the logo of the governing body
	GoverningBodyLogoURL *string `json:"governingBodyLogoURL,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, draft, and archived
	Status *enums.StandardStatus `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for system owned standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for system owned standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// type of the standard - cybersecurity, healthcare , financial, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version    *string  `json:"version,omitempty"`
	OwnerID    *string  `json:"ownerID,omitempty"`
	ControlIDs []string `json:"controlIDs,omitempty"`
}

// CreateSubcontrolInput is used for create Subcontrol object.
// Input was generated by ent.
type CreateSubcontrolInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode             string   `json:"refCode"`
	OwnerID             *string  `json:"ownerID,omitempty"`
	ControlID           string   `json:"controlID"`
	MappedControlIDs    []string `json:"mappedControlIDs,omitempty"`
	EvidenceIDs         []string `json:"evidenceIDs,omitempty"`
	ControlObjectiveIDs []string `json:"controlObjectiveIDs,omitempty"`
	TaskIDs             []string `json:"taskIDs,omitempty"`
	NarrativeIDs        []string `json:"narrativeIDs,omitempty"`
	RiskIDs             []string `json:"riskIDs,omitempty"`
	ActionPlanIDs       []string `json:"actionPlanIDs,omitempty"`
	ProcedureIDs        []string `json:"procedureIDs,omitempty"`
	InternalPolicyIDs   []string `json:"internalPolicyIDs,omitempty"`
	ControlOwnerID      *string  `json:"controlOwnerID,omitempty"`
	DelegateID          *string  `json:"delegateID,omitempty"`
}

// CreateSubscriberInput is used for create Subscriber object.
// Input was generated by ent.
type CreateSubscriberInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string  `json:"phoneNumber,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateTFASettingInput is used for create TFASetting object.
// Input was generated by ent.
type CreateTFASettingInput struct {
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool `json:"totpAllowed,omitempty"`
}

// CreateTaskInput is used for create Task object.
// Input was generated by ent.
type CreateTaskInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status *enums.TaskStatus `json:"status,omitempty"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed           *time.Time `json:"completed,omitempty"`
	OwnerID             *string    `json:"ownerID,omitempty"`
	AssignerID          *string    `json:"assignerID,omitempty"`
	AssigneeID          *string    `json:"assigneeID,omitempty"`
	CommentIDs          []string   `json:"commentIDs,omitempty"`
	GroupIDs            []string   `json:"groupIDs,omitempty"`
	InternalPolicyIDs   []string   `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs        []string   `json:"procedureIDs,omitempty"`
	ControlIDs          []string   `json:"controlIDs,omitempty"`
	SubcontrolIDs       []string   `json:"subcontrolIDs,omitempty"`
	ControlObjectiveIDs []string   `json:"controlObjectiveIDs,omitempty"`
	ProgramIDs          []string   `json:"programIDs,omitempty"`
	EvidenceIDs         []string   `json:"evidenceIDs,omitempty"`
}

// CreateTemplateInput is used for create Template object.
// Input was generated by ent.
type CreateTemplateInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema    map[string]any `json:"uischema,omitempty"`
	OwnerID     *string        `json:"ownerID,omitempty"`
	DocumentIDs []string       `json:"documentIDs,omitempty"`
	FileIDs     []string       `json:"fileIDs,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// user password hash
	Password *string `json:"password,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role                      *enums.Role `json:"role,omitempty"`
	PersonalAccessTokenIDs    []string    `json:"personalAccessTokenIDs,omitempty"`
	TfaSettingIDs             []string    `json:"tfaSettingIDs,omitempty"`
	SettingID                 string      `json:"settingID"`
	EmailVerificationTokenIDs []string    `json:"emailVerificationTokenIDs,omitempty"`
	PasswordResetTokenIDs     []string    `json:"passwordResetTokenIDs,omitempty"`
	GroupIDs                  []string    `json:"groupIDs,omitempty"`
	OrganizationIDs           []string    `json:"organizationIDs,omitempty"`
	WebauthnIDs               []string    `json:"webauthnIDs,omitempty"`
	FileIDs                   []string    `json:"fileIDs,omitempty"`
	AvatarFileID              *string     `json:"avatarFileID,omitempty"`
	EventIDs                  []string    `json:"eventIDs,omitempty"`
	ActionPlanIDs             []string    `json:"actionPlanIDs,omitempty"`
	SubcontrolIDs             []string    `json:"subcontrolIDs,omitempty"`
	AssignerTaskIDs           []string    `json:"assignerTaskIDs,omitempty"`
	AssigneeTaskIDs           []string    `json:"assigneeTaskIDs,omitempty"`
	ProgramIDs                []string    `json:"programIDs,omitempty"`
}

// CreateUserSettingInput is used for create UserSetting object.
// Input was generated by ent.
type CreateUserSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool    `json:"isTfaEnabled,omitempty"`
	UserID       *string  `json:"userID,omitempty"`
	DefaultOrgID *string  `json:"defaultOrgID,omitempty"`
	FileIDs      []string `json:"fileIDs,omitempty"`
}

type DocumentData struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID string `json:"templateID"`
	// the json data of the document
	Data     map[string]any    `json:"data"`
	Owner    *Organization     `json:"owner,omitempty"`
	Template *Template         `json:"template"`
	Entities *EntityConnection `json:"entities"`
	Files    *FileConnection   `json:"files"`
}

func (DocumentData) IsNode() {}

// Return response for createBulkDocumentData mutation
type DocumentDataBulkCreatePayload struct {
	// Created documentData
	DocumentData []*DocumentData `json:"documentData,omitempty"`
}

// A connection to a list of items.
type DocumentDataConnection struct {
	// A list of edges.
	Edges []*DocumentDataEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDocumentData mutation
type DocumentDataCreatePayload struct {
	// Created documentData
	DocumentData *DocumentData `json:"documentData"`
}

// Return response for deleteDocumentData mutation
type DocumentDataDeletePayload struct {
	// Deleted documentData ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DocumentDataEdge struct {
	// The item at the end of the edge.
	Node *DocumentData `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DocumentDataHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID string `json:"templateID"`
	// the json data of the document
	Data map[string]any `json:"data"`
}

func (DocumentDataHistory) IsNode() {}

// A connection to a list of items.
type DocumentDataHistoryConnection struct {
	// A list of edges.
	Edges []*DocumentDataHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DocumentDataHistoryEdge struct {
	// The item at the end of the edge.
	Node *DocumentDataHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for DocumentDataHistory connections
type DocumentDataHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DocumentDataHistories.
	Field DocumentDataHistoryOrderField `json:"field"`
}

// DocumentDataHistoryWhereInput is used for filtering DocumentDataHistory objects.
// Input was generated by ent.
type DocumentDataHistoryWhereInput struct {
	Not *DocumentDataHistoryWhereInput   `json:"not,omitempty"`
	And []*DocumentDataHistoryWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
}

// Ordering options for DocumentData connections
type DocumentDataOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order DocumentDataSlice.
	Field DocumentDataOrderField `json:"field"`
}

type DocumentDataSearchResult struct {
	DocumentData []*DocumentData `json:"documentData,omitempty"`
}

func (DocumentDataSearchResult) IsSearchResult() {}

// Return response for updateDocumentData mutation
type DocumentDataUpdatePayload struct {
	// Updated documentData
	DocumentData *DocumentData `json:"documentData"`
}

// DocumentDataWhereInput is used for filtering DocumentData objects.
// Input was generated by ent.
type DocumentDataWhereInput struct {
	Not *DocumentDataWhereInput   `json:"not,omitempty"`
	And []*DocumentDataWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Entity struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status     *string                 `json:"status,omitempty"`
	Owner      *Organization           `json:"owner,omitempty"`
	Contacts   *ContactConnection      `json:"contacts"`
	Documents  *DocumentDataConnection `json:"documents"`
	Notes      *NoteConnection         `json:"notes"`
	Files      *FileConnection         `json:"files"`
	EntityType *EntityType             `json:"entityType,omitempty"`
}

func (Entity) IsNode() {}

// Return response for createBulkEntity mutation
type EntityBulkCreatePayload struct {
	// Created entities
	Entities []*Entity `json:"entities,omitempty"`
}

// A connection to a list of items.
type EntityConnection struct {
	// A list of edges.
	Edges []*EntityEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntity mutation
type EntityCreatePayload struct {
	// Created entity
	Entity *Entity `json:"entity"`
}

// Return response for deleteEntity mutation
type EntityDeletePayload struct {
	// Deleted entity ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityEdge struct {
	// The item at the end of the edge.
	Node *Entity `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status *string `json:"status,omitempty"`
}

func (EntityHistory) IsNode() {}

// A connection to a list of items.
type EntityHistoryConnection struct {
	// A list of edges.
	Edges []*EntityHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityHistory connections
type EntityHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityHistories.
	Field EntityHistoryOrderField `json:"field"`
}

// EntityHistoryWhereInput is used for filtering EntityHistory objects.
// Input was generated by ent.
type EntityHistoryWhereInput struct {
	Not *EntityHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIdneq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIdgt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIdgte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIdlt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIdlte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
}

// Ordering options for Entity connections
type EntityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Entities.
	Field EntityOrderField `json:"field"`
}

type EntitySearchResult struct {
	Entities []*Entity `json:"entities,omitempty"`
}

func (EntitySearchResult) IsSearchResult() {}

type EntityType struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name     string            `json:"name"`
	Owner    *Organization     `json:"owner,omitempty"`
	Entities *EntityConnection `json:"entities"`
}

func (EntityType) IsNode() {}

// Return response for createBulkEntityType mutation
type EntityTypeBulkCreatePayload struct {
	// Created entityTypes
	EntityTypes []*EntityType `json:"entityTypes,omitempty"`
}

// A connection to a list of items.
type EntityTypeConnection struct {
	// A list of edges.
	Edges []*EntityTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntityType mutation
type EntityTypeCreatePayload struct {
	// Created entityType
	EntityType *EntityType `json:"entityType"`
}

// Return response for deleteEntityType mutation
type EntityTypeDeletePayload struct {
	// Deleted entityType ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityTypeEdge struct {
	// The item at the end of the edge.
	Node *EntityType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityTypeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name string `json:"name"`
}

func (EntityTypeHistory) IsNode() {}

// A connection to a list of items.
type EntityTypeHistoryConnection struct {
	// A list of edges.
	Edges []*EntityTypeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityTypeHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityTypeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityTypeHistory connections
type EntityTypeHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypeHistories.
	Field EntityTypeHistoryOrderField `json:"field"`
}

// EntityTypeHistoryWhereInput is used for filtering EntityTypeHistory objects.
// Input was generated by ent.
type EntityTypeHistoryWhereInput struct {
	Not *EntityTypeHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityTypeHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// Ordering options for EntityType connections
type EntityTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypes.
	Field EntityTypeOrderField `json:"field"`
}

type EntityTypeSearchResult struct {
	EntityTypes []*EntityType `json:"entityTypes,omitempty"`
}

func (EntityTypeSearchResult) IsSearchResult() {}

// Return response for updateEntityType mutation
type EntityTypeUpdatePayload struct {
	// Updated entityType
	EntityType *EntityType `json:"entityType"`
}

// EntityTypeWhereInput is used for filtering EntityType objects.
// Input was generated by ent.
type EntityTypeWhereInput struct {
	Not *EntityTypeWhereInput   `json:"not,omitempty"`
	And []*EntityTypeWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
}

// Return response for updateEntity mutation
type EntityUpdatePayload struct {
	// Updated entity
	Entity *Entity `json:"entity"`
}

// EntityWhereInput is used for filtering Entity objects.
// Input was generated by ent.
type EntityWhereInput struct {
	Not *EntityWhereInput   `json:"not,omitempty"`
	And []*EntityWhereInput `json:"and,omitempty"`
	Or  []*EntityWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIdneq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIdgt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIdgte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIdlt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIdlte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// entity_type edge predicates
	HasEntityType     *bool                   `json:"hasEntityType,omitempty"`
	HasEntityTypeWith []*EntityTypeWhereInput `json:"hasEntityTypeWith,omitempty"`
}

type Event struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags                 []string                       `json:"tags,omitempty"`
	EventID              *string                        `json:"eventID,omitempty"`
	CorrelationID        *string                        `json:"correlationID,omitempty"`
	EventType            string                         `json:"eventType"`
	Metadata             map[string]any                 `json:"metadata,omitempty"`
	Users                *UserConnection                `json:"users"`
	Groups               *GroupConnection               `json:"groups"`
	Integrations         *IntegrationConnection         `json:"integrations"`
	Organizations        *OrganizationConnection        `json:"organizations"`
	Invites              *InviteConnection              `json:"invites"`
	PersonalAccessTokens *PersonalAccessTokenConnection `json:"personalAccessTokens"`
	Secrets              *HushConnection                `json:"secrets"`
	Orgmemberships       *OrgMembershipConnection       `json:"orgmemberships"`
	Groupmemberships     *GroupMembershipConnection     `json:"groupmemberships"`
	Subscribers          *SubscriberConnection          `json:"subscribers"`
	Files                *FileConnection                `json:"files"`
	OrgSubscriptions     *OrgSubscriptionConnection     `json:"orgSubscriptions"`
}

func (Event) IsNode() {}

// Return response for createBulkEvent mutation
type EventBulkCreatePayload struct {
	// Created events
	Events []*Event `json:"events,omitempty"`
}

// A connection to a list of items.
type EventConnection struct {
	// A list of edges.
	Edges []*EventEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEvent mutation
type EventCreatePayload struct {
	// Created event
	Event *Event `json:"event"`
}

// Return response for deleteEvent mutation
type EventDeletePayload struct {
	// Deleted event ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EventEdge struct {
	// The item at the end of the edge.
	Node *Event `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EventHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags          []string       `json:"tags,omitempty"`
	EventID       *string        `json:"eventID,omitempty"`
	CorrelationID *string        `json:"correlationID,omitempty"`
	EventType     string         `json:"eventType"`
	Metadata      map[string]any `json:"metadata,omitempty"`
}

func (EventHistory) IsNode() {}

// A connection to a list of items.
type EventHistoryConnection struct {
	// A list of edges.
	Edges []*EventHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EventHistoryEdge struct {
	// The item at the end of the edge.
	Node *EventHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EventHistory connections
type EventHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EventHistories.
	Field EventHistoryOrderField `json:"field"`
}

// EventHistoryWhereInput is used for filtering EventHistory objects.
// Input was generated by ent.
type EventHistoryWhereInput struct {
	Not *EventHistoryWhereInput   `json:"not,omitempty"`
	And []*EventHistoryWhereInput `json:"and,omitempty"`
	Or  []*EventHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIdneq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIdgt           *string  `json:"eventIDGT,omitempty"`
	EventIdgte          *string  `json:"eventIDGTE,omitempty"`
	EventIdlt           *string  `json:"eventIDLT,omitempty"`
	EventIdlte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDIsNil        *bool    `json:"eventIDIsNil,omitempty"`
	EventIDNotNil       *bool    `json:"eventIDNotNil,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIdneq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIdgt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIdgte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIdlt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIdlte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
}

// Ordering options for Event connections
type EventOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Events.
	Field EventOrderField `json:"field"`
}

type EventSearchResult struct {
	Events []*Event `json:"events,omitempty"`
}

func (EventSearchResult) IsSearchResult() {}

// Return response for updateEvent mutation
type EventUpdatePayload struct {
	// Updated event
	Event *Event `json:"event"`
}

// EventWhereInput is used for filtering Event objects.
// Input was generated by ent.
type EventWhereInput struct {
	Not *EventWhereInput   `json:"not,omitempty"`
	And []*EventWhereInput `json:"and,omitempty"`
	Or  []*EventWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIdneq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIdgt           *string  `json:"eventIDGT,omitempty"`
	EventIdgte          *string  `json:"eventIDGTE,omitempty"`
	EventIdlt           *string  `json:"eventIDLT,omitempty"`
	EventIdlte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDIsNil        *bool    `json:"eventIDIsNil,omitempty"`
	EventIDNotNil       *bool    `json:"eventIDNotNil,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIdneq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIdgt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIdgte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIdlt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIdlte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// invites edge predicates
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// orgmemberships edge predicates
	HasOrgmemberships     *bool                      `json:"hasOrgmemberships,omitempty"`
	HasOrgmembershipsWith []*OrgMembershipWhereInput `json:"hasOrgmembershipsWith,omitempty"`
	// groupmemberships edge predicates
	HasGroupmemberships     *bool                        `json:"hasGroupmemberships,omitempty"`
	HasGroupmembershipsWith []*GroupMembershipWhereInput `json:"hasGroupmembershipsWith,omitempty"`
	// subscribers edge predicates
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// org_subscriptions edge predicates
	HasOrgSubscriptions     *bool                        `json:"hasOrgSubscriptions,omitempty"`
	HasOrgSubscriptionsWith []*OrgSubscriptionWhereInput `json:"hasOrgSubscriptionsWith,omitempty"`
}

type Evidence struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate time.Time `json:"creationDate"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL *string `json:"url,omitempty"`
	// the status of the evidence, ready, approved, needs renewal, missing artifact, rejected
	Status            *enums.EvidenceStatus       `json:"status,omitempty"`
	Owner             *Organization               `json:"owner,omitempty"`
	ControlObjectives *ControlObjectiveConnection `json:"controlObjectives"`
	Controls          *ControlConnection          `json:"controls"`
	Subcontrols       *SubcontrolConnection       `json:"subcontrols"`
	Files             *FileConnection             `json:"files"`
	Programs          *ProgramConnection          `json:"programs"`
	Tasks             *TaskConnection             `json:"tasks"`
}

func (Evidence) IsNode() {}

// Return response for createBulkEvidence mutation
type EvidenceBulkCreatePayload struct {
	// Created evidences
	Evidences []*Evidence `json:"evidences,omitempty"`
}

// A connection to a list of items.
type EvidenceConnection struct {
	// A list of edges.
	Edges []*EvidenceEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEvidence mutation
type EvidenceCreatePayload struct {
	// Created evidence
	Evidence *Evidence `json:"evidence"`
}

// Return response for deleteEvidence mutation
type EvidenceDeletePayload struct {
	// Deleted evidence ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EvidenceEdge struct {
	// The item at the end of the edge.
	Node *Evidence `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EvidenceHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate time.Time `json:"creationDate"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL *string `json:"url,omitempty"`
	// the status of the evidence, ready, approved, needs renewal, missing artifact, rejected
	Status *enums.EvidenceStatus `json:"status,omitempty"`
}

func (EvidenceHistory) IsNode() {}

// A connection to a list of items.
type EvidenceHistoryConnection struct {
	// A list of edges.
	Edges []*EvidenceHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EvidenceHistoryEdge struct {
	// The item at the end of the edge.
	Node *EvidenceHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EvidenceHistory connections
type EvidenceHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EvidenceHistories.
	Field EvidenceHistoryOrderField `json:"field"`
}

// EvidenceHistoryWhereInput is used for filtering EvidenceHistory objects.
// Input was generated by ent.
type EvidenceHistoryWhereInput struct {
	Not *EvidenceHistoryWhereInput   `json:"not,omitempty"`
	And []*EvidenceHistoryWhereInput `json:"and,omitempty"`
	Or  []*EvidenceHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// collection_procedure field predicates
	CollectionProcedure             *string  `json:"collectionProcedure,omitempty"`
	CollectionProcedureNeq          *string  `json:"collectionProcedureNEQ,omitempty"`
	CollectionProcedureIn           []string `json:"collectionProcedureIn,omitempty"`
	CollectionProcedureNotIn        []string `json:"collectionProcedureNotIn,omitempty"`
	CollectionProcedureGt           *string  `json:"collectionProcedureGT,omitempty"`
	CollectionProcedureGte          *string  `json:"collectionProcedureGTE,omitempty"`
	CollectionProcedureLt           *string  `json:"collectionProcedureLT,omitempty"`
	CollectionProcedureLte          *string  `json:"collectionProcedureLTE,omitempty"`
	CollectionProcedureContains     *string  `json:"collectionProcedureContains,omitempty"`
	CollectionProcedureHasPrefix    *string  `json:"collectionProcedureHasPrefix,omitempty"`
	CollectionProcedureHasSuffix    *string  `json:"collectionProcedureHasSuffix,omitempty"`
	CollectionProcedureIsNil        *bool    `json:"collectionProcedureIsNil,omitempty"`
	CollectionProcedureNotNil       *bool    `json:"collectionProcedureNotNil,omitempty"`
	CollectionProcedureEqualFold    *string  `json:"collectionProcedureEqualFold,omitempty"`
	CollectionProcedureContainsFold *string  `json:"collectionProcedureContainsFold,omitempty"`
	// creation_date field predicates
	CreationDate      *time.Time   `json:"creationDate,omitempty"`
	CreationDateNeq   *time.Time   `json:"creationDateNEQ,omitempty"`
	CreationDateIn    []*time.Time `json:"creationDateIn,omitempty"`
	CreationDateNotIn []*time.Time `json:"creationDateNotIn,omitempty"`
	CreationDateGt    *time.Time   `json:"creationDateGT,omitempty"`
	CreationDateGte   *time.Time   `json:"creationDateGTE,omitempty"`
	CreationDateLt    *time.Time   `json:"creationDateLT,omitempty"`
	CreationDateLte   *time.Time   `json:"creationDateLTE,omitempty"`
	// renewal_date field predicates
	RenewalDate       *time.Time   `json:"renewalDate,omitempty"`
	RenewalDateNeq    *time.Time   `json:"renewalDateNEQ,omitempty"`
	RenewalDateIn     []*time.Time `json:"renewalDateIn,omitempty"`
	RenewalDateNotIn  []*time.Time `json:"renewalDateNotIn,omitempty"`
	RenewalDateGt     *time.Time   `json:"renewalDateGT,omitempty"`
	RenewalDateGte    *time.Time   `json:"renewalDateGTE,omitempty"`
	RenewalDateLt     *time.Time   `json:"renewalDateLT,omitempty"`
	RenewalDateLte    *time.Time   `json:"renewalDateLTE,omitempty"`
	RenewalDateIsNil  *bool        `json:"renewalDateIsNil,omitempty"`
	RenewalDateNotNil *bool        `json:"renewalDateNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// is_automated field predicates
	IsAutomated       *bool `json:"isAutomated,omitempty"`
	IsAutomatedNeq    *bool `json:"isAutomatedNEQ,omitempty"`
	IsAutomatedIsNil  *bool `json:"isAutomatedIsNil,omitempty"`
	IsAutomatedNotNil *bool `json:"isAutomatedNotNil,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// status field predicates
	Status       *enums.EvidenceStatus  `json:"status,omitempty"`
	StatusNeq    *enums.EvidenceStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.EvidenceStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.EvidenceStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
}

// Ordering options for Evidence connections
type EvidenceOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Evidences.
	Field EvidenceOrderField `json:"field"`
}

type EvidenceSearchResult struct {
	Evidences []*Evidence `json:"evidences,omitempty"`
}

func (EvidenceSearchResult) IsSearchResult() {}

// Return response for updateEvidence mutation
type EvidenceUpdatePayload struct {
	// Updated evidence
	Evidence *Evidence `json:"evidence"`
}

// EvidenceWhereInput is used for filtering Evidence objects.
// Input was generated by ent.
type EvidenceWhereInput struct {
	Not *EvidenceWhereInput   `json:"not,omitempty"`
	And []*EvidenceWhereInput `json:"and,omitempty"`
	Or  []*EvidenceWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// collection_procedure field predicates
	CollectionProcedure             *string  `json:"collectionProcedure,omitempty"`
	CollectionProcedureNeq          *string  `json:"collectionProcedureNEQ,omitempty"`
	CollectionProcedureIn           []string `json:"collectionProcedureIn,omitempty"`
	CollectionProcedureNotIn        []string `json:"collectionProcedureNotIn,omitempty"`
	CollectionProcedureGt           *string  `json:"collectionProcedureGT,omitempty"`
	CollectionProcedureGte          *string  `json:"collectionProcedureGTE,omitempty"`
	CollectionProcedureLt           *string  `json:"collectionProcedureLT,omitempty"`
	CollectionProcedureLte          *string  `json:"collectionProcedureLTE,omitempty"`
	CollectionProcedureContains     *string  `json:"collectionProcedureContains,omitempty"`
	CollectionProcedureHasPrefix    *string  `json:"collectionProcedureHasPrefix,omitempty"`
	CollectionProcedureHasSuffix    *string  `json:"collectionProcedureHasSuffix,omitempty"`
	CollectionProcedureIsNil        *bool    `json:"collectionProcedureIsNil,omitempty"`
	CollectionProcedureNotNil       *bool    `json:"collectionProcedureNotNil,omitempty"`
	CollectionProcedureEqualFold    *string  `json:"collectionProcedureEqualFold,omitempty"`
	CollectionProcedureContainsFold *string  `json:"collectionProcedureContainsFold,omitempty"`
	// creation_date field predicates
	CreationDate      *time.Time   `json:"creationDate,omitempty"`
	CreationDateNeq   *time.Time   `json:"creationDateNEQ,omitempty"`
	CreationDateIn    []*time.Time `json:"creationDateIn,omitempty"`
	CreationDateNotIn []*time.Time `json:"creationDateNotIn,omitempty"`
	CreationDateGt    *time.Time   `json:"creationDateGT,omitempty"`
	CreationDateGte   *time.Time   `json:"creationDateGTE,omitempty"`
	CreationDateLt    *time.Time   `json:"creationDateLT,omitempty"`
	CreationDateLte   *time.Time   `json:"creationDateLTE,omitempty"`
	// renewal_date field predicates
	RenewalDate       *time.Time   `json:"renewalDate,omitempty"`
	RenewalDateNeq    *time.Time   `json:"renewalDateNEQ,omitempty"`
	RenewalDateIn     []*time.Time `json:"renewalDateIn,omitempty"`
	RenewalDateNotIn  []*time.Time `json:"renewalDateNotIn,omitempty"`
	RenewalDateGt     *time.Time   `json:"renewalDateGT,omitempty"`
	RenewalDateGte    *time.Time   `json:"renewalDateGTE,omitempty"`
	RenewalDateLt     *time.Time   `json:"renewalDateLT,omitempty"`
	RenewalDateLte    *time.Time   `json:"renewalDateLTE,omitempty"`
	RenewalDateIsNil  *bool        `json:"renewalDateIsNil,omitempty"`
	RenewalDateNotNil *bool        `json:"renewalDateNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// is_automated field predicates
	IsAutomated       *bool `json:"isAutomated,omitempty"`
	IsAutomatedNeq    *bool `json:"isAutomatedNEQ,omitempty"`
	IsAutomatedIsNil  *bool `json:"isAutomatedIsNil,omitempty"`
	IsAutomatedNotNil *bool `json:"isAutomatedNotNil,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// status field predicates
	Status       *enums.EvidenceStatus  `json:"status,omitempty"`
	StatusNeq    *enums.EvidenceStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.EvidenceStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.EvidenceStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

type File struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath         *string                `json:"storagePath,omitempty"`
	User                []*User                `json:"user,omitempty"`
	Organization        []*Organization        `json:"organization,omitempty"`
	Groups              *GroupConnection       `json:"groups"`
	Contact             []*Contact             `json:"contact,omitempty"`
	Entity              []*Entity              `json:"entity,omitempty"`
	UserSetting         []*UserSetting         `json:"userSetting,omitempty"`
	OrganizationSetting []*OrganizationSetting `json:"organizationSetting,omitempty"`
	Template            []*Template            `json:"template,omitempty"`
	Document            []*DocumentData        `json:"document,omitempty"`
	Program             []*Program             `json:"program,omitempty"`
	Evidence            []*Evidence            `json:"evidence,omitempty"`
	Events              *EventConnection       `json:"events"`
	PresignedURL        *string                `json:"presignedURL,omitempty"`
}

func (File) IsNode() {}

// A connection to a list of items.
type FileConnection struct {
	// A list of edges.
	Edges []*FileEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for deleteFile mutation
type FileDeletePayload struct {
	// Deleted file ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FileEdge struct {
	// The item at the end of the edge.
	Node *File `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FileHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath *string `json:"storagePath,omitempty"`
}

func (FileHistory) IsNode() {}

// A connection to a list of items.
type FileHistoryConnection struct {
	// A list of edges.
	Edges []*FileHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FileHistoryEdge struct {
	// The item at the end of the edge.
	Node *FileHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for FileHistory connections
type FileHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order FileHistories.
	Field FileHistoryOrderField `json:"field"`
}

// FileHistoryWhereInput is used for filtering FileHistory objects.
// Input was generated by ent.
type FileHistoryWhereInput struct {
	Not *FileHistoryWhereInput   `json:"not,omitempty"`
	And []*FileHistoryWhereInput `json:"and,omitempty"`
	Or  []*FileHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// provided_file_name field predicates
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNeq          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGt           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGte          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLt           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLte          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`
	// provided_file_extension field predicates
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNeq          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGt           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGte          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLt           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLte          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`
	// provided_file_size field predicates
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNeq    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGt     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGte    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLt     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLte    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  *bool   `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil *bool   `json:"providedFileSizeNotNil,omitempty"`
	// persisted_file_size field predicates
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNeq    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGt     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGte    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLt     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLte    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  *bool   `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil *bool   `json:"persistedFileSizeNotNil,omitempty"`
	// detected_mime_type field predicates
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNeq          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGt           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGte          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLt           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLte          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        *bool    `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       *bool    `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`
	// md5_hash field predicates
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNeq          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGt           *string  `json:"md5HashGT,omitempty"`
	Md5HashGte          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLt           *string  `json:"md5HashLT,omitempty"`
	Md5HashLte          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        *bool    `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       *bool    `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`
	// detected_content_type field predicates
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNeq          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGt           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGte          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLt           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLte          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        *bool    `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       *bool    `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category_type field predicates
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNeq          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGt           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGte          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLt           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLte          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        *bool    `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       *bool    `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`
	// uri field predicates
	URI             *string  `json:"uri,omitempty"`
	URINeq          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGt           *string  `json:"uriGT,omitempty"`
	URIGte          *string  `json:"uriGTE,omitempty"`
	URILt           *string  `json:"uriLT,omitempty"`
	URILte          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        *bool    `json:"uriIsNil,omitempty"`
	URINotNil       *bool    `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`
	// storage_scheme field predicates
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNeq          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGt           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGte          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLt           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLte          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        *bool    `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       *bool    `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`
	// storage_volume field predicates
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNeq          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGt           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGte          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLt           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLte          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        *bool    `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       *bool    `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`
	// storage_path field predicates
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNeq          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGt           *string  `json:"storagePathGT,omitempty"`
	StoragePathGte          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLt           *string  `json:"storagePathLT,omitempty"`
	StoragePathLte          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        *bool    `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       *bool    `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
}

// Ordering options for File connections
type FileOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Files.
	Field FileOrderField `json:"field"`
}

type FileSearchResult struct {
	Files []*File `json:"files,omitempty"`
}

func (FileSearchResult) IsSearchResult() {}

// FileWhereInput is used for filtering File objects.
// Input was generated by ent.
type FileWhereInput struct {
	Not *FileWhereInput   `json:"not,omitempty"`
	And []*FileWhereInput `json:"and,omitempty"`
	Or  []*FileWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// provided_file_name field predicates
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNeq          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGt           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGte          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLt           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLte          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`
	// provided_file_extension field predicates
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNeq          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGt           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGte          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLt           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLte          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`
	// provided_file_size field predicates
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNeq    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGt     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGte    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLt     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLte    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  *bool   `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil *bool   `json:"providedFileSizeNotNil,omitempty"`
	// persisted_file_size field predicates
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNeq    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGt     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGte    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLt     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLte    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  *bool   `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil *bool   `json:"persistedFileSizeNotNil,omitempty"`
	// detected_mime_type field predicates
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNeq          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGt           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGte          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLt           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLte          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        *bool    `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       *bool    `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`
	// md5_hash field predicates
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNeq          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGt           *string  `json:"md5HashGT,omitempty"`
	Md5HashGte          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLt           *string  `json:"md5HashLT,omitempty"`
	Md5HashLte          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        *bool    `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       *bool    `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`
	// detected_content_type field predicates
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNeq          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGt           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGte          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLt           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLte          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        *bool    `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       *bool    `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category_type field predicates
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNeq          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGt           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGte          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLt           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLte          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        *bool    `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       *bool    `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`
	// uri field predicates
	URI             *string  `json:"uri,omitempty"`
	URINeq          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGt           *string  `json:"uriGT,omitempty"`
	URIGte          *string  `json:"uriGTE,omitempty"`
	URILt           *string  `json:"uriLT,omitempty"`
	URILte          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        *bool    `json:"uriIsNil,omitempty"`
	URINotNil       *bool    `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`
	// storage_scheme field predicates
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNeq          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGt           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGte          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLt           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLte          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        *bool    `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       *bool    `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`
	// storage_volume field predicates
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNeq          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGt           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGte          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLt           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLte          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        *bool    `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       *bool    `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`
	// storage_path field predicates
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNeq          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGt           *string  `json:"storagePathGT,omitempty"`
	StoragePathGte          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLt           *string  `json:"storagePathLT,omitempty"`
	StoragePathLte          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        *bool    `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       *bool    `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// contact edge predicates
	HasContact     *bool                `json:"hasContact,omitempty"`
	HasContactWith []*ContactWhereInput `json:"hasContactWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
	// user_setting edge predicates
	HasUserSetting     *bool                    `json:"hasUserSetting,omitempty"`
	HasUserSettingWith []*UserSettingWhereInput `json:"hasUserSettingWith,omitempty"`
	// organization_setting edge predicates
	HasOrganizationSetting     *bool                            `json:"hasOrganizationSetting,omitempty"`
	HasOrganizationSettingWith []*OrganizationSettingWhereInput `json:"hasOrganizationSettingWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// document edge predicates
	HasDocument     *bool                     `json:"hasDocument,omitempty"`
	HasDocumentWith []*DocumentDataWhereInput `json:"hasDocumentWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Group struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// whether the group is managed by the system
	IsManaged *bool `json:"isManaged,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName                   string                 `json:"displayName"`
	Owner                         *Organization          `json:"owner,omitempty"`
	ProgramEditors                []*Program             `json:"programEditors,omitempty"`
	ProgramBlockedGroups          []*Program             `json:"programBlockedGroups,omitempty"`
	ProgramViewers                []*Program             `json:"programViewers,omitempty"`
	RiskEditors                   []*Risk                `json:"riskEditors,omitempty"`
	RiskBlockedGroups             []*Risk                `json:"riskBlockedGroups,omitempty"`
	RiskViewers                   []*Risk                `json:"riskViewers,omitempty"`
	ControlObjectiveEditors       []*ControlObjective    `json:"controlObjectiveEditors,omitempty"`
	ControlObjectiveBlockedGroups []*ControlObjective    `json:"controlObjectiveBlockedGroups,omitempty"`
	ControlObjectiveViewers       []*ControlObjective    `json:"controlObjectiveViewers,omitempty"`
	ControlEditors                []*Control             `json:"controlEditors,omitempty"`
	ControlBlockedGroups          []*Control             `json:"controlBlockedGroups,omitempty"`
	ControlViewers                []*Control             `json:"controlViewers,omitempty"`
	NarrativeEditors              []*Narrative           `json:"narrativeEditors,omitempty"`
	NarrativeBlockedGroups        []*Narrative           `json:"narrativeBlockedGroups,omitempty"`
	NarrativeViewers              []*Narrative           `json:"narrativeViewers,omitempty"`
	ProcedureEditors              []*Procedure           `json:"procedureEditors,omitempty"`
	ProcedureBlockedGroups        []*Procedure           `json:"procedureBlockedGroups,omitempty"`
	InternalPolicyEditors         []*InternalPolicy      `json:"internalPolicyEditors,omitempty"`
	InternalPolicyBlockedGroups   []*InternalPolicy      `json:"internalPolicyBlockedGroups,omitempty"`
	Setting                       *GroupSetting          `json:"setting,omitempty"`
	Users                         []*User                `json:"users,omitempty"`
	Events                        *EventConnection       `json:"events"`
	Integrations                  *IntegrationConnection `json:"integrations"`
	Files                         *FileConnection        `json:"files"`
	Tasks                         *TaskConnection        `json:"tasks"`
	Members                       []*GroupMembership     `json:"members,omitempty"`
	// permissions the group provides
	Permissions []*GroupPermissions `json:"permissions,omitempty"`
}

func (Group) IsNode() {}

// Return response for createBulkGroup mutation
type GroupBulkCreatePayload struct {
	// Created groups
	Groups []*Group `json:"groups,omitempty"`
}

// A connection to a list of items.
type GroupConnection struct {
	// A list of edges.
	Edges []*GroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroup mutation
type GroupCreatePayload struct {
	// Created group
	Group *Group `json:"group"`
}

// Return response for deleteGroup mutation
type GroupDeletePayload struct {
	// Deleted group ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupEdge struct {
	// The item at the end of the edge.
	Node *Group `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// whether the group is managed by the system
	IsManaged *bool `json:"isManaged,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName string `json:"displayName"`
}

func (GroupHistory) IsNode() {}

// A connection to a list of items.
type GroupHistoryConnection struct {
	// A list of edges.
	Edges []*GroupHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupHistory connections
type GroupHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupHistories.
	Field GroupHistoryOrderField `json:"field"`
}

// GroupHistoryWhereInput is used for filtering GroupHistory objects.
// Input was generated by ent.
type GroupHistoryWhereInput struct {
	Not *GroupHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// is_managed field predicates
	IsManaged       *bool `json:"isManaged,omitempty"`
	IsManagedNeq    *bool `json:"isManagedNEQ,omitempty"`
	IsManagedIsNil  *bool `json:"isManagedIsNil,omitempty"`
	IsManagedNotNil *bool `json:"isManagedNotNil,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

// GroupMembersInput is used to create members for a group
// along with the group creation
type GroupMembersInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

type GroupMembership struct {
	ID        string           `json:"id"`
	CreatedAt *time.Time       `json:"createdAt,omitempty"`
	UpdatedAt *time.Time       `json:"updatedAt,omitempty"`
	CreatedBy *string          `json:"createdBy,omitempty"`
	UpdatedBy *string          `json:"updatedBy,omitempty"`
	DeletedAt *time.Time       `json:"deletedAt,omitempty"`
	DeletedBy *string          `json:"deletedBy,omitempty"`
	Role      enums.Role       `json:"role"`
	GroupID   string           `json:"groupID"`
	UserID    string           `json:"userID"`
	Group     *Group           `json:"group"`
	User      *User            `json:"user"`
	Events    *EventConnection `json:"events"`
}

func (GroupMembership) IsNode() {}

// Return response for createBulkGroupMembership mutation
type GroupMembershipBulkCreatePayload struct {
	// Created groupMemberships
	GroupMemberships []*GroupMembership `json:"groupMemberships,omitempty"`
}

// A connection to a list of items.
type GroupMembershipConnection struct {
	// A list of edges.
	Edges []*GroupMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupMembership mutation
type GroupMembershipCreatePayload struct {
	// Created groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// Return response for deleteGroupMembership mutation
type GroupMembershipDeletePayload struct {
	// Deleted groupMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupMembershipEdge struct {
	// The item at the end of the edge.
	Node *GroupMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	GroupID     string         `json:"groupID"`
	UserID      string         `json:"userID"`
}

func (GroupMembershipHistory) IsNode() {}

// A connection to a list of items.
type GroupMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*GroupMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupMembershipHistory connections
type GroupMembershipHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupMembershipHistories.
	Field GroupMembershipHistoryOrderField `json:"field"`
}

// GroupMembershipHistoryWhereInput is used for filtering GroupMembershipHistory objects.
// Input was generated by ent.
type GroupMembershipHistoryWhereInput struct {
	Not *GroupMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Ordering options for GroupMembership connections
type GroupMembershipOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupMemberships.
	Field GroupMembershipOrderField `json:"field"`
}

// Return response for updateGroupMembership mutation
type GroupMembershipUpdatePayload struct {
	// Updated groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// GroupMembershipWhereInput is used for filtering GroupMembership objects.
// Input was generated by ent.
type GroupMembershipWhereInput struct {
	Not *GroupMembershipWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	GroupID   *string      `json:"groupID,omitempty"`
	UserID    *string      `json:"userID,omitempty"`
}

// Ordering options for Group connections
type GroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Groups.
	Field GroupOrderField `json:"field"`
}

// GroupPermissions contains details for the related object and the permissions
// the group provides (or removes in the case of blocked) to the object within the
// organization
type GroupPermissions struct {
	ObjectType  string           `json:"objectType"`
	Permissions enums.Permission `json:"permissions"`
	ID          *string          `json:"id,omitempty"`
	DisplayID   *string          `json:"displayID,omitempty"`
	Name        *string          `json:"name,omitempty"`
}

type GroupSearchResult struct {
	Groups []*Group `json:"groups,omitempty"`
}

func (GroupSearchResult) IsSearchResult() {}

type GroupSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
	Group   *Group  `json:"group,omitempty"`
}

func (GroupSetting) IsNode() {}

// Return response for createBulkGroupSetting mutation
type GroupSettingBulkCreatePayload struct {
	// Created groupSettings
	GroupSettings []*GroupSetting `json:"groupSettings,omitempty"`
}

// A connection to a list of items.
type GroupSettingConnection struct {
	// A list of edges.
	Edges []*GroupSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupSetting mutation
type GroupSettingCreatePayload struct {
	// Created groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// Return response for deleteGroupSetting mutation
type GroupSettingDeletePayload struct {
	// Deleted groupSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupSettingEdge struct {
	// The item at the end of the edge.
	Node *GroupSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
}

func (GroupSettingHistory) IsNode() {}

// A connection to a list of items.
type GroupSettingHistoryConnection struct {
	// A list of edges.
	Edges []*GroupSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupSettingHistory connections
type GroupSettingHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupSettingHistories.
	Field GroupSettingHistoryOrderField `json:"field"`
}

// GroupSettingHistoryWhereInput is used for filtering GroupSettingHistory objects.
// Input was generated by ent.
type GroupSettingHistoryWhereInput struct {
	Not *GroupSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
}

// Ordering options for GroupSetting connections
type GroupSettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupSettings.
	Field GroupSettingOrderField `json:"field"`
}

// Return response for updateGroupSetting mutation
type GroupSettingUpdatePayload struct {
	// Updated groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// GroupSettingWhereInput is used for filtering GroupSetting objects.
// Input was generated by ent.
type GroupSettingWhereInput struct {
	Not *GroupSettingWhereInput   `json:"not,omitempty"`
	And []*GroupSettingWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

// Return response for updateGroup mutation
type GroupUpdatePayload struct {
	// Updated group
	Group *Group `json:"group"`
}

// GroupWhereInput is used for filtering Group objects.
// Input was generated by ent.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// is_managed field predicates
	IsManaged       *bool `json:"isManaged,omitempty"`
	IsManagedNeq    *bool `json:"isManagedNEQ,omitempty"`
	IsManagedIsNil  *bool `json:"isManagedIsNil,omitempty"`
	IsManagedNotNil *bool `json:"isManagedNotNil,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// program_editors edge predicates
	HasProgramEditors     *bool                `json:"hasProgramEditors,omitempty"`
	HasProgramEditorsWith []*ProgramWhereInput `json:"hasProgramEditorsWith,omitempty"`
	// program_blocked_groups edge predicates
	HasProgramBlockedGroups     *bool                `json:"hasProgramBlockedGroups,omitempty"`
	HasProgramBlockedGroupsWith []*ProgramWhereInput `json:"hasProgramBlockedGroupsWith,omitempty"`
	// program_viewers edge predicates
	HasProgramViewers     *bool                `json:"hasProgramViewers,omitempty"`
	HasProgramViewersWith []*ProgramWhereInput `json:"hasProgramViewersWith,omitempty"`
	// risk_editors edge predicates
	HasRiskEditors     *bool             `json:"hasRiskEditors,omitempty"`
	HasRiskEditorsWith []*RiskWhereInput `json:"hasRiskEditorsWith,omitempty"`
	// risk_blocked_groups edge predicates
	HasRiskBlockedGroups     *bool             `json:"hasRiskBlockedGroups,omitempty"`
	HasRiskBlockedGroupsWith []*RiskWhereInput `json:"hasRiskBlockedGroupsWith,omitempty"`
	// risk_viewers edge predicates
	HasRiskViewers     *bool             `json:"hasRiskViewers,omitempty"`
	HasRiskViewersWith []*RiskWhereInput `json:"hasRiskViewersWith,omitempty"`
	// control_objective_editors edge predicates
	HasControlObjectiveEditors     *bool                         `json:"hasControlObjectiveEditors,omitempty"`
	HasControlObjectiveEditorsWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveEditorsWith,omitempty"`
	// control_objective_blocked_groups edge predicates
	HasControlObjectiveBlockedGroups     *bool                         `json:"hasControlObjectiveBlockedGroups,omitempty"`
	HasControlObjectiveBlockedGroupsWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveBlockedGroupsWith,omitempty"`
	// control_objective_viewers edge predicates
	HasControlObjectiveViewers     *bool                         `json:"hasControlObjectiveViewers,omitempty"`
	HasControlObjectiveViewersWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveViewersWith,omitempty"`
	// control_editors edge predicates
	HasControlEditors     *bool                `json:"hasControlEditors,omitempty"`
	HasControlEditorsWith []*ControlWhereInput `json:"hasControlEditorsWith,omitempty"`
	// control_blocked_groups edge predicates
	HasControlBlockedGroups     *bool                `json:"hasControlBlockedGroups,omitempty"`
	HasControlBlockedGroupsWith []*ControlWhereInput `json:"hasControlBlockedGroupsWith,omitempty"`
	// control_viewers edge predicates
	HasControlViewers     *bool                `json:"hasControlViewers,omitempty"`
	HasControlViewersWith []*ControlWhereInput `json:"hasControlViewersWith,omitempty"`
	// narrative_editors edge predicates
	HasNarrativeEditors     *bool                  `json:"hasNarrativeEditors,omitempty"`
	HasNarrativeEditorsWith []*NarrativeWhereInput `json:"hasNarrativeEditorsWith,omitempty"`
	// narrative_blocked_groups edge predicates
	HasNarrativeBlockedGroups     *bool                  `json:"hasNarrativeBlockedGroups,omitempty"`
	HasNarrativeBlockedGroupsWith []*NarrativeWhereInput `json:"hasNarrativeBlockedGroupsWith,omitempty"`
	// narrative_viewers edge predicates
	HasNarrativeViewers     *bool                  `json:"hasNarrativeViewers,omitempty"`
	HasNarrativeViewersWith []*NarrativeWhereInput `json:"hasNarrativeViewersWith,omitempty"`
	// procedure_editors edge predicates
	HasProcedureEditors     *bool                  `json:"hasProcedureEditors,omitempty"`
	HasProcedureEditorsWith []*ProcedureWhereInput `json:"hasProcedureEditorsWith,omitempty"`
	// procedure_blocked_groups edge predicates
	HasProcedureBlockedGroups     *bool                  `json:"hasProcedureBlockedGroups,omitempty"`
	HasProcedureBlockedGroupsWith []*ProcedureWhereInput `json:"hasProcedureBlockedGroupsWith,omitempty"`
	// internal_policy_editors edge predicates
	HasInternalPolicyEditors     *bool                       `json:"hasInternalPolicyEditors,omitempty"`
	HasInternalPolicyEditorsWith []*InternalPolicyWhereInput `json:"hasInternalPolicyEditorsWith,omitempty"`
	// internal_policy_blocked_groups edge predicates
	HasInternalPolicyBlockedGroups     *bool                       `json:"hasInternalPolicyBlockedGroups,omitempty"`
	HasInternalPolicyBlockedGroupsWith []*InternalPolicyWhereInput `json:"hasInternalPolicyBlockedGroupsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                     `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingWhereInput `json:"hasSettingWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                        `json:"hasMembers,omitempty"`
	HasMembersWith []*GroupMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Hush struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName   *string                `json:"secretName,omitempty"`
	Integrations *IntegrationConnection `json:"integrations"`
	Organization []*Organization        `json:"organization,omitempty"`
	Events       *EventConnection       `json:"events"`
}

func (Hush) IsNode() {}

// Return response for createBulkHush mutation
type HushBulkCreatePayload struct {
	// Created hushs
	Hushes []*Hush `json:"hushes,omitempty"`
}

// A connection to a list of items.
type HushConnection struct {
	// A list of edges.
	Edges []*HushEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createHush mutation
type HushCreatePayload struct {
	// Created hush
	Hush *Hush `json:"hush"`
}

// Return response for deleteHush mutation
type HushDeletePayload struct {
	// Deleted hush ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type HushEdge struct {
	// The item at the end of the edge.
	Node *Hush `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type HushHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
}

func (HushHistory) IsNode() {}

// A connection to a list of items.
type HushHistoryConnection struct {
	// A list of edges.
	Edges []*HushHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type HushHistoryEdge struct {
	// The item at the end of the edge.
	Node *HushHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for HushHistory connections
type HushHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order HushHistories.
	Field HushHistoryOrderField `json:"field"`
}

// HushHistoryWhereInput is used for filtering HushHistory objects.
// Input was generated by ent.
type HushHistoryWhereInput struct {
	Not *HushHistoryWhereInput   `json:"not,omitempty"`
	And []*HushHistoryWhereInput `json:"and,omitempty"`
	Or  []*HushHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
}

// Ordering options for Hush connections
type HushOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Hushes.
	Field HushOrderField `json:"field"`
}

// Return response for updateHush mutation
type HushUpdatePayload struct {
	// Updated hush
	Hush *Hush `json:"hush"`
}

// HushWhereInput is used for filtering Hush objects.
// Input was generated by ent.
type HushWhereInput struct {
	Not *HushWhereInput   `json:"not,omitempty"`
	And []*HushWhereInput `json:"and,omitempty"`
	Or  []*HushWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Integration struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string          `json:"description,omitempty"`
	Kind        *string          `json:"kind,omitempty"`
	Owner       *Organization    `json:"owner,omitempty"`
	Secrets     *HushConnection  `json:"secrets"`
	Events      *EventConnection `json:"events"`
}

func (Integration) IsNode() {}

// Return response for createBulkIntegration mutation
type IntegrationBulkCreatePayload struct {
	// Created integrations
	Integrations []*Integration `json:"integrations,omitempty"`
}

// A connection to a list of items.
type IntegrationConnection struct {
	// A list of edges.
	Edges []*IntegrationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIntegration mutation
type IntegrationCreatePayload struct {
	// Created integration
	Integration *Integration `json:"integration"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type IntegrationEdge struct {
	// The item at the end of the edge.
	Node *Integration `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type IntegrationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string `json:"description,omitempty"`
	Kind        *string `json:"kind,omitempty"`
}

func (IntegrationHistory) IsNode() {}

// A connection to a list of items.
type IntegrationHistoryConnection struct {
	// A list of edges.
	Edges []*IntegrationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type IntegrationHistoryEdge struct {
	// The item at the end of the edge.
	Node *IntegrationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for IntegrationHistory connections
type IntegrationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order IntegrationHistories.
	Field IntegrationHistoryOrderField `json:"field"`
}

// IntegrationHistoryWhereInput is used for filtering IntegrationHistory objects.
// Input was generated by ent.
type IntegrationHistoryWhereInput struct {
	Not *IntegrationHistoryWhereInput   `json:"not,omitempty"`
	And []*IntegrationHistoryWhereInput `json:"and,omitempty"`
	Or  []*IntegrationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
}

// Ordering options for Integration connections
type IntegrationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Integrations.
	Field IntegrationOrderField `json:"field"`
}

type IntegrationSearchResult struct {
	Integrations []*Integration `json:"integrations,omitempty"`
}

func (IntegrationSearchResult) IsSearchResult() {}

// Return response for updateIntegration mutation
type IntegrationUpdatePayload struct {
	// Updated integration
	Integration *Integration `json:"integration"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type InternalPolicy struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// status of the policy, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the policy, e.g. compliance, operational, health and safety, etc.
	PolicyType *string `json:"policyType,omitempty"`
	// details of the policy
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the policy
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the policy should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the policy should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	Owner           *Organization    `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// the group of users who are responsible for approving the policy
	Approver *Group `json:"approver,omitempty"`
	// temporary delegates for the policy, used for temporary approval
	Delegate          *Group                      `json:"delegate,omitempty"`
	ControlObjectives *ControlObjectiveConnection `json:"controlObjectives"`
	Controls          *ControlConnection          `json:"controls"`
	Procedures        *ProcedureConnection        `json:"procedures"`
	Narratives        *NarrativeConnection        `json:"narratives"`
	Tasks             *TaskConnection             `json:"tasks"`
	Programs          *ProgramConnection          `json:"programs"`
}

func (InternalPolicy) IsNode() {}

// Return response for createBulkInternalPolicy mutation
type InternalPolicyBulkCreatePayload struct {
	// Created internalPolicys
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
}

// A connection to a list of items.
type InternalPolicyConnection struct {
	// A list of edges.
	Edges []*InternalPolicyEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInternalPolicy mutation
type InternalPolicyCreatePayload struct {
	// Created internalPolicy
	InternalPolicy *InternalPolicy `json:"internalPolicy"`
}

// Return response for deleteInternalPolicy mutation
type InternalPolicyDeletePayload struct {
	// Deleted internalPolicy ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InternalPolicyEdge struct {
	// The item at the end of the edge.
	Node *InternalPolicy `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type InternalPolicyHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// status of the policy, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the policy, e.g. compliance, operational, health and safety, etc.
	PolicyType *string `json:"policyType,omitempty"`
	// details of the policy
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the policy
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the policy should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the policy should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
}

func (InternalPolicyHistory) IsNode() {}

// A connection to a list of items.
type InternalPolicyHistoryConnection struct {
	// A list of edges.
	Edges []*InternalPolicyHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type InternalPolicyHistoryEdge struct {
	// The item at the end of the edge.
	Node *InternalPolicyHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for InternalPolicyHistory connections
type InternalPolicyHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order InternalPolicyHistories.
	Field InternalPolicyHistoryOrderField `json:"field"`
}

// InternalPolicyHistoryWhereInput is used for filtering InternalPolicyHistory objects.
// Input was generated by ent.
type InternalPolicyHistoryWhereInput struct {
	Not *InternalPolicyHistoryWhereInput   `json:"not,omitempty"`
	And []*InternalPolicyHistoryWhereInput `json:"and,omitempty"`
	Or  []*InternalPolicyHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// policy_type field predicates
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNeq          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGt           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGte          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLt           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLte          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        *bool    `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       *bool    `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
}

// Ordering options for InternalPolicy connections
type InternalPolicyOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order InternalPolicies.
	Field InternalPolicyOrderField `json:"field"`
}

type InternalPolicySearchResult struct {
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
}

func (InternalPolicySearchResult) IsSearchResult() {}

// Return response for updateInternalPolicy mutation
type InternalPolicyUpdatePayload struct {
	// Updated internalPolicy
	InternalPolicy *InternalPolicy `json:"internalPolicy"`
}

// InternalPolicyWhereInput is used for filtering InternalPolicy objects.
// Input was generated by ent.
type InternalPolicyWhereInput struct {
	Not *InternalPolicyWhereInput   `json:"not,omitempty"`
	And []*InternalPolicyWhereInput `json:"and,omitempty"`
	Or  []*InternalPolicyWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// policy_type field predicates
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNeq          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGt           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGte          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLt           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLte          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        *bool    `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       *bool    `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// approver edge predicates
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Invite struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status enums.InviteStatus `json:"status"`
	Role   enums.Role         `json:"role"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts int64 `json:"sendAttempts"`
	// the user who initiated the invitation
	RequestorID *string          `json:"requestorID,omitempty"`
	Owner       *Organization    `json:"owner,omitempty"`
	Events      *EventConnection `json:"events"`
}

func (Invite) IsNode() {}

// Return response for createBulkInvite mutation
type InviteBulkCreatePayload struct {
	// Created invites
	Invites []*Invite `json:"invites,omitempty"`
}

// A connection to a list of items.
type InviteConnection struct {
	// A list of edges.
	Edges []*InviteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInvite mutation
type InviteCreatePayload struct {
	// Created invite
	Invite *Invite `json:"invite"`
}

// Return response for deleteInvite mutation
type InviteDeletePayload struct {
	// Deleted invite ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InviteEdge struct {
	// The item at the end of the edge.
	Node *Invite `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Invite connections
type InviteOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Invites.
	Field InviteOrderField `json:"field"`
}

// Return response for updateInvite mutation
type InviteUpdatePayload struct {
	// Updated invite
	Invite *Invite `json:"invite"`
}

// InviteWhereInput is used for filtering Invite objects.
// Input was generated by ent.
type InviteWhereInput struct {
	Not *InviteWhereInput   `json:"not,omitempty"`
	And []*InviteWhereInput `json:"and,omitempty"`
	Or  []*InviteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// expires field predicates
	Expires       *time.Time   `json:"expires,omitempty"`
	ExpiresNeq    *time.Time   `json:"expiresNEQ,omitempty"`
	ExpiresIn     []*time.Time `json:"expiresIn,omitempty"`
	ExpiresNotIn  []*time.Time `json:"expiresNotIn,omitempty"`
	ExpiresGt     *time.Time   `json:"expiresGT,omitempty"`
	ExpiresGte    *time.Time   `json:"expiresGTE,omitempty"`
	ExpiresLt     *time.Time   `json:"expiresLT,omitempty"`
	ExpiresLte    *time.Time   `json:"expiresLTE,omitempty"`
	ExpiresIsNil  *bool        `json:"expiresIsNil,omitempty"`
	ExpiresNotNil *bool        `json:"expiresNotNil,omitempty"`
	// recipient field predicates
	Recipient             *string  `json:"recipient,omitempty"`
	RecipientNeq          *string  `json:"recipientNEQ,omitempty"`
	RecipientIn           []string `json:"recipientIn,omitempty"`
	RecipientNotIn        []string `json:"recipientNotIn,omitempty"`
	RecipientGt           *string  `json:"recipientGT,omitempty"`
	RecipientGte          *string  `json:"recipientGTE,omitempty"`
	RecipientLt           *string  `json:"recipientLT,omitempty"`
	RecipientLte          *string  `json:"recipientLTE,omitempty"`
	RecipientContains     *string  `json:"recipientContains,omitempty"`
	RecipientHasPrefix    *string  `json:"recipientHasPrefix,omitempty"`
	RecipientHasSuffix    *string  `json:"recipientHasSuffix,omitempty"`
	RecipientEqualFold    *string  `json:"recipientEqualFold,omitempty"`
	RecipientContainsFold *string  `json:"recipientContainsFold,omitempty"`
	// status field predicates
	Status      *enums.InviteStatus  `json:"status,omitempty"`
	StatusNeq   *enums.InviteStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.InviteStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.InviteStatus `json:"statusNotIn,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// send_attempts field predicates
	SendAttempts      *int64  `json:"sendAttempts,omitempty"`
	SendAttemptsNeq   *int64  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int64 `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int64 `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGt    *int64  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGte   *int64  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLt    *int64  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLte   *int64  `json:"sendAttemptsLTE,omitempty"`
	// requestor_id field predicates
	RequestorID             *string  `json:"requestorID,omitempty"`
	RequestorIdneq          *string  `json:"requestorIDNEQ,omitempty"`
	RequestorIDIn           []string `json:"requestorIDIn,omitempty"`
	RequestorIDNotIn        []string `json:"requestorIDNotIn,omitempty"`
	RequestorIdgt           *string  `json:"requestorIDGT,omitempty"`
	RequestorIdgte          *string  `json:"requestorIDGTE,omitempty"`
	RequestorIdlt           *string  `json:"requestorIDLT,omitempty"`
	RequestorIdlte          *string  `json:"requestorIDLTE,omitempty"`
	RequestorIDContains     *string  `json:"requestorIDContains,omitempty"`
	RequestorIDHasPrefix    *string  `json:"requestorIDHasPrefix,omitempty"`
	RequestorIDHasSuffix    *string  `json:"requestorIDHasSuffix,omitempty"`
	RequestorIDIsNil        *bool    `json:"requestorIDIsNil,omitempty"`
	RequestorIDNotNil       *bool    `json:"requestorIDNotNil,omitempty"`
	RequestorIDEqualFold    *string  `json:"requestorIDEqualFold,omitempty"`
	RequestorIDContainsFold *string  `json:"requestorIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type MappedControl struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType *string `json:"mappingType,omitempty"`
	// description of how the two controls are related
	Relation    *string               `json:"relation,omitempty"`
	Controls    *ControlConnection    `json:"controls"`
	Subcontrols *SubcontrolConnection `json:"subcontrols"`
}

func (MappedControl) IsNode() {}

// Return response for createBulkMappedControl mutation
type MappedControlBulkCreatePayload struct {
	// Created mappedControls
	MappedControls []*MappedControl `json:"mappedControls,omitempty"`
}

// A connection to a list of items.
type MappedControlConnection struct {
	// A list of edges.
	Edges []*MappedControlEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createMappedControl mutation
type MappedControlCreatePayload struct {
	// Created mappedControl
	MappedControl *MappedControl `json:"mappedControl"`
}

// Return response for deleteMappedControl mutation
type MappedControlDeletePayload struct {
	// Deleted mappedControl ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type MappedControlEdge struct {
	// The item at the end of the edge.
	Node *MappedControl `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type MappedControlHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType *string `json:"mappingType,omitempty"`
	// description of how the two controls are related
	Relation *string `json:"relation,omitempty"`
}

func (MappedControlHistory) IsNode() {}

// A connection to a list of items.
type MappedControlHistoryConnection struct {
	// A list of edges.
	Edges []*MappedControlHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type MappedControlHistoryEdge struct {
	// The item at the end of the edge.
	Node *MappedControlHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for MappedControlHistory connections
type MappedControlHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order MappedControlHistories.
	Field MappedControlHistoryOrderField `json:"field"`
}

// MappedControlHistoryWhereInput is used for filtering MappedControlHistory objects.
// Input was generated by ent.
type MappedControlHistoryWhereInput struct {
	Not *MappedControlHistoryWhereInput   `json:"not,omitempty"`
	And []*MappedControlHistoryWhereInput `json:"and,omitempty"`
	Or  []*MappedControlHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// mapping_type field predicates
	MappingType             *string  `json:"mappingType,omitempty"`
	MappingTypeNeq          *string  `json:"mappingTypeNEQ,omitempty"`
	MappingTypeIn           []string `json:"mappingTypeIn,omitempty"`
	MappingTypeNotIn        []string `json:"mappingTypeNotIn,omitempty"`
	MappingTypeGt           *string  `json:"mappingTypeGT,omitempty"`
	MappingTypeGte          *string  `json:"mappingTypeGTE,omitempty"`
	MappingTypeLt           *string  `json:"mappingTypeLT,omitempty"`
	MappingTypeLte          *string  `json:"mappingTypeLTE,omitempty"`
	MappingTypeContains     *string  `json:"mappingTypeContains,omitempty"`
	MappingTypeHasPrefix    *string  `json:"mappingTypeHasPrefix,omitempty"`
	MappingTypeHasSuffix    *string  `json:"mappingTypeHasSuffix,omitempty"`
	MappingTypeIsNil        *bool    `json:"mappingTypeIsNil,omitempty"`
	MappingTypeNotNil       *bool    `json:"mappingTypeNotNil,omitempty"`
	MappingTypeEqualFold    *string  `json:"mappingTypeEqualFold,omitempty"`
	MappingTypeContainsFold *string  `json:"mappingTypeContainsFold,omitempty"`
	// relation field predicates
	Relation             *string  `json:"relation,omitempty"`
	RelationNeq          *string  `json:"relationNEQ,omitempty"`
	RelationIn           []string `json:"relationIn,omitempty"`
	RelationNotIn        []string `json:"relationNotIn,omitempty"`
	RelationGt           *string  `json:"relationGT,omitempty"`
	RelationGte          *string  `json:"relationGTE,omitempty"`
	RelationLt           *string  `json:"relationLT,omitempty"`
	RelationLte          *string  `json:"relationLTE,omitempty"`
	RelationContains     *string  `json:"relationContains,omitempty"`
	RelationHasPrefix    *string  `json:"relationHasPrefix,omitempty"`
	RelationHasSuffix    *string  `json:"relationHasSuffix,omitempty"`
	RelationIsNil        *bool    `json:"relationIsNil,omitempty"`
	RelationNotNil       *bool    `json:"relationNotNil,omitempty"`
	RelationEqualFold    *string  `json:"relationEqualFold,omitempty"`
	RelationContainsFold *string  `json:"relationContainsFold,omitempty"`
}

// Ordering options for MappedControl connections
type MappedControlOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order MappedControls.
	Field MappedControlOrderField `json:"field"`
}

type MappedControlSearchResult struct {
	MappedControls []*MappedControl `json:"mappedControls,omitempty"`
}

func (MappedControlSearchResult) IsSearchResult() {}

// Return response for updateMappedControl mutation
type MappedControlUpdatePayload struct {
	// Updated mappedControl
	MappedControl *MappedControl `json:"mappedControl"`
}

// MappedControlWhereInput is used for filtering MappedControl objects.
// Input was generated by ent.
type MappedControlWhereInput struct {
	Not *MappedControlWhereInput   `json:"not,omitempty"`
	And []*MappedControlWhereInput `json:"and,omitempty"`
	Or  []*MappedControlWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// mapping_type field predicates
	MappingType             *string  `json:"mappingType,omitempty"`
	MappingTypeNeq          *string  `json:"mappingTypeNEQ,omitempty"`
	MappingTypeIn           []string `json:"mappingTypeIn,omitempty"`
	MappingTypeNotIn        []string `json:"mappingTypeNotIn,omitempty"`
	MappingTypeGt           *string  `json:"mappingTypeGT,omitempty"`
	MappingTypeGte          *string  `json:"mappingTypeGTE,omitempty"`
	MappingTypeLt           *string  `json:"mappingTypeLT,omitempty"`
	MappingTypeLte          *string  `json:"mappingTypeLTE,omitempty"`
	MappingTypeContains     *string  `json:"mappingTypeContains,omitempty"`
	MappingTypeHasPrefix    *string  `json:"mappingTypeHasPrefix,omitempty"`
	MappingTypeHasSuffix    *string  `json:"mappingTypeHasSuffix,omitempty"`
	MappingTypeIsNil        *bool    `json:"mappingTypeIsNil,omitempty"`
	MappingTypeNotNil       *bool    `json:"mappingTypeNotNil,omitempty"`
	MappingTypeEqualFold    *string  `json:"mappingTypeEqualFold,omitempty"`
	MappingTypeContainsFold *string  `json:"mappingTypeContainsFold,omitempty"`
	// relation field predicates
	Relation             *string  `json:"relation,omitempty"`
	RelationNeq          *string  `json:"relationNEQ,omitempty"`
	RelationIn           []string `json:"relationIn,omitempty"`
	RelationNotIn        []string `json:"relationNotIn,omitempty"`
	RelationGt           *string  `json:"relationGT,omitempty"`
	RelationGte          *string  `json:"relationGTE,omitempty"`
	RelationLt           *string  `json:"relationLT,omitempty"`
	RelationLte          *string  `json:"relationLTE,omitempty"`
	RelationContains     *string  `json:"relationContains,omitempty"`
	RelationHasPrefix    *string  `json:"relationHasPrefix,omitempty"`
	RelationHasSuffix    *string  `json:"relationHasSuffix,omitempty"`
	RelationIsNil        *bool    `json:"relationIsNil,omitempty"`
	RelationNotNil       *bool    `json:"relationNotNil,omitempty"`
	RelationEqualFold    *string  `json:"relationEqualFold,omitempty"`
	RelationContainsFold *string  `json:"relationContainsFold,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
}

type Mutation struct {
}

type Narrative struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details *string       `json:"details,omitempty"`
	Owner   *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers   []*Group           `json:"viewers,omitempty"`
	Satisfies *ControlConnection `json:"satisfies"`
	Programs  *ProgramConnection `json:"programs"`
}

func (Narrative) IsNode() {}

// Return response for createBulkNarrative mutation
type NarrativeBulkCreatePayload struct {
	// Created narratives
	Narratives []*Narrative `json:"narratives,omitempty"`
}

// A connection to a list of items.
type NarrativeConnection struct {
	// A list of edges.
	Edges []*NarrativeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createNarrative mutation
type NarrativeCreatePayload struct {
	// Created narrative
	Narrative *Narrative `json:"narrative"`
}

// Return response for deleteNarrative mutation
type NarrativeDeletePayload struct {
	// Deleted narrative ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type NarrativeEdge struct {
	// The item at the end of the edge.
	Node *Narrative `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NarrativeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details *string `json:"details,omitempty"`
}

func (NarrativeHistory) IsNode() {}

// A connection to a list of items.
type NarrativeHistoryConnection struct {
	// A list of edges.
	Edges []*NarrativeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NarrativeHistoryEdge struct {
	// The item at the end of the edge.
	Node *NarrativeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for NarrativeHistory connections
type NarrativeHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order NarrativeHistories.
	Field NarrativeHistoryOrderField `json:"field"`
}

// NarrativeHistoryWhereInput is used for filtering NarrativeHistory objects.
// Input was generated by ent.
type NarrativeHistoryWhereInput struct {
	Not *NarrativeHistoryWhereInput   `json:"not,omitempty"`
	And []*NarrativeHistoryWhereInput `json:"and,omitempty"`
	Or  []*NarrativeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
}

// Ordering options for Narrative connections
type NarrativeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Narratives.
	Field NarrativeOrderField `json:"field"`
}

type NarrativeSearchResult struct {
	Narratives []*Narrative `json:"narratives,omitempty"`
}

func (NarrativeSearchResult) IsSearchResult() {}

// Return response for updateNarrative mutation
type NarrativeUpdatePayload struct {
	// Updated narrative
	Narrative *Narrative `json:"narrative"`
}

// NarrativeWhereInput is used for filtering Narrative objects.
// Input was generated by ent.
type NarrativeWhereInput struct {
	Not *NarrativeWhereInput   `json:"not,omitempty"`
	And []*NarrativeWhereInput `json:"and,omitempty"`
	Or  []*NarrativeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// satisfies edge predicates
	HasSatisfies     *bool                `json:"hasSatisfies,omitempty"`
	HasSatisfiesWith []*ControlWhereInput `json:"hasSatisfiesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Note struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text  string        `json:"text"`
	Owner *Organization `json:"owner,omitempty"`
	Task  *Task         `json:"task,omitempty"`
}

func (Note) IsNode() {}

// A connection to a list of items.
type NoteConnection struct {
	// A list of edges.
	Edges []*NoteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteEdge struct {
	// The item at the end of the edge.
	Node *Note `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NoteHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text string `json:"text"`
}

func (NoteHistory) IsNode() {}

// A connection to a list of items.
type NoteHistoryConnection struct {
	// A list of edges.
	Edges []*NoteHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteHistoryEdge struct {
	// The item at the end of the edge.
	Node *NoteHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for NoteHistory connections
type NoteHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order NoteHistories.
	Field NoteHistoryOrderField `json:"field"`
}

// NoteHistoryWhereInput is used for filtering NoteHistory objects.
// Input was generated by ent.
type NoteHistoryWhereInput struct {
	Not *NoteHistoryWhereInput   `json:"not,omitempty"`
	And []*NoteHistoryWhereInput `json:"and,omitempty"`
	Or  []*NoteHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
}

// Ordering options for Note connections
type NoteOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Notes.
	Field NoteOrderField `json:"field"`
}

// NoteWhereInput is used for filtering Note objects.
// Input was generated by ent.
type NoteWhereInput struct {
	Not *NoteWhereInput   `json:"not,omitempty"`
	And []*NoteWhereInput `json:"and,omitempty"`
	Or  []*NoteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// task edge predicates
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`
}

type Onboarding struct {
	ID             string     `json:"id"`
	DeletedAt      *time.Time `json:"deletedAt,omitempty"`
	DeletedBy      *string    `json:"deletedBy,omitempty"`
	OrganizationID *string    `json:"organizationID,omitempty"`
	// name of the company
	CompanyName string `json:"companyName"`
	// domains associated with the company
	Domains []string `json:"domains,omitempty"`
	// details given about the company during the onboarding process, including things such as company size, sector, etc
	CompanyDetails map[string]any `json:"companyDetails,omitempty"`
	// details given about the user during the onboarding process, including things such as name, job title, department, etc
	UserDetails map[string]any `json:"userDetails,omitempty"`
	// details given about the compliance requirements during the onboarding process, such as coming with existing policies, controls, risk assessments, etc
	Compliance   map[string]any `json:"compliance,omitempty"`
	Organization *Organization  `json:"organization,omitempty"`
}

func (Onboarding) IsNode() {}

// Return response for createOnboarding mutation
type OnboardingCreatePayload struct {
	// Created onboarding
	Onboarding *Onboarding `json:"onboarding"`
}

// OnboardingWhereInput is used for filtering Onboarding objects.
// Input was generated by ent.
type OnboardingWhereInput struct {
	Not *OnboardingWhereInput   `json:"not,omitempty"`
	And []*OnboardingWhereInput `json:"and,omitempty"`
	Or  []*OnboardingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// company_name field predicates
	CompanyName             *string  `json:"companyName,omitempty"`
	CompanyNameNeq          *string  `json:"companyNameNEQ,omitempty"`
	CompanyNameIn           []string `json:"companyNameIn,omitempty"`
	CompanyNameNotIn        []string `json:"companyNameNotIn,omitempty"`
	CompanyNameGt           *string  `json:"companyNameGT,omitempty"`
	CompanyNameGte          *string  `json:"companyNameGTE,omitempty"`
	CompanyNameLt           *string  `json:"companyNameLT,omitempty"`
	CompanyNameLte          *string  `json:"companyNameLTE,omitempty"`
	CompanyNameContains     *string  `json:"companyNameContains,omitempty"`
	CompanyNameHasPrefix    *string  `json:"companyNameHasPrefix,omitempty"`
	CompanyNameHasSuffix    *string  `json:"companyNameHasSuffix,omitempty"`
	CompanyNameEqualFold    *string  `json:"companyNameEqualFold,omitempty"`
	CompanyNameContainsFold *string  `json:"companyNameContainsFold,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
}

// OrgMembersInput is used to create members for a organization
// along with the org creation
type OrgMembersInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

type OrgMembership struct {
	ID             string           `json:"id"`
	CreatedAt      *time.Time       `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time       `json:"updatedAt,omitempty"`
	CreatedBy      *string          `json:"createdBy,omitempty"`
	UpdatedBy      *string          `json:"updatedBy,omitempty"`
	DeletedAt      *time.Time       `json:"deletedAt,omitempty"`
	DeletedBy      *string          `json:"deletedBy,omitempty"`
	Role           enums.Role       `json:"role"`
	OrganizationID string           `json:"organizationID"`
	UserID         string           `json:"userID"`
	Organization   *Organization    `json:"organization"`
	User           *User            `json:"user"`
	Events         *EventConnection `json:"events"`
}

func (OrgMembership) IsNode() {}

// Return response for createBulkOrgMembership mutation
type OrgMembershipBulkCreatePayload struct {
	// Created orgMemberships
	OrgMemberships []*OrgMembership `json:"orgMemberships,omitempty"`
}

// A connection to a list of items.
type OrgMembershipConnection struct {
	// A list of edges.
	Edges []*OrgMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrgMembership mutation
type OrgMembershipCreatePayload struct {
	// Created orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// Return response for deleteOrgMembership mutation
type OrgMembershipDeletePayload struct {
	// Deleted orgMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrgMembershipEdge struct {
	// The item at the end of the edge.
	Node *OrgMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrgMembershipHistory struct {
	ID             string         `json:"id"`
	HistoryTime    time.Time      `json:"historyTime"`
	Ref            *string        `json:"ref,omitempty"`
	Operation      history.OpType `json:"operation"`
	CreatedAt      *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy      *string        `json:"createdBy,omitempty"`
	UpdatedBy      *string        `json:"updatedBy,omitempty"`
	DeletedAt      *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy      *string        `json:"deletedBy,omitempty"`
	Role           enums.Role     `json:"role"`
	OrganizationID string         `json:"organizationID"`
	UserID         string         `json:"userID"`
}

func (OrgMembershipHistory) IsNode() {}

// A connection to a list of items.
type OrgMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*OrgMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrgMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrgMembershipHistory connections
type OrgMembershipHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrgMembershipHistories.
	Field OrgMembershipHistoryOrderField `json:"field"`
}

// OrgMembershipHistoryWhereInput is used for filtering OrgMembershipHistory objects.
// Input was generated by ent.
type OrgMembershipHistoryWhereInput struct {
	Not *OrgMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Ordering options for OrgMembership connections
type OrgMembershipOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrgMemberships.
	Field OrgMembershipOrderField `json:"field"`
}

// Return response for updateOrgMembership mutation
type OrgMembershipUpdatePayload struct {
	// Updated orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// OrgMembershipWhereInput is used for filtering OrgMembership objects.
// Input was generated by ent.
type OrgMembershipWhereInput struct {
	Not *OrgMembershipWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role           *enums.Role  `json:"role,omitempty"`
	RoleNeq        *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn         []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn      []enums.Role `json:"roleNotIn,omitempty"`
	OrganizationID *string      `json:"organizationID,omitempty"`
	UserID         *string      `json:"userID,omitempty"`
}

type OrgSubscription struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the stripe subscription id
	StripeSubscriptionID *string `json:"stripeSubscriptionID,omitempty"`
	// the common name of the product tier the subscription is associated with, e.g. starter tier
	ProductTier *string `json:"productTier,omitempty"`
	// the price of the product tier
	ProductPrice *models.Price `json:"productPrice,omitempty"`
	// the product id that represents the tier in stripe
	StripeProductTierID *string `json:"stripeProductTierID,omitempty"`
	// the status of the subscription in stripe -- see https://docs.stripe.com/api/subscriptions/object#subscription_object-status
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty"`
	// indicates if the subscription is active
	Active bool `json:"active"`
	// the customer ID the subscription is associated to
	StripeCustomerID *string `json:"stripeCustomerID,omitempty"`
	// the time the subscription is set to expire; only populated if subscription is cancelled
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// the time the trial is set to expire
	TrialExpiresAt *time.Time `json:"trialExpiresAt,omitempty"`
	// number of days until there is a due payment
	DaysUntilDue *string `json:"daysUntilDue,omitempty"`
	// whether or not a payment method has been added to the account
	PaymentMethodAdded *bool `json:"paymentMethodAdded,omitempty"`
	// the features associated with the subscription
	Features []string `json:"features,omitempty"`
	// the feature lookup keys associated with the subscription
	FeatureLookupKeys    []string         `json:"featureLookupKeys,omitempty"`
	Owner                *Organization    `json:"owner,omitempty"`
	Events               *EventConnection `json:"events"`
	SubscriptionURL      *string          `json:"subscriptionURL,omitempty"`
	ManagePaymentMethods *string          `json:"managePaymentMethods,omitempty"`
	Cancellation         *string          `json:"cancellation,omitempty"`
}

func (OrgSubscription) IsNode() {}

// A connection to a list of items.
type OrgSubscriptionConnection struct {
	// A list of edges.
	Edges []*OrgSubscriptionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgSubscriptionEdge struct {
	// The item at the end of the edge.
	Node *OrgSubscription `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrgSubscriptionHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the stripe subscription id
	StripeSubscriptionID *string `json:"stripeSubscriptionID,omitempty"`
	// the common name of the product tier the subscription is associated with, e.g. starter tier
	ProductTier *string `json:"productTier,omitempty"`
	// the price of the product tier
	ProductPrice *models.Price `json:"productPrice,omitempty"`
	// the product id that represents the tier in stripe
	StripeProductTierID *string `json:"stripeProductTierID,omitempty"`
	// the status of the subscription in stripe -- see https://docs.stripe.com/api/subscriptions/object#subscription_object-status
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty"`
	// indicates if the subscription is active
	Active bool `json:"active"`
	// the customer ID the subscription is associated to
	StripeCustomerID *string `json:"stripeCustomerID,omitempty"`
	// the time the subscription is set to expire; only populated if subscription is cancelled
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// the time the trial is set to expire
	TrialExpiresAt *time.Time `json:"trialExpiresAt,omitempty"`
	// number of days until there is a due payment
	DaysUntilDue *string `json:"daysUntilDue,omitempty"`
	// whether or not a payment method has been added to the account
	PaymentMethodAdded *bool `json:"paymentMethodAdded,omitempty"`
	// the features associated with the subscription
	Features []string `json:"features,omitempty"`
	// the feature lookup keys associated with the subscription
	FeatureLookupKeys []string `json:"featureLookupKeys,omitempty"`
}

func (OrgSubscriptionHistory) IsNode() {}

// A connection to a list of items.
type OrgSubscriptionHistoryConnection struct {
	// A list of edges.
	Edges []*OrgSubscriptionHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgSubscriptionHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrgSubscriptionHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrgSubscriptionHistory connections
type OrgSubscriptionHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrgSubscriptionHistories.
	Field OrgSubscriptionHistoryOrderField `json:"field"`
}

// OrgSubscriptionHistoryWhereInput is used for filtering OrgSubscriptionHistory objects.
// Input was generated by ent.
type OrgSubscriptionHistoryWhereInput struct {
	Not *OrgSubscriptionHistoryWhereInput   `json:"not,omitempty"`
	And []*OrgSubscriptionHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrgSubscriptionHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// stripe_subscription_id field predicates
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIdneq          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIdgt           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIdgte          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIdlt           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIdlte          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        *bool    `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       *bool    `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`
	// product_tier field predicates
	ProductTier             *string  `json:"productTier,omitempty"`
	ProductTierNeq          *string  `json:"productTierNEQ,omitempty"`
	ProductTierIn           []string `json:"productTierIn,omitempty"`
	ProductTierNotIn        []string `json:"productTierNotIn,omitempty"`
	ProductTierGt           *string  `json:"productTierGT,omitempty"`
	ProductTierGte          *string  `json:"productTierGTE,omitempty"`
	ProductTierLt           *string  `json:"productTierLT,omitempty"`
	ProductTierLte          *string  `json:"productTierLTE,omitempty"`
	ProductTierContains     *string  `json:"productTierContains,omitempty"`
	ProductTierHasPrefix    *string  `json:"productTierHasPrefix,omitempty"`
	ProductTierHasSuffix    *string  `json:"productTierHasSuffix,omitempty"`
	ProductTierIsNil        *bool    `json:"productTierIsNil,omitempty"`
	ProductTierNotNil       *bool    `json:"productTierNotNil,omitempty"`
	ProductTierEqualFold    *string  `json:"productTierEqualFold,omitempty"`
	ProductTierContainsFold *string  `json:"productTierContainsFold,omitempty"`
	// stripe_product_tier_id field predicates
	StripeProductTierID             *string  `json:"stripeProductTierID,omitempty"`
	StripeProductTierIdneq          *string  `json:"stripeProductTierIDNEQ,omitempty"`
	StripeProductTierIDIn           []string `json:"stripeProductTierIDIn,omitempty"`
	StripeProductTierIDNotIn        []string `json:"stripeProductTierIDNotIn,omitempty"`
	StripeProductTierIdgt           *string  `json:"stripeProductTierIDGT,omitempty"`
	StripeProductTierIdgte          *string  `json:"stripeProductTierIDGTE,omitempty"`
	StripeProductTierIdlt           *string  `json:"stripeProductTierIDLT,omitempty"`
	StripeProductTierIdlte          *string  `json:"stripeProductTierIDLTE,omitempty"`
	StripeProductTierIDContains     *string  `json:"stripeProductTierIDContains,omitempty"`
	StripeProductTierIDHasPrefix    *string  `json:"stripeProductTierIDHasPrefix,omitempty"`
	StripeProductTierIDHasSuffix    *string  `json:"stripeProductTierIDHasSuffix,omitempty"`
	StripeProductTierIDIsNil        *bool    `json:"stripeProductTierIDIsNil,omitempty"`
	StripeProductTierIDNotNil       *bool    `json:"stripeProductTierIDNotNil,omitempty"`
	StripeProductTierIDEqualFold    *string  `json:"stripeProductTierIDEqualFold,omitempty"`
	StripeProductTierIDContainsFold *string  `json:"stripeProductTierIDContainsFold,omitempty"`
	// stripe_subscription_status field predicates
	StripeSubscriptionStatus             *string  `json:"stripeSubscriptionStatus,omitempty"`
	StripeSubscriptionStatusNeq          *string  `json:"stripeSubscriptionStatusNEQ,omitempty"`
	StripeSubscriptionStatusIn           []string `json:"stripeSubscriptionStatusIn,omitempty"`
	StripeSubscriptionStatusNotIn        []string `json:"stripeSubscriptionStatusNotIn,omitempty"`
	StripeSubscriptionStatusGt           *string  `json:"stripeSubscriptionStatusGT,omitempty"`
	StripeSubscriptionStatusGte          *string  `json:"stripeSubscriptionStatusGTE,omitempty"`
	StripeSubscriptionStatusLt           *string  `json:"stripeSubscriptionStatusLT,omitempty"`
	StripeSubscriptionStatusLte          *string  `json:"stripeSubscriptionStatusLTE,omitempty"`
	StripeSubscriptionStatusContains     *string  `json:"stripeSubscriptionStatusContains,omitempty"`
	StripeSubscriptionStatusHasPrefix    *string  `json:"stripeSubscriptionStatusHasPrefix,omitempty"`
	StripeSubscriptionStatusHasSuffix    *string  `json:"stripeSubscriptionStatusHasSuffix,omitempty"`
	StripeSubscriptionStatusIsNil        *bool    `json:"stripeSubscriptionStatusIsNil,omitempty"`
	StripeSubscriptionStatusNotNil       *bool    `json:"stripeSubscriptionStatusNotNil,omitempty"`
	StripeSubscriptionStatusEqualFold    *string  `json:"stripeSubscriptionStatusEqualFold,omitempty"`
	StripeSubscriptionStatusContainsFold *string  `json:"stripeSubscriptionStatusContainsFold,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// stripe_customer_id field predicates
	StripeCustomerID             *string  `json:"stripeCustomerID,omitempty"`
	StripeCustomerIdneq          *string  `json:"stripeCustomerIDNEQ,omitempty"`
	StripeCustomerIDIn           []string `json:"stripeCustomerIDIn,omitempty"`
	StripeCustomerIDNotIn        []string `json:"stripeCustomerIDNotIn,omitempty"`
	StripeCustomerIdgt           *string  `json:"stripeCustomerIDGT,omitempty"`
	StripeCustomerIdgte          *string  `json:"stripeCustomerIDGTE,omitempty"`
	StripeCustomerIdlt           *string  `json:"stripeCustomerIDLT,omitempty"`
	StripeCustomerIdlte          *string  `json:"stripeCustomerIDLTE,omitempty"`
	StripeCustomerIDContains     *string  `json:"stripeCustomerIDContains,omitempty"`
	StripeCustomerIDHasPrefix    *string  `json:"stripeCustomerIDHasPrefix,omitempty"`
	StripeCustomerIDHasSuffix    *string  `json:"stripeCustomerIDHasSuffix,omitempty"`
	StripeCustomerIDIsNil        *bool    `json:"stripeCustomerIDIsNil,omitempty"`
	StripeCustomerIDNotNil       *bool    `json:"stripeCustomerIDNotNil,omitempty"`
	StripeCustomerIDEqualFold    *string  `json:"stripeCustomerIDEqualFold,omitempty"`
	StripeCustomerIDContainsFold *string  `json:"stripeCustomerIDContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// trial_expires_at field predicates
	TrialExpiresAt       *time.Time   `json:"trialExpiresAt,omitempty"`
	TrialExpiresAtNeq    *time.Time   `json:"trialExpiresAtNEQ,omitempty"`
	TrialExpiresAtIn     []*time.Time `json:"trialExpiresAtIn,omitempty"`
	TrialExpiresAtNotIn  []*time.Time `json:"trialExpiresAtNotIn,omitempty"`
	TrialExpiresAtGt     *time.Time   `json:"trialExpiresAtGT,omitempty"`
	TrialExpiresAtGte    *time.Time   `json:"trialExpiresAtGTE,omitempty"`
	TrialExpiresAtLt     *time.Time   `json:"trialExpiresAtLT,omitempty"`
	TrialExpiresAtLte    *time.Time   `json:"trialExpiresAtLTE,omitempty"`
	TrialExpiresAtIsNil  *bool        `json:"trialExpiresAtIsNil,omitempty"`
	TrialExpiresAtNotNil *bool        `json:"trialExpiresAtNotNil,omitempty"`
	// days_until_due field predicates
	DaysUntilDue             *string  `json:"daysUntilDue,omitempty"`
	DaysUntilDueNeq          *string  `json:"daysUntilDueNEQ,omitempty"`
	DaysUntilDueIn           []string `json:"daysUntilDueIn,omitempty"`
	DaysUntilDueNotIn        []string `json:"daysUntilDueNotIn,omitempty"`
	DaysUntilDueGt           *string  `json:"daysUntilDueGT,omitempty"`
	DaysUntilDueGte          *string  `json:"daysUntilDueGTE,omitempty"`
	DaysUntilDueLt           *string  `json:"daysUntilDueLT,omitempty"`
	DaysUntilDueLte          *string  `json:"daysUntilDueLTE,omitempty"`
	DaysUntilDueContains     *string  `json:"daysUntilDueContains,omitempty"`
	DaysUntilDueHasPrefix    *string  `json:"daysUntilDueHasPrefix,omitempty"`
	DaysUntilDueHasSuffix    *string  `json:"daysUntilDueHasSuffix,omitempty"`
	DaysUntilDueIsNil        *bool    `json:"daysUntilDueIsNil,omitempty"`
	DaysUntilDueNotNil       *bool    `json:"daysUntilDueNotNil,omitempty"`
	DaysUntilDueEqualFold    *string  `json:"daysUntilDueEqualFold,omitempty"`
	DaysUntilDueContainsFold *string  `json:"daysUntilDueContainsFold,omitempty"`
	// payment_method_added field predicates
	PaymentMethodAdded       *bool `json:"paymentMethodAdded,omitempty"`
	PaymentMethodAddedNeq    *bool `json:"paymentMethodAddedNEQ,omitempty"`
	PaymentMethodAddedIsNil  *bool `json:"paymentMethodAddedIsNil,omitempty"`
	PaymentMethodAddedNotNil *bool `json:"paymentMethodAddedNotNil,omitempty"`
}

// Ordering options for OrgSubscription connections
type OrgSubscriptionOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrgSubscriptions.
	Field OrgSubscriptionOrderField `json:"field"`
}

type OrgSubscriptionSearchResult struct {
	OrgSubscriptions []*OrgSubscription `json:"orgSubscriptions,omitempty"`
}

func (OrgSubscriptionSearchResult) IsSearchResult() {}

// OrgSubscriptionWhereInput is used for filtering OrgSubscription objects.
// Input was generated by ent.
type OrgSubscriptionWhereInput struct {
	Not *OrgSubscriptionWhereInput   `json:"not,omitempty"`
	And []*OrgSubscriptionWhereInput `json:"and,omitempty"`
	Or  []*OrgSubscriptionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// stripe_subscription_id field predicates
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIdneq          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIdgt           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIdgte          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIdlt           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIdlte          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        *bool    `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       *bool    `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`
	// product_tier field predicates
	ProductTier             *string  `json:"productTier,omitempty"`
	ProductTierNeq          *string  `json:"productTierNEQ,omitempty"`
	ProductTierIn           []string `json:"productTierIn,omitempty"`
	ProductTierNotIn        []string `json:"productTierNotIn,omitempty"`
	ProductTierGt           *string  `json:"productTierGT,omitempty"`
	ProductTierGte          *string  `json:"productTierGTE,omitempty"`
	ProductTierLt           *string  `json:"productTierLT,omitempty"`
	ProductTierLte          *string  `json:"productTierLTE,omitempty"`
	ProductTierContains     *string  `json:"productTierContains,omitempty"`
	ProductTierHasPrefix    *string  `json:"productTierHasPrefix,omitempty"`
	ProductTierHasSuffix    *string  `json:"productTierHasSuffix,omitempty"`
	ProductTierIsNil        *bool    `json:"productTierIsNil,omitempty"`
	ProductTierNotNil       *bool    `json:"productTierNotNil,omitempty"`
	ProductTierEqualFold    *string  `json:"productTierEqualFold,omitempty"`
	ProductTierContainsFold *string  `json:"productTierContainsFold,omitempty"`
	// stripe_product_tier_id field predicates
	StripeProductTierID             *string  `json:"stripeProductTierID,omitempty"`
	StripeProductTierIdneq          *string  `json:"stripeProductTierIDNEQ,omitempty"`
	StripeProductTierIDIn           []string `json:"stripeProductTierIDIn,omitempty"`
	StripeProductTierIDNotIn        []string `json:"stripeProductTierIDNotIn,omitempty"`
	StripeProductTierIdgt           *string  `json:"stripeProductTierIDGT,omitempty"`
	StripeProductTierIdgte          *string  `json:"stripeProductTierIDGTE,omitempty"`
	StripeProductTierIdlt           *string  `json:"stripeProductTierIDLT,omitempty"`
	StripeProductTierIdlte          *string  `json:"stripeProductTierIDLTE,omitempty"`
	StripeProductTierIDContains     *string  `json:"stripeProductTierIDContains,omitempty"`
	StripeProductTierIDHasPrefix    *string  `json:"stripeProductTierIDHasPrefix,omitempty"`
	StripeProductTierIDHasSuffix    *string  `json:"stripeProductTierIDHasSuffix,omitempty"`
	StripeProductTierIDIsNil        *bool    `json:"stripeProductTierIDIsNil,omitempty"`
	StripeProductTierIDNotNil       *bool    `json:"stripeProductTierIDNotNil,omitempty"`
	StripeProductTierIDEqualFold    *string  `json:"stripeProductTierIDEqualFold,omitempty"`
	StripeProductTierIDContainsFold *string  `json:"stripeProductTierIDContainsFold,omitempty"`
	// stripe_subscription_status field predicates
	StripeSubscriptionStatus             *string  `json:"stripeSubscriptionStatus,omitempty"`
	StripeSubscriptionStatusNeq          *string  `json:"stripeSubscriptionStatusNEQ,omitempty"`
	StripeSubscriptionStatusIn           []string `json:"stripeSubscriptionStatusIn,omitempty"`
	StripeSubscriptionStatusNotIn        []string `json:"stripeSubscriptionStatusNotIn,omitempty"`
	StripeSubscriptionStatusGt           *string  `json:"stripeSubscriptionStatusGT,omitempty"`
	StripeSubscriptionStatusGte          *string  `json:"stripeSubscriptionStatusGTE,omitempty"`
	StripeSubscriptionStatusLt           *string  `json:"stripeSubscriptionStatusLT,omitempty"`
	StripeSubscriptionStatusLte          *string  `json:"stripeSubscriptionStatusLTE,omitempty"`
	StripeSubscriptionStatusContains     *string  `json:"stripeSubscriptionStatusContains,omitempty"`
	StripeSubscriptionStatusHasPrefix    *string  `json:"stripeSubscriptionStatusHasPrefix,omitempty"`
	StripeSubscriptionStatusHasSuffix    *string  `json:"stripeSubscriptionStatusHasSuffix,omitempty"`
	StripeSubscriptionStatusIsNil        *bool    `json:"stripeSubscriptionStatusIsNil,omitempty"`
	StripeSubscriptionStatusNotNil       *bool    `json:"stripeSubscriptionStatusNotNil,omitempty"`
	StripeSubscriptionStatusEqualFold    *string  `json:"stripeSubscriptionStatusEqualFold,omitempty"`
	StripeSubscriptionStatusContainsFold *string  `json:"stripeSubscriptionStatusContainsFold,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// stripe_customer_id field predicates
	StripeCustomerID             *string  `json:"stripeCustomerID,omitempty"`
	StripeCustomerIdneq          *string  `json:"stripeCustomerIDNEQ,omitempty"`
	StripeCustomerIDIn           []string `json:"stripeCustomerIDIn,omitempty"`
	StripeCustomerIDNotIn        []string `json:"stripeCustomerIDNotIn,omitempty"`
	StripeCustomerIdgt           *string  `json:"stripeCustomerIDGT,omitempty"`
	StripeCustomerIdgte          *string  `json:"stripeCustomerIDGTE,omitempty"`
	StripeCustomerIdlt           *string  `json:"stripeCustomerIDLT,omitempty"`
	StripeCustomerIdlte          *string  `json:"stripeCustomerIDLTE,omitempty"`
	StripeCustomerIDContains     *string  `json:"stripeCustomerIDContains,omitempty"`
	StripeCustomerIDHasPrefix    *string  `json:"stripeCustomerIDHasPrefix,omitempty"`
	StripeCustomerIDHasSuffix    *string  `json:"stripeCustomerIDHasSuffix,omitempty"`
	StripeCustomerIDIsNil        *bool    `json:"stripeCustomerIDIsNil,omitempty"`
	StripeCustomerIDNotNil       *bool    `json:"stripeCustomerIDNotNil,omitempty"`
	StripeCustomerIDEqualFold    *string  `json:"stripeCustomerIDEqualFold,omitempty"`
	StripeCustomerIDContainsFold *string  `json:"stripeCustomerIDContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// trial_expires_at field predicates
	TrialExpiresAt       *time.Time   `json:"trialExpiresAt,omitempty"`
	TrialExpiresAtNeq    *time.Time   `json:"trialExpiresAtNEQ,omitempty"`
	TrialExpiresAtIn     []*time.Time `json:"trialExpiresAtIn,omitempty"`
	TrialExpiresAtNotIn  []*time.Time `json:"trialExpiresAtNotIn,omitempty"`
	TrialExpiresAtGt     *time.Time   `json:"trialExpiresAtGT,omitempty"`
	TrialExpiresAtGte    *time.Time   `json:"trialExpiresAtGTE,omitempty"`
	TrialExpiresAtLt     *time.Time   `json:"trialExpiresAtLT,omitempty"`
	TrialExpiresAtLte    *time.Time   `json:"trialExpiresAtLTE,omitempty"`
	TrialExpiresAtIsNil  *bool        `json:"trialExpiresAtIsNil,omitempty"`
	TrialExpiresAtNotNil *bool        `json:"trialExpiresAtNotNil,omitempty"`
	// days_until_due field predicates
	DaysUntilDue             *string  `json:"daysUntilDue,omitempty"`
	DaysUntilDueNeq          *string  `json:"daysUntilDueNEQ,omitempty"`
	DaysUntilDueIn           []string `json:"daysUntilDueIn,omitempty"`
	DaysUntilDueNotIn        []string `json:"daysUntilDueNotIn,omitempty"`
	DaysUntilDueGt           *string  `json:"daysUntilDueGT,omitempty"`
	DaysUntilDueGte          *string  `json:"daysUntilDueGTE,omitempty"`
	DaysUntilDueLt           *string  `json:"daysUntilDueLT,omitempty"`
	DaysUntilDueLte          *string  `json:"daysUntilDueLTE,omitempty"`
	DaysUntilDueContains     *string  `json:"daysUntilDueContains,omitempty"`
	DaysUntilDueHasPrefix    *string  `json:"daysUntilDueHasPrefix,omitempty"`
	DaysUntilDueHasSuffix    *string  `json:"daysUntilDueHasSuffix,omitempty"`
	DaysUntilDueIsNil        *bool    `json:"daysUntilDueIsNil,omitempty"`
	DaysUntilDueNotNil       *bool    `json:"daysUntilDueNotNil,omitempty"`
	DaysUntilDueEqualFold    *string  `json:"daysUntilDueEqualFold,omitempty"`
	DaysUntilDueContainsFold *string  `json:"daysUntilDueContainsFold,omitempty"`
	// payment_method_added field predicates
	PaymentMethodAdded       *bool `json:"paymentMethodAdded,omitempty"`
	PaymentMethodAddedNeq    *bool `json:"paymentMethodAddedNEQ,omitempty"`
	PaymentMethodAddedIsNil  *bool `json:"paymentMethodAddedIsNil,omitempty"`
	PaymentMethodAddedNotNil *bool `json:"paymentMethodAddedNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Organization struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The organizations's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb bool `json:"dedicatedDb"`
	// groups that are allowed to create controls
	ControlCreators []*Group `json:"controlCreators,omitempty"`
	// groups that are allowed to create control_objectives
	ControlObjectiveCreators []*Group `json:"controlObjectiveCreators,omitempty"`
	// groups that are allowed to create groups
	GroupCreators []*Group `json:"groupCreators,omitempty"`
	// groups that are allowed to create internal_policys
	InternalPolicyCreators []*Group `json:"internalPolicyCreators,omitempty"`
	// groups that are allowed to create narratives
	NarrativeCreators []*Group `json:"narrativeCreators,omitempty"`
	// groups that are allowed to create procedures
	ProcedureCreators []*Group `json:"procedureCreators,omitempty"`
	// groups that are allowed to create programs
	ProgramCreators []*Group `json:"programCreators,omitempty"`
	// groups that are allowed to create risks
	RiskCreators []*Group `json:"riskCreators,omitempty"`
	// groups that are allowed to create templates
	TemplateCreators     []*Group                       `json:"templateCreators,omitempty"`
	Parent               *Organization                  `json:"parent,omitempty"`
	Children             *OrganizationConnection        `json:"children"`
	Setting              *OrganizationSetting           `json:"setting,omitempty"`
	PersonalAccessTokens *PersonalAccessTokenConnection `json:"personalAccessTokens"`
	APITokens            *APITokenConnection            `json:"apiTokens"`
	Users                []*User                        `json:"users,omitempty"`
	Files                *FileConnection                `json:"files"`
	Events               *EventConnection               `json:"events"`
	Secrets              *HushConnection                `json:"secrets"`
	AvatarFile           *File                          `json:"avatarFile,omitempty"`
	Groups               *GroupConnection               `json:"groups"`
	Templates            *TemplateConnection            `json:"templates"`
	Integrations         *IntegrationConnection         `json:"integrations"`
	Documents            *DocumentDataConnection        `json:"documents"`
	OrgSubscriptions     []*OrgSubscription             `json:"orgSubscriptions,omitempty"`
	Invites              *InviteConnection              `json:"invites"`
	Subscribers          *SubscriberConnection          `json:"subscribers"`
	Entities             *EntityConnection              `json:"entities"`
	EntityTypes          *EntityTypeConnection          `json:"entityTypes"`
	Contacts             *ContactConnection             `json:"contacts"`
	Notes                *NoteConnection                `json:"notes"`
	Tasks                *TaskConnection                `json:"tasks"`
	Programs             *ProgramConnection             `json:"programs"`
	Procedures           *ProcedureConnection           `json:"procedures"`
	InternalPolicies     *InternalPolicyConnection      `json:"internalPolicies"`
	Risks                *RiskConnection                `json:"risks"`
	ControlObjectives    *ControlObjectiveConnection    `json:"controlObjectives"`
	Narratives           *NarrativeConnection           `json:"narratives"`
	Controls             *ControlConnection             `json:"controls"`
	Subcontrols          *SubcontrolConnection          `json:"subcontrols"`
	Evidence             *EvidenceConnection            `json:"evidence"`
	Standards            *StandardConnection            `json:"standards"`
	ActionPlans          *ActionPlanConnection          `json:"actionPlans"`
	Members              []*OrgMembership               `json:"members,omitempty"`
}

func (Organization) IsNode() {}

// Return response for createBulkOrganization mutation
type OrganizationBulkCreatePayload struct {
	// Created organizations
	Organizations []*Organization `json:"organizations,omitempty"`
}

// A connection to a list of items.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization *Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The organizations's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb bool `json:"dedicatedDb"`
}

func (OrganizationHistory) IsNode() {}

// A connection to a list of items.
type OrganizationHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrganizationHistory connections
type OrganizationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationHistories.
	Field OrganizationHistoryOrderField `json:"field"`
}

// OrganizationHistoryWhereInput is used for filtering OrganizationHistory objects.
// Input was generated by ent.
type OrganizationHistoryWhereInput struct {
	Not *OrganizationHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIdneq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIdgt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIdgte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIdlt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIdlte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
}

// Ordering options for Organization connections
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Organizations.
	Field OrganizationOrderField `json:"field"`
}

type OrganizationSearchResult struct {
	Organizations []*Organization `json:"organizations,omitempty"`
}

func (OrganizationSearchResult) IsSearchResult() {}

type OrganizationSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string `json:"organizationID,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled bool `json:"billingNotificationsEnabled"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string        `json:"allowedEmailDomains,omitempty"`
	Organization        *Organization   `json:"organization,omitempty"`
	Files               *FileConnection `json:"files"`
}

func (OrganizationSetting) IsNode() {}

// Return response for createBulkOrganizationSetting mutation
type OrganizationSettingBulkCreatePayload struct {
	// Created organizationSettings
	OrganizationSettings []*OrganizationSetting `json:"organizationSettings,omitempty"`
}

// A connection to a list of items.
type OrganizationSettingConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganizationSetting mutation
type OrganizationSettingCreatePayload struct {
	// Created organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// Return response for deleteOrganizationSetting mutation
type OrganizationSettingDeletePayload struct {
	// Deleted organizationSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationSettingEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string `json:"organizationID,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled bool `json:"billingNotificationsEnabled"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string `json:"allowedEmailDomains,omitempty"`
}

func (OrganizationSettingHistory) IsNode() {}

// A connection to a list of items.
type OrganizationSettingHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrganizationSettingHistory connections
type OrganizationSettingHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationSettingHistories.
	Field OrganizationSettingHistoryOrderField `json:"field"`
}

// OrganizationSettingHistoryWhereInput is used for filtering OrganizationSettingHistory objects.
// Input was generated by ent.
type OrganizationSettingHistoryWhereInput struct {
	Not *OrganizationSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// billing_notifications_enabled field predicates
	BillingNotificationsEnabled    *bool `json:"billingNotificationsEnabled,omitempty"`
	BillingNotificationsEnabledNeq *bool `json:"billingNotificationsEnabledNEQ,omitempty"`
}

// Ordering options for OrganizationSetting connections
type OrganizationSettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationSettings.
	Field OrganizationSettingOrderField `json:"field"`
}

type OrganizationSettingSearchResult struct {
	OrganizationSettings []*OrganizationSetting `json:"organizationSettings,omitempty"`
}

func (OrganizationSettingSearchResult) IsSearchResult() {}

// Return response for updateOrganizationSetting mutation
type OrganizationSettingUpdatePayload struct {
	// Updated organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// OrganizationSettingWhereInput is used for filtering OrganizationSetting objects.
// Input was generated by ent.
type OrganizationSettingWhereInput struct {
	Not *OrganizationSettingWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// billing_notifications_enabled field predicates
	BillingNotificationsEnabled    *bool `json:"billingNotificationsEnabled,omitempty"`
	BillingNotificationsEnabledNeq *bool `json:"billingNotificationsEnabledNEQ,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization *Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIdneq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIdgt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIdgte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIdlt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIdlte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// control_creators edge predicates
	HasControlCreators     *bool              `json:"hasControlCreators,omitempty"`
	HasControlCreatorsWith []*GroupWhereInput `json:"hasControlCreatorsWith,omitempty"`
	// control_objective_creators edge predicates
	HasControlObjectiveCreators     *bool              `json:"hasControlObjectiveCreators,omitempty"`
	HasControlObjectiveCreatorsWith []*GroupWhereInput `json:"hasControlObjectiveCreatorsWith,omitempty"`
	// group_creators edge predicates
	HasGroupCreators     *bool              `json:"hasGroupCreators,omitempty"`
	HasGroupCreatorsWith []*GroupWhereInput `json:"hasGroupCreatorsWith,omitempty"`
	// internal_policy_creators edge predicates
	HasInternalPolicyCreators     *bool              `json:"hasInternalPolicyCreators,omitempty"`
	HasInternalPolicyCreatorsWith []*GroupWhereInput `json:"hasInternalPolicyCreatorsWith,omitempty"`
	// narrative_creators edge predicates
	HasNarrativeCreators     *bool              `json:"hasNarrativeCreators,omitempty"`
	HasNarrativeCreatorsWith []*GroupWhereInput `json:"hasNarrativeCreatorsWith,omitempty"`
	// procedure_creators edge predicates
	HasProcedureCreators     *bool              `json:"hasProcedureCreators,omitempty"`
	HasProcedureCreatorsWith []*GroupWhereInput `json:"hasProcedureCreatorsWith,omitempty"`
	// program_creators edge predicates
	HasProgramCreators     *bool              `json:"hasProgramCreators,omitempty"`
	HasProgramCreatorsWith []*GroupWhereInput `json:"hasProgramCreatorsWith,omitempty"`
	// risk_creators edge predicates
	HasRiskCreators     *bool              `json:"hasRiskCreators,omitempty"`
	HasRiskCreatorsWith []*GroupWhereInput `json:"hasRiskCreatorsWith,omitempty"`
	// template_creators edge predicates
	HasTemplateCreators     *bool              `json:"hasTemplateCreators,omitempty"`
	HasTemplateCreatorsWith []*GroupWhereInput `json:"hasTemplateCreatorsWith,omitempty"`
	// parent edge predicates
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                            `json:"hasSetting,omitempty"`
	HasSettingWith []*OrganizationSettingWhereInput `json:"hasSettingWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// api_tokens edge predicates
	HasAPITokens     *bool                 `json:"hasAPITokens,omitempty"`
	HasAPITokensWith []*APITokenWhereInput `json:"hasAPITokensWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// avatar_file edge predicates
	HasAvatarFile     *bool             `json:"hasAvatarFile,omitempty"`
	HasAvatarFileWith []*FileWhereInput `json:"hasAvatarFileWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// templates edge predicates
	HasTemplates     *bool                 `json:"hasTemplates,omitempty"`
	HasTemplatesWith []*TemplateWhereInput `json:"hasTemplatesWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// org_subscriptions edge predicates
	HasOrgSubscriptions     *bool                        `json:"hasOrgSubscriptions,omitempty"`
	HasOrgSubscriptionsWith []*OrgSubscriptionWhereInput `json:"hasOrgSubscriptionsWith,omitempty"`
	// invites edge predicates
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`
	// subscribers edge predicates
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// entity_types edge predicates
	HasEntityTypes     *bool                   `json:"hasEntityTypes,omitempty"`
	HasEntityTypesWith []*EntityTypeWhereInput `json:"hasEntityTypesWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// standards edge predicates
	HasStandards     *bool                 `json:"hasStandards,omitempty"`
	HasStandardsWith []*StandardWhereInput `json:"hasStandardsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                      `json:"hasMembers,omitempty"`
	HasMembersWith []*OrgMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PersonalAccessToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt     *time.Time              `json:"revokedAt,omitempty"`
	Owner         *User                   `json:"owner"`
	Organizations *OrganizationConnection `json:"organizations"`
	Events        *EventConnection        `json:"events"`
}

func (PersonalAccessToken) IsNode() {}

// Return response for createBulkPersonalAccessToken mutation
type PersonalAccessTokenBulkCreatePayload struct {
	// Created personalAccessTokens
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
}

// A connection to a list of items.
type PersonalAccessTokenConnection struct {
	// A list of edges.
	Edges []*PersonalAccessTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPersonalAccessToken mutation
type PersonalAccessTokenCreatePayload struct {
	// Created personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// Return response for deletePersonalAccessToken mutation
type PersonalAccessTokenDeletePayload struct {
	// Deleted personalAccessToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type PersonalAccessTokenEdge struct {
	// The item at the end of the edge.
	Node *PersonalAccessToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for PersonalAccessToken connections
type PersonalAccessTokenOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order PersonalAccessTokens.
	Field PersonalAccessTokenOrderField `json:"field"`
}

type PersonalAccessTokenSearchResult struct {
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
}

func (PersonalAccessTokenSearchResult) IsSearchResult() {}

// Return response for updatePersonalAccessToken mutation
type PersonalAccessTokenUpdatePayload struct {
	// Updated personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
// Input was generated by ent.
type PersonalAccessTokenWhereInput struct {
	Not *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	And []*PersonalAccessTokenWhereInput `json:"and,omitempty"`
	Or  []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// is_active field predicates
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNeq    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  *bool `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil *bool `json:"isActiveNotNil,omitempty"`
	// revoked_reason field predicates
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNeq          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGt           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGte          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLt           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLte          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        *bool    `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       *bool    `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`
	// revoked_by field predicates
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNeq          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGt           *string  `json:"revokedByGT,omitempty"`
	RevokedByGte          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLt           *string  `json:"revokedByLT,omitempty"`
	RevokedByLte          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        *bool    `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       *bool    `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`
	// revoked_at field predicates
	RevokedAt       *time.Time   `json:"revokedAt,omitempty"`
	RevokedAtNeq    *time.Time   `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []*time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []*time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGt     *time.Time   `json:"revokedAtGT,omitempty"`
	RevokedAtGte    *time.Time   `json:"revokedAtGTE,omitempty"`
	RevokedAtLt     *time.Time   `json:"revokedAtLT,omitempty"`
	RevokedAtLte    *time.Time   `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  *bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil *bool        `json:"revokedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Procedure struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// status of the procedure, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the procedure, e.g. compliance, operational, health and safety, etc.
	ProcedureType *string `json:"procedureType,omitempty"`
	// details of the procedure
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the procedure
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the procedure should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the procedure should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
	Owner           *Organization    `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// the group of users who are responsible for approving the procedure
	Approver *Group `json:"approver,omitempty"`
	// temporary delegates for the procedure, used for temporary approval
	Delegate         *Group                    `json:"delegate,omitempty"`
	Controls         *ControlConnection        `json:"controls"`
	InternalPolicies *InternalPolicyConnection `json:"internalPolicies"`
	Programs         *ProgramConnection        `json:"programs"`
	Narratives       *NarrativeConnection      `json:"narratives"`
	Risks            *RiskConnection           `json:"risks"`
	Tasks            *TaskConnection           `json:"tasks"`
}

func (Procedure) IsNode() {}

// Return response for createBulkProcedure mutation
type ProcedureBulkCreatePayload struct {
	// Created procedures
	Procedures []*Procedure `json:"procedures,omitempty"`
}

// A connection to a list of items.
type ProcedureConnection struct {
	// A list of edges.
	Edges []*ProcedureEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProcedure mutation
type ProcedureCreatePayload struct {
	// Created procedure
	Procedure *Procedure `json:"procedure"`
}

// Return response for deleteProcedure mutation
type ProcedureDeletePayload struct {
	// Deleted procedure ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProcedureEdge struct {
	// The item at the end of the edge.
	Node *Procedure `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProcedureHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// status of the procedure, e.g. draft, published, archived, etc.
	Status *enums.DocumentStatus `json:"status,omitempty"`
	// type of the procedure, e.g. compliance, operational, health and safety, etc.
	ProcedureType *string `json:"procedureType,omitempty"`
	// details of the procedure
	Details *string `json:"details,omitempty"`
	// whether approval is required for edits to the procedure
	ApprovalRequired *bool `json:"approvalRequired,omitempty"`
	// the date the procedure should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// the frequency at which the procedure should be reviewed, used to calculate the review_due date
	ReviewFrequency *enums.Frequency `json:"reviewFrequency,omitempty"`
}

func (ProcedureHistory) IsNode() {}

// A connection to a list of items.
type ProcedureHistoryConnection struct {
	// A list of edges.
	Edges []*ProcedureHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProcedureHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProcedureHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ProcedureHistory connections
type ProcedureHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ProcedureHistories.
	Field ProcedureHistoryOrderField `json:"field"`
}

// ProcedureHistoryWhereInput is used for filtering ProcedureHistory objects.
// Input was generated by ent.
type ProcedureHistoryWhereInput struct {
	Not *ProcedureHistoryWhereInput   `json:"not,omitempty"`
	And []*ProcedureHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProcedureHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// procedure_type field predicates
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNeq          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGt           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGte          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLt           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLte          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        *bool    `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       *bool    `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
}

// Ordering options for Procedure connections
type ProcedureOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Procedures.
	Field ProcedureOrderField `json:"field"`
}

type ProcedureSearchResult struct {
	Procedures []*Procedure `json:"procedures,omitempty"`
}

func (ProcedureSearchResult) IsSearchResult() {}

// Return response for updateProcedure mutation
type ProcedureUpdatePayload struct {
	// Updated procedure
	Procedure *Procedure `json:"procedure"`
}

// ProcedureWhereInput is used for filtering Procedure objects.
// Input was generated by ent.
type ProcedureWhereInput struct {
	Not *ProcedureWhereInput   `json:"not,omitempty"`
	And []*ProcedureWhereInput `json:"and,omitempty"`
	Or  []*ProcedureWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.DocumentStatus  `json:"status,omitempty"`
	StatusNeq    *enums.DocumentStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.DocumentStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.DocumentStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// procedure_type field predicates
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNeq          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGt           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGte          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLt           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLte          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        *bool    `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       *bool    `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// approval_required field predicates
	ApprovalRequired       *bool `json:"approvalRequired,omitempty"`
	ApprovalRequiredNeq    *bool `json:"approvalRequiredNEQ,omitempty"`
	ApprovalRequiredIsNil  *bool `json:"approvalRequiredIsNil,omitempty"`
	ApprovalRequiredNotNil *bool `json:"approvalRequiredNotNil,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// review_frequency field predicates
	ReviewFrequency       *enums.Frequency  `json:"reviewFrequency,omitempty"`
	ReviewFrequencyNeq    *enums.Frequency  `json:"reviewFrequencyNEQ,omitempty"`
	ReviewFrequencyIn     []enums.Frequency `json:"reviewFrequencyIn,omitempty"`
	ReviewFrequencyNotIn  []enums.Frequency `json:"reviewFrequencyNotIn,omitempty"`
	ReviewFrequencyIsNil  *bool             `json:"reviewFrequencyIsNil,omitempty"`
	ReviewFrequencyNotNil *bool             `json:"reviewFrequencyNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// approver edge predicates
	HasApprover     *bool              `json:"hasApprover,omitempty"`
	HasApproverWith []*GroupWhereInput `json:"hasApproverWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

type Program struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status enums.ProgramStatus `json:"status"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady bool `json:"auditorReady"`
	// can the auditor write comments
	AuditorWriteComments bool `json:"auditorWriteComments"`
	// can the auditor read comments
	AuditorReadComments bool          `json:"auditorReadComments"`
	Owner               *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers           []*Group                     `json:"viewers,omitempty"`
	Controls          *ControlConnection           `json:"controls"`
	Subcontrols       *SubcontrolConnection        `json:"subcontrols"`
	ControlObjectives *ControlObjectiveConnection  `json:"controlObjectives"`
	InternalPolicies  *InternalPolicyConnection    `json:"internalPolicies"`
	Procedures        *ProcedureConnection         `json:"procedures"`
	Risks             *RiskConnection              `json:"risks"`
	Tasks             *TaskConnection              `json:"tasks"`
	Notes             *NoteConnection              `json:"notes"`
	Files             *FileConnection              `json:"files"`
	Evidence          *EvidenceConnection          `json:"evidence"`
	Narratives        *NarrativeConnection         `json:"narratives"`
	ActionPlans       *ActionPlanConnection        `json:"actionPlans"`
	Users             *UserConnection              `json:"users"`
	Members           *ProgramMembershipConnection `json:"members"`
}

func (Program) IsNode() {}

// Return response for createBulkProgram mutation
type ProgramBulkCreatePayload struct {
	// Created programs
	Programs []*Program `json:"programs,omitempty"`
}

// A connection to a list of items.
type ProgramConnection struct {
	// A list of edges.
	Edges []*ProgramEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProgram mutation
type ProgramCreatePayload struct {
	// Created program
	Program *Program `json:"program"`
}

// Return response for deleteProgram mutation
type ProgramDeletePayload struct {
	// Deleted program ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProgramEdge struct {
	// The item at the end of the edge.
	Node *Program `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProgramHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status enums.ProgramStatus `json:"status"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady bool `json:"auditorReady"`
	// can the auditor write comments
	AuditorWriteComments bool `json:"auditorWriteComments"`
	// can the auditor read comments
	AuditorReadComments bool `json:"auditorReadComments"`
}

func (ProgramHistory) IsNode() {}

// A connection to a list of items.
type ProgramHistoryConnection struct {
	// A list of edges.
	Edges []*ProgramHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProgramHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProgramHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ProgramHistory connections
type ProgramHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ProgramHistories.
	Field ProgramHistoryOrderField `json:"field"`
}

// ProgramHistoryWhereInput is used for filtering ProgramHistory objects.
// Input was generated by ent.
type ProgramHistoryWhereInput struct {
	Not *ProgramHistoryWhereInput   `json:"not,omitempty"`
	And []*ProgramHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProgramHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`
	// start_date field predicates
	StartDate       *time.Time   `json:"startDate,omitempty"`
	StartDateNeq    *time.Time   `json:"startDateNEQ,omitempty"`
	StartDateIn     []*time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []*time.Time `json:"startDateNotIn,omitempty"`
	StartDateGt     *time.Time   `json:"startDateGT,omitempty"`
	StartDateGte    *time.Time   `json:"startDateGTE,omitempty"`
	StartDateLt     *time.Time   `json:"startDateLT,omitempty"`
	StartDateLte    *time.Time   `json:"startDateLTE,omitempty"`
	StartDateIsNil  *bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil *bool        `json:"startDateNotNil,omitempty"`
	// end_date field predicates
	EndDate       *time.Time   `json:"endDate,omitempty"`
	EndDateNeq    *time.Time   `json:"endDateNEQ,omitempty"`
	EndDateIn     []*time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []*time.Time `json:"endDateNotIn,omitempty"`
	EndDateGt     *time.Time   `json:"endDateGT,omitempty"`
	EndDateGte    *time.Time   `json:"endDateGTE,omitempty"`
	EndDateLt     *time.Time   `json:"endDateLT,omitempty"`
	EndDateLte    *time.Time   `json:"endDateLTE,omitempty"`
	EndDateIsNil  *bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil *bool        `json:"endDateNotNil,omitempty"`
	// auditor_ready field predicates
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNeq *bool `json:"auditorReadyNEQ,omitempty"`
	// auditor_write_comments field predicates
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNeq *bool `json:"auditorWriteCommentsNEQ,omitempty"`
	// auditor_read_comments field predicates
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNeq *bool `json:"auditorReadCommentsNEQ,omitempty"`
}

type ProgramMembership struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	Role      enums.Role `json:"role"`
	ProgramID string     `json:"programID"`
	UserID    string     `json:"userID"`
	Program   *Program   `json:"program"`
	User      *User      `json:"user"`
}

func (ProgramMembership) IsNode() {}

// Return response for createBulkProgramMembership mutation
type ProgramMembershipBulkCreatePayload struct {
	// Created programMemberships
	ProgramMemberships []*ProgramMembership `json:"programMemberships,omitempty"`
}

// A connection to a list of items.
type ProgramMembershipConnection struct {
	// A list of edges.
	Edges []*ProgramMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProgramMembership mutation
type ProgramMembershipCreatePayload struct {
	// Created programMembership
	ProgramMembership *ProgramMembership `json:"programMembership"`
}

// Return response for deleteProgramMembership mutation
type ProgramMembershipDeletePayload struct {
	// Deleted programMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProgramMembershipEdge struct {
	// The item at the end of the edge.
	Node *ProgramMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProgramMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	ProgramID   string         `json:"programID"`
	UserID      string         `json:"userID"`
}

func (ProgramMembershipHistory) IsNode() {}

// A connection to a list of items.
type ProgramMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*ProgramMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProgramMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProgramMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ProgramMembershipHistory connections
type ProgramMembershipHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ProgramMembershipHistories.
	Field ProgramMembershipHistoryOrderField `json:"field"`
}

// ProgramMembershipHistoryWhereInput is used for filtering ProgramMembershipHistory objects.
// Input was generated by ent.
type ProgramMembershipHistoryWhereInput struct {
	Not *ProgramMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*ProgramMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProgramMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// program_id field predicates
	ProgramID             *string  `json:"programID,omitempty"`
	ProgramIdneq          *string  `json:"programIDNEQ,omitempty"`
	ProgramIDIn           []string `json:"programIDIn,omitempty"`
	ProgramIDNotIn        []string `json:"programIDNotIn,omitempty"`
	ProgramIdgt           *string  `json:"programIDGT,omitempty"`
	ProgramIdgte          *string  `json:"programIDGTE,omitempty"`
	ProgramIdlt           *string  `json:"programIDLT,omitempty"`
	ProgramIdlte          *string  `json:"programIDLTE,omitempty"`
	ProgramIDContains     *string  `json:"programIDContains,omitempty"`
	ProgramIDHasPrefix    *string  `json:"programIDHasPrefix,omitempty"`
	ProgramIDHasSuffix    *string  `json:"programIDHasSuffix,omitempty"`
	ProgramIDEqualFold    *string  `json:"programIDEqualFold,omitempty"`
	ProgramIDContainsFold *string  `json:"programIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Ordering options for ProgramMembership connections
type ProgramMembershipOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ProgramMemberships.
	Field ProgramMembershipOrderField `json:"field"`
}

// Return response for updateProgramMembership mutation
type ProgramMembershipUpdatePayload struct {
	// Updated programMembership
	ProgramMembership *ProgramMembership `json:"programMembership"`
}

// ProgramMembershipWhereInput is used for filtering ProgramMembership objects.
// Input was generated by ent.
type ProgramMembershipWhereInput struct {
	Not *ProgramMembershipWhereInput   `json:"not,omitempty"`
	And []*ProgramMembershipWhereInput `json:"and,omitempty"`
	Or  []*ProgramMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	ProgramID *string      `json:"programID,omitempty"`
	UserID    *string      `json:"userID,omitempty"`
}

// Ordering options for Program connections
type ProgramOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Programs.
	Field ProgramOrderField `json:"field"`
}

type ProgramSearchResult struct {
	Programs []*Program `json:"programs,omitempty"`
}

func (ProgramSearchResult) IsSearchResult() {}

// Return response for updateProgram mutation
type ProgramUpdatePayload struct {
	// Updated program
	Program *Program `json:"program"`
}

// ProgramWhereInput is used for filtering Program objects.
// Input was generated by ent.
type ProgramWhereInput struct {
	Not *ProgramWhereInput   `json:"not,omitempty"`
	And []*ProgramWhereInput `json:"and,omitempty"`
	Or  []*ProgramWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`
	// start_date field predicates
	StartDate       *time.Time   `json:"startDate,omitempty"`
	StartDateNeq    *time.Time   `json:"startDateNEQ,omitempty"`
	StartDateIn     []*time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []*time.Time `json:"startDateNotIn,omitempty"`
	StartDateGt     *time.Time   `json:"startDateGT,omitempty"`
	StartDateGte    *time.Time   `json:"startDateGTE,omitempty"`
	StartDateLt     *time.Time   `json:"startDateLT,omitempty"`
	StartDateLte    *time.Time   `json:"startDateLTE,omitempty"`
	StartDateIsNil  *bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil *bool        `json:"startDateNotNil,omitempty"`
	// end_date field predicates
	EndDate       *time.Time   `json:"endDate,omitempty"`
	EndDateNeq    *time.Time   `json:"endDateNEQ,omitempty"`
	EndDateIn     []*time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []*time.Time `json:"endDateNotIn,omitempty"`
	EndDateGt     *time.Time   `json:"endDateGT,omitempty"`
	EndDateGte    *time.Time   `json:"endDateGTE,omitempty"`
	EndDateLt     *time.Time   `json:"endDateLT,omitempty"`
	EndDateLte    *time.Time   `json:"endDateLTE,omitempty"`
	EndDateIsNil  *bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil *bool        `json:"endDateNotNil,omitempty"`
	// auditor_ready field predicates
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNeq *bool `json:"auditorReadyNEQ,omitempty"`
	// auditor_write_comments field predicates
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNeq *bool `json:"auditorWriteCommentsNEQ,omitempty"`
	// auditor_read_comments field predicates
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNeq *bool `json:"auditorReadCommentsNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                          `json:"hasMembers,omitempty"`
	HasMembersWith []*ProgramMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Query struct {
}

type Risk struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// status of the risk - open, mitigated, ongoing, in-progress, and archived.
	Status *enums.RiskStatus `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// category of the risk, e.g. human resources, operations, IT, etc.
	Category *string `json:"category,omitempty"`
	// impact of the risk -critical, high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// score of the risk based on impact and likelihood (1-4 unlikely, 5-9 likely, 10-16 highly likely, 17-20 critical)
	Score *int64 `json:"score,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// details of the risk
	Details *string `json:"details,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string       `json:"businessCosts,omitempty"`
	Owner         *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers     []*Group              `json:"viewers,omitempty"`
	Controls    *ControlConnection    `json:"controls"`
	Procedures  *ProcedureConnection  `json:"procedures"`
	Programs    *ProgramConnection    `json:"programs"`
	ActionPlans *ActionPlanConnection `json:"actionPlans"`
	// the group of users who are responsible for risk oversight
	Stakeholder *Group `json:"stakeholder,omitempty"`
	// temporary delegates for the risk, used for temporary ownership
	Delegate *Group `json:"delegate,omitempty"`
}

func (Risk) IsNode() {}

// Return response for createBulkRisk mutation
type RiskBulkCreatePayload struct {
	// Created risks
	Risks []*Risk `json:"risks,omitempty"`
}

// A connection to a list of items.
type RiskConnection struct {
	// A list of edges.
	Edges []*RiskEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createRisk mutation
type RiskCreatePayload struct {
	// Created risk
	Risk *Risk `json:"risk"`
}

// Return response for deleteRisk mutation
type RiskDeletePayload struct {
	// Deleted risk ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type RiskEdge struct {
	// The item at the end of the edge.
	Node *Risk `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type RiskHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// status of the risk - open, mitigated, ongoing, in-progress, and archived.
	Status *enums.RiskStatus `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// category of the risk, e.g. human resources, operations, IT, etc.
	Category *string `json:"category,omitempty"`
	// impact of the risk -critical, high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// score of the risk based on impact and likelihood (1-4 unlikely, 5-9 likely, 10-16 highly likely, 17-20 critical)
	Score *int64 `json:"score,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// details of the risk
	Details *string `json:"details,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
}

func (RiskHistory) IsNode() {}

// A connection to a list of items.
type RiskHistoryConnection struct {
	// A list of edges.
	Edges []*RiskHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type RiskHistoryEdge struct {
	// The item at the end of the edge.
	Node *RiskHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for RiskHistory connections
type RiskHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order RiskHistories.
	Field RiskHistoryOrderField `json:"field"`
}

// RiskHistoryWhereInput is used for filtering RiskHistory objects.
// Input was generated by ent.
type RiskHistoryWhereInput struct {
	Not *RiskHistoryWhereInput   `json:"not,omitempty"`
	And []*RiskHistoryWhereInput `json:"and,omitempty"`
	Or  []*RiskHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.RiskStatus  `json:"status,omitempty"`
	StatusNeq    *enums.RiskStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.RiskStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.RiskStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool              `json:"statusIsNil,omitempty"`
	StatusNotNil *bool              `json:"statusNotNil,omitempty"`
	// risk_type field predicates
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNeq          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGt           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGte          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLt           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLte          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        *bool    `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       *bool    `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// impact field predicates
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNeq    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  *bool              `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool              `json:"impactNotNil,omitempty"`
	// likelihood field predicates
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNeq    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  *bool                  `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil *bool                  `json:"likelihoodNotNil,omitempty"`
	// score field predicates
	Score       *int64  `json:"score,omitempty"`
	ScoreNeq    *int64  `json:"scoreNEQ,omitempty"`
	ScoreIn     []int64 `json:"scoreIn,omitempty"`
	ScoreNotIn  []int64 `json:"scoreNotIn,omitempty"`
	ScoreGt     *int64  `json:"scoreGT,omitempty"`
	ScoreGte    *int64  `json:"scoreGTE,omitempty"`
	ScoreLt     *int64  `json:"scoreLT,omitempty"`
	ScoreLte    *int64  `json:"scoreLTE,omitempty"`
	ScoreIsNil  *bool   `json:"scoreIsNil,omitempty"`
	ScoreNotNil *bool   `json:"scoreNotNil,omitempty"`
	// mitigation field predicates
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNeq          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGt           *string  `json:"mitigationGT,omitempty"`
	MitigationGte          *string  `json:"mitigationGTE,omitempty"`
	MitigationLt           *string  `json:"mitigationLT,omitempty"`
	MitigationLte          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        *bool    `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       *bool    `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// business_costs field predicates
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNeq          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGt           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGte          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLt           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLte          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        *bool    `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       *bool    `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`
}

// Ordering options for Risk connections
type RiskOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Risks.
	Field RiskOrderField `json:"field"`
}

type RiskSearchResult struct {
	Risks []*Risk `json:"risks,omitempty"`
}

func (RiskSearchResult) IsSearchResult() {}

// Return response for updateRisk mutation
type RiskUpdatePayload struct {
	// Updated risk
	Risk *Risk `json:"risk"`
}

// RiskWhereInput is used for filtering Risk objects.
// Input was generated by ent.
type RiskWhereInput struct {
	Not *RiskWhereInput   `json:"not,omitempty"`
	And []*RiskWhereInput `json:"and,omitempty"`
	Or  []*RiskWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// status field predicates
	Status       *enums.RiskStatus  `json:"status,omitempty"`
	StatusNeq    *enums.RiskStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.RiskStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.RiskStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool              `json:"statusIsNil,omitempty"`
	StatusNotNil *bool              `json:"statusNotNil,omitempty"`
	// risk_type field predicates
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNeq          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGt           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGte          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLt           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLte          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        *bool    `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       *bool    `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// impact field predicates
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNeq    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  *bool              `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool              `json:"impactNotNil,omitempty"`
	// likelihood field predicates
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNeq    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  *bool                  `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil *bool                  `json:"likelihoodNotNil,omitempty"`
	// score field predicates
	Score       *int64  `json:"score,omitempty"`
	ScoreNeq    *int64  `json:"scoreNEQ,omitempty"`
	ScoreIn     []int64 `json:"scoreIn,omitempty"`
	ScoreNotIn  []int64 `json:"scoreNotIn,omitempty"`
	ScoreGt     *int64  `json:"scoreGT,omitempty"`
	ScoreGte    *int64  `json:"scoreGTE,omitempty"`
	ScoreLt     *int64  `json:"scoreLT,omitempty"`
	ScoreLte    *int64  `json:"scoreLTE,omitempty"`
	ScoreIsNil  *bool   `json:"scoreIsNil,omitempty"`
	ScoreNotNil *bool   `json:"scoreNotNil,omitempty"`
	// mitigation field predicates
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNeq          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGt           *string  `json:"mitigationGT,omitempty"`
	MitigationGte          *string  `json:"mitigationGTE,omitempty"`
	MitigationLt           *string  `json:"mitigationLT,omitempty"`
	MitigationLte          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        *bool    `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       *bool    `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// business_costs field predicates
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNeq          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGt           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGte          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLt           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLte          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        *bool    `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       *bool    `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// stakeholder edge predicates
	HasStakeholder     *bool              `json:"hasStakeholder,omitempty"`
	HasStakeholderWith []*GroupWhereInput `json:"hasStakeholderWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
}

type SearchResultConnection struct {
	// Information to aid in pagination.
	Page *PageInfo `json:"page"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
	// A list of nodes with results.
	Nodes []SearchResult `json:"nodes"`
}

type Standard struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// long description of the standard with details of what is covered
	Description *string `json:"description,omitempty"`
	// URL to the logo of the governing body
	GoverningBodyLogoURL *string `json:"governingBodyLogoURL,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, draft, and archived
	Status *enums.StandardStatus `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for system owned standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for system owned standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// type of the standard - cybersecurity, healthcare , financial, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version  *string            `json:"version,omitempty"`
	Owner    *Organization      `json:"owner,omitempty"`
	Controls *ControlConnection `json:"controls"`
}

func (Standard) IsNode() {}

// Return response for createBulkStandard mutation
type StandardBulkCreatePayload struct {
	// Created standards
	Standards []*Standard `json:"standards,omitempty"`
}

// A connection to a list of items.
type StandardConnection struct {
	// A list of edges.
	Edges []*StandardEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createStandard mutation
type StandardCreatePayload struct {
	// Created standard
	Standard *Standard `json:"standard"`
}

// Return response for deleteStandard mutation
type StandardDeletePayload struct {
	// Deleted standard ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type StandardEdge struct {
	// The item at the end of the edge.
	Node *Standard `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type StandardHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision *string `json:"revision,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// long description of the standard with details of what is covered
	Description *string `json:"description,omitempty"`
	// URL to the logo of the governing body
	GoverningBodyLogoURL *string `json:"governingBodyLogoURL,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, draft, and archived
	Status *enums.StandardStatus `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for system owned standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for system owned standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// type of the standard - cybersecurity, healthcare , financial, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
}

func (StandardHistory) IsNode() {}

// A connection to a list of items.
type StandardHistoryConnection struct {
	// A list of edges.
	Edges []*StandardHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type StandardHistoryEdge struct {
	// The item at the end of the edge.
	Node *StandardHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for StandardHistory connections
type StandardHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order StandardHistories.
	Field StandardHistoryOrderField `json:"field"`
}

// StandardHistoryWhereInput is used for filtering StandardHistory objects.
// Input was generated by ent.
type StandardHistoryWhereInput struct {
	Not *StandardHistoryWhereInput   `json:"not,omitempty"`
	And []*StandardHistoryWhereInput `json:"and,omitempty"`
	Or  []*StandardHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// short_name field predicates
	ShortName             *string  `json:"shortName,omitempty"`
	ShortNameNeq          *string  `json:"shortNameNEQ,omitempty"`
	ShortNameIn           []string `json:"shortNameIn,omitempty"`
	ShortNameNotIn        []string `json:"shortNameNotIn,omitempty"`
	ShortNameGt           *string  `json:"shortNameGT,omitempty"`
	ShortNameGte          *string  `json:"shortNameGTE,omitempty"`
	ShortNameLt           *string  `json:"shortNameLT,omitempty"`
	ShortNameLte          *string  `json:"shortNameLTE,omitempty"`
	ShortNameContains     *string  `json:"shortNameContains,omitempty"`
	ShortNameHasPrefix    *string  `json:"shortNameHasPrefix,omitempty"`
	ShortNameHasSuffix    *string  `json:"shortNameHasSuffix,omitempty"`
	ShortNameIsNil        *bool    `json:"shortNameIsNil,omitempty"`
	ShortNameNotNil       *bool    `json:"shortNameNotNil,omitempty"`
	ShortNameEqualFold    *string  `json:"shortNameEqualFold,omitempty"`
	ShortNameContainsFold *string  `json:"shortNameContainsFold,omitempty"`
	// framework field predicates
	Framework             *string  `json:"framework,omitempty"`
	FrameworkNeq          *string  `json:"frameworkNEQ,omitempty"`
	FrameworkIn           []string `json:"frameworkIn,omitempty"`
	FrameworkNotIn        []string `json:"frameworkNotIn,omitempty"`
	FrameworkGt           *string  `json:"frameworkGT,omitempty"`
	FrameworkGte          *string  `json:"frameworkGTE,omitempty"`
	FrameworkLt           *string  `json:"frameworkLT,omitempty"`
	FrameworkLte          *string  `json:"frameworkLTE,omitempty"`
	FrameworkContains     *string  `json:"frameworkContains,omitempty"`
	FrameworkHasPrefix    *string  `json:"frameworkHasPrefix,omitempty"`
	FrameworkHasSuffix    *string  `json:"frameworkHasSuffix,omitempty"`
	FrameworkIsNil        *bool    `json:"frameworkIsNil,omitempty"`
	FrameworkNotNil       *bool    `json:"frameworkNotNil,omitempty"`
	FrameworkEqualFold    *string  `json:"frameworkEqualFold,omitempty"`
	FrameworkContainsFold *string  `json:"frameworkContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// governing_body_logo_url field predicates
	GoverningBodyLogoURL             *string  `json:"governingBodyLogoURL,omitempty"`
	GoverningBodyLogoURLNeq          *string  `json:"governingBodyLogoURLNEQ,omitempty"`
	GoverningBodyLogoURLIn           []string `json:"governingBodyLogoURLIn,omitempty"`
	GoverningBodyLogoURLNotIn        []string `json:"governingBodyLogoURLNotIn,omitempty"`
	GoverningBodyLogoURLGt           *string  `json:"governingBodyLogoURLGT,omitempty"`
	GoverningBodyLogoURLGte          *string  `json:"governingBodyLogoURLGTE,omitempty"`
	GoverningBodyLogoURLLt           *string  `json:"governingBodyLogoURLLT,omitempty"`
	GoverningBodyLogoURLLte          *string  `json:"governingBodyLogoURLLTE,omitempty"`
	GoverningBodyLogoURLContains     *string  `json:"governingBodyLogoURLContains,omitempty"`
	GoverningBodyLogoURLHasPrefix    *string  `json:"governingBodyLogoURLHasPrefix,omitempty"`
	GoverningBodyLogoURLHasSuffix    *string  `json:"governingBodyLogoURLHasSuffix,omitempty"`
	GoverningBodyLogoURLIsNil        *bool    `json:"governingBodyLogoURLIsNil,omitempty"`
	GoverningBodyLogoURLNotNil       *bool    `json:"governingBodyLogoURLNotNil,omitempty"`
	GoverningBodyLogoURLEqualFold    *string  `json:"governingBodyLogoURLEqualFold,omitempty"`
	GoverningBodyLogoURLContainsFold *string  `json:"governingBodyLogoURLContainsFold,omitempty"`
	// governing_body field predicates
	GoverningBody             *string  `json:"governingBody,omitempty"`
	GoverningBodyNeq          *string  `json:"governingBodyNEQ,omitempty"`
	GoverningBodyIn           []string `json:"governingBodyIn,omitempty"`
	GoverningBodyNotIn        []string `json:"governingBodyNotIn,omitempty"`
	GoverningBodyGt           *string  `json:"governingBodyGT,omitempty"`
	GoverningBodyGte          *string  `json:"governingBodyGTE,omitempty"`
	GoverningBodyLt           *string  `json:"governingBodyLT,omitempty"`
	GoverningBodyLte          *string  `json:"governingBodyLTE,omitempty"`
	GoverningBodyContains     *string  `json:"governingBodyContains,omitempty"`
	GoverningBodyHasPrefix    *string  `json:"governingBodyHasPrefix,omitempty"`
	GoverningBodyHasSuffix    *string  `json:"governingBodyHasSuffix,omitempty"`
	GoverningBodyIsNil        *bool    `json:"governingBodyIsNil,omitempty"`
	GoverningBodyNotNil       *bool    `json:"governingBodyNotNil,omitempty"`
	GoverningBodyEqualFold    *string  `json:"governingBodyEqualFold,omitempty"`
	GoverningBodyContainsFold *string  `json:"governingBodyContainsFold,omitempty"`
	// link field predicates
	Link             *string  `json:"link,omitempty"`
	LinkNeq          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGt           *string  `json:"linkGT,omitempty"`
	LinkGte          *string  `json:"linkGTE,omitempty"`
	LinkLt           *string  `json:"linkLT,omitempty"`
	LinkLte          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        *bool    `json:"linkIsNil,omitempty"`
	LinkNotNil       *bool    `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`
	// status field predicates
	Status       *enums.StandardStatus  `json:"status,omitempty"`
	StatusNeq    *enums.StandardStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.StandardStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.StandardStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// is_public field predicates
	IsPublic       *bool `json:"isPublic,omitempty"`
	IsPublicNeq    *bool `json:"isPublicNEQ,omitempty"`
	IsPublicIsNil  *bool `json:"isPublicIsNil,omitempty"`
	IsPublicNotNil *bool `json:"isPublicNotNil,omitempty"`
	// free_to_use field predicates
	FreeToUse       *bool `json:"freeToUse,omitempty"`
	FreeToUseNeq    *bool `json:"freeToUseNEQ,omitempty"`
	FreeToUseIsNil  *bool `json:"freeToUseIsNil,omitempty"`
	FreeToUseNotNil *bool `json:"freeToUseNotNil,omitempty"`
	// standard_type field predicates
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNeq          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGt           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGte          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLt           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLte          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        *bool    `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       *bool    `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
}

// Ordering options for Standard connections
type StandardOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Standards.
	Field StandardOrderField `json:"field"`
}

type StandardSearchResult struct {
	Standards []*Standard `json:"standards,omitempty"`
}

func (StandardSearchResult) IsSearchResult() {}

// Return response for updateStandard mutation
type StandardUpdatePayload struct {
	// Updated standard
	Standard *Standard `json:"standard"`
}

// StandardWhereInput is used for filtering Standard objects.
// Input was generated by ent.
type StandardWhereInput struct {
	Not *StandardWhereInput   `json:"not,omitempty"`
	And []*StandardWhereInput `json:"and,omitempty"`
	Or  []*StandardWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// short_name field predicates
	ShortName             *string  `json:"shortName,omitempty"`
	ShortNameNeq          *string  `json:"shortNameNEQ,omitempty"`
	ShortNameIn           []string `json:"shortNameIn,omitempty"`
	ShortNameNotIn        []string `json:"shortNameNotIn,omitempty"`
	ShortNameGt           *string  `json:"shortNameGT,omitempty"`
	ShortNameGte          *string  `json:"shortNameGTE,omitempty"`
	ShortNameLt           *string  `json:"shortNameLT,omitempty"`
	ShortNameLte          *string  `json:"shortNameLTE,omitempty"`
	ShortNameContains     *string  `json:"shortNameContains,omitempty"`
	ShortNameHasPrefix    *string  `json:"shortNameHasPrefix,omitempty"`
	ShortNameHasSuffix    *string  `json:"shortNameHasSuffix,omitempty"`
	ShortNameIsNil        *bool    `json:"shortNameIsNil,omitempty"`
	ShortNameNotNil       *bool    `json:"shortNameNotNil,omitempty"`
	ShortNameEqualFold    *string  `json:"shortNameEqualFold,omitempty"`
	ShortNameContainsFold *string  `json:"shortNameContainsFold,omitempty"`
	// framework field predicates
	Framework             *string  `json:"framework,omitempty"`
	FrameworkNeq          *string  `json:"frameworkNEQ,omitempty"`
	FrameworkIn           []string `json:"frameworkIn,omitempty"`
	FrameworkNotIn        []string `json:"frameworkNotIn,omitempty"`
	FrameworkGt           *string  `json:"frameworkGT,omitempty"`
	FrameworkGte          *string  `json:"frameworkGTE,omitempty"`
	FrameworkLt           *string  `json:"frameworkLT,omitempty"`
	FrameworkLte          *string  `json:"frameworkLTE,omitempty"`
	FrameworkContains     *string  `json:"frameworkContains,omitempty"`
	FrameworkHasPrefix    *string  `json:"frameworkHasPrefix,omitempty"`
	FrameworkHasSuffix    *string  `json:"frameworkHasSuffix,omitempty"`
	FrameworkIsNil        *bool    `json:"frameworkIsNil,omitempty"`
	FrameworkNotNil       *bool    `json:"frameworkNotNil,omitempty"`
	FrameworkEqualFold    *string  `json:"frameworkEqualFold,omitempty"`
	FrameworkContainsFold *string  `json:"frameworkContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// governing_body_logo_url field predicates
	GoverningBodyLogoURL             *string  `json:"governingBodyLogoURL,omitempty"`
	GoverningBodyLogoURLNeq          *string  `json:"governingBodyLogoURLNEQ,omitempty"`
	GoverningBodyLogoURLIn           []string `json:"governingBodyLogoURLIn,omitempty"`
	GoverningBodyLogoURLNotIn        []string `json:"governingBodyLogoURLNotIn,omitempty"`
	GoverningBodyLogoURLGt           *string  `json:"governingBodyLogoURLGT,omitempty"`
	GoverningBodyLogoURLGte          *string  `json:"governingBodyLogoURLGTE,omitempty"`
	GoverningBodyLogoURLLt           *string  `json:"governingBodyLogoURLLT,omitempty"`
	GoverningBodyLogoURLLte          *string  `json:"governingBodyLogoURLLTE,omitempty"`
	GoverningBodyLogoURLContains     *string  `json:"governingBodyLogoURLContains,omitempty"`
	GoverningBodyLogoURLHasPrefix    *string  `json:"governingBodyLogoURLHasPrefix,omitempty"`
	GoverningBodyLogoURLHasSuffix    *string  `json:"governingBodyLogoURLHasSuffix,omitempty"`
	GoverningBodyLogoURLIsNil        *bool    `json:"governingBodyLogoURLIsNil,omitempty"`
	GoverningBodyLogoURLNotNil       *bool    `json:"governingBodyLogoURLNotNil,omitempty"`
	GoverningBodyLogoURLEqualFold    *string  `json:"governingBodyLogoURLEqualFold,omitempty"`
	GoverningBodyLogoURLContainsFold *string  `json:"governingBodyLogoURLContainsFold,omitempty"`
	// governing_body field predicates
	GoverningBody             *string  `json:"governingBody,omitempty"`
	GoverningBodyNeq          *string  `json:"governingBodyNEQ,omitempty"`
	GoverningBodyIn           []string `json:"governingBodyIn,omitempty"`
	GoverningBodyNotIn        []string `json:"governingBodyNotIn,omitempty"`
	GoverningBodyGt           *string  `json:"governingBodyGT,omitempty"`
	GoverningBodyGte          *string  `json:"governingBodyGTE,omitempty"`
	GoverningBodyLt           *string  `json:"governingBodyLT,omitempty"`
	GoverningBodyLte          *string  `json:"governingBodyLTE,omitempty"`
	GoverningBodyContains     *string  `json:"governingBodyContains,omitempty"`
	GoverningBodyHasPrefix    *string  `json:"governingBodyHasPrefix,omitempty"`
	GoverningBodyHasSuffix    *string  `json:"governingBodyHasSuffix,omitempty"`
	GoverningBodyIsNil        *bool    `json:"governingBodyIsNil,omitempty"`
	GoverningBodyNotNil       *bool    `json:"governingBodyNotNil,omitempty"`
	GoverningBodyEqualFold    *string  `json:"governingBodyEqualFold,omitempty"`
	GoverningBodyContainsFold *string  `json:"governingBodyContainsFold,omitempty"`
	// link field predicates
	Link             *string  `json:"link,omitempty"`
	LinkNeq          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGt           *string  `json:"linkGT,omitempty"`
	LinkGte          *string  `json:"linkGTE,omitempty"`
	LinkLt           *string  `json:"linkLT,omitempty"`
	LinkLte          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        *bool    `json:"linkIsNil,omitempty"`
	LinkNotNil       *bool    `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`
	// status field predicates
	Status       *enums.StandardStatus  `json:"status,omitempty"`
	StatusNeq    *enums.StandardStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []enums.StandardStatus `json:"statusIn,omitempty"`
	StatusNotIn  []enums.StandardStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  *bool                  `json:"statusIsNil,omitempty"`
	StatusNotNil *bool                  `json:"statusNotNil,omitempty"`
	// is_public field predicates
	IsPublic       *bool `json:"isPublic,omitempty"`
	IsPublicNeq    *bool `json:"isPublicNEQ,omitempty"`
	IsPublicIsNil  *bool `json:"isPublicIsNil,omitempty"`
	IsPublicNotNil *bool `json:"isPublicNotNil,omitempty"`
	// free_to_use field predicates
	FreeToUse       *bool `json:"freeToUse,omitempty"`
	FreeToUseNeq    *bool `json:"freeToUseNEQ,omitempty"`
	FreeToUseIsNil  *bool `json:"freeToUseIsNil,omitempty"`
	FreeToUseNotNil *bool `json:"freeToUseNotNil,omitempty"`
	// standard_type field predicates
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNeq          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGt           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGte          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLt           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLte          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        *bool    `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       *bool    `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
}

type Subcontrol struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the parent control
	ControlID         string                      `json:"controlID"`
	Owner             *Organization               `json:"owner,omitempty"`
	Control           *Control                    `json:"control"`
	MappedControls    *MappedControlConnection    `json:"mappedControls"`
	Evidence          *EvidenceConnection         `json:"evidence"`
	ControlObjectives *ControlObjectiveConnection `json:"controlObjectives"`
	Tasks             *TaskConnection             `json:"tasks"`
	Narratives        *NarrativeConnection        `json:"narratives"`
	Risks             *RiskConnection             `json:"risks"`
	ActionPlans       *ActionPlanConnection       `json:"actionPlans"`
	Procedures        *ProcedureConnection        `json:"procedures"`
	InternalPolicies  *InternalPolicyConnection   `json:"internalPolicies"`
	// the user who is responsible for the subcontrol, defaults to the parent control owner if not set
	ControlOwner *Group `json:"controlOwner,omitempty"`
	// temporary delegate for the subcontrol, used for temporary control ownership
	Delegate *Group `json:"delegate,omitempty"`
}

func (Subcontrol) IsNode() {}

// Return response for createBulkSubcontrol mutation
type SubcontrolBulkCreatePayload struct {
	// Created subcontrols
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
}

// A connection to a list of items.
type SubcontrolConnection struct {
	// A list of edges.
	Edges []*SubcontrolEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubcontrol mutation
type SubcontrolCreatePayload struct {
	// Created subcontrol
	Subcontrol *Subcontrol `json:"subcontrol"`
}

// Return response for deleteSubcontrol mutation
type SubcontrolDeletePayload struct {
	// Deleted subcontrol ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type SubcontrolEdge struct {
	// The item at the end of the edge.
	Node *Subcontrol `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type SubcontrolHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the parent control
	ControlID string `json:"controlID"`
}

func (SubcontrolHistory) IsNode() {}

// A connection to a list of items.
type SubcontrolHistoryConnection struct {
	// A list of edges.
	Edges []*SubcontrolHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type SubcontrolHistoryEdge struct {
	// The item at the end of the edge.
	Node *SubcontrolHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for SubcontrolHistory connections
type SubcontrolHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order SubcontrolHistories.
	Field SubcontrolHistoryOrderField `json:"field"`
}

// SubcontrolHistoryWhereInput is used for filtering SubcontrolHistory objects.
// Input was generated by ent.
type SubcontrolHistoryWhereInput struct {
	Not *SubcontrolHistoryWhereInput   `json:"not,omitempty"`
	And []*SubcontrolHistoryWhereInput `json:"and,omitempty"`
	Or  []*SubcontrolHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
}

// Ordering options for Subcontrol connections
type SubcontrolOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Subcontrols.
	Field SubcontrolOrderField `json:"field"`
}

type SubcontrolSearchResult struct {
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
}

func (SubcontrolSearchResult) IsSearchResult() {}

// Return response for updateSubcontrol mutation
type SubcontrolUpdatePayload struct {
	// Updated subcontrol
	Subcontrol *Subcontrol `json:"subcontrol"`
}

// SubcontrolWhereInput is used for filtering Subcontrol objects.
// Input was generated by ent.
type SubcontrolWhereInput struct {
	Not *SubcontrolWhereInput   `json:"not,omitempty"`
	And []*SubcontrolWhereInput `json:"and,omitempty"`
	Or  []*SubcontrolWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// mapped_controls edge predicates
	HasMappedControls     *bool                      `json:"hasMappedControls,omitempty"`
	HasMappedControlsWith []*MappedControlWhereInput `json:"hasMappedControlsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// control_owner edge predicates
	HasControlOwner     *bool              `json:"hasControlOwner,omitempty"`
	HasControlOwnerWith []*GroupWhereInput `json:"hasControlOwnerWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
}

type Subscriber struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// indicates if the email address has been verified
	VerifiedEmail bool `json:"verifiedEmail"`
	// indicates if the phone number has been verified
	VerifiedPhone bool `json:"verifiedPhone"`
	// indicates if the subscriber is active or not, active users will have at least one verified contact method
	Active bool `json:"active"`
	// indicates if the subscriber has unsubscribed from communications
	Unsubscribed bool             `json:"unsubscribed"`
	Owner        *Organization    `json:"owner,omitempty"`
	Events       *EventConnection `json:"events"`
}

func (Subscriber) IsNode() {}

// Return response for createBulkSubscriber mutation
type SubscriberBulkCreatePayload struct {
	// Created subscribers
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

// A connection to a list of items.
type SubscriberConnection struct {
	// A list of edges.
	Edges []*SubscriberEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubscriber mutation
type SubscriberCreatePayload struct {
	// Created subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// Return response for deleteSubscriber mutation
type SubscriberDeletePayload struct {
	// Deleted subscriber email
	Email string `json:"email"`
}

// An edge in a connection.
type SubscriberEdge struct {
	// The item at the end of the edge.
	Node *Subscriber `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Subscriber connections
type SubscriberOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Subscribers.
	Field SubscriberOrderField `json:"field"`
}

type SubscriberSearchResult struct {
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

func (SubscriberSearchResult) IsSearchResult() {}

// Return response for updateSubscriber mutation
type SubscriberUpdatePayload struct {
	// Updated subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// SubscriberWhereInput is used for filtering Subscriber objects.
// Input was generated by ent.
type SubscriberWhereInput struct {
	Not *SubscriberWhereInput   `json:"not,omitempty"`
	And []*SubscriberWhereInput `json:"and,omitempty"`
	Or  []*SubscriberWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// verified_email field predicates
	VerifiedEmail    *bool `json:"verifiedEmail,omitempty"`
	VerifiedEmailNeq *bool `json:"verifiedEmailNEQ,omitempty"`
	// verified_phone field predicates
	VerifiedPhone    *bool `json:"verifiedPhone,omitempty"`
	VerifiedPhoneNeq *bool `json:"verifiedPhoneNEQ,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// unsubscribed field predicates
	Unsubscribed    *bool `json:"unsubscribed,omitempty"`
	UnsubscribedNeq *bool `json:"unsubscribedNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type TFASetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// specifies if the TFA device has been verified
	Verified bool `json:"verified"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool `json:"totpAllowed,omitempty"`
	Owner       *User `json:"owner,omitempty"`
}

func (TFASetting) IsNode() {}

// A connection to a list of items.
type TFASettingConnection struct {
	// A list of edges.
	Edges []*TFASettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTFASetting mutation
type TFASettingCreatePayload struct {
	// Created tfaSetting
	TfaSetting *TFASetting `json:"tfaSetting"`
	TfaSecret  *string     `json:"tfaSecret,omitempty"`
	QRCode     *string     `json:"qrCode,omitempty"`
}

// An edge in a connection.
type TFASettingEdge struct {
	// The item at the end of the edge.
	Node *TFASetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TFASetting connections
type TFASettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TFASettings.
	Field TFASettingOrderField `json:"field"`
}

// Return response for updateTFASetting mutation
type TFASettingUpdatePayload struct {
	// Updated tfaSetting
	TfaSetting    *TFASetting `json:"tfaSetting"`
	TfaSecret     *string     `json:"tfaSecret,omitempty"`
	QRCode        *string     `json:"qrCode,omitempty"`
	RecoveryCodes []string    `json:"recoveryCodes,omitempty"`
}

// TFASettingWhereInput is used for filtering TFASetting objects.
// Input was generated by ent.
type TFASettingWhereInput struct {
	Not *TFASettingWhereInput   `json:"not,omitempty"`
	And []*TFASettingWhereInput `json:"and,omitempty"`
	Or  []*TFASettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// verified field predicates
	Verified    *bool `json:"verified,omitempty"`
	VerifiedNeq *bool `json:"verifiedNEQ,omitempty"`
	// totp_allowed field predicates
	TotpAllowed       *bool `json:"totpAllowed,omitempty"`
	TotpAllowedNeq    *bool `json:"totpAllowedNEQ,omitempty"`
	TotpAllowedIsNil  *bool `json:"totpAllowedIsNil,omitempty"`
	TotpAllowedNotNil *bool `json:"totpAllowedNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type Task struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status enums.TaskStatus `json:"status"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed *time.Time `json:"completed,omitempty"`
	// the id of the user who was assigned the task
	AssigneeID *string `json:"assigneeID,omitempty"`
	// the id of the user who assigned the task, can be left empty if created by the system or a service token
	AssignerID        *string                     `json:"assignerID,omitempty"`
	Owner             *Organization               `json:"owner,omitempty"`
	Assigner          *User                       `json:"assigner,omitempty"`
	Assignee          *User                       `json:"assignee,omitempty"`
	Comments          *NoteConnection             `json:"comments"`
	Groups            *GroupConnection            `json:"groups"`
	InternalPolicies  *InternalPolicyConnection   `json:"internalPolicies"`
	Procedures        *ProcedureConnection        `json:"procedures"`
	Controls          *ControlConnection          `json:"controls"`
	Subcontrols       *SubcontrolConnection       `json:"subcontrols"`
	ControlObjectives *ControlObjectiveConnection `json:"controlObjectives"`
	Programs          *ProgramConnection          `json:"programs"`
	Evidence          *EvidenceConnection         `json:"evidence"`
}

func (Task) IsNode() {}

// Return response for createBulkTask mutation
type TaskBulkCreatePayload struct {
	// Created tasks
	Tasks []*Task `json:"tasks,omitempty"`
}

// A connection to a list of items.
type TaskConnection struct {
	// A list of edges.
	Edges []*TaskEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTask mutation
type TaskCreatePayload struct {
	// Created task
	Task *Task `json:"task"`
}

// Return response for deleteTask mutation
type TaskDeletePayload struct {
	// Deleted task ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TaskEdge struct {
	// The item at the end of the edge.
	Node *Task `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TaskHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status enums.TaskStatus `json:"status"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed *time.Time `json:"completed,omitempty"`
	// the id of the user who was assigned the task
	AssigneeID *string `json:"assigneeID,omitempty"`
	// the id of the user who assigned the task, can be left empty if created by the system or a service token
	AssignerID *string `json:"assignerID,omitempty"`
}

func (TaskHistory) IsNode() {}

// A connection to a list of items.
type TaskHistoryConnection struct {
	// A list of edges.
	Edges []*TaskHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TaskHistoryEdge struct {
	// The item at the end of the edge.
	Node *TaskHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TaskHistory connections
type TaskHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TaskHistories.
	Field TaskHistoryOrderField `json:"field"`
}

// TaskHistoryWhereInput is used for filtering TaskHistory objects.
// Input was generated by ent.
type TaskHistoryWhereInput struct {
	Not *TaskHistoryWhereInput   `json:"not,omitempty"`
	And []*TaskHistoryWhereInput `json:"and,omitempty"`
	Or  []*TaskHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// status field predicates
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNeq   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// due field predicates
	Due       *time.Time   `json:"due,omitempty"`
	DueNeq    *time.Time   `json:"dueNEQ,omitempty"`
	DueIn     []*time.Time `json:"dueIn,omitempty"`
	DueNotIn  []*time.Time `json:"dueNotIn,omitempty"`
	DueGt     *time.Time   `json:"dueGT,omitempty"`
	DueGte    *time.Time   `json:"dueGTE,omitempty"`
	DueLt     *time.Time   `json:"dueLT,omitempty"`
	DueLte    *time.Time   `json:"dueLTE,omitempty"`
	DueIsNil  *bool        `json:"dueIsNil,omitempty"`
	DueNotNil *bool        `json:"dueNotNil,omitempty"`
	// completed field predicates
	Completed       *time.Time   `json:"completed,omitempty"`
	CompletedNeq    *time.Time   `json:"completedNEQ,omitempty"`
	CompletedIn     []*time.Time `json:"completedIn,omitempty"`
	CompletedNotIn  []*time.Time `json:"completedNotIn,omitempty"`
	CompletedGt     *time.Time   `json:"completedGT,omitempty"`
	CompletedGte    *time.Time   `json:"completedGTE,omitempty"`
	CompletedLt     *time.Time   `json:"completedLT,omitempty"`
	CompletedLte    *time.Time   `json:"completedLTE,omitempty"`
	CompletedIsNil  *bool        `json:"completedIsNil,omitempty"`
	CompletedNotNil *bool        `json:"completedNotNil,omitempty"`
	// assignee_id field predicates
	AssigneeID             *string  `json:"assigneeID,omitempty"`
	AssigneeIdneq          *string  `json:"assigneeIDNEQ,omitempty"`
	AssigneeIDIn           []string `json:"assigneeIDIn,omitempty"`
	AssigneeIDNotIn        []string `json:"assigneeIDNotIn,omitempty"`
	AssigneeIdgt           *string  `json:"assigneeIDGT,omitempty"`
	AssigneeIdgte          *string  `json:"assigneeIDGTE,omitempty"`
	AssigneeIdlt           *string  `json:"assigneeIDLT,omitempty"`
	AssigneeIdlte          *string  `json:"assigneeIDLTE,omitempty"`
	AssigneeIDContains     *string  `json:"assigneeIDContains,omitempty"`
	AssigneeIDHasPrefix    *string  `json:"assigneeIDHasPrefix,omitempty"`
	AssigneeIDHasSuffix    *string  `json:"assigneeIDHasSuffix,omitempty"`
	AssigneeIDIsNil        *bool    `json:"assigneeIDIsNil,omitempty"`
	AssigneeIDNotNil       *bool    `json:"assigneeIDNotNil,omitempty"`
	AssigneeIDEqualFold    *string  `json:"assigneeIDEqualFold,omitempty"`
	AssigneeIDContainsFold *string  `json:"assigneeIDContainsFold,omitempty"`
	// assigner_id field predicates
	AssignerID             *string  `json:"assignerID,omitempty"`
	AssignerIdneq          *string  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn           []string `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn        []string `json:"assignerIDNotIn,omitempty"`
	AssignerIdgt           *string  `json:"assignerIDGT,omitempty"`
	AssignerIdgte          *string  `json:"assignerIDGTE,omitempty"`
	AssignerIdlt           *string  `json:"assignerIDLT,omitempty"`
	AssignerIdlte          *string  `json:"assignerIDLTE,omitempty"`
	AssignerIDContains     *string  `json:"assignerIDContains,omitempty"`
	AssignerIDHasPrefix    *string  `json:"assignerIDHasPrefix,omitempty"`
	AssignerIDHasSuffix    *string  `json:"assignerIDHasSuffix,omitempty"`
	AssignerIDIsNil        *bool    `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil       *bool    `json:"assignerIDNotNil,omitempty"`
	AssignerIDEqualFold    *string  `json:"assignerIDEqualFold,omitempty"`
	AssignerIDContainsFold *string  `json:"assignerIDContainsFold,omitempty"`
}

// Ordering options for Task connections
type TaskOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Tasks.
	Field TaskOrderField `json:"field"`
}

type TaskSearchResult struct {
	Tasks []*Task `json:"tasks,omitempty"`
}

func (TaskSearchResult) IsSearchResult() {}

// Return response for updateTask mutation
type TaskUpdatePayload struct {
	// Updated task
	Task *Task `json:"task"`
}

// TaskWhereInput is used for filtering Task objects.
// Input was generated by ent.
type TaskWhereInput struct {
	Not *TaskWhereInput   `json:"not,omitempty"`
	And []*TaskWhereInput `json:"and,omitempty"`
	Or  []*TaskWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// status field predicates
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNeq   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// due field predicates
	Due       *time.Time   `json:"due,omitempty"`
	DueNeq    *time.Time   `json:"dueNEQ,omitempty"`
	DueIn     []*time.Time `json:"dueIn,omitempty"`
	DueNotIn  []*time.Time `json:"dueNotIn,omitempty"`
	DueGt     *time.Time   `json:"dueGT,omitempty"`
	DueGte    *time.Time   `json:"dueGTE,omitempty"`
	DueLt     *time.Time   `json:"dueLT,omitempty"`
	DueLte    *time.Time   `json:"dueLTE,omitempty"`
	DueIsNil  *bool        `json:"dueIsNil,omitempty"`
	DueNotNil *bool        `json:"dueNotNil,omitempty"`
	// completed field predicates
	Completed       *time.Time   `json:"completed,omitempty"`
	CompletedNeq    *time.Time   `json:"completedNEQ,omitempty"`
	CompletedIn     []*time.Time `json:"completedIn,omitempty"`
	CompletedNotIn  []*time.Time `json:"completedNotIn,omitempty"`
	CompletedGt     *time.Time   `json:"completedGT,omitempty"`
	CompletedGte    *time.Time   `json:"completedGTE,omitempty"`
	CompletedLt     *time.Time   `json:"completedLT,omitempty"`
	CompletedLte    *time.Time   `json:"completedLTE,omitempty"`
	CompletedIsNil  *bool        `json:"completedIsNil,omitempty"`
	CompletedNotNil *bool        `json:"completedNotNil,omitempty"`
	// assignee_id field predicates
	AssigneeID             *string  `json:"assigneeID,omitempty"`
	AssigneeIdneq          *string  `json:"assigneeIDNEQ,omitempty"`
	AssigneeIDIn           []string `json:"assigneeIDIn,omitempty"`
	AssigneeIDNotIn        []string `json:"assigneeIDNotIn,omitempty"`
	AssigneeIdgt           *string  `json:"assigneeIDGT,omitempty"`
	AssigneeIdgte          *string  `json:"assigneeIDGTE,omitempty"`
	AssigneeIdlt           *string  `json:"assigneeIDLT,omitempty"`
	AssigneeIdlte          *string  `json:"assigneeIDLTE,omitempty"`
	AssigneeIDContains     *string  `json:"assigneeIDContains,omitempty"`
	AssigneeIDHasPrefix    *string  `json:"assigneeIDHasPrefix,omitempty"`
	AssigneeIDHasSuffix    *string  `json:"assigneeIDHasSuffix,omitempty"`
	AssigneeIDIsNil        *bool    `json:"assigneeIDIsNil,omitempty"`
	AssigneeIDNotNil       *bool    `json:"assigneeIDNotNil,omitempty"`
	AssigneeIDEqualFold    *string  `json:"assigneeIDEqualFold,omitempty"`
	AssigneeIDContainsFold *string  `json:"assigneeIDContainsFold,omitempty"`
	// assigner_id field predicates
	AssignerID             *string  `json:"assignerID,omitempty"`
	AssignerIdneq          *string  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn           []string `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn        []string `json:"assignerIDNotIn,omitempty"`
	AssignerIdgt           *string  `json:"assignerIDGT,omitempty"`
	AssignerIdgte          *string  `json:"assignerIDGTE,omitempty"`
	AssignerIdlt           *string  `json:"assignerIDLT,omitempty"`
	AssignerIdlte          *string  `json:"assignerIDLTE,omitempty"`
	AssignerIDContains     *string  `json:"assignerIDContains,omitempty"`
	AssignerIDHasPrefix    *string  `json:"assignerIDHasPrefix,omitempty"`
	AssignerIDHasSuffix    *string  `json:"assignerIDHasSuffix,omitempty"`
	AssignerIDIsNil        *bool    `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil       *bool    `json:"assignerIDNotNil,omitempty"`
	AssignerIDEqualFold    *string  `json:"assignerIDEqualFold,omitempty"`
	AssignerIDContainsFold *string  `json:"assignerIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// assigner edge predicates
	HasAssigner     *bool             `json:"hasAssigner,omitempty"`
	HasAssignerWith []*UserWhereInput `json:"hasAssignerWith,omitempty"`
	// assignee edge predicates
	HasAssignee     *bool             `json:"hasAssignee,omitempty"`
	HasAssigneeWith []*UserWhereInput `json:"hasAssigneeWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
}

type Template struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema  map[string]any          `json:"uischema,omitempty"`
	Owner     *Organization           `json:"owner,omitempty"`
	Documents *DocumentDataConnection `json:"documents"`
	Files     *FileConnection         `json:"files"`
}

func (Template) IsNode() {}

// Return response for createBulkTemplate mutation
type TemplateBulkCreatePayload struct {
	// Created templates
	Templates []*Template `json:"templates,omitempty"`
}

// A connection to a list of items.
type TemplateConnection struct {
	// A list of edges.
	Edges []*TemplateEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTemplate mutation
type TemplateCreatePayload struct {
	// Created template
	Template *Template `json:"template"`
}

// Return response for deleteTemplate mutation
type TemplateDeletePayload struct {
	// Deleted template ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TemplateEdge struct {
	// The item at the end of the edge.
	Node *Template `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TemplateHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema map[string]any `json:"uischema,omitempty"`
}

func (TemplateHistory) IsNode() {}

// A connection to a list of items.
type TemplateHistoryConnection struct {
	// A list of edges.
	Edges []*TemplateHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TemplateHistoryEdge struct {
	// The item at the end of the edge.
	Node *TemplateHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TemplateHistory connections
type TemplateHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TemplateHistories.
	Field TemplateHistoryOrderField `json:"field"`
}

// TemplateHistoryWhereInput is used for filtering TemplateHistory objects.
// Input was generated by ent.
type TemplateHistoryWhereInput struct {
	Not *TemplateHistoryWhereInput   `json:"not,omitempty"`
	And []*TemplateHistoryWhereInput `json:"and,omitempty"`
	Or  []*TemplateHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
}

// Ordering options for Template connections
type TemplateOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Templates.
	Field TemplateOrderField `json:"field"`
}

type TemplateSearchResult struct {
	Templates []*Template `json:"templates,omitempty"`
}

func (TemplateSearchResult) IsSearchResult() {}

// Return response for updateTemplate mutation
type TemplateUpdatePayload struct {
	// Updated template
	Template *Template `json:"template"`
}

// TemplateWhereInput is used for filtering Template objects.
// Input was generated by ent.
type TemplateWhereInput struct {
	Not *TemplateWhereInput   `json:"not,omitempty"`
	And []*TemplateWhereInput `json:"and,omitempty"`
	Or  []*TemplateWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// UpdateAPITokenInput is used for update APIToken object.
// Input was generated by ent.
type UpdateAPITokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// a description of the token's purpose
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	Scopes           []string   `json:"scopes,omitempty"`
	AppendScopes     []string   `json:"appendScopes,omitempty"`
	ClearScopes      *bool      `json:"clearScopes,omitempty"`
	LastUsedAt       *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt  *bool      `json:"clearLastUsedAt,omitempty"`
	// whether the token is active
	IsActive      *bool `json:"isActive,omitempty"`
	ClearIsActive *bool `json:"clearIsActive,omitempty"`
	// the reason the token was revoked
	RevokedReason      *string `json:"revokedReason,omitempty"`
	ClearRevokedReason *bool   `json:"clearRevokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy      *string `json:"revokedBy,omitempty"`
	ClearRevokedBy *bool   `json:"clearRevokedBy,omitempty"`
	// when the token was revoked
	RevokedAt      *time.Time `json:"revokedAt,omitempty"`
	ClearRevokedAt *bool      `json:"clearRevokedAt,omitempty"`
	OwnerID        *string    `json:"ownerID,omitempty"`
	ClearOwner     *bool      `json:"clearOwner,omitempty"`
}

// UpdateActionPlanInput is used for update ActionPlan object.
// Input was generated by ent.
type UpdateActionPlanInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// the name of the action_plan
	Name *string `json:"name,omitempty"`
	// status of the action_plan, e.g. draft, published, archived, etc.
	Status      *enums.DocumentStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// type of the action_plan, e.g. compliance, operational, health and safety, etc.
	ActionPlanType      *string `json:"actionPlanType,omitempty"`
	ClearActionPlanType *bool   `json:"clearActionPlanType,omitempty"`
	// details of the action_plan
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// whether approval is required for edits to the action_plan
	ApprovalRequired      *bool `json:"approvalRequired,omitempty"`
	ClearApprovalRequired *bool `json:"clearApprovalRequired,omitempty"`
	// the date the action_plan should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue      *time.Time `json:"reviewDue,omitempty"`
	ClearReviewDue *bool      `json:"clearReviewDue,omitempty"`
	// the frequency at which the action_plan should be reviewed, used to calculate the review_due date
	ReviewFrequency      *enums.Frequency `json:"reviewFrequency,omitempty"`
	ClearReviewFrequency *bool            `json:"clearReviewFrequency,omitempty"`
	// due date of the action plan
	DueDate      *time.Time `json:"dueDate,omitempty"`
	ClearDueDate *bool      `json:"clearDueDate,omitempty"`
	// priority of the action plan
	Priority      *enums.Priority `json:"priority,omitempty"`
	ClearPriority *bool           `json:"clearPriority,omitempty"`
	// source of the action plan
	Source           *string             `json:"source,omitempty"`
	ClearSource      *bool               `json:"clearSource,omitempty"`
	ApproverID       *string             `json:"approverID,omitempty"`
	ClearApprover    *bool               `json:"clearApprover,omitempty"`
	DelegateID       *string             `json:"delegateID,omitempty"`
	ClearDelegate    *bool               `json:"clearDelegate,omitempty"`
	OwnerID          *string             `json:"ownerID,omitempty"`
	ClearOwner       *bool               `json:"clearOwner,omitempty"`
	AddRiskIDs       []string            `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs    []string            `json:"removeRiskIDs,omitempty"`
	ClearRisks       *bool               `json:"clearRisks,omitempty"`
	AddControlIDs    []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs []string            `json:"removeControlIDs,omitempty"`
	ClearControls    *bool               `json:"clearControls,omitempty"`
	AddUserIDs       []string            `json:"addUserIDs,omitempty"`
	RemoveUserIDs    []string            `json:"removeUserIDs,omitempty"`
	ClearUsers       *bool               `json:"clearUsers,omitempty"`
	AddProgramIDs    []string            `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs []string            `json:"removeProgramIDs,omitempty"`
	ClearPrograms    *bool               `json:"clearPrograms,omitempty"`
	RevisionBump     *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateContactInput is used for update Contact object.
// Input was generated by ent.
type UpdateContactInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the full name of the contact
	FullName *string `json:"fullName,omitempty"`
	// the title of the contact
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// the company of the contact
	Company      *string `json:"company,omitempty"`
	ClearCompany *bool   `json:"clearCompany,omitempty"`
	// the email of the contact
	Email      *string `json:"email,omitempty"`
	ClearEmail *bool   `json:"clearEmail,omitempty"`
	// the phone number of the contact
	PhoneNumber      *string `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool   `json:"clearPhoneNumber,omitempty"`
	// the address of the contact
	Address      *string `json:"address,omitempty"`
	ClearAddress *bool   `json:"clearAddress,omitempty"`
	// status of the contact
	Status          *enums.UserStatus `json:"status,omitempty"`
	OwnerID         *string           `json:"ownerID,omitempty"`
	ClearOwner      *bool             `json:"clearOwner,omitempty"`
	AddEntityIDs    []string          `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string          `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool             `json:"clearEntities,omitempty"`
	AddFileIDs      []string          `json:"addFileIDs,omitempty"`
	RemoveFileIDs   []string          `json:"removeFileIDs,omitempty"`
	ClearFiles      *bool             `json:"clearFiles,omitempty"`
}

// UpdateControlImplementationInput is used for update ControlImplementation object.
// Input was generated by ent.
type UpdateControlImplementationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// status of the %s, e.g. draft, published, archived, etc.
	Status      *enums.DocumentStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// date the control was implemented
	ImplementationDate      *time.Time `json:"implementationDate,omitempty"`
	ClearImplementationDate *bool      `json:"clearImplementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified      *bool `json:"verified,omitempty"`
	ClearVerified *bool `json:"clearVerified,omitempty"`
	// date the control implementation was verified
	VerificationDate      *time.Time `json:"verificationDate,omitempty"`
	ClearVerificationDate *bool      `json:"clearVerificationDate,omitempty"`
	// details of the control implementation
	Details          *string  `json:"details,omitempty"`
	ClearDetails     *bool    `json:"clearDetails,omitempty"`
	AddControlIDs    []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs []string `json:"removeControlIDs,omitempty"`
	ClearControls    *bool    `json:"clearControls,omitempty"`
}

// UpdateControlInput is used for update Control object.
// Input was generated by ent.
type UpdateControlInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// description of what the control is supposed to accomplish
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the control
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType      *enums.ControlType `json:"controlType,omitempty"`
	ClearControlType *bool              `json:"clearControlType,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// category id of the control
	CategoryID      *string `json:"categoryID,omitempty"`
	ClearCategoryID *bool   `json:"clearCategoryID,omitempty"`
	// subcategory of the control
	Subcategory      *string `json:"subcategory,omitempty"`
	ClearSubcategory *bool   `json:"clearSubcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories       []string `json:"mappedCategories,omitempty"`
	AppendMappedCategories []string `json:"appendMappedCategories,omitempty"`
	ClearMappedCategories  *bool    `json:"clearMappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives       []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	AppendAssessmentObjectives []*models.AssessmentObjective `json:"appendAssessmentObjectives,omitempty"`
	ClearAssessmentObjectives  *bool                         `json:"clearAssessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods       []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	AppendAssessmentMethods []*models.AssessmentMethod `json:"appendAssessmentMethods,omitempty"`
	ClearAssessmentMethods  *bool                      `json:"clearAssessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions       []string `json:"controlQuestions,omitempty"`
	AppendControlQuestions []string `json:"appendControlQuestions,omitempty"`
	ClearControlQuestions  *bool    `json:"clearControlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance       []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	AppendImplementationGuidance []*models.ImplementationGuidance `json:"appendImplementationGuidance,omitempty"`
	ClearImplementationGuidance  *bool                            `json:"clearImplementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence       []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	AppendExampleEvidence []*models.ExampleEvidence `json:"appendExampleEvidence,omitempty"`
	ClearExampleEvidence  *bool                     `json:"clearExampleEvidence,omitempty"`
	// references for the control
	References       []*models.Reference `json:"references,omitempty"`
	AppendReferences []*models.Reference `json:"appendReferences,omitempty"`
	ClearReferences  *bool               `json:"clearReferences,omitempty"`
	// the unique reference code for the control
	RefCode                        *string  `json:"refCode,omitempty"`
	AddBlockedGroupIDs             []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs          []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups             *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs                   []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs                []string `json:"removeEditorIDs,omitempty"`
	ClearEditors                   *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs                   []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs                []string `json:"removeViewerIDs,omitempty"`
	ClearViewers                   *bool    `json:"clearViewers,omitempty"`
	StandardID                     *string  `json:"standardID,omitempty"`
	ClearStandard                  *bool    `json:"clearStandard,omitempty"`
	AddProgramIDs                  []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs               []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms                  *bool    `json:"clearPrograms,omitempty"`
	AddEvidenceIDs                 []string `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs              []string `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                  *bool    `json:"clearEvidence,omitempty"`
	AddControlImplementationIDs    []string `json:"addControlImplementationIDs,omitempty"`
	RemoveControlImplementationIDs []string `json:"removeControlImplementationIDs,omitempty"`
	ClearControlImplementations    *bool    `json:"clearControlImplementations,omitempty"`
	AddMappedControlIDs            []string `json:"addMappedControlIDs,omitempty"`
	RemoveMappedControlIDs         []string `json:"removeMappedControlIDs,omitempty"`
	ClearMappedControls            *bool    `json:"clearMappedControls,omitempty"`
	AddControlObjectiveIDs         []string `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs      []string `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives         *bool    `json:"clearControlObjectives,omitempty"`
	AddSubcontrolIDs               []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs            []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols               *bool    `json:"clearSubcontrols,omitempty"`
	AddTaskIDs                     []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                  []string `json:"removeTaskIDs,omitempty"`
	ClearTasks                     *bool    `json:"clearTasks,omitempty"`
	AddNarrativeIDs                []string `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs             []string `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives                *bool    `json:"clearNarratives,omitempty"`
	AddRiskIDs                     []string `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                  []string `json:"removeRiskIDs,omitempty"`
	ClearRisks                     *bool    `json:"clearRisks,omitempty"`
	AddActionPlanIDs               []string `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs            []string `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans               *bool    `json:"clearActionPlans,omitempty"`
	AddProcedureIDs                []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs             []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                *bool    `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs           []string `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs        []string `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies          *bool    `json:"clearInternalPolicies,omitempty"`
	ControlOwnerID                 *string  `json:"controlOwnerID,omitempty"`
	ClearControlOwner              *bool    `json:"clearControlOwner,omitempty"`
	DelegateID                     *string  `json:"delegateID,omitempty"`
	ClearDelegate                  *bool    `json:"clearDelegate,omitempty"`
}

// UpdateControlObjectiveInput is used for update ControlObjective object.
// Input was generated by ent.
type UpdateControlObjectiveInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// the name of the control objective
	Name *string `json:"name,omitempty"`
	// the desired outcome or target of the control objective
	DesiredOutcome      *string `json:"desiredOutcome,omitempty"`
	ClearDesiredOutcome *bool   `json:"clearDesiredOutcome,omitempty"`
	// status of the control objective
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType      *string `json:"controlObjectiveType,omitempty"`
	ClearControlObjectiveType *bool   `json:"clearControlObjectiveType,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// subcategory of the control
	Subcategory             *string             `json:"subcategory,omitempty"`
	ClearSubcategory        *bool               `json:"clearSubcategory,omitempty"`
	AddBlockedGroupIDs      []string            `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string            `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool               `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string            `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string            `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool               `json:"clearEditors,omitempty"`
	AddViewerIDs            []string            `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs         []string            `json:"removeViewerIDs,omitempty"`
	ClearViewers            *bool               `json:"clearViewers,omitempty"`
	AddProgramIDs           []string            `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string            `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool               `json:"clearPrograms,omitempty"`
	AddEvidenceIDs          []string            `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs       []string            `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence           *bool               `json:"clearEvidence,omitempty"`
	AddControlIDs           []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string            `json:"removeControlIDs,omitempty"`
	ClearControls           *bool               `json:"clearControls,omitempty"`
	AddSubcontrolIDs        []string            `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs     []string            `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols        *bool               `json:"clearSubcontrols,omitempty"`
	AddInternalPolicyIDs    []string            `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string            `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool               `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs         []string            `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs      []string            `json:"removeProcedureIDs,omitempty"`
	ClearProcedures         *bool               `json:"clearProcedures,omitempty"`
	AddRiskIDs              []string            `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs           []string            `json:"removeRiskIDs,omitempty"`
	ClearRisks              *bool               `json:"clearRisks,omitempty"`
	AddNarrativeIDs         []string            `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs      []string            `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives         *bool               `json:"clearNarratives,omitempty"`
	AddTaskIDs              []string            `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string            `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool               `json:"clearTasks,omitempty"`
	RevisionBump            *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateDocumentDataInput is used for update DocumentData object.
// Input was generated by ent.
type UpdateDocumentDataInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the json data of the document
	Data            map[string]any `json:"data,omitempty"`
	TemplateID      *string        `json:"templateID,omitempty"`
	AddEntityIDs    []string       `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string       `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool          `json:"clearEntities,omitempty"`
	AddFileIDs      []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs   []string       `json:"removeFileIDs,omitempty"`
	ClearFiles      *bool          `json:"clearFiles,omitempty"`
}

// UpdateEntityInput is used for update Entity object.
// Input was generated by ent.
type UpdateEntityInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the entity
	Name      *string `json:"name,omitempty"`
	ClearName *bool   `json:"clearName,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// An optional description of the entity
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// domains associated with the entity
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// status of the entity
	Status            *string          `json:"status,omitempty"`
	ClearStatus       *bool            `json:"clearStatus,omitempty"`
	OwnerID           *string          `json:"ownerID,omitempty"`
	ClearOwner        *bool            `json:"clearOwner,omitempty"`
	AddContactIDs     []string         `json:"addContactIDs,omitempty"`
	RemoveContactIDs  []string         `json:"removeContactIDs,omitempty"`
	ClearContacts     *bool            `json:"clearContacts,omitempty"`
	AddDocumentIDs    []string         `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs []string         `json:"removeDocumentIDs,omitempty"`
	ClearDocuments    *bool            `json:"clearDocuments,omitempty"`
	AddNoteIDs        []string         `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs     []string         `json:"removeNoteIDs,omitempty"`
	ClearNotes        *bool            `json:"clearNotes,omitempty"`
	AddFileIDs        []string         `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string         `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool            `json:"clearFiles,omitempty"`
	EntityTypeID      *string          `json:"entityTypeID,omitempty"`
	ClearEntityType   *bool            `json:"clearEntityType,omitempty"`
	Note              *CreateNoteInput `json:"note,omitempty"`
}

// UpdateEntityTypeInput is used for update EntityType object.
// Input was generated by ent.
type UpdateEntityTypeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the entity
	Name            *string  `json:"name,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	ClearOwner      *bool    `json:"clearOwner,omitempty"`
	AddEntityIDs    []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool    `json:"clearEntities,omitempty"`
}

// UpdateEventInput is used for update Event object.
// Input was generated by ent.
type UpdateEventInput struct {
	// tags associated with the object
	Tags                         []string       `json:"tags,omitempty"`
	AppendTags                   []string       `json:"appendTags,omitempty"`
	ClearTags                    *bool          `json:"clearTags,omitempty"`
	EventID                      *string        `json:"eventID,omitempty"`
	ClearEventID                 *bool          `json:"clearEventID,omitempty"`
	CorrelationID                *string        `json:"correlationID,omitempty"`
	ClearCorrelationID           *bool          `json:"clearCorrelationID,omitempty"`
	EventType                    *string        `json:"eventType,omitempty"`
	Metadata                     map[string]any `json:"metadata,omitempty"`
	ClearMetadata                *bool          `json:"clearMetadata,omitempty"`
	AddUserIDs                   []string       `json:"addUserIDs,omitempty"`
	RemoveUserIDs                []string       `json:"removeUserIDs,omitempty"`
	ClearUsers                   *bool          `json:"clearUsers,omitempty"`
	AddGroupIDs                  []string       `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string       `json:"removeGroupIDs,omitempty"`
	ClearGroups                  *bool          `json:"clearGroups,omitempty"`
	AddIntegrationIDs            []string       `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs         []string       `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations            *bool          `json:"clearIntegrations,omitempty"`
	AddOrganizationIDs           []string       `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string       `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations           *bool          `json:"clearOrganizations,omitempty"`
	AddInviteIDs                 []string       `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs              []string       `json:"removeInviteIDs,omitempty"`
	ClearInvites                 *bool          `json:"clearInvites,omitempty"`
	AddPersonalAccessTokenIDs    []string       `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs []string       `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens    *bool          `json:"clearPersonalAccessTokens,omitempty"`
	AddSecretIDs                 []string       `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs              []string       `json:"removeSecretIDs,omitempty"`
	ClearSecrets                 *bool          `json:"clearSecrets,omitempty"`
	AddSubscriberIDs             []string       `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs          []string       `json:"removeSubscriberIDs,omitempty"`
	ClearSubscribers             *bool          `json:"clearSubscribers,omitempty"`
	AddFileIDs                   []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs                []string       `json:"removeFileIDs,omitempty"`
	ClearFiles                   *bool          `json:"clearFiles,omitempty"`
	AddOrgSubscriptionIDs        []string       `json:"addOrgSubscriptionIDs,omitempty"`
	RemoveOrgSubscriptionIDs     []string       `json:"removeOrgSubscriptionIDs,omitempty"`
	ClearOrgSubscriptions        *bool          `json:"clearOrgSubscriptions,omitempty"`
}

// UpdateEvidenceInput is used for update Evidence object.
// Input was generated by ent.
type UpdateEvidenceInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the evidence
	Name *string `json:"name,omitempty"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure      *string `json:"collectionProcedure,omitempty"`
	ClearCollectionProcedure *bool   `json:"clearCollectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate *time.Time `json:"creationDate,omitempty"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate      *time.Time `json:"renewalDate,omitempty"`
	ClearRenewalDate *bool      `json:"clearRenewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated      *bool `json:"isAutomated,omitempty"`
	ClearIsAutomated *bool `json:"clearIsAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL      *string `json:"url,omitempty"`
	ClearURL *bool   `json:"clearURL,omitempty"`
	// the status of the evidence, ready, approved, needs renewal, missing artifact, rejected
	Status                    *enums.EvidenceStatus `json:"status,omitempty"`
	ClearStatus               *bool                 `json:"clearStatus,omitempty"`
	AddControlObjectiveIDs    []string              `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string              `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool                 `json:"clearControlObjectives,omitempty"`
	AddControlIDs             []string              `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string              `json:"removeControlIDs,omitempty"`
	ClearControls             *bool                 `json:"clearControls,omitempty"`
	AddSubcontrolIDs          []string              `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string              `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols          *bool                 `json:"clearSubcontrols,omitempty"`
	AddFileIDs                []string              `json:"addFileIDs,omitempty"`
	RemoveFileIDs             []string              `json:"removeFileIDs,omitempty"`
	ClearFiles                *bool                 `json:"clearFiles,omitempty"`
	AddProgramIDs             []string              `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string              `json:"removeProgramIDs,omitempty"`
	ClearPrograms             *bool                 `json:"clearPrograms,omitempty"`
	AddTaskIDs                []string              `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string              `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool                 `json:"clearTasks,omitempty"`
}

// UpdateFileInput is used for update File object.
// Input was generated by ent.
type UpdateFileInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName *string `json:"providedFileName,omitempty"`
	// the extension of the file provided
	ProvidedFileExtension *string `json:"providedFileExtension,omitempty"`
	// the computed size of the file in the original http request
	ProvidedFileSize       *int64 `json:"providedFileSize,omitempty"`
	ClearProvidedFileSize  *bool  `json:"clearProvidedFileSize,omitempty"`
	PersistedFileSize      *int64 `json:"persistedFileSize,omitempty"`
	ClearPersistedFileSize *bool  `json:"clearPersistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType      *string `json:"detectedMimeType,omitempty"`
	ClearDetectedMimeType *bool   `json:"clearDetectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash      *string `json:"md5Hash,omitempty"`
	ClearMd5Hash *bool   `json:"clearMd5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType *string `json:"detectedContentType,omitempty"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey      *string `json:"storeKey,omitempty"`
	ClearStoreKey *bool   `json:"clearStoreKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType      *string `json:"categoryType,omitempty"`
	ClearCategoryType *bool   `json:"clearCategoryType,omitempty"`
	// the full URI of the file
	URI      *string `json:"uri,omitempty"`
	ClearURI *bool   `json:"clearURI,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme      *string `json:"storageScheme,omitempty"`
	ClearStorageScheme *bool   `json:"clearStorageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume      *string `json:"storageVolume,omitempty"`
	ClearStorageVolume *bool   `json:"clearStorageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath                  *string  `json:"storagePath,omitempty"`
	ClearStoragePath             *bool    `json:"clearStoragePath,omitempty"`
	AddUserIDs                   []string `json:"addUserIDs,omitempty"`
	RemoveUserIDs                []string `json:"removeUserIDs,omitempty"`
	ClearUser                    *bool    `json:"clearUser,omitempty"`
	AddOrganizationIDs           []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization            *bool    `json:"clearOrganization,omitempty"`
	AddGroupIDs                  []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string `json:"removeGroupIDs,omitempty"`
	ClearGroups                  *bool    `json:"clearGroups,omitempty"`
	AddContactIDs                []string `json:"addContactIDs,omitempty"`
	RemoveContactIDs             []string `json:"removeContactIDs,omitempty"`
	ClearContact                 *bool    `json:"clearContact,omitempty"`
	AddEntityIDs                 []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs              []string `json:"removeEntityIDs,omitempty"`
	ClearEntity                  *bool    `json:"clearEntity,omitempty"`
	AddUserSettingIDs            []string `json:"addUserSettingIDs,omitempty"`
	RemoveUserSettingIDs         []string `json:"removeUserSettingIDs,omitempty"`
	ClearUserSetting             *bool    `json:"clearUserSetting,omitempty"`
	AddOrganizationSettingIDs    []string `json:"addOrganizationSettingIDs,omitempty"`
	RemoveOrganizationSettingIDs []string `json:"removeOrganizationSettingIDs,omitempty"`
	ClearOrganizationSetting     *bool    `json:"clearOrganizationSetting,omitempty"`
	AddTemplateIDs               []string `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs            []string `json:"removeTemplateIDs,omitempty"`
	ClearTemplate                *bool    `json:"clearTemplate,omitempty"`
	AddDocumentIDs               []string `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs            []string `json:"removeDocumentIDs,omitempty"`
	ClearDocument                *bool    `json:"clearDocument,omitempty"`
	AddProgramIDs                []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs             []string `json:"removeProgramIDs,omitempty"`
	ClearProgram                 *bool    `json:"clearProgram,omitempty"`
	AddEvidenceIDs               []string `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs            []string `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                *bool    `json:"clearEvidence,omitempty"`
	AddEventIDs                  []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs               []string `json:"removeEventIDs,omitempty"`
	ClearEvents                  *bool    `json:"clearEvents,omitempty"`
}

// UpdateGroupInput is used for update Group object.
// Input was generated by ent.
type UpdateGroupInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the group - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// the groups description
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL      *string `json:"logoURL,omitempty"`
	ClearLogoURL *bool   `json:"clearLogoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName                           *string                       `json:"displayName,omitempty"`
	OwnerID                               *string                       `json:"ownerID,omitempty"`
	ClearOwner                            *bool                         `json:"clearOwner,omitempty"`
	AddProgramEditorIDs                   []string                      `json:"addProgramEditorIDs,omitempty"`
	RemoveProgramEditorIDs                []string                      `json:"removeProgramEditorIDs,omitempty"`
	ClearProgramEditors                   *bool                         `json:"clearProgramEditors,omitempty"`
	AddProgramBlockedGroupIDs             []string                      `json:"addProgramBlockedGroupIDs,omitempty"`
	RemoveProgramBlockedGroupIDs          []string                      `json:"removeProgramBlockedGroupIDs,omitempty"`
	ClearProgramBlockedGroups             *bool                         `json:"clearProgramBlockedGroups,omitempty"`
	AddProgramViewerIDs                   []string                      `json:"addProgramViewerIDs,omitempty"`
	RemoveProgramViewerIDs                []string                      `json:"removeProgramViewerIDs,omitempty"`
	ClearProgramViewers                   *bool                         `json:"clearProgramViewers,omitempty"`
	AddRiskEditorIDs                      []string                      `json:"addRiskEditorIDs,omitempty"`
	RemoveRiskEditorIDs                   []string                      `json:"removeRiskEditorIDs,omitempty"`
	ClearRiskEditors                      *bool                         `json:"clearRiskEditors,omitempty"`
	AddRiskBlockedGroupIDs                []string                      `json:"addRiskBlockedGroupIDs,omitempty"`
	RemoveRiskBlockedGroupIDs             []string                      `json:"removeRiskBlockedGroupIDs,omitempty"`
	ClearRiskBlockedGroups                *bool                         `json:"clearRiskBlockedGroups,omitempty"`
	AddRiskViewerIDs                      []string                      `json:"addRiskViewerIDs,omitempty"`
	RemoveRiskViewerIDs                   []string                      `json:"removeRiskViewerIDs,omitempty"`
	ClearRiskViewers                      *bool                         `json:"clearRiskViewers,omitempty"`
	AddControlObjectiveEditorIDs          []string                      `json:"addControlObjectiveEditorIDs,omitempty"`
	RemoveControlObjectiveEditorIDs       []string                      `json:"removeControlObjectiveEditorIDs,omitempty"`
	ClearControlObjectiveEditors          *bool                         `json:"clearControlObjectiveEditors,omitempty"`
	AddControlObjectiveBlockedGroupIDs    []string                      `json:"addControlObjectiveBlockedGroupIDs,omitempty"`
	RemoveControlObjectiveBlockedGroupIDs []string                      `json:"removeControlObjectiveBlockedGroupIDs,omitempty"`
	ClearControlObjectiveBlockedGroups    *bool                         `json:"clearControlObjectiveBlockedGroups,omitempty"`
	AddControlObjectiveViewerIDs          []string                      `json:"addControlObjectiveViewerIDs,omitempty"`
	RemoveControlObjectiveViewerIDs       []string                      `json:"removeControlObjectiveViewerIDs,omitempty"`
	ClearControlObjectiveViewers          *bool                         `json:"clearControlObjectiveViewers,omitempty"`
	AddControlEditorIDs                   []string                      `json:"addControlEditorIDs,omitempty"`
	RemoveControlEditorIDs                []string                      `json:"removeControlEditorIDs,omitempty"`
	ClearControlEditors                   *bool                         `json:"clearControlEditors,omitempty"`
	AddControlBlockedGroupIDs             []string                      `json:"addControlBlockedGroupIDs,omitempty"`
	RemoveControlBlockedGroupIDs          []string                      `json:"removeControlBlockedGroupIDs,omitempty"`
	ClearControlBlockedGroups             *bool                         `json:"clearControlBlockedGroups,omitempty"`
	AddControlViewerIDs                   []string                      `json:"addControlViewerIDs,omitempty"`
	RemoveControlViewerIDs                []string                      `json:"removeControlViewerIDs,omitempty"`
	ClearControlViewers                   *bool                         `json:"clearControlViewers,omitempty"`
	AddNarrativeEditorIDs                 []string                      `json:"addNarrativeEditorIDs,omitempty"`
	RemoveNarrativeEditorIDs              []string                      `json:"removeNarrativeEditorIDs,omitempty"`
	ClearNarrativeEditors                 *bool                         `json:"clearNarrativeEditors,omitempty"`
	AddNarrativeBlockedGroupIDs           []string                      `json:"addNarrativeBlockedGroupIDs,omitempty"`
	RemoveNarrativeBlockedGroupIDs        []string                      `json:"removeNarrativeBlockedGroupIDs,omitempty"`
	ClearNarrativeBlockedGroups           *bool                         `json:"clearNarrativeBlockedGroups,omitempty"`
	AddNarrativeViewerIDs                 []string                      `json:"addNarrativeViewerIDs,omitempty"`
	RemoveNarrativeViewerIDs              []string                      `json:"removeNarrativeViewerIDs,omitempty"`
	ClearNarrativeViewers                 *bool                         `json:"clearNarrativeViewers,omitempty"`
	AddProcedureEditorIDs                 []string                      `json:"addProcedureEditorIDs,omitempty"`
	RemoveProcedureEditorIDs              []string                      `json:"removeProcedureEditorIDs,omitempty"`
	ClearProcedureEditors                 *bool                         `json:"clearProcedureEditors,omitempty"`
	AddProcedureBlockedGroupIDs           []string                      `json:"addProcedureBlockedGroupIDs,omitempty"`
	RemoveProcedureBlockedGroupIDs        []string                      `json:"removeProcedureBlockedGroupIDs,omitempty"`
	ClearProcedureBlockedGroups           *bool                         `json:"clearProcedureBlockedGroups,omitempty"`
	AddInternalPolicyEditorIDs            []string                      `json:"addInternalPolicyEditorIDs,omitempty"`
	RemoveInternalPolicyEditorIDs         []string                      `json:"removeInternalPolicyEditorIDs,omitempty"`
	ClearInternalPolicyEditors            *bool                         `json:"clearInternalPolicyEditors,omitempty"`
	AddInternalPolicyBlockedGroupIDs      []string                      `json:"addInternalPolicyBlockedGroupIDs,omitempty"`
	RemoveInternalPolicyBlockedGroupIDs   []string                      `json:"removeInternalPolicyBlockedGroupIDs,omitempty"`
	ClearInternalPolicyBlockedGroups      *bool                         `json:"clearInternalPolicyBlockedGroups,omitempty"`
	SettingID                             *string                       `json:"settingID,omitempty"`
	ClearSetting                          *bool                         `json:"clearSetting,omitempty"`
	AddEventIDs                           []string                      `json:"addEventIDs,omitempty"`
	RemoveEventIDs                        []string                      `json:"removeEventIDs,omitempty"`
	ClearEvents                           *bool                         `json:"clearEvents,omitempty"`
	AddIntegrationIDs                     []string                      `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs                  []string                      `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations                     *bool                         `json:"clearIntegrations,omitempty"`
	AddFileIDs                            []string                      `json:"addFileIDs,omitempty"`
	RemoveFileIDs                         []string                      `json:"removeFileIDs,omitempty"`
	ClearFiles                            *bool                         `json:"clearFiles,omitempty"`
	AddTaskIDs                            []string                      `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                         []string                      `json:"removeTaskIDs,omitempty"`
	ClearTasks                            *bool                         `json:"clearTasks,omitempty"`
	AddGroupMembers                       []*CreateGroupMembershipInput `json:"addGroupMembers,omitempty"`
	RemoveGroupMembers                    []string                      `json:"removeGroupMembers,omitempty"`
	UpdateGroupSettings                   *UpdateGroupSettingInput      `json:"updateGroupSettings,omitempty"`
	// inheritGroupPermissions allows a group to be updated with the same permissions
	// as the specified group ID, existing permissions will be removed
	InheritGroupPermissions *string `json:"inheritGroupPermissions,omitempty"`
}

// UpdateGroupMembershipInput is used for update GroupMembership object.
// Input was generated by ent.
type UpdateGroupMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateGroupSettingInput is used for update GroupSetting object.
// Input was generated by ent.
type UpdateGroupSettingInput struct {
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack      *bool `json:"syncToSlack,omitempty"`
	ClearSyncToSlack *bool `json:"clearSyncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub      *bool   `json:"syncToGithub,omitempty"`
	ClearSyncToGithub *bool   `json:"clearSyncToGithub,omitempty"`
	GroupID           *string `json:"groupID,omitempty"`
	ClearGroup        *bool   `json:"clearGroup,omitempty"`
}

// UpdateHushInput is used for update Hush object.
// Input was generated by ent.
type UpdateHushInput struct {
	// the logical name of the corresponding hush secret or it's general grouping
	Name *string `json:"name,omitempty"`
	// a description of the hush value or purpose, such as github PAT
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind                  *string  `json:"kind,omitempty"`
	ClearKind             *bool    `json:"clearKind,omitempty"`
	AddIntegrationIDs     []string `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs  []string `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations     *bool    `json:"clearIntegrations,omitempty"`
	AddOrganizationIDs    []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization     *bool    `json:"clearOrganization,omitempty"`
	AddEventIDs           []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool    `json:"clearEvents,omitempty"`
}

// UpdateIntegrationInput is used for update Integration object.
// Input was generated by ent.
type UpdateIntegrationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the integration - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// a description of the integration
	Description      *string  `json:"description,omitempty"`
	ClearDescription *bool    `json:"clearDescription,omitempty"`
	Kind             *string  `json:"kind,omitempty"`
	ClearKind        *bool    `json:"clearKind,omitempty"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	ClearOwner       *bool    `json:"clearOwner,omitempty"`
	AddSecretIDs     []string `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs  []string `json:"removeSecretIDs,omitempty"`
	ClearSecrets     *bool    `json:"clearSecrets,omitempty"`
	AddEventIDs      []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs   []string `json:"removeEventIDs,omitempty"`
	ClearEvents      *bool    `json:"clearEvents,omitempty"`
}

// UpdateInternalPolicyInput is used for update InternalPolicy object.
// Input was generated by ent.
type UpdateInternalPolicyInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// the name of the policy
	Name *string `json:"name,omitempty"`
	// status of the policy, e.g. draft, published, archived, etc.
	Status      *enums.DocumentStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// type of the policy, e.g. compliance, operational, health and safety, etc.
	PolicyType      *string `json:"policyType,omitempty"`
	ClearPolicyType *bool   `json:"clearPolicyType,omitempty"`
	// details of the policy
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// whether approval is required for edits to the policy
	ApprovalRequired      *bool `json:"approvalRequired,omitempty"`
	ClearApprovalRequired *bool `json:"clearApprovalRequired,omitempty"`
	// the date the policy should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue      *time.Time `json:"reviewDue,omitempty"`
	ClearReviewDue *bool      `json:"clearReviewDue,omitempty"`
	// the frequency at which the policy should be reviewed, used to calculate the review_due date
	ReviewFrequency           *enums.Frequency    `json:"reviewFrequency,omitempty"`
	ClearReviewFrequency      *bool               `json:"clearReviewFrequency,omitempty"`
	OwnerID                   *string             `json:"ownerID,omitempty"`
	ClearOwner                *bool               `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs        []string            `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs     []string            `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups        *bool               `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs              []string            `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs           []string            `json:"removeEditorIDs,omitempty"`
	ClearEditors              *bool               `json:"clearEditors,omitempty"`
	ApproverID                *string             `json:"approverID,omitempty"`
	ClearApprover             *bool               `json:"clearApprover,omitempty"`
	DelegateID                *string             `json:"delegateID,omitempty"`
	ClearDelegate             *bool               `json:"clearDelegate,omitempty"`
	AddControlObjectiveIDs    []string            `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string            `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool               `json:"clearControlObjectives,omitempty"`
	AddControlIDs             []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string            `json:"removeControlIDs,omitempty"`
	ClearControls             *bool               `json:"clearControls,omitempty"`
	AddProcedureIDs           []string            `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string            `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool               `json:"clearProcedures,omitempty"`
	AddNarrativeIDs           []string            `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string            `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool               `json:"clearNarratives,omitempty"`
	AddTaskIDs                []string            `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string            `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool               `json:"clearTasks,omitempty"`
	AddProgramIDs             []string            `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string            `json:"removeProgramIDs,omitempty"`
	ClearPrograms             *bool               `json:"clearPrograms,omitempty"`
	RevisionBump              *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateInviteInput is used for update Invite object.
// Input was generated by ent.
type UpdateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires      *time.Time `json:"expires,omitempty"`
	ClearExpires *bool      `json:"clearExpires,omitempty"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts   *int64   `json:"sendAttempts,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	ClearOwner     *bool    `json:"clearOwner,omitempty"`
	AddEventIDs    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool    `json:"clearEvents,omitempty"`
}

// UpdateMappedControlInput is used for update MappedControl object.
// Input was generated by ent.
type UpdateMappedControlInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType      *string `json:"mappingType,omitempty"`
	ClearMappingType *bool   `json:"clearMappingType,omitempty"`
	// description of how the two controls are related
	Relation            *string  `json:"relation,omitempty"`
	ClearRelation       *bool    `json:"clearRelation,omitempty"`
	AddControlIDs       []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs    []string `json:"removeControlIDs,omitempty"`
	ClearControls       *bool    `json:"clearControls,omitempty"`
	AddSubcontrolIDs    []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols    *bool    `json:"clearSubcontrols,omitempty"`
}

// UpdateNarrativeInput is used for update Narrative object.
// Input was generated by ent.
type UpdateNarrativeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the narrative
	Name *string `json:"name,omitempty"`
	// the description of the narrative
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// text data for the narrative document
	Details               *string  `json:"details,omitempty"`
	ClearDetails          *bool    `json:"clearDetails,omitempty"`
	AddBlockedGroupIDs    []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs          []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool    `json:"clearViewers,omitempty"`
	AddSatisfyIDs         []string `json:"addSatisfyIDs,omitempty"`
	RemoveSatisfyIDs      []string `json:"removeSatisfyIDs,omitempty"`
	ClearSatisfies        *bool    `json:"clearSatisfies,omitempty"`
	AddProgramIDs         []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs      []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms         *bool    `json:"clearPrograms,omitempty"`
}

// UpdateNoteInput is used for update Note object.
// Input was generated by ent.
type UpdateNoteInput struct {
	// the text of the note
	Text      *string `json:"text,omitempty"`
	TaskID    *string `json:"taskID,omitempty"`
	ClearTask *bool   `json:"clearTask,omitempty"`
}

// UpdateOrgMembershipInput is used for update OrgMembership object.
// Input was generated by ent.
type UpdateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the organization
	Name *string `json:"name,omitempty"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt                  *time.Time                      `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt             *bool                           `json:"clearAvatarUpdatedAt,omitempty"`
	AddControlCreatorIDs             []string                        `json:"addControlCreatorIDs,omitempty"`
	RemoveControlCreatorIDs          []string                        `json:"removeControlCreatorIDs,omitempty"`
	ClearControlCreators             *bool                           `json:"clearControlCreators,omitempty"`
	AddControlObjectiveCreatorIDs    []string                        `json:"addControlObjectiveCreatorIDs,omitempty"`
	RemoveControlObjectiveCreatorIDs []string                        `json:"removeControlObjectiveCreatorIDs,omitempty"`
	ClearControlObjectiveCreators    *bool                           `json:"clearControlObjectiveCreators,omitempty"`
	AddGroupCreatorIDs               []string                        `json:"addGroupCreatorIDs,omitempty"`
	RemoveGroupCreatorIDs            []string                        `json:"removeGroupCreatorIDs,omitempty"`
	ClearGroupCreators               *bool                           `json:"clearGroupCreators,omitempty"`
	AddInternalPolicyCreatorIDs      []string                        `json:"addInternalPolicyCreatorIDs,omitempty"`
	RemoveInternalPolicyCreatorIDs   []string                        `json:"removeInternalPolicyCreatorIDs,omitempty"`
	ClearInternalPolicyCreators      *bool                           `json:"clearInternalPolicyCreators,omitempty"`
	AddNarrativeCreatorIDs           []string                        `json:"addNarrativeCreatorIDs,omitempty"`
	RemoveNarrativeCreatorIDs        []string                        `json:"removeNarrativeCreatorIDs,omitempty"`
	ClearNarrativeCreators           *bool                           `json:"clearNarrativeCreators,omitempty"`
	AddProcedureCreatorIDs           []string                        `json:"addProcedureCreatorIDs,omitempty"`
	RemoveProcedureCreatorIDs        []string                        `json:"removeProcedureCreatorIDs,omitempty"`
	ClearProcedureCreators           *bool                           `json:"clearProcedureCreators,omitempty"`
	AddProgramCreatorIDs             []string                        `json:"addProgramCreatorIDs,omitempty"`
	RemoveProgramCreatorIDs          []string                        `json:"removeProgramCreatorIDs,omitempty"`
	ClearProgramCreators             *bool                           `json:"clearProgramCreators,omitempty"`
	AddRiskCreatorIDs                []string                        `json:"addRiskCreatorIDs,omitempty"`
	RemoveRiskCreatorIDs             []string                        `json:"removeRiskCreatorIDs,omitempty"`
	ClearRiskCreators                *bool                           `json:"clearRiskCreators,omitempty"`
	AddTemplateCreatorIDs            []string                        `json:"addTemplateCreatorIDs,omitempty"`
	RemoveTemplateCreatorIDs         []string                        `json:"removeTemplateCreatorIDs,omitempty"`
	ClearTemplateCreators            *bool                           `json:"clearTemplateCreators,omitempty"`
	SettingID                        *string                         `json:"settingID,omitempty"`
	ClearSetting                     *bool                           `json:"clearSetting,omitempty"`
	AddPersonalAccessTokenIDs        []string                        `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs     []string                        `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens        *bool                           `json:"clearPersonalAccessTokens,omitempty"`
	AddAPITokenIDs                   []string                        `json:"addAPITokenIDs,omitempty"`
	RemoveAPITokenIDs                []string                        `json:"removeAPITokenIDs,omitempty"`
	ClearAPITokens                   *bool                           `json:"clearAPITokens,omitempty"`
	AddFileIDs                       []string                        `json:"addFileIDs,omitempty"`
	RemoveFileIDs                    []string                        `json:"removeFileIDs,omitempty"`
	ClearFiles                       *bool                           `json:"clearFiles,omitempty"`
	AddEventIDs                      []string                        `json:"addEventIDs,omitempty"`
	RemoveEventIDs                   []string                        `json:"removeEventIDs,omitempty"`
	ClearEvents                      *bool                           `json:"clearEvents,omitempty"`
	AddSecretIDs                     []string                        `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs                  []string                        `json:"removeSecretIDs,omitempty"`
	ClearSecrets                     *bool                           `json:"clearSecrets,omitempty"`
	AvatarFileID                     *string                         `json:"avatarFileID,omitempty"`
	ClearAvatarFile                  *bool                           `json:"clearAvatarFile,omitempty"`
	AddGroupIDs                      []string                        `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                   []string                        `json:"removeGroupIDs,omitempty"`
	ClearGroups                      *bool                           `json:"clearGroups,omitempty"`
	AddTemplateIDs                   []string                        `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs                []string                        `json:"removeTemplateIDs,omitempty"`
	ClearTemplates                   *bool                           `json:"clearTemplates,omitempty"`
	AddIntegrationIDs                []string                        `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs             []string                        `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations                *bool                           `json:"clearIntegrations,omitempty"`
	AddDocumentIDs                   []string                        `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs                []string                        `json:"removeDocumentIDs,omitempty"`
	ClearDocuments                   *bool                           `json:"clearDocuments,omitempty"`
	AddOrgSubscriptionIDs            []string                        `json:"addOrgSubscriptionIDs,omitempty"`
	RemoveOrgSubscriptionIDs         []string                        `json:"removeOrgSubscriptionIDs,omitempty"`
	ClearOrgSubscriptions            *bool                           `json:"clearOrgSubscriptions,omitempty"`
	AddInviteIDs                     []string                        `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs                  []string                        `json:"removeInviteIDs,omitempty"`
	ClearInvites                     *bool                           `json:"clearInvites,omitempty"`
	AddSubscriberIDs                 []string                        `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs              []string                        `json:"removeSubscriberIDs,omitempty"`
	ClearSubscribers                 *bool                           `json:"clearSubscribers,omitempty"`
	AddEntityIDs                     []string                        `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs                  []string                        `json:"removeEntityIDs,omitempty"`
	ClearEntities                    *bool                           `json:"clearEntities,omitempty"`
	AddEntityTypeIDs                 []string                        `json:"addEntityTypeIDs,omitempty"`
	RemoveEntityTypeIDs              []string                        `json:"removeEntityTypeIDs,omitempty"`
	ClearEntityTypes                 *bool                           `json:"clearEntityTypes,omitempty"`
	AddContactIDs                    []string                        `json:"addContactIDs,omitempty"`
	RemoveContactIDs                 []string                        `json:"removeContactIDs,omitempty"`
	ClearContacts                    *bool                           `json:"clearContacts,omitempty"`
	AddNoteIDs                       []string                        `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs                    []string                        `json:"removeNoteIDs,omitempty"`
	ClearNotes                       *bool                           `json:"clearNotes,omitempty"`
	AddTaskIDs                       []string                        `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                    []string                        `json:"removeTaskIDs,omitempty"`
	ClearTasks                       *bool                           `json:"clearTasks,omitempty"`
	AddProgramIDs                    []string                        `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs                 []string                        `json:"removeProgramIDs,omitempty"`
	ClearPrograms                    *bool                           `json:"clearPrograms,omitempty"`
	AddProcedureIDs                  []string                        `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs               []string                        `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                  *bool                           `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs             []string                        `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs          []string                        `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies            *bool                           `json:"clearInternalPolicies,omitempty"`
	AddRiskIDs                       []string                        `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                    []string                        `json:"removeRiskIDs,omitempty"`
	ClearRisks                       *bool                           `json:"clearRisks,omitempty"`
	AddControlObjectiveIDs           []string                        `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs        []string                        `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives           *bool                           `json:"clearControlObjectives,omitempty"`
	AddNarrativeIDs                  []string                        `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs               []string                        `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives                  *bool                           `json:"clearNarratives,omitempty"`
	AddControlIDs                    []string                        `json:"addControlIDs,omitempty"`
	RemoveControlIDs                 []string                        `json:"removeControlIDs,omitempty"`
	ClearControls                    *bool                           `json:"clearControls,omitempty"`
	AddSubcontrolIDs                 []string                        `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs              []string                        `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols                 *bool                           `json:"clearSubcontrols,omitempty"`
	AddEvidenceIDs                   []string                        `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs                []string                        `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                    *bool                           `json:"clearEvidence,omitempty"`
	AddStandardIDs                   []string                        `json:"addStandardIDs,omitempty"`
	RemoveStandardIDs                []string                        `json:"removeStandardIDs,omitempty"`
	ClearStandards                   *bool                           `json:"clearStandards,omitempty"`
	AddActionPlanIDs                 []string                        `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs              []string                        `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans                 *bool                           `json:"clearActionPlans,omitempty"`
	AddOrgMembers                    []*CreateOrgMembershipInput     `json:"addOrgMembers,omitempty"`
	RemoveOrgMembers                 []string                        `json:"removeOrgMembers,omitempty"`
	UpdateOrgSettings                *UpdateOrganizationSettingInput `json:"updateOrgSettings,omitempty"`
}

// UpdateOrganizationSettingInput is used for update OrganizationSetting object.
// Input was generated by ent.
type UpdateOrganizationSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// Name of the person to contact for billing
	BillingContact      *string `json:"billingContact,omitempty"`
	ClearBillingContact *bool   `json:"clearBillingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail      *string `json:"billingEmail,omitempty"`
	ClearBillingEmail *bool   `json:"clearBillingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone      *string `json:"billingPhone,omitempty"`
	ClearBillingPhone *bool   `json:"clearBillingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress      *models.Address `json:"billingAddress,omitempty"`
	ClearBillingAddress *bool           `json:"clearBillingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier      *string `json:"taxIdentifier,omitempty"`
	ClearTaxIdentifier *bool   `json:"clearTaxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation      *enums.Region `json:"geoLocation,omitempty"`
	ClearGeoLocation *bool         `json:"clearGeoLocation,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled *bool `json:"billingNotificationsEnabled,omitempty"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains       []string `json:"allowedEmailDomains,omitempty"`
	AppendAllowedEmailDomains []string `json:"appendAllowedEmailDomains,omitempty"`
	ClearAllowedEmailDomains  *bool    `json:"clearAllowedEmailDomains,omitempty"`
	OrganizationID            *string  `json:"organizationID,omitempty"`
	ClearOrganization         *bool    `json:"clearOrganization,omitempty"`
	AddFileIDs                []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs             []string `json:"removeFileIDs,omitempty"`
	ClearFiles                *bool    `json:"clearFiles,omitempty"`
}

// UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
// Input was generated by ent.
type UpdatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// a description of the token's purpose
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	Scopes           []string   `json:"scopes,omitempty"`
	AppendScopes     []string   `json:"appendScopes,omitempty"`
	ClearScopes      *bool      `json:"clearScopes,omitempty"`
	LastUsedAt       *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt  *bool      `json:"clearLastUsedAt,omitempty"`
	// whether the token is active
	IsActive              *bool    `json:"isActive,omitempty"`
	ClearIsActive         *bool    `json:"clearIsActive,omitempty"`
	AddOrganizationIDs    []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations    *bool    `json:"clearOrganizations,omitempty"`
	AddEventIDs           []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool    `json:"clearEvents,omitempty"`
}

// UpdateProcedureInput is used for update Procedure object.
// Input was generated by ent.
type UpdateProcedureInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// the name of the procedure
	Name *string `json:"name,omitempty"`
	// status of the procedure, e.g. draft, published, archived, etc.
	Status      *enums.DocumentStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// type of the procedure, e.g. compliance, operational, health and safety, etc.
	ProcedureType      *string `json:"procedureType,omitempty"`
	ClearProcedureType *bool   `json:"clearProcedureType,omitempty"`
	// details of the procedure
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// whether approval is required for edits to the procedure
	ApprovalRequired      *bool `json:"approvalRequired,omitempty"`
	ClearApprovalRequired *bool `json:"clearApprovalRequired,omitempty"`
	// the date the procedure should be reviewed, calculated based on the review_frequency if not directly set
	ReviewDue      *time.Time `json:"reviewDue,omitempty"`
	ClearReviewDue *bool      `json:"clearReviewDue,omitempty"`
	// the frequency at which the procedure should be reviewed, used to calculate the review_due date
	ReviewFrequency         *enums.Frequency    `json:"reviewFrequency,omitempty"`
	ClearReviewFrequency    *bool               `json:"clearReviewFrequency,omitempty"`
	OwnerID                 *string             `json:"ownerID,omitempty"`
	ClearOwner              *bool               `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs      []string            `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string            `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool               `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string            `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string            `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool               `json:"clearEditors,omitempty"`
	ApproverID              *string             `json:"approverID,omitempty"`
	ClearApprover           *bool               `json:"clearApprover,omitempty"`
	DelegateID              *string             `json:"delegateID,omitempty"`
	ClearDelegate           *bool               `json:"clearDelegate,omitempty"`
	AddControlIDs           []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string            `json:"removeControlIDs,omitempty"`
	ClearControls           *bool               `json:"clearControls,omitempty"`
	AddInternalPolicyIDs    []string            `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string            `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool               `json:"clearInternalPolicies,omitempty"`
	AddProgramIDs           []string            `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string            `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool               `json:"clearPrograms,omitempty"`
	AddNarrativeIDs         []string            `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs      []string            `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives         *bool               `json:"clearNarratives,omitempty"`
	AddRiskIDs              []string            `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs           []string            `json:"removeRiskIDs,omitempty"`
	ClearRisks              *bool               `json:"clearRisks,omitempty"`
	AddTaskIDs              []string            `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string            `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool               `json:"clearTasks,omitempty"`
	RevisionBump            *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateProgramInput is used for update Program object.
// Input was generated by ent.
type UpdateProgramInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the program
	Name *string `json:"name,omitempty"`
	// the description of the program
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the status of the program
	Status *enums.ProgramStatus `json:"status,omitempty"`
	// the start date of the period
	StartDate      *time.Time `json:"startDate,omitempty"`
	ClearStartDate *bool      `json:"clearStartDate,omitempty"`
	// the end date of the period
	EndDate      *time.Time `json:"endDate,omitempty"`
	ClearEndDate *bool      `json:"clearEndDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady *bool `json:"auditorReady,omitempty"`
	// can the auditor write comments
	AuditorWriteComments *bool `json:"auditorWriteComments,omitempty"`
	// can the auditor read comments
	AuditorReadComments       *bool                           `json:"auditorReadComments,omitempty"`
	OwnerID                   *string                         `json:"ownerID,omitempty"`
	ClearOwner                *bool                           `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs        []string                        `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs     []string                        `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups        *bool                           `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs              []string                        `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs           []string                        `json:"removeEditorIDs,omitempty"`
	ClearEditors              *bool                           `json:"clearEditors,omitempty"`
	AddViewerIDs              []string                        `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs           []string                        `json:"removeViewerIDs,omitempty"`
	ClearViewers              *bool                           `json:"clearViewers,omitempty"`
	AddControlIDs             []string                        `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string                        `json:"removeControlIDs,omitempty"`
	ClearControls             *bool                           `json:"clearControls,omitempty"`
	AddSubcontrolIDs          []string                        `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string                        `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols          *bool                           `json:"clearSubcontrols,omitempty"`
	AddControlObjectiveIDs    []string                        `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string                        `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool                           `json:"clearControlObjectives,omitempty"`
	AddInternalPolicyIDs      []string                        `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs   []string                        `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies     *bool                           `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs           []string                        `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string                        `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool                           `json:"clearProcedures,omitempty"`
	AddRiskIDs                []string                        `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs             []string                        `json:"removeRiskIDs,omitempty"`
	ClearRisks                *bool                           `json:"clearRisks,omitempty"`
	AddTaskIDs                []string                        `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string                        `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool                           `json:"clearTasks,omitempty"`
	AddNoteIDs                []string                        `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs             []string                        `json:"removeNoteIDs,omitempty"`
	ClearNotes                *bool                           `json:"clearNotes,omitempty"`
	AddFileIDs                []string                        `json:"addFileIDs,omitempty"`
	RemoveFileIDs             []string                        `json:"removeFileIDs,omitempty"`
	ClearFiles                *bool                           `json:"clearFiles,omitempty"`
	AddEvidenceIDs            []string                        `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs         []string                        `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence             *bool                           `json:"clearEvidence,omitempty"`
	AddNarrativeIDs           []string                        `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string                        `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool                           `json:"clearNarratives,omitempty"`
	AddActionPlanIDs          []string                        `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs       []string                        `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans          *bool                           `json:"clearActionPlans,omitempty"`
	AddProgramMembers         []*CreateProgramMembershipInput `json:"addProgramMembers,omitempty"`
	RemoveProgramMembers      []string                        `json:"removeProgramMembers,omitempty"`
}

// UpdateProgramMembershipInput is used for update ProgramMembership object.
// Input was generated by ent.
type UpdateProgramMembershipInput struct {
	Role *enums.Role `json:"role,omitempty"`
}

// UpdateRiskInput is used for update Risk object.
// Input was generated by ent.
type UpdateRiskInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the risk
	Name *string `json:"name,omitempty"`
	// status of the risk - open, mitigated, ongoing, in-progress, and archived.
	Status      *enums.RiskStatus `json:"status,omitempty"`
	ClearStatus *bool             `json:"clearStatus,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType      *string `json:"riskType,omitempty"`
	ClearRiskType *bool   `json:"clearRiskType,omitempty"`
	// category of the risk, e.g. human resources, operations, IT, etc.
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// impact of the risk -critical, high, medium, low
	Impact      *enums.RiskImpact `json:"impact,omitempty"`
	ClearImpact *bool             `json:"clearImpact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood      *enums.RiskLikelihood `json:"likelihood,omitempty"`
	ClearLikelihood *bool                 `json:"clearLikelihood,omitempty"`
	// score of the risk based on impact and likelihood (1-4 unlikely, 5-9 likely, 10-16 highly likely, 17-20 critical)
	Score      *int64 `json:"score,omitempty"`
	ClearScore *bool  `json:"clearScore,omitempty"`
	// mitigation for the risk
	Mitigation      *string `json:"mitigation,omitempty"`
	ClearMitigation *bool   `json:"clearMitigation,omitempty"`
	// details of the risk
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// business costs associated with the risk
	BusinessCosts         *string  `json:"businessCosts,omitempty"`
	ClearBusinessCosts    *bool    `json:"clearBusinessCosts,omitempty"`
	AddBlockedGroupIDs    []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs          []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool    `json:"clearViewers,omitempty"`
	AddControlIDs         []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs      []string `json:"removeControlIDs,omitempty"`
	ClearControls         *bool    `json:"clearControls,omitempty"`
	AddProcedureIDs       []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs    []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures       *bool    `json:"clearProcedures,omitempty"`
	AddProgramIDs         []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs      []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms         *bool    `json:"clearPrograms,omitempty"`
	AddActionPlanIDs      []string `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs   []string `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans      *bool    `json:"clearActionPlans,omitempty"`
	StakeholderID         *string  `json:"stakeholderID,omitempty"`
	ClearStakeholder      *bool    `json:"clearStakeholder,omitempty"`
	DelegateID            *string  `json:"delegateID,omitempty"`
	ClearDelegate         *bool    `json:"clearDelegate,omitempty"`
}

// UpdateStandardInput is used for update Standard object.
// Input was generated by ent.
type UpdateStandardInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// revision of the object as a semver (e.g. v1.0.0), by default any update will bump the patch version, unless the revision_bump field is set
	Revision      *string `json:"revision,omitempty"`
	ClearRevision *bool   `json:"clearRevision,omitempty"`
	// the long name of the standard body
	Name *string `json:"name,omitempty"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName      *string `json:"shortName,omitempty"`
	ClearShortName *bool   `json:"clearShortName,omitempty"`
	// unique identifier of the standard with version
	Framework      *string `json:"framework,omitempty"`
	ClearFramework *bool   `json:"clearFramework,omitempty"`
	// long description of the standard with details of what is covered
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// URL to the logo of the governing body
	GoverningBodyLogoURL      *string `json:"governingBodyLogoURL,omitempty"`
	ClearGoverningBodyLogoURL *bool   `json:"clearGoverningBodyLogoURL,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody      *string `json:"governingBody,omitempty"`
	ClearGoverningBody *bool   `json:"clearGoverningBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// link to the official standard documentation
	Link      *string `json:"link,omitempty"`
	ClearLink *bool   `json:"clearLink,omitempty"`
	// status of the standard - active, draft, and archived
	Status      *enums.StandardStatus `json:"status,omitempty"`
	ClearStatus *bool                 `json:"clearStatus,omitempty"`
	// indicates if the standard should be made available to all users, only for system owned standards
	IsPublic      *bool `json:"isPublic,omitempty"`
	ClearIsPublic *bool `json:"clearIsPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for system owned standards
	FreeToUse      *bool `json:"freeToUse,omitempty"`
	ClearFreeToUse *bool `json:"clearFreeToUse,omitempty"`
	// type of the standard - cybersecurity, healthcare , financial, etc.
	StandardType      *string `json:"standardType,omitempty"`
	ClearStandardType *bool   `json:"clearStandardType,omitempty"`
	// version of the standard
	Version          *string             `json:"version,omitempty"`
	ClearVersion     *bool               `json:"clearVersion,omitempty"`
	OwnerID          *string             `json:"ownerID,omitempty"`
	ClearOwner       *bool               `json:"clearOwner,omitempty"`
	AddControlIDs    []string            `json:"addControlIDs,omitempty"`
	RemoveControlIDs []string            `json:"removeControlIDs,omitempty"`
	ClearControls    *bool               `json:"clearControls,omitempty"`
	RevisionBump     *models.VersionBump `json:"RevisionBump,omitempty"`
}

// UpdateSubcontrolInput is used for update Subcontrol object.
// Input was generated by ent.
type UpdateSubcontrolInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// description of what the control is supposed to accomplish
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the control
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType      *enums.ControlType `json:"controlType,omitempty"`
	ClearControlType *bool              `json:"clearControlType,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// category id of the control
	CategoryID      *string `json:"categoryID,omitempty"`
	ClearCategoryID *bool   `json:"clearCategoryID,omitempty"`
	// subcategory of the control
	Subcategory      *string `json:"subcategory,omitempty"`
	ClearSubcategory *bool   `json:"clearSubcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories       []string `json:"mappedCategories,omitempty"`
	AppendMappedCategories []string `json:"appendMappedCategories,omitempty"`
	ClearMappedCategories  *bool    `json:"clearMappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives       []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	AppendAssessmentObjectives []*models.AssessmentObjective `json:"appendAssessmentObjectives,omitempty"`
	ClearAssessmentObjectives  *bool                         `json:"clearAssessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods       []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	AppendAssessmentMethods []*models.AssessmentMethod `json:"appendAssessmentMethods,omitempty"`
	ClearAssessmentMethods  *bool                      `json:"clearAssessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions       []string `json:"controlQuestions,omitempty"`
	AppendControlQuestions []string `json:"appendControlQuestions,omitempty"`
	ClearControlQuestions  *bool    `json:"clearControlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance       []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	AppendImplementationGuidance []*models.ImplementationGuidance `json:"appendImplementationGuidance,omitempty"`
	ClearImplementationGuidance  *bool                            `json:"clearImplementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence       []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	AppendExampleEvidence []*models.ExampleEvidence `json:"appendExampleEvidence,omitempty"`
	ClearExampleEvidence  *bool                     `json:"clearExampleEvidence,omitempty"`
	// references for the control
	References       []*models.Reference `json:"references,omitempty"`
	AppendReferences []*models.Reference `json:"appendReferences,omitempty"`
	ClearReferences  *bool               `json:"clearReferences,omitempty"`
	// the unique reference code for the control
	RefCode                   *string  `json:"refCode,omitempty"`
	ControlID                 *string  `json:"controlID,omitempty"`
	AddMappedControlIDs       []string `json:"addMappedControlIDs,omitempty"`
	RemoveMappedControlIDs    []string `json:"removeMappedControlIDs,omitempty"`
	ClearMappedControls       *bool    `json:"clearMappedControls,omitempty"`
	AddEvidenceIDs            []string `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs         []string `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence             *bool    `json:"clearEvidence,omitempty"`
	AddControlObjectiveIDs    []string `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool    `json:"clearControlObjectives,omitempty"`
	AddTaskIDs                []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool    `json:"clearTasks,omitempty"`
	AddNarrativeIDs           []string `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool    `json:"clearNarratives,omitempty"`
	AddRiskIDs                []string `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs             []string `json:"removeRiskIDs,omitempty"`
	ClearRisks                *bool    `json:"clearRisks,omitempty"`
	AddActionPlanIDs          []string `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs       []string `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans          *bool    `json:"clearActionPlans,omitempty"`
	AddProcedureIDs           []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool    `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs      []string `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs   []string `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies     *bool    `json:"clearInternalPolicies,omitempty"`
	ControlOwnerID            *string  `json:"controlOwnerID,omitempty"`
	ClearControlOwner         *bool    `json:"clearControlOwner,omitempty"`
	DelegateID                *string  `json:"delegateID,omitempty"`
	ClearDelegate             *bool    `json:"clearDelegate,omitempty"`
}

// UpdateSubscriberInput is used for update Subscriber object.
// Input was generated by ent.
type UpdateSubscriberInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// email address of the subscriber
	Email *string `json:"email,omitempty"`
	// phone number of the subscriber
	PhoneNumber      *string `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool   `json:"clearPhoneNumber,omitempty"`
	// indicates if the subscriber has unsubscribed from communications
	Unsubscribed   *bool    `json:"unsubscribed,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	ClearOwner     *bool    `json:"clearOwner,omitempty"`
	AddEventIDs    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool    `json:"clearEvents,omitempty"`
}

// UpdateTFASettingInput is used for update TFASetting object.
// Input was generated by ent.
type UpdateTFASettingInput struct {
	// specifies if the TFA device has been verified
	Verified *bool `json:"verified,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed      *bool `json:"totpAllowed,omitempty"`
	ClearTotpAllowed *bool `json:"clearTotpAllowed,omitempty"`
	// Whether to regenerate backup codes
	RegenBackupCodes *bool `json:"regenBackupCodes,omitempty"`
}

// UpdateTaskInput is used for update Task object.
// Input was generated by ent.
type UpdateTaskInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the title of the task
	Title *string `json:"title,omitempty"`
	// the description of the task
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the details of the task
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// the status of the task
	Status *enums.TaskStatus `json:"status,omitempty"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// the due date of the task
	Due      *time.Time `json:"due,omitempty"`
	ClearDue *bool      `json:"clearDue,omitempty"`
	// the completion date of the task
	Completed                 *time.Time       `json:"completed,omitempty"`
	ClearCompleted            *bool            `json:"clearCompleted,omitempty"`
	AssignerID                *string          `json:"assignerID,omitempty"`
	ClearAssigner             *bool            `json:"clearAssigner,omitempty"`
	AssigneeID                *string          `json:"assigneeID,omitempty"`
	ClearAssignee             *bool            `json:"clearAssignee,omitempty"`
	AddCommentIDs             []string         `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs          []string         `json:"removeCommentIDs,omitempty"`
	ClearComments             *bool            `json:"clearComments,omitempty"`
	AddGroupIDs               []string         `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs            []string         `json:"removeGroupIDs,omitempty"`
	ClearGroups               *bool            `json:"clearGroups,omitempty"`
	AddInternalPolicyIDs      []string         `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs   []string         `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies     *bool            `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs           []string         `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string         `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool            `json:"clearProcedures,omitempty"`
	AddControlIDs             []string         `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string         `json:"removeControlIDs,omitempty"`
	ClearControls             *bool            `json:"clearControls,omitempty"`
	AddSubcontrolIDs          []string         `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string         `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols          *bool            `json:"clearSubcontrols,omitempty"`
	AddControlObjectiveIDs    []string         `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string         `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool            `json:"clearControlObjectives,omitempty"`
	AddProgramIDs             []string         `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string         `json:"removeProgramIDs,omitempty"`
	ClearPrograms             *bool            `json:"clearPrograms,omitempty"`
	AddEvidenceIDs            []string         `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs         []string         `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence             *bool            `json:"clearEvidence,omitempty"`
	AddComment                *CreateNoteInput `json:"addComment,omitempty"`
	DeleteComment             *string          `json:"deleteComment,omitempty"`
}

// UpdateTemplateInput is used for update Template object.
// Input was generated by ent.
type UpdateTemplateInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the template
	Name *string `json:"name,omitempty"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig,omitempty"`
	// the uischema for the template to render in the UI
	Uischema          map[string]any `json:"uischema,omitempty"`
	ClearUischema     *bool          `json:"clearUischema,omitempty"`
	OwnerID           *string        `json:"ownerID,omitempty"`
	ClearOwner        *bool          `json:"clearOwner,omitempty"`
	AddDocumentIDs    []string       `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs []string       `json:"removeDocumentIDs,omitempty"`
	ClearDocuments    *bool          `json:"clearDocuments,omitempty"`
	AddFileIDs        []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string       `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool          `json:"clearFiles,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	// tags associated with the object
	Tags           []string `json:"tags,omitempty"`
	AppendTags     []string `json:"appendTags,omitempty"`
	ClearTags      *bool    `json:"clearTags,omitempty"`
	Email          *string  `json:"email,omitempty"`
	FirstName      *string  `json:"firstName,omitempty"`
	ClearFirstName *bool    `json:"clearFirstName,omitempty"`
	LastName       *string  `json:"lastName,omitempty"`
	ClearLastName  *bool    `json:"clearLastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen      *time.Time `json:"lastSeen,omitempty"`
	ClearLastSeen *bool      `json:"clearLastSeen,omitempty"`
	// user password hash
	Password      *string `json:"password,omitempty"`
	ClearPassword *bool   `json:"clearPassword,omitempty"`
	// the Subject of the user JWT
	Sub      *string `json:"sub,omitempty"`
	ClearSub *bool   `json:"clearSub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role                            *enums.Role `json:"role,omitempty"`
	ClearRole                       *bool       `json:"clearRole,omitempty"`
	AddPersonalAccessTokenIDs       []string    `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs    []string    `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens       *bool       `json:"clearPersonalAccessTokens,omitempty"`
	AddTfaSettingIDs                []string    `json:"addTfaSettingIDs,omitempty"`
	RemoveTfaSettingIDs             []string    `json:"removeTfaSettingIDs,omitempty"`
	ClearTfaSettings                *bool       `json:"clearTfaSettings,omitempty"`
	SettingID                       *string     `json:"settingID,omitempty"`
	AddEmailVerificationTokenIDs    []string    `json:"addEmailVerificationTokenIDs,omitempty"`
	RemoveEmailVerificationTokenIDs []string    `json:"removeEmailVerificationTokenIDs,omitempty"`
	ClearEmailVerificationTokens    *bool       `json:"clearEmailVerificationTokens,omitempty"`
	AddPasswordResetTokenIDs        []string    `json:"addPasswordResetTokenIDs,omitempty"`
	RemovePasswordResetTokenIDs     []string    `json:"removePasswordResetTokenIDs,omitempty"`
	ClearPasswordResetTokens        *bool       `json:"clearPasswordResetTokens,omitempty"`
	AddGroupIDs                     []string    `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                  []string    `json:"removeGroupIDs,omitempty"`
	ClearGroups                     *bool       `json:"clearGroups,omitempty"`
	AddOrganizationIDs              []string    `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs           []string    `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations              *bool       `json:"clearOrganizations,omitempty"`
	AddWebauthnIDs                  []string    `json:"addWebauthnIDs,omitempty"`
	RemoveWebauthnIDs               []string    `json:"removeWebauthnIDs,omitempty"`
	ClearWebauthn                   *bool       `json:"clearWebauthn,omitempty"`
	AddFileIDs                      []string    `json:"addFileIDs,omitempty"`
	RemoveFileIDs                   []string    `json:"removeFileIDs,omitempty"`
	ClearFiles                      *bool       `json:"clearFiles,omitempty"`
	AvatarFileID                    *string     `json:"avatarFileID,omitempty"`
	ClearAvatarFile                 *bool       `json:"clearAvatarFile,omitempty"`
	AddEventIDs                     []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs                  []string    `json:"removeEventIDs,omitempty"`
	ClearEvents                     *bool       `json:"clearEvents,omitempty"`
	AddActionPlanIDs                []string    `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs             []string    `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans                *bool       `json:"clearActionPlans,omitempty"`
	AddSubcontrolIDs                []string    `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs             []string    `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols                *bool       `json:"clearSubcontrols,omitempty"`
	AddAssignerTaskIDs              []string    `json:"addAssignerTaskIDs,omitempty"`
	RemoveAssignerTaskIDs           []string    `json:"removeAssignerTaskIDs,omitempty"`
	ClearAssignerTasks              *bool       `json:"clearAssignerTasks,omitempty"`
	AddAssigneeTaskIDs              []string    `json:"addAssigneeTaskIDs,omitempty"`
	RemoveAssigneeTaskIDs           []string    `json:"removeAssigneeTaskIDs,omitempty"`
	ClearAssigneeTasks              *bool       `json:"clearAssigneeTasks,omitempty"`
	AddProgramIDs                   []string    `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs                []string    `json:"removeProgramIDs,omitempty"`
	ClearPrograms                   *bool       `json:"clearPrograms,omitempty"`
}

// UpdateUserSettingInput is used for update UserSetting object.
// Input was generated by ent.
type UpdateUserSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed      *bool `json:"isWebauthnAllowed,omitempty"`
	ClearIsWebauthnAllowed *bool `json:"clearIsWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled      *bool    `json:"isTfaEnabled,omitempty"`
	ClearIsTfaEnabled *bool    `json:"clearIsTfaEnabled,omitempty"`
	UserID            *string  `json:"userID,omitempty"`
	ClearUser         *bool    `json:"clearUser,omitempty"`
	DefaultOrgID      *string  `json:"defaultOrgID,omitempty"`
	ClearDefaultOrg   *bool    `json:"clearDefaultOrg,omitempty"`
	AddFileIDs        []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool    `json:"clearFiles,omitempty"`
}

type User struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role                 *enums.Role                    `json:"role,omitempty"`
	PersonalAccessTokens *PersonalAccessTokenConnection `json:"personalAccessTokens"`
	TfaSettings          *TFASettingConnection          `json:"tfaSettings"`
	Setting              *UserSetting                   `json:"setting"`
	Groups               *GroupConnection               `json:"groups"`
	Organizations        *OrganizationConnection        `json:"organizations"`
	Files                *FileConnection                `json:"files"`
	AvatarFile           *File                          `json:"avatarFile,omitempty"`
	Events               *EventConnection               `json:"events"`
	ActionPlans          *ActionPlanConnection          `json:"actionPlans"`
	Subcontrols          *SubcontrolConnection          `json:"subcontrols"`
	AssignerTasks        *TaskConnection                `json:"assignerTasks"`
	AssigneeTasks        *TaskConnection                `json:"assigneeTasks"`
	Programs             []*Program                     `json:"programs,omitempty"`
	GroupMemberships     *GroupMembershipConnection     `json:"groupMemberships"`
	OrgMemberships       *OrgMembershipConnection       `json:"orgMemberships"`
	ProgramMemberships   []*ProgramMembership           `json:"programMemberships,omitempty"`
}

func (User) IsNode() {}

// Return response for createBulkUser mutation
type UserBulkCreatePayload struct {
	// Created users
	Users []*User `json:"users,omitempty"`
}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User *User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role *enums.Role `json:"role,omitempty"`
}

func (UserHistory) IsNode() {}

// A connection to a list of items.
type UserHistoryConnection struct {
	// A list of edges.
	Edges []*UserHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for UserHistory connections
type UserHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserHistories.
	Field UserHistoryOrderField `json:"field"`
}

// UserHistoryWhereInput is used for filtering UserHistory objects.
// Input was generated by ent.
type UserHistoryWhereInput struct {
	Not *UserHistoryWhereInput   `json:"not,omitempty"`
	And []*UserHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

type UserSearchResult struct {
	Users []*User `json:"users,omitempty"`
}

func (UserSearchResult) IsSearchResult() {}

type UserSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags   []string `json:"tags,omitempty"`
	UserID *string  `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
	User         *User `json:"user,omitempty"`
	// organization to load on user login
	DefaultOrg *Organization   `json:"defaultOrg,omitempty"`
	Files      *FileConnection `json:"files"`
}

func (UserSetting) IsNode() {}

// Return response for createBulkUserSetting mutation
type UserSettingBulkCreatePayload struct {
	// Created userSettings
	UserSettings []*UserSetting `json:"userSettings,omitempty"`
}

// A connection to a list of items.
type UserSettingConnection struct {
	// A list of edges.
	Edges []*UserSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUserSetting mutation
type UserSettingCreatePayload struct {
	// Created userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// An edge in a connection.
type UserSettingEdge struct {
	// The item at the end of the edge.
	Node *UserSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags   []string `json:"tags,omitempty"`
	UserID *string  `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
}

func (UserSettingHistory) IsNode() {}

// A connection to a list of items.
type UserSettingHistoryConnection struct {
	// A list of edges.
	Edges []*UserSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for UserSettingHistory connections
type UserSettingHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserSettingHistories.
	Field UserSettingHistoryOrderField `json:"field"`
}

// UserSettingHistoryWhereInput is used for filtering UserSettingHistory objects.
// Input was generated by ent.
type UserSettingHistoryWhereInput struct {
	Not *UserSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*UserSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_webauthn_allowed field predicates
	IsWebauthnAllowed       *bool `json:"isWebauthnAllowed,omitempty"`
	IsWebauthnAllowedNeq    *bool `json:"isWebauthnAllowedNEQ,omitempty"`
	IsWebauthnAllowedIsNil  *bool `json:"isWebauthnAllowedIsNil,omitempty"`
	IsWebauthnAllowedNotNil *bool `json:"isWebauthnAllowedNotNil,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
}

// Ordering options for UserSetting connections
type UserSettingOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserSettings.
	Field UserSettingOrderField `json:"field"`
}

type UserSettingSearchResult struct {
	UserSettings []*UserSetting `json:"userSettings,omitempty"`
}

func (UserSettingSearchResult) IsSearchResult() {}

// Return response for updateUserSetting mutation
type UserSettingUpdatePayload struct {
	// Updated userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// UserSettingWhereInput is used for filtering UserSetting objects.
// Input was generated by ent.
type UserSettingWhereInput struct {
	Not *UserSettingWhereInput   `json:"not,omitempty"`
	And []*UserSettingWhereInput `json:"and,omitempty"`
	Or  []*UserSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_webauthn_allowed field predicates
	IsWebauthnAllowed       *bool `json:"isWebauthnAllowed,omitempty"`
	IsWebauthnAllowedNeq    *bool `json:"isWebauthnAllowedNEQ,omitempty"`
	IsWebauthnAllowedIsNil  *bool `json:"isWebauthnAllowedIsNil,omitempty"`
	IsWebauthnAllowedNotNil *bool `json:"isWebauthnAllowedNotNil,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// default_org edge predicates
	HasDefaultOrg     *bool                     `json:"hasDefaultOrg,omitempty"`
	HasDefaultOrgWith []*OrganizationWhereInput `json:"hasDefaultOrgWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User *User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// tfa_settings edge predicates
	HasTfaSettings     *bool                   `json:"hasTfaSettings,omitempty"`
	HasTfaSettingsWith []*TFASettingWhereInput `json:"hasTfaSettingsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                    `json:"hasSetting,omitempty"`
	HasSettingWith []*UserSettingWhereInput `json:"hasSettingWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// avatar_file edge predicates
	HasAvatarFile     *bool             `json:"hasAvatarFile,omitempty"`
	HasAvatarFileWith []*FileWhereInput `json:"hasAvatarFileWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// assigner_tasks edge predicates
	HasAssignerTasks     *bool             `json:"hasAssignerTasks,omitempty"`
	HasAssignerTasksWith []*TaskWhereInput `json:"hasAssignerTasksWith,omitempty"`
	// assignee_tasks edge predicates
	HasAssigneeTasks     *bool             `json:"hasAssigneeTasks,omitempty"`
	HasAssigneeTasksWith []*TaskWhereInput `json:"hasAssigneeTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// group_memberships edge predicates
	HasGroupMemberships     *bool                        `json:"hasGroupMemberships,omitempty"`
	HasGroupMembershipsWith []*GroupMembershipWhereInput `json:"hasGroupMembershipsWith,omitempty"`
	// org_memberships edge predicates
	HasOrgMemberships     *bool                      `json:"hasOrgMemberships,omitempty"`
	HasOrgMembershipsWith []*OrgMembershipWhereInput `json:"hasOrgMembershipsWith,omitempty"`
	// program_memberships edge predicates
	HasProgramMemberships     *bool                          `json:"hasProgramMemberships,omitempty"`
	HasProgramMembershipsWith []*ProgramMembershipWhereInput `json:"hasProgramMembershipsWith,omitempty"`
}

// Properties by which APIToken connections can be ordered.
type APITokenOrderField string

const (
	APITokenOrderFieldCreatedAt  APITokenOrderField = "created_at"
	APITokenOrderFieldUpdatedAt  APITokenOrderField = "updated_at"
	APITokenOrderFieldExpiresAt  APITokenOrderField = "expires_at"
	APITokenOrderFieldLastUsedAt APITokenOrderField = "last_used_at"
)

var AllAPITokenOrderField = []APITokenOrderField{
	APITokenOrderFieldCreatedAt,
	APITokenOrderFieldUpdatedAt,
	APITokenOrderFieldExpiresAt,
	APITokenOrderFieldLastUsedAt,
}

func (e APITokenOrderField) IsValid() bool {
	switch e {
	case APITokenOrderFieldCreatedAt, APITokenOrderFieldUpdatedAt, APITokenOrderFieldExpiresAt, APITokenOrderFieldLastUsedAt:
		return true
	}
	return false
}

func (e APITokenOrderField) String() string {
	return string(e)
}

func (e *APITokenOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APITokenOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid APITokenOrderField", str)
	}
	return nil
}

func (e APITokenOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ActionPlanHistory connections can be ordered.
type ActionPlanHistoryOrderField string

const (
	ActionPlanHistoryOrderFieldCreatedAt       ActionPlanHistoryOrderField = "created_at"
	ActionPlanHistoryOrderFieldUpdatedAt       ActionPlanHistoryOrderField = "updated_at"
	ActionPlanHistoryOrderFieldRevision        ActionPlanHistoryOrderField = "revision"
	ActionPlanHistoryOrderFieldName            ActionPlanHistoryOrderField = "name"
	ActionPlanHistoryOrderFieldStatus          ActionPlanHistoryOrderField = "STATUS"
	ActionPlanHistoryOrderFieldReviewDue       ActionPlanHistoryOrderField = "review_due"
	ActionPlanHistoryOrderFieldReviewFrequency ActionPlanHistoryOrderField = "REVIEW_FREQUENCY"
	ActionPlanHistoryOrderFieldDueDate         ActionPlanHistoryOrderField = "due_date"
	ActionPlanHistoryOrderFieldPriority        ActionPlanHistoryOrderField = "PRIORITY"
	ActionPlanHistoryOrderFieldSource          ActionPlanHistoryOrderField = "source"
)

var AllActionPlanHistoryOrderField = []ActionPlanHistoryOrderField{
	ActionPlanHistoryOrderFieldCreatedAt,
	ActionPlanHistoryOrderFieldUpdatedAt,
	ActionPlanHistoryOrderFieldRevision,
	ActionPlanHistoryOrderFieldName,
	ActionPlanHistoryOrderFieldStatus,
	ActionPlanHistoryOrderFieldReviewDue,
	ActionPlanHistoryOrderFieldReviewFrequency,
	ActionPlanHistoryOrderFieldDueDate,
	ActionPlanHistoryOrderFieldPriority,
	ActionPlanHistoryOrderFieldSource,
}

func (e ActionPlanHistoryOrderField) IsValid() bool {
	switch e {
	case ActionPlanHistoryOrderFieldCreatedAt, ActionPlanHistoryOrderFieldUpdatedAt, ActionPlanHistoryOrderFieldRevision, ActionPlanHistoryOrderFieldName, ActionPlanHistoryOrderFieldStatus, ActionPlanHistoryOrderFieldReviewDue, ActionPlanHistoryOrderFieldReviewFrequency, ActionPlanHistoryOrderFieldDueDate, ActionPlanHistoryOrderFieldPriority, ActionPlanHistoryOrderFieldSource:
		return true
	}
	return false
}

func (e ActionPlanHistoryOrderField) String() string {
	return string(e)
}

func (e *ActionPlanHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionPlanHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionPlanHistoryOrderField", str)
	}
	return nil
}

func (e ActionPlanHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ActionPlan connections can be ordered.
type ActionPlanOrderField string

const (
	ActionPlanOrderFieldCreatedAt       ActionPlanOrderField = "created_at"
	ActionPlanOrderFieldUpdatedAt       ActionPlanOrderField = "updated_at"
	ActionPlanOrderFieldRevision        ActionPlanOrderField = "revision"
	ActionPlanOrderFieldName            ActionPlanOrderField = "name"
	ActionPlanOrderFieldStatus          ActionPlanOrderField = "STATUS"
	ActionPlanOrderFieldReviewDue       ActionPlanOrderField = "review_due"
	ActionPlanOrderFieldReviewFrequency ActionPlanOrderField = "REVIEW_FREQUENCY"
	ActionPlanOrderFieldDueDate         ActionPlanOrderField = "due_date"
	ActionPlanOrderFieldPriority        ActionPlanOrderField = "PRIORITY"
	ActionPlanOrderFieldSource          ActionPlanOrderField = "source"
)

var AllActionPlanOrderField = []ActionPlanOrderField{
	ActionPlanOrderFieldCreatedAt,
	ActionPlanOrderFieldUpdatedAt,
	ActionPlanOrderFieldRevision,
	ActionPlanOrderFieldName,
	ActionPlanOrderFieldStatus,
	ActionPlanOrderFieldReviewDue,
	ActionPlanOrderFieldReviewFrequency,
	ActionPlanOrderFieldDueDate,
	ActionPlanOrderFieldPriority,
	ActionPlanOrderFieldSource,
}

func (e ActionPlanOrderField) IsValid() bool {
	switch e {
	case ActionPlanOrderFieldCreatedAt, ActionPlanOrderFieldUpdatedAt, ActionPlanOrderFieldRevision, ActionPlanOrderFieldName, ActionPlanOrderFieldStatus, ActionPlanOrderFieldReviewDue, ActionPlanOrderFieldReviewFrequency, ActionPlanOrderFieldDueDate, ActionPlanOrderFieldPriority, ActionPlanOrderFieldSource:
		return true
	}
	return false
}

func (e ActionPlanOrderField) String() string {
	return string(e)
}

func (e *ActionPlanOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionPlanOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionPlanOrderField", str)
	}
	return nil
}

func (e ActionPlanOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ContactHistory connections can be ordered.
type ContactHistoryOrderField string

const (
	ContactHistoryOrderFieldCreatedAt ContactHistoryOrderField = "created_at"
	ContactHistoryOrderFieldUpdatedAt ContactHistoryOrderField = "updated_at"
	ContactHistoryOrderFieldFullName  ContactHistoryOrderField = "full_name"
	ContactHistoryOrderFieldTitle     ContactHistoryOrderField = "title"
	ContactHistoryOrderFieldCompany   ContactHistoryOrderField = "company"
	ContactHistoryOrderFieldEmail     ContactHistoryOrderField = "email"
	ContactHistoryOrderFieldStatus    ContactHistoryOrderField = "STATUS"
)

var AllContactHistoryOrderField = []ContactHistoryOrderField{
	ContactHistoryOrderFieldCreatedAt,
	ContactHistoryOrderFieldUpdatedAt,
	ContactHistoryOrderFieldFullName,
	ContactHistoryOrderFieldTitle,
	ContactHistoryOrderFieldCompany,
	ContactHistoryOrderFieldEmail,
	ContactHistoryOrderFieldStatus,
}

func (e ContactHistoryOrderField) IsValid() bool {
	switch e {
	case ContactHistoryOrderFieldCreatedAt, ContactHistoryOrderFieldUpdatedAt, ContactHistoryOrderFieldFullName, ContactHistoryOrderFieldTitle, ContactHistoryOrderFieldCompany, ContactHistoryOrderFieldEmail, ContactHistoryOrderFieldStatus:
		return true
	}
	return false
}

func (e ContactHistoryOrderField) String() string {
	return string(e)
}

func (e *ContactHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContactHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContactHistoryOrderField", str)
	}
	return nil
}

func (e ContactHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Contact connections can be ordered.
type ContactOrderField string

const (
	ContactOrderFieldCreatedAt ContactOrderField = "created_at"
	ContactOrderFieldUpdatedAt ContactOrderField = "updated_at"
	ContactOrderFieldFullName  ContactOrderField = "full_name"
	ContactOrderFieldTitle     ContactOrderField = "title"
	ContactOrderFieldCompany   ContactOrderField = "company"
	ContactOrderFieldEmail     ContactOrderField = "email"
	ContactOrderFieldStatus    ContactOrderField = "STATUS"
)

var AllContactOrderField = []ContactOrderField{
	ContactOrderFieldCreatedAt,
	ContactOrderFieldUpdatedAt,
	ContactOrderFieldFullName,
	ContactOrderFieldTitle,
	ContactOrderFieldCompany,
	ContactOrderFieldEmail,
	ContactOrderFieldStatus,
}

func (e ContactOrderField) IsValid() bool {
	switch e {
	case ContactOrderFieldCreatedAt, ContactOrderFieldUpdatedAt, ContactOrderFieldFullName, ContactOrderFieldTitle, ContactOrderFieldCompany, ContactOrderFieldEmail, ContactOrderFieldStatus:
		return true
	}
	return false
}

func (e ContactOrderField) String() string {
	return string(e)
}

func (e *ContactOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContactOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContactOrderField", str)
	}
	return nil
}

func (e ContactOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ControlHistory connections can be ordered.
type ControlHistoryOrderField string

const (
	ControlHistoryOrderFieldCreatedAt   ControlHistoryOrderField = "created_at"
	ControlHistoryOrderFieldUpdatedAt   ControlHistoryOrderField = "updated_at"
	ControlHistoryOrderFieldStatus      ControlHistoryOrderField = "status"
	ControlHistoryOrderFieldSource      ControlHistoryOrderField = "SOURCE"
	ControlHistoryOrderFieldControlType ControlHistoryOrderField = "CONTROL_TYPE"
	ControlHistoryOrderFieldCategory    ControlHistoryOrderField = "category"
	ControlHistoryOrderFieldSubcategory ControlHistoryOrderField = "subcategory"
	ControlHistoryOrderFieldRefCode     ControlHistoryOrderField = "ref_code"
)

var AllControlHistoryOrderField = []ControlHistoryOrderField{
	ControlHistoryOrderFieldCreatedAt,
	ControlHistoryOrderFieldUpdatedAt,
	ControlHistoryOrderFieldStatus,
	ControlHistoryOrderFieldSource,
	ControlHistoryOrderFieldControlType,
	ControlHistoryOrderFieldCategory,
	ControlHistoryOrderFieldSubcategory,
	ControlHistoryOrderFieldRefCode,
}

func (e ControlHistoryOrderField) IsValid() bool {
	switch e {
	case ControlHistoryOrderFieldCreatedAt, ControlHistoryOrderFieldUpdatedAt, ControlHistoryOrderFieldStatus, ControlHistoryOrderFieldSource, ControlHistoryOrderFieldControlType, ControlHistoryOrderFieldCategory, ControlHistoryOrderFieldSubcategory, ControlHistoryOrderFieldRefCode:
		return true
	}
	return false
}

func (e ControlHistoryOrderField) String() string {
	return string(e)
}

func (e *ControlHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlHistoryOrderField", str)
	}
	return nil
}

func (e ControlHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ControlImplementationHistory connections can be ordered.
type ControlImplementationHistoryOrderField string

const (
	ControlImplementationHistoryOrderFieldCreatedAt          ControlImplementationHistoryOrderField = "created_at"
	ControlImplementationHistoryOrderFieldUpdatedAt          ControlImplementationHistoryOrderField = "updated_at"
	ControlImplementationHistoryOrderFieldStatus             ControlImplementationHistoryOrderField = "STATUS"
	ControlImplementationHistoryOrderFieldImplementationDate ControlImplementationHistoryOrderField = "implementation_date"
	ControlImplementationHistoryOrderFieldVerified           ControlImplementationHistoryOrderField = "verified"
	ControlImplementationHistoryOrderFieldVerificationDate   ControlImplementationHistoryOrderField = "verification_date"
)

var AllControlImplementationHistoryOrderField = []ControlImplementationHistoryOrderField{
	ControlImplementationHistoryOrderFieldCreatedAt,
	ControlImplementationHistoryOrderFieldUpdatedAt,
	ControlImplementationHistoryOrderFieldStatus,
	ControlImplementationHistoryOrderFieldImplementationDate,
	ControlImplementationHistoryOrderFieldVerified,
	ControlImplementationHistoryOrderFieldVerificationDate,
}

func (e ControlImplementationHistoryOrderField) IsValid() bool {
	switch e {
	case ControlImplementationHistoryOrderFieldCreatedAt, ControlImplementationHistoryOrderFieldUpdatedAt, ControlImplementationHistoryOrderFieldStatus, ControlImplementationHistoryOrderFieldImplementationDate, ControlImplementationHistoryOrderFieldVerified, ControlImplementationHistoryOrderFieldVerificationDate:
		return true
	}
	return false
}

func (e ControlImplementationHistoryOrderField) String() string {
	return string(e)
}

func (e *ControlImplementationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlImplementationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlImplementationHistoryOrderField", str)
	}
	return nil
}

func (e ControlImplementationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ControlImplementation connections can be ordered.
type ControlImplementationOrderField string

const (
	ControlImplementationOrderFieldCreatedAt          ControlImplementationOrderField = "created_at"
	ControlImplementationOrderFieldUpdatedAt          ControlImplementationOrderField = "updated_at"
	ControlImplementationOrderFieldStatus             ControlImplementationOrderField = "STATUS"
	ControlImplementationOrderFieldImplementationDate ControlImplementationOrderField = "implementation_date"
	ControlImplementationOrderFieldVerified           ControlImplementationOrderField = "verified"
	ControlImplementationOrderFieldVerificationDate   ControlImplementationOrderField = "verification_date"
)

var AllControlImplementationOrderField = []ControlImplementationOrderField{
	ControlImplementationOrderFieldCreatedAt,
	ControlImplementationOrderFieldUpdatedAt,
	ControlImplementationOrderFieldStatus,
	ControlImplementationOrderFieldImplementationDate,
	ControlImplementationOrderFieldVerified,
	ControlImplementationOrderFieldVerificationDate,
}

func (e ControlImplementationOrderField) IsValid() bool {
	switch e {
	case ControlImplementationOrderFieldCreatedAt, ControlImplementationOrderFieldUpdatedAt, ControlImplementationOrderFieldStatus, ControlImplementationOrderFieldImplementationDate, ControlImplementationOrderFieldVerified, ControlImplementationOrderFieldVerificationDate:
		return true
	}
	return false
}

func (e ControlImplementationOrderField) String() string {
	return string(e)
}

func (e *ControlImplementationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlImplementationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlImplementationOrderField", str)
	}
	return nil
}

func (e ControlImplementationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ControlObjectiveHistory connections can be ordered.
type ControlObjectiveHistoryOrderField string

const (
	ControlObjectiveHistoryOrderFieldCreatedAt            ControlObjectiveHistoryOrderField = "created_at"
	ControlObjectiveHistoryOrderFieldUpdatedAt            ControlObjectiveHistoryOrderField = "updated_at"
	ControlObjectiveHistoryOrderFieldRevision             ControlObjectiveHistoryOrderField = "revision"
	ControlObjectiveHistoryOrderFieldName                 ControlObjectiveHistoryOrderField = "name"
	ControlObjectiveHistoryOrderFieldStatus               ControlObjectiveHistoryOrderField = "status"
	ControlObjectiveHistoryOrderFieldSource               ControlObjectiveHistoryOrderField = "SOURCE"
	ControlObjectiveHistoryOrderFieldControlObjectiveType ControlObjectiveHistoryOrderField = "control_objective_type"
	ControlObjectiveHistoryOrderFieldCategory             ControlObjectiveHistoryOrderField = "category"
	ControlObjectiveHistoryOrderFieldSubcategory          ControlObjectiveHistoryOrderField = "subcategory"
)

var AllControlObjectiveHistoryOrderField = []ControlObjectiveHistoryOrderField{
	ControlObjectiveHistoryOrderFieldCreatedAt,
	ControlObjectiveHistoryOrderFieldUpdatedAt,
	ControlObjectiveHistoryOrderFieldRevision,
	ControlObjectiveHistoryOrderFieldName,
	ControlObjectiveHistoryOrderFieldStatus,
	ControlObjectiveHistoryOrderFieldSource,
	ControlObjectiveHistoryOrderFieldControlObjectiveType,
	ControlObjectiveHistoryOrderFieldCategory,
	ControlObjectiveHistoryOrderFieldSubcategory,
}

func (e ControlObjectiveHistoryOrderField) IsValid() bool {
	switch e {
	case ControlObjectiveHistoryOrderFieldCreatedAt, ControlObjectiveHistoryOrderFieldUpdatedAt, ControlObjectiveHistoryOrderFieldRevision, ControlObjectiveHistoryOrderFieldName, ControlObjectiveHistoryOrderFieldStatus, ControlObjectiveHistoryOrderFieldSource, ControlObjectiveHistoryOrderFieldControlObjectiveType, ControlObjectiveHistoryOrderFieldCategory, ControlObjectiveHistoryOrderFieldSubcategory:
		return true
	}
	return false
}

func (e ControlObjectiveHistoryOrderField) String() string {
	return string(e)
}

func (e *ControlObjectiveHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlObjectiveHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlObjectiveHistoryOrderField", str)
	}
	return nil
}

func (e ControlObjectiveHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ControlObjective connections can be ordered.
type ControlObjectiveOrderField string

const (
	ControlObjectiveOrderFieldCreatedAt            ControlObjectiveOrderField = "created_at"
	ControlObjectiveOrderFieldUpdatedAt            ControlObjectiveOrderField = "updated_at"
	ControlObjectiveOrderFieldRevision             ControlObjectiveOrderField = "revision"
	ControlObjectiveOrderFieldName                 ControlObjectiveOrderField = "name"
	ControlObjectiveOrderFieldStatus               ControlObjectiveOrderField = "status"
	ControlObjectiveOrderFieldSource               ControlObjectiveOrderField = "SOURCE"
	ControlObjectiveOrderFieldControlObjectiveType ControlObjectiveOrderField = "control_objective_type"
	ControlObjectiveOrderFieldCategory             ControlObjectiveOrderField = "category"
	ControlObjectiveOrderFieldSubcategory          ControlObjectiveOrderField = "subcategory"
)

var AllControlObjectiveOrderField = []ControlObjectiveOrderField{
	ControlObjectiveOrderFieldCreatedAt,
	ControlObjectiveOrderFieldUpdatedAt,
	ControlObjectiveOrderFieldRevision,
	ControlObjectiveOrderFieldName,
	ControlObjectiveOrderFieldStatus,
	ControlObjectiveOrderFieldSource,
	ControlObjectiveOrderFieldControlObjectiveType,
	ControlObjectiveOrderFieldCategory,
	ControlObjectiveOrderFieldSubcategory,
}

func (e ControlObjectiveOrderField) IsValid() bool {
	switch e {
	case ControlObjectiveOrderFieldCreatedAt, ControlObjectiveOrderFieldUpdatedAt, ControlObjectiveOrderFieldRevision, ControlObjectiveOrderFieldName, ControlObjectiveOrderFieldStatus, ControlObjectiveOrderFieldSource, ControlObjectiveOrderFieldControlObjectiveType, ControlObjectiveOrderFieldCategory, ControlObjectiveOrderFieldSubcategory:
		return true
	}
	return false
}

func (e ControlObjectiveOrderField) String() string {
	return string(e)
}

func (e *ControlObjectiveOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlObjectiveOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlObjectiveOrderField", str)
	}
	return nil
}

func (e ControlObjectiveOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Control connections can be ordered.
type ControlOrderField string

const (
	ControlOrderFieldCreatedAt   ControlOrderField = "created_at"
	ControlOrderFieldUpdatedAt   ControlOrderField = "updated_at"
	ControlOrderFieldStatus      ControlOrderField = "status"
	ControlOrderFieldSource      ControlOrderField = "SOURCE"
	ControlOrderFieldControlType ControlOrderField = "CONTROL_TYPE"
	ControlOrderFieldCategory    ControlOrderField = "category"
	ControlOrderFieldSubcategory ControlOrderField = "subcategory"
	ControlOrderFieldRefCode     ControlOrderField = "ref_code"
)

var AllControlOrderField = []ControlOrderField{
	ControlOrderFieldCreatedAt,
	ControlOrderFieldUpdatedAt,
	ControlOrderFieldStatus,
	ControlOrderFieldSource,
	ControlOrderFieldControlType,
	ControlOrderFieldCategory,
	ControlOrderFieldSubcategory,
	ControlOrderFieldRefCode,
}

func (e ControlOrderField) IsValid() bool {
	switch e {
	case ControlOrderFieldCreatedAt, ControlOrderFieldUpdatedAt, ControlOrderFieldStatus, ControlOrderFieldSource, ControlOrderFieldControlType, ControlOrderFieldCategory, ControlOrderFieldSubcategory, ControlOrderFieldRefCode:
		return true
	}
	return false
}

func (e ControlOrderField) String() string {
	return string(e)
}

func (e *ControlOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ControlOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ControlOrderField", str)
	}
	return nil
}

func (e ControlOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which DocumentDataHistory connections can be ordered.
type DocumentDataHistoryOrderField string

const (
	DocumentDataHistoryOrderFieldCreatedAt DocumentDataHistoryOrderField = "created_at"
	DocumentDataHistoryOrderFieldUpdatedAt DocumentDataHistoryOrderField = "updated_at"
)

var AllDocumentDataHistoryOrderField = []DocumentDataHistoryOrderField{
	DocumentDataHistoryOrderFieldCreatedAt,
	DocumentDataHistoryOrderFieldUpdatedAt,
}

func (e DocumentDataHistoryOrderField) IsValid() bool {
	switch e {
	case DocumentDataHistoryOrderFieldCreatedAt, DocumentDataHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DocumentDataHistoryOrderField) String() string {
	return string(e)
}

func (e *DocumentDataHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DocumentDataHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DocumentDataHistoryOrderField", str)
	}
	return nil
}

func (e DocumentDataHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which DocumentData connections can be ordered.
type DocumentDataOrderField string

const (
	DocumentDataOrderFieldCreatedAt DocumentDataOrderField = "created_at"
	DocumentDataOrderFieldUpdatedAt DocumentDataOrderField = "updated_at"
)

var AllDocumentDataOrderField = []DocumentDataOrderField{
	DocumentDataOrderFieldCreatedAt,
	DocumentDataOrderFieldUpdatedAt,
}

func (e DocumentDataOrderField) IsValid() bool {
	switch e {
	case DocumentDataOrderFieldCreatedAt, DocumentDataOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e DocumentDataOrderField) String() string {
	return string(e)
}

func (e *DocumentDataOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DocumentDataOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DocumentDataOrderField", str)
	}
	return nil
}

func (e DocumentDataOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityHistory connections can be ordered.
type EntityHistoryOrderField string

const (
	EntityHistoryOrderFieldCreatedAt   EntityHistoryOrderField = "created_at"
	EntityHistoryOrderFieldUpdatedAt   EntityHistoryOrderField = "updated_at"
	EntityHistoryOrderFieldName        EntityHistoryOrderField = "name"
	EntityHistoryOrderFieldDisplayName EntityHistoryOrderField = "display_name"
	EntityHistoryOrderFieldStatus      EntityHistoryOrderField = "status"
)

var AllEntityHistoryOrderField = []EntityHistoryOrderField{
	EntityHistoryOrderFieldCreatedAt,
	EntityHistoryOrderFieldUpdatedAt,
	EntityHistoryOrderFieldName,
	EntityHistoryOrderFieldDisplayName,
	EntityHistoryOrderFieldStatus,
}

func (e EntityHistoryOrderField) IsValid() bool {
	switch e {
	case EntityHistoryOrderFieldCreatedAt, EntityHistoryOrderFieldUpdatedAt, EntityHistoryOrderFieldName, EntityHistoryOrderFieldDisplayName, EntityHistoryOrderFieldStatus:
		return true
	}
	return false
}

func (e EntityHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

func (e EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Entity connections can be ordered.
type EntityOrderField string

const (
	EntityOrderFieldCreatedAt   EntityOrderField = "created_at"
	EntityOrderFieldUpdatedAt   EntityOrderField = "updated_at"
	EntityOrderFieldName        EntityOrderField = "name"
	EntityOrderFieldDisplayName EntityOrderField = "display_name"
	EntityOrderFieldStatus      EntityOrderField = "status"
)

var AllEntityOrderField = []EntityOrderField{
	EntityOrderFieldCreatedAt,
	EntityOrderFieldUpdatedAt,
	EntityOrderFieldName,
	EntityOrderFieldDisplayName,
	EntityOrderFieldStatus,
}

func (e EntityOrderField) IsValid() bool {
	switch e {
	case EntityOrderFieldCreatedAt, EntityOrderFieldUpdatedAt, EntityOrderFieldName, EntityOrderFieldDisplayName, EntityOrderFieldStatus:
		return true
	}
	return false
}

func (e EntityOrderField) String() string {
	return string(e)
}

func (e *EntityOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

func (e EntityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityTypeHistory connections can be ordered.
type EntityTypeHistoryOrderField string

const (
	EntityTypeHistoryOrderFieldCreatedAt EntityTypeHistoryOrderField = "created_at"
	EntityTypeHistoryOrderFieldUpdatedAt EntityTypeHistoryOrderField = "updated_at"
	EntityTypeHistoryOrderFieldName      EntityTypeHistoryOrderField = "name"
)

var AllEntityTypeHistoryOrderField = []EntityTypeHistoryOrderField{
	EntityTypeHistoryOrderFieldCreatedAt,
	EntityTypeHistoryOrderFieldUpdatedAt,
	EntityTypeHistoryOrderFieldName,
}

func (e EntityTypeHistoryOrderField) IsValid() bool {
	switch e {
	case EntityTypeHistoryOrderFieldCreatedAt, EntityTypeHistoryOrderFieldUpdatedAt, EntityTypeHistoryOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityTypeHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

func (e EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityType connections can be ordered.
type EntityTypeOrderField string

const (
	EntityTypeOrderFieldCreatedAt EntityTypeOrderField = "created_at"
	EntityTypeOrderFieldUpdatedAt EntityTypeOrderField = "updated_at"
	EntityTypeOrderFieldName      EntityTypeOrderField = "name"
)

var AllEntityTypeOrderField = []EntityTypeOrderField{
	EntityTypeOrderFieldCreatedAt,
	EntityTypeOrderFieldUpdatedAt,
	EntityTypeOrderFieldName,
}

func (e EntityTypeOrderField) IsValid() bool {
	switch e {
	case EntityTypeOrderFieldCreatedAt, EntityTypeOrderFieldUpdatedAt, EntityTypeOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeOrderField) String() string {
	return string(e)
}

func (e *EntityTypeOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

func (e EntityTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EventHistory connections can be ordered.
type EventHistoryOrderField string

const (
	EventHistoryOrderFieldCreatedAt EventHistoryOrderField = "created_at"
	EventHistoryOrderFieldUpdatedAt EventHistoryOrderField = "updated_at"
)

var AllEventHistoryOrderField = []EventHistoryOrderField{
	EventHistoryOrderFieldCreatedAt,
	EventHistoryOrderFieldUpdatedAt,
}

func (e EventHistoryOrderField) IsValid() bool {
	switch e {
	case EventHistoryOrderFieldCreatedAt, EventHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e EventHistoryOrderField) String() string {
	return string(e)
}

func (e *EventHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventHistoryOrderField", str)
	}
	return nil
}

func (e EventHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Event connections can be ordered.
type EventOrderField string

const (
	EventOrderFieldCreatedAt EventOrderField = "created_at"
	EventOrderFieldUpdatedAt EventOrderField = "updated_at"
)

var AllEventOrderField = []EventOrderField{
	EventOrderFieldCreatedAt,
	EventOrderFieldUpdatedAt,
}

func (e EventOrderField) IsValid() bool {
	switch e {
	case EventOrderFieldCreatedAt, EventOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e EventOrderField) String() string {
	return string(e)
}

func (e *EventOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventOrderField", str)
	}
	return nil
}

func (e EventOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EvidenceHistory connections can be ordered.
type EvidenceHistoryOrderField string

const (
	EvidenceHistoryOrderFieldCreatedAt    EvidenceHistoryOrderField = "created_at"
	EvidenceHistoryOrderFieldUpdatedAt    EvidenceHistoryOrderField = "updated_at"
	EvidenceHistoryOrderFieldName         EvidenceHistoryOrderField = "name"
	EvidenceHistoryOrderFieldCreationDate EvidenceHistoryOrderField = "creation_date"
	EvidenceHistoryOrderFieldRenewalDate  EvidenceHistoryOrderField = "renewal_date"
	EvidenceHistoryOrderFieldStatus       EvidenceHistoryOrderField = "STATUS"
)

var AllEvidenceHistoryOrderField = []EvidenceHistoryOrderField{
	EvidenceHistoryOrderFieldCreatedAt,
	EvidenceHistoryOrderFieldUpdatedAt,
	EvidenceHistoryOrderFieldName,
	EvidenceHistoryOrderFieldCreationDate,
	EvidenceHistoryOrderFieldRenewalDate,
	EvidenceHistoryOrderFieldStatus,
}

func (e EvidenceHistoryOrderField) IsValid() bool {
	switch e {
	case EvidenceHistoryOrderFieldCreatedAt, EvidenceHistoryOrderFieldUpdatedAt, EvidenceHistoryOrderFieldName, EvidenceHistoryOrderFieldCreationDate, EvidenceHistoryOrderFieldRenewalDate, EvidenceHistoryOrderFieldStatus:
		return true
	}
	return false
}

func (e EvidenceHistoryOrderField) String() string {
	return string(e)
}

func (e *EvidenceHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EvidenceHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EvidenceHistoryOrderField", str)
	}
	return nil
}

func (e EvidenceHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Evidence connections can be ordered.
type EvidenceOrderField string

const (
	EvidenceOrderFieldCreatedAt    EvidenceOrderField = "created_at"
	EvidenceOrderFieldUpdatedAt    EvidenceOrderField = "updated_at"
	EvidenceOrderFieldName         EvidenceOrderField = "name"
	EvidenceOrderFieldCreationDate EvidenceOrderField = "creation_date"
	EvidenceOrderFieldRenewalDate  EvidenceOrderField = "renewal_date"
	EvidenceOrderFieldStatus       EvidenceOrderField = "STATUS"
)

var AllEvidenceOrderField = []EvidenceOrderField{
	EvidenceOrderFieldCreatedAt,
	EvidenceOrderFieldUpdatedAt,
	EvidenceOrderFieldName,
	EvidenceOrderFieldCreationDate,
	EvidenceOrderFieldRenewalDate,
	EvidenceOrderFieldStatus,
}

func (e EvidenceOrderField) IsValid() bool {
	switch e {
	case EvidenceOrderFieldCreatedAt, EvidenceOrderFieldUpdatedAt, EvidenceOrderFieldName, EvidenceOrderFieldCreationDate, EvidenceOrderFieldRenewalDate, EvidenceOrderFieldStatus:
		return true
	}
	return false
}

func (e EvidenceOrderField) String() string {
	return string(e)
}

func (e *EvidenceOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EvidenceOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EvidenceOrderField", str)
	}
	return nil
}

func (e EvidenceOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which FileHistory connections can be ordered.
type FileHistoryOrderField string

const (
	FileHistoryOrderFieldCreatedAt FileHistoryOrderField = "created_at"
	FileHistoryOrderFieldUpdatedAt FileHistoryOrderField = "updated_at"
)

var AllFileHistoryOrderField = []FileHistoryOrderField{
	FileHistoryOrderFieldCreatedAt,
	FileHistoryOrderFieldUpdatedAt,
}

func (e FileHistoryOrderField) IsValid() bool {
	switch e {
	case FileHistoryOrderFieldCreatedAt, FileHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e FileHistoryOrderField) String() string {
	return string(e)
}

func (e *FileHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileHistoryOrderField", str)
	}
	return nil
}

func (e FileHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which File connections can be ordered.
type FileOrderField string

const (
	FileOrderFieldCreatedAt FileOrderField = "created_at"
	FileOrderFieldUpdatedAt FileOrderField = "updated_at"
)

var AllFileOrderField = []FileOrderField{
	FileOrderFieldCreatedAt,
	FileOrderFieldUpdatedAt,
}

func (e FileOrderField) IsValid() bool {
	switch e {
	case FileOrderFieldCreatedAt, FileOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e FileOrderField) String() string {
	return string(e)
}

func (e *FileOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileOrderField", str)
	}
	return nil
}

func (e FileOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GroupHistory connections can be ordered.
type GroupHistoryOrderField string

const (
	GroupHistoryOrderFieldCreatedAt   GroupHistoryOrderField = "created_at"
	GroupHistoryOrderFieldUpdatedAt   GroupHistoryOrderField = "updated_at"
	GroupHistoryOrderFieldName        GroupHistoryOrderField = "name"
	GroupHistoryOrderFieldDisplayName GroupHistoryOrderField = "display_name"
)

var AllGroupHistoryOrderField = []GroupHistoryOrderField{
	GroupHistoryOrderFieldCreatedAt,
	GroupHistoryOrderFieldUpdatedAt,
	GroupHistoryOrderFieldName,
	GroupHistoryOrderFieldDisplayName,
}

func (e GroupHistoryOrderField) IsValid() bool {
	switch e {
	case GroupHistoryOrderFieldCreatedAt, GroupHistoryOrderFieldUpdatedAt, GroupHistoryOrderFieldName, GroupHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

func (e GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GroupMembershipHistory connections can be ordered.
type GroupMembershipHistoryOrderField string

const (
	GroupMembershipHistoryOrderFieldCreatedAt GroupMembershipHistoryOrderField = "created_at"
	GroupMembershipHistoryOrderFieldUpdatedAt GroupMembershipHistoryOrderField = "updated_at"
	GroupMembershipHistoryOrderFieldRole      GroupMembershipHistoryOrderField = "ROLE"
)

var AllGroupMembershipHistoryOrderField = []GroupMembershipHistoryOrderField{
	GroupMembershipHistoryOrderFieldCreatedAt,
	GroupMembershipHistoryOrderFieldUpdatedAt,
	GroupMembershipHistoryOrderFieldRole,
}

func (e GroupMembershipHistoryOrderField) IsValid() bool {
	switch e {
	case GroupMembershipHistoryOrderFieldCreatedAt, GroupMembershipHistoryOrderFieldUpdatedAt, GroupMembershipHistoryOrderFieldRole:
		return true
	}
	return false
}

func (e GroupMembershipHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupMembershipHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupMembershipHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupMembershipHistoryOrderField", str)
	}
	return nil
}

func (e GroupMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GroupMembership connections can be ordered.
type GroupMembershipOrderField string

const (
	GroupMembershipOrderFieldCreatedAt GroupMembershipOrderField = "created_at"
	GroupMembershipOrderFieldUpdatedAt GroupMembershipOrderField = "updated_at"
	GroupMembershipOrderFieldRole      GroupMembershipOrderField = "ROLE"
)

var AllGroupMembershipOrderField = []GroupMembershipOrderField{
	GroupMembershipOrderFieldCreatedAt,
	GroupMembershipOrderFieldUpdatedAt,
	GroupMembershipOrderFieldRole,
}

func (e GroupMembershipOrderField) IsValid() bool {
	switch e {
	case GroupMembershipOrderFieldCreatedAt, GroupMembershipOrderFieldUpdatedAt, GroupMembershipOrderFieldRole:
		return true
	}
	return false
}

func (e GroupMembershipOrderField) String() string {
	return string(e)
}

func (e *GroupMembershipOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupMembershipOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupMembershipOrderField", str)
	}
	return nil
}

func (e GroupMembershipOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Group connections can be ordered.
type GroupOrderField string

const (
	GroupOrderFieldCreatedAt   GroupOrderField = "created_at"
	GroupOrderFieldUpdatedAt   GroupOrderField = "updated_at"
	GroupOrderFieldName        GroupOrderField = "name"
	GroupOrderFieldDisplayName GroupOrderField = "display_name"
)

var AllGroupOrderField = []GroupOrderField{
	GroupOrderFieldCreatedAt,
	GroupOrderFieldUpdatedAt,
	GroupOrderFieldName,
	GroupOrderFieldDisplayName,
}

func (e GroupOrderField) IsValid() bool {
	switch e {
	case GroupOrderFieldCreatedAt, GroupOrderFieldUpdatedAt, GroupOrderFieldName, GroupOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupOrderField) String() string {
	return string(e)
}

func (e *GroupOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

func (e GroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GroupSettingHistory connections can be ordered.
type GroupSettingHistoryOrderField string

const (
	GroupSettingHistoryOrderFieldCreatedAt GroupSettingHistoryOrderField = "created_at"
	GroupSettingHistoryOrderFieldUpdatedAt GroupSettingHistoryOrderField = "updated_at"
)

var AllGroupSettingHistoryOrderField = []GroupSettingHistoryOrderField{
	GroupSettingHistoryOrderFieldCreatedAt,
	GroupSettingHistoryOrderFieldUpdatedAt,
}

func (e GroupSettingHistoryOrderField) IsValid() bool {
	switch e {
	case GroupSettingHistoryOrderFieldCreatedAt, GroupSettingHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e GroupSettingHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupSettingHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupSettingHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupSettingHistoryOrderField", str)
	}
	return nil
}

func (e GroupSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GroupSetting connections can be ordered.
type GroupSettingOrderField string

const (
	GroupSettingOrderFieldCreatedAt GroupSettingOrderField = "created_at"
	GroupSettingOrderFieldUpdatedAt GroupSettingOrderField = "updated_at"
)

var AllGroupSettingOrderField = []GroupSettingOrderField{
	GroupSettingOrderFieldCreatedAt,
	GroupSettingOrderFieldUpdatedAt,
}

func (e GroupSettingOrderField) IsValid() bool {
	switch e {
	case GroupSettingOrderFieldCreatedAt, GroupSettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e GroupSettingOrderField) String() string {
	return string(e)
}

func (e *GroupSettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupSettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupSettingOrderField", str)
	}
	return nil
}

func (e GroupSettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which HushHistory connections can be ordered.
type HushHistoryOrderField string

const (
	HushHistoryOrderFieldCreatedAt HushHistoryOrderField = "created_at"
	HushHistoryOrderFieldUpdatedAt HushHistoryOrderField = "updated_at"
	HushHistoryOrderFieldName      HushHistoryOrderField = "name"
	HushHistoryOrderFieldKind      HushHistoryOrderField = "kind"
)

var AllHushHistoryOrderField = []HushHistoryOrderField{
	HushHistoryOrderFieldCreatedAt,
	HushHistoryOrderFieldUpdatedAt,
	HushHistoryOrderFieldName,
	HushHistoryOrderFieldKind,
}

func (e HushHistoryOrderField) IsValid() bool {
	switch e {
	case HushHistoryOrderFieldCreatedAt, HushHistoryOrderFieldUpdatedAt, HushHistoryOrderFieldName, HushHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e HushHistoryOrderField) String() string {
	return string(e)
}

func (e *HushHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

func (e HushHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Hush connections can be ordered.
type HushOrderField string

const (
	HushOrderFieldCreatedAt HushOrderField = "created_at"
	HushOrderFieldUpdatedAt HushOrderField = "updated_at"
	HushOrderFieldName      HushOrderField = "name"
	HushOrderFieldKind      HushOrderField = "kind"
)

var AllHushOrderField = []HushOrderField{
	HushOrderFieldCreatedAt,
	HushOrderFieldUpdatedAt,
	HushOrderFieldName,
	HushOrderFieldKind,
}

func (e HushOrderField) IsValid() bool {
	switch e {
	case HushOrderFieldCreatedAt, HushOrderFieldUpdatedAt, HushOrderFieldName, HushOrderFieldKind:
		return true
	}
	return false
}

func (e HushOrderField) String() string {
	return string(e)
}

func (e *HushOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

func (e HushOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which IntegrationHistory connections can be ordered.
type IntegrationHistoryOrderField string

const (
	IntegrationHistoryOrderFieldCreatedAt IntegrationHistoryOrderField = "created_at"
	IntegrationHistoryOrderFieldUpdatedAt IntegrationHistoryOrderField = "updated_at"
	IntegrationHistoryOrderFieldName      IntegrationHistoryOrderField = "name"
	IntegrationHistoryOrderFieldKind      IntegrationHistoryOrderField = "kind"
)

var AllIntegrationHistoryOrderField = []IntegrationHistoryOrderField{
	IntegrationHistoryOrderFieldCreatedAt,
	IntegrationHistoryOrderFieldUpdatedAt,
	IntegrationHistoryOrderFieldName,
	IntegrationHistoryOrderFieldKind,
}

func (e IntegrationHistoryOrderField) IsValid() bool {
	switch e {
	case IntegrationHistoryOrderFieldCreatedAt, IntegrationHistoryOrderFieldUpdatedAt, IntegrationHistoryOrderFieldName, IntegrationHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationHistoryOrderField) String() string {
	return string(e)
}

func (e *IntegrationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

func (e IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Integration connections can be ordered.
type IntegrationOrderField string

const (
	IntegrationOrderFieldCreatedAt IntegrationOrderField = "created_at"
	IntegrationOrderFieldUpdatedAt IntegrationOrderField = "updated_at"
	IntegrationOrderFieldName      IntegrationOrderField = "name"
	IntegrationOrderFieldKind      IntegrationOrderField = "kind"
)

var AllIntegrationOrderField = []IntegrationOrderField{
	IntegrationOrderFieldCreatedAt,
	IntegrationOrderFieldUpdatedAt,
	IntegrationOrderFieldName,
	IntegrationOrderFieldKind,
}

func (e IntegrationOrderField) IsValid() bool {
	switch e {
	case IntegrationOrderFieldCreatedAt, IntegrationOrderFieldUpdatedAt, IntegrationOrderFieldName, IntegrationOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationOrderField) String() string {
	return string(e)
}

func (e *IntegrationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

func (e IntegrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which InternalPolicyHistory connections can be ordered.
type InternalPolicyHistoryOrderField string

const (
	InternalPolicyHistoryOrderFieldCreatedAt       InternalPolicyHistoryOrderField = "created_at"
	InternalPolicyHistoryOrderFieldUpdatedAt       InternalPolicyHistoryOrderField = "updated_at"
	InternalPolicyHistoryOrderFieldRevision        InternalPolicyHistoryOrderField = "revision"
	InternalPolicyHistoryOrderFieldName            InternalPolicyHistoryOrderField = "name"
	InternalPolicyHistoryOrderFieldStatus          InternalPolicyHistoryOrderField = "STATUS"
	InternalPolicyHistoryOrderFieldReviewDue       InternalPolicyHistoryOrderField = "review_due"
	InternalPolicyHistoryOrderFieldReviewFrequency InternalPolicyHistoryOrderField = "REVIEW_FREQUENCY"
)

var AllInternalPolicyHistoryOrderField = []InternalPolicyHistoryOrderField{
	InternalPolicyHistoryOrderFieldCreatedAt,
	InternalPolicyHistoryOrderFieldUpdatedAt,
	InternalPolicyHistoryOrderFieldRevision,
	InternalPolicyHistoryOrderFieldName,
	InternalPolicyHistoryOrderFieldStatus,
	InternalPolicyHistoryOrderFieldReviewDue,
	InternalPolicyHistoryOrderFieldReviewFrequency,
}

func (e InternalPolicyHistoryOrderField) IsValid() bool {
	switch e {
	case InternalPolicyHistoryOrderFieldCreatedAt, InternalPolicyHistoryOrderFieldUpdatedAt, InternalPolicyHistoryOrderFieldRevision, InternalPolicyHistoryOrderFieldName, InternalPolicyHistoryOrderFieldStatus, InternalPolicyHistoryOrderFieldReviewDue, InternalPolicyHistoryOrderFieldReviewFrequency:
		return true
	}
	return false
}

func (e InternalPolicyHistoryOrderField) String() string {
	return string(e)
}

func (e *InternalPolicyHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InternalPolicyHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InternalPolicyHistoryOrderField", str)
	}
	return nil
}

func (e InternalPolicyHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which InternalPolicy connections can be ordered.
type InternalPolicyOrderField string

const (
	InternalPolicyOrderFieldCreatedAt       InternalPolicyOrderField = "created_at"
	InternalPolicyOrderFieldUpdatedAt       InternalPolicyOrderField = "updated_at"
	InternalPolicyOrderFieldRevision        InternalPolicyOrderField = "revision"
	InternalPolicyOrderFieldName            InternalPolicyOrderField = "name"
	InternalPolicyOrderFieldStatus          InternalPolicyOrderField = "STATUS"
	InternalPolicyOrderFieldReviewDue       InternalPolicyOrderField = "review_due"
	InternalPolicyOrderFieldReviewFrequency InternalPolicyOrderField = "REVIEW_FREQUENCY"
)

var AllInternalPolicyOrderField = []InternalPolicyOrderField{
	InternalPolicyOrderFieldCreatedAt,
	InternalPolicyOrderFieldUpdatedAt,
	InternalPolicyOrderFieldRevision,
	InternalPolicyOrderFieldName,
	InternalPolicyOrderFieldStatus,
	InternalPolicyOrderFieldReviewDue,
	InternalPolicyOrderFieldReviewFrequency,
}

func (e InternalPolicyOrderField) IsValid() bool {
	switch e {
	case InternalPolicyOrderFieldCreatedAt, InternalPolicyOrderFieldUpdatedAt, InternalPolicyOrderFieldRevision, InternalPolicyOrderFieldName, InternalPolicyOrderFieldStatus, InternalPolicyOrderFieldReviewDue, InternalPolicyOrderFieldReviewFrequency:
		return true
	}
	return false
}

func (e InternalPolicyOrderField) String() string {
	return string(e)
}

func (e *InternalPolicyOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InternalPolicyOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InternalPolicyOrderField", str)
	}
	return nil
}

func (e InternalPolicyOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Invite connections can be ordered.
type InviteOrderField string

const (
	InviteOrderFieldCreatedAt    InviteOrderField = "created_at"
	InviteOrderFieldUpdatedAt    InviteOrderField = "updated_at"
	InviteOrderFieldExpires      InviteOrderField = "expires"
	InviteOrderFieldStatus       InviteOrderField = "STATUS"
	InviteOrderFieldSendAttempts InviteOrderField = "send_attempts"
)

var AllInviteOrderField = []InviteOrderField{
	InviteOrderFieldCreatedAt,
	InviteOrderFieldUpdatedAt,
	InviteOrderFieldExpires,
	InviteOrderFieldStatus,
	InviteOrderFieldSendAttempts,
}

func (e InviteOrderField) IsValid() bool {
	switch e {
	case InviteOrderFieldCreatedAt, InviteOrderFieldUpdatedAt, InviteOrderFieldExpires, InviteOrderFieldStatus, InviteOrderFieldSendAttempts:
		return true
	}
	return false
}

func (e InviteOrderField) String() string {
	return string(e)
}

func (e *InviteOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InviteOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InviteOrderField", str)
	}
	return nil
}

func (e InviteOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which MappedControlHistory connections can be ordered.
type MappedControlHistoryOrderField string

const (
	MappedControlHistoryOrderFieldCreatedAt   MappedControlHistoryOrderField = "created_at"
	MappedControlHistoryOrderFieldUpdatedAt   MappedControlHistoryOrderField = "updated_at"
	MappedControlHistoryOrderFieldMappingType MappedControlHistoryOrderField = "mapping_type"
)

var AllMappedControlHistoryOrderField = []MappedControlHistoryOrderField{
	MappedControlHistoryOrderFieldCreatedAt,
	MappedControlHistoryOrderFieldUpdatedAt,
	MappedControlHistoryOrderFieldMappingType,
}

func (e MappedControlHistoryOrderField) IsValid() bool {
	switch e {
	case MappedControlHistoryOrderFieldCreatedAt, MappedControlHistoryOrderFieldUpdatedAt, MappedControlHistoryOrderFieldMappingType:
		return true
	}
	return false
}

func (e MappedControlHistoryOrderField) String() string {
	return string(e)
}

func (e *MappedControlHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MappedControlHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MappedControlHistoryOrderField", str)
	}
	return nil
}

func (e MappedControlHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which MappedControl connections can be ordered.
type MappedControlOrderField string

const (
	MappedControlOrderFieldCreatedAt   MappedControlOrderField = "created_at"
	MappedControlOrderFieldUpdatedAt   MappedControlOrderField = "updated_at"
	MappedControlOrderFieldMappingType MappedControlOrderField = "mapping_type"
)

var AllMappedControlOrderField = []MappedControlOrderField{
	MappedControlOrderFieldCreatedAt,
	MappedControlOrderFieldUpdatedAt,
	MappedControlOrderFieldMappingType,
}

func (e MappedControlOrderField) IsValid() bool {
	switch e {
	case MappedControlOrderFieldCreatedAt, MappedControlOrderFieldUpdatedAt, MappedControlOrderFieldMappingType:
		return true
	}
	return false
}

func (e MappedControlOrderField) String() string {
	return string(e)
}

func (e *MappedControlOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MappedControlOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MappedControlOrderField", str)
	}
	return nil
}

func (e MappedControlOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which NarrativeHistory connections can be ordered.
type NarrativeHistoryOrderField string

const (
	NarrativeHistoryOrderFieldCreatedAt NarrativeHistoryOrderField = "created_at"
	NarrativeHistoryOrderFieldUpdatedAt NarrativeHistoryOrderField = "updated_at"
	NarrativeHistoryOrderFieldName      NarrativeHistoryOrderField = "name"
)

var AllNarrativeHistoryOrderField = []NarrativeHistoryOrderField{
	NarrativeHistoryOrderFieldCreatedAt,
	NarrativeHistoryOrderFieldUpdatedAt,
	NarrativeHistoryOrderFieldName,
}

func (e NarrativeHistoryOrderField) IsValid() bool {
	switch e {
	case NarrativeHistoryOrderFieldCreatedAt, NarrativeHistoryOrderFieldUpdatedAt, NarrativeHistoryOrderFieldName:
		return true
	}
	return false
}

func (e NarrativeHistoryOrderField) String() string {
	return string(e)
}

func (e *NarrativeHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NarrativeHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NarrativeHistoryOrderField", str)
	}
	return nil
}

func (e NarrativeHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Narrative connections can be ordered.
type NarrativeOrderField string

const (
	NarrativeOrderFieldCreatedAt NarrativeOrderField = "created_at"
	NarrativeOrderFieldUpdatedAt NarrativeOrderField = "updated_at"
	NarrativeOrderFieldName      NarrativeOrderField = "name"
)

var AllNarrativeOrderField = []NarrativeOrderField{
	NarrativeOrderFieldCreatedAt,
	NarrativeOrderFieldUpdatedAt,
	NarrativeOrderFieldName,
}

func (e NarrativeOrderField) IsValid() bool {
	switch e {
	case NarrativeOrderFieldCreatedAt, NarrativeOrderFieldUpdatedAt, NarrativeOrderFieldName:
		return true
	}
	return false
}

func (e NarrativeOrderField) String() string {
	return string(e)
}

func (e *NarrativeOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NarrativeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NarrativeOrderField", str)
	}
	return nil
}

func (e NarrativeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which NoteHistory connections can be ordered.
type NoteHistoryOrderField string

const (
	NoteHistoryOrderFieldCreatedAt NoteHistoryOrderField = "created_at"
	NoteHistoryOrderFieldUpdatedAt NoteHistoryOrderField = "updated_at"
)

var AllNoteHistoryOrderField = []NoteHistoryOrderField{
	NoteHistoryOrderFieldCreatedAt,
	NoteHistoryOrderFieldUpdatedAt,
}

func (e NoteHistoryOrderField) IsValid() bool {
	switch e {
	case NoteHistoryOrderFieldCreatedAt, NoteHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e NoteHistoryOrderField) String() string {
	return string(e)
}

func (e *NoteHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NoteHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NoteHistoryOrderField", str)
	}
	return nil
}

func (e NoteHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Note connections can be ordered.
type NoteOrderField string

const (
	NoteOrderFieldCreatedAt NoteOrderField = "created_at"
	NoteOrderFieldUpdatedAt NoteOrderField = "updated_at"
)

var AllNoteOrderField = []NoteOrderField{
	NoteOrderFieldCreatedAt,
	NoteOrderFieldUpdatedAt,
}

func (e NoteOrderField) IsValid() bool {
	switch e {
	case NoteOrderFieldCreatedAt, NoteOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e NoteOrderField) String() string {
	return string(e)
}

func (e *NoteOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NoteOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NoteOrderField", str)
	}
	return nil
}

func (e NoteOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrgMembershipHistory connections can be ordered.
type OrgMembershipHistoryOrderField string

const (
	OrgMembershipHistoryOrderFieldCreatedAt OrgMembershipHistoryOrderField = "created_at"
	OrgMembershipHistoryOrderFieldUpdatedAt OrgMembershipHistoryOrderField = "updated_at"
	OrgMembershipHistoryOrderFieldRole      OrgMembershipHistoryOrderField = "ROLE"
)

var AllOrgMembershipHistoryOrderField = []OrgMembershipHistoryOrderField{
	OrgMembershipHistoryOrderFieldCreatedAt,
	OrgMembershipHistoryOrderFieldUpdatedAt,
	OrgMembershipHistoryOrderFieldRole,
}

func (e OrgMembershipHistoryOrderField) IsValid() bool {
	switch e {
	case OrgMembershipHistoryOrderFieldCreatedAt, OrgMembershipHistoryOrderFieldUpdatedAt, OrgMembershipHistoryOrderFieldRole:
		return true
	}
	return false
}

func (e OrgMembershipHistoryOrderField) String() string {
	return string(e)
}

func (e *OrgMembershipHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgMembershipHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgMembershipHistoryOrderField", str)
	}
	return nil
}

func (e OrgMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrgMembership connections can be ordered.
type OrgMembershipOrderField string

const (
	OrgMembershipOrderFieldCreatedAt OrgMembershipOrderField = "created_at"
	OrgMembershipOrderFieldUpdatedAt OrgMembershipOrderField = "updated_at"
	OrgMembershipOrderFieldRole      OrgMembershipOrderField = "ROLE"
)

var AllOrgMembershipOrderField = []OrgMembershipOrderField{
	OrgMembershipOrderFieldCreatedAt,
	OrgMembershipOrderFieldUpdatedAt,
	OrgMembershipOrderFieldRole,
}

func (e OrgMembershipOrderField) IsValid() bool {
	switch e {
	case OrgMembershipOrderFieldCreatedAt, OrgMembershipOrderFieldUpdatedAt, OrgMembershipOrderFieldRole:
		return true
	}
	return false
}

func (e OrgMembershipOrderField) String() string {
	return string(e)
}

func (e *OrgMembershipOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgMembershipOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgMembershipOrderField", str)
	}
	return nil
}

func (e OrgMembershipOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrgSubscriptionHistory connections can be ordered.
type OrgSubscriptionHistoryOrderField string

const (
	OrgSubscriptionHistoryOrderFieldCreatedAt                OrgSubscriptionHistoryOrderField = "created_at"
	OrgSubscriptionHistoryOrderFieldUpdatedAt                OrgSubscriptionHistoryOrderField = "updated_at"
	OrgSubscriptionHistoryOrderFieldProductTier              OrgSubscriptionHistoryOrderField = "product_tier"
	OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus OrgSubscriptionHistoryOrderField = "stripe_subscription_status"
	OrgSubscriptionHistoryOrderFieldActive                   OrgSubscriptionHistoryOrderField = "active"
	OrgSubscriptionHistoryOrderFieldExpiresAt                OrgSubscriptionHistoryOrderField = "expires_at"
	OrgSubscriptionHistoryOrderFieldTrialExpiresAt           OrgSubscriptionHistoryOrderField = "trial_expires_at"
	OrgSubscriptionHistoryOrderFieldDaysUntilDue             OrgSubscriptionHistoryOrderField = "days_until_due"
)

var AllOrgSubscriptionHistoryOrderField = []OrgSubscriptionHistoryOrderField{
	OrgSubscriptionHistoryOrderFieldCreatedAt,
	OrgSubscriptionHistoryOrderFieldUpdatedAt,
	OrgSubscriptionHistoryOrderFieldProductTier,
	OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus,
	OrgSubscriptionHistoryOrderFieldActive,
	OrgSubscriptionHistoryOrderFieldExpiresAt,
	OrgSubscriptionHistoryOrderFieldTrialExpiresAt,
	OrgSubscriptionHistoryOrderFieldDaysUntilDue,
}

func (e OrgSubscriptionHistoryOrderField) IsValid() bool {
	switch e {
	case OrgSubscriptionHistoryOrderFieldCreatedAt, OrgSubscriptionHistoryOrderFieldUpdatedAt, OrgSubscriptionHistoryOrderFieldProductTier, OrgSubscriptionHistoryOrderFieldStripeSubscriptionStatus, OrgSubscriptionHistoryOrderFieldActive, OrgSubscriptionHistoryOrderFieldExpiresAt, OrgSubscriptionHistoryOrderFieldTrialExpiresAt, OrgSubscriptionHistoryOrderFieldDaysUntilDue:
		return true
	}
	return false
}

func (e OrgSubscriptionHistoryOrderField) String() string {
	return string(e)
}

func (e *OrgSubscriptionHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgSubscriptionHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgSubscriptionHistoryOrderField", str)
	}
	return nil
}

func (e OrgSubscriptionHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrgSubscription connections can be ordered.
type OrgSubscriptionOrderField string

const (
	OrgSubscriptionOrderFieldCreatedAt                OrgSubscriptionOrderField = "created_at"
	OrgSubscriptionOrderFieldUpdatedAt                OrgSubscriptionOrderField = "updated_at"
	OrgSubscriptionOrderFieldProductTier              OrgSubscriptionOrderField = "product_tier"
	OrgSubscriptionOrderFieldStripeSubscriptionStatus OrgSubscriptionOrderField = "stripe_subscription_status"
	OrgSubscriptionOrderFieldActive                   OrgSubscriptionOrderField = "active"
	OrgSubscriptionOrderFieldExpiresAt                OrgSubscriptionOrderField = "expires_at"
	OrgSubscriptionOrderFieldTrialExpiresAt           OrgSubscriptionOrderField = "trial_expires_at"
	OrgSubscriptionOrderFieldDaysUntilDue             OrgSubscriptionOrderField = "days_until_due"
)

var AllOrgSubscriptionOrderField = []OrgSubscriptionOrderField{
	OrgSubscriptionOrderFieldCreatedAt,
	OrgSubscriptionOrderFieldUpdatedAt,
	OrgSubscriptionOrderFieldProductTier,
	OrgSubscriptionOrderFieldStripeSubscriptionStatus,
	OrgSubscriptionOrderFieldActive,
	OrgSubscriptionOrderFieldExpiresAt,
	OrgSubscriptionOrderFieldTrialExpiresAt,
	OrgSubscriptionOrderFieldDaysUntilDue,
}

func (e OrgSubscriptionOrderField) IsValid() bool {
	switch e {
	case OrgSubscriptionOrderFieldCreatedAt, OrgSubscriptionOrderFieldUpdatedAt, OrgSubscriptionOrderFieldProductTier, OrgSubscriptionOrderFieldStripeSubscriptionStatus, OrgSubscriptionOrderFieldActive, OrgSubscriptionOrderFieldExpiresAt, OrgSubscriptionOrderFieldTrialExpiresAt, OrgSubscriptionOrderFieldDaysUntilDue:
		return true
	}
	return false
}

func (e OrgSubscriptionOrderField) String() string {
	return string(e)
}

func (e *OrgSubscriptionOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrgSubscriptionOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrgSubscriptionOrderField", str)
	}
	return nil
}

func (e OrgSubscriptionOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrganizationHistory connections can be ordered.
type OrganizationHistoryOrderField string

const (
	OrganizationHistoryOrderFieldCreatedAt   OrganizationHistoryOrderField = "created_at"
	OrganizationHistoryOrderFieldUpdatedAt   OrganizationHistoryOrderField = "updated_at"
	OrganizationHistoryOrderFieldName        OrganizationHistoryOrderField = "name"
	OrganizationHistoryOrderFieldDisplayName OrganizationHistoryOrderField = "display_name"
)

var AllOrganizationHistoryOrderField = []OrganizationHistoryOrderField{
	OrganizationHistoryOrderFieldCreatedAt,
	OrganizationHistoryOrderFieldUpdatedAt,
	OrganizationHistoryOrderFieldName,
	OrganizationHistoryOrderFieldDisplayName,
}

func (e OrganizationHistoryOrderField) IsValid() bool {
	switch e {
	case OrganizationHistoryOrderFieldCreatedAt, OrganizationHistoryOrderFieldUpdatedAt, OrganizationHistoryOrderFieldName, OrganizationHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationHistoryOrderField) String() string {
	return string(e)
}

func (e *OrganizationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

func (e OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Organization connections can be ordered.
type OrganizationOrderField string

const (
	OrganizationOrderFieldCreatedAt   OrganizationOrderField = "created_at"
	OrganizationOrderFieldUpdatedAt   OrganizationOrderField = "updated_at"
	OrganizationOrderFieldName        OrganizationOrderField = "name"
	OrganizationOrderFieldDisplayName OrganizationOrderField = "display_name"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldCreatedAt,
	OrganizationOrderFieldUpdatedAt,
	OrganizationOrderFieldName,
	OrganizationOrderFieldDisplayName,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldCreatedAt, OrganizationOrderFieldUpdatedAt, OrganizationOrderFieldName, OrganizationOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrganizationSettingHistory connections can be ordered.
type OrganizationSettingHistoryOrderField string

const (
	OrganizationSettingHistoryOrderFieldCreatedAt OrganizationSettingHistoryOrderField = "created_at"
	OrganizationSettingHistoryOrderFieldUpdatedAt OrganizationSettingHistoryOrderField = "updated_at"
)

var AllOrganizationSettingHistoryOrderField = []OrganizationSettingHistoryOrderField{
	OrganizationSettingHistoryOrderFieldCreatedAt,
	OrganizationSettingHistoryOrderFieldUpdatedAt,
}

func (e OrganizationSettingHistoryOrderField) IsValid() bool {
	switch e {
	case OrganizationSettingHistoryOrderFieldCreatedAt, OrganizationSettingHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e OrganizationSettingHistoryOrderField) String() string {
	return string(e)
}

func (e *OrganizationSettingHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationSettingHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationSettingHistoryOrderField", str)
	}
	return nil
}

func (e OrganizationSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrganizationSetting connections can be ordered.
type OrganizationSettingOrderField string

const (
	OrganizationSettingOrderFieldCreatedAt OrganizationSettingOrderField = "created_at"
	OrganizationSettingOrderFieldUpdatedAt OrganizationSettingOrderField = "updated_at"
)

var AllOrganizationSettingOrderField = []OrganizationSettingOrderField{
	OrganizationSettingOrderFieldCreatedAt,
	OrganizationSettingOrderFieldUpdatedAt,
}

func (e OrganizationSettingOrderField) IsValid() bool {
	switch e {
	case OrganizationSettingOrderFieldCreatedAt, OrganizationSettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e OrganizationSettingOrderField) String() string {
	return string(e)
}

func (e *OrganizationSettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationSettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationSettingOrderField", str)
	}
	return nil
}

func (e OrganizationSettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which PersonalAccessToken connections can be ordered.
type PersonalAccessTokenOrderField string

const (
	PersonalAccessTokenOrderFieldCreatedAt  PersonalAccessTokenOrderField = "created_at"
	PersonalAccessTokenOrderFieldUpdatedAt  PersonalAccessTokenOrderField = "updated_at"
	PersonalAccessTokenOrderFieldName       PersonalAccessTokenOrderField = "name"
	PersonalAccessTokenOrderFieldExpiresAt  PersonalAccessTokenOrderField = "expires_at"
	PersonalAccessTokenOrderFieldLastUsedAt PersonalAccessTokenOrderField = "last_used_at"
	PersonalAccessTokenOrderFieldIsActive   PersonalAccessTokenOrderField = "is_active"
)

var AllPersonalAccessTokenOrderField = []PersonalAccessTokenOrderField{
	PersonalAccessTokenOrderFieldCreatedAt,
	PersonalAccessTokenOrderFieldUpdatedAt,
	PersonalAccessTokenOrderFieldName,
	PersonalAccessTokenOrderFieldExpiresAt,
	PersonalAccessTokenOrderFieldLastUsedAt,
	PersonalAccessTokenOrderFieldIsActive,
}

func (e PersonalAccessTokenOrderField) IsValid() bool {
	switch e {
	case PersonalAccessTokenOrderFieldCreatedAt, PersonalAccessTokenOrderFieldUpdatedAt, PersonalAccessTokenOrderFieldName, PersonalAccessTokenOrderFieldExpiresAt, PersonalAccessTokenOrderFieldLastUsedAt, PersonalAccessTokenOrderFieldIsActive:
		return true
	}
	return false
}

func (e PersonalAccessTokenOrderField) String() string {
	return string(e)
}

func (e *PersonalAccessTokenOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PersonalAccessTokenOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PersonalAccessTokenOrderField", str)
	}
	return nil
}

func (e PersonalAccessTokenOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ProcedureHistory connections can be ordered.
type ProcedureHistoryOrderField string

const (
	ProcedureHistoryOrderFieldCreatedAt       ProcedureHistoryOrderField = "created_at"
	ProcedureHistoryOrderFieldUpdatedAt       ProcedureHistoryOrderField = "updated_at"
	ProcedureHistoryOrderFieldRevision        ProcedureHistoryOrderField = "revision"
	ProcedureHistoryOrderFieldName            ProcedureHistoryOrderField = "name"
	ProcedureHistoryOrderFieldStatus          ProcedureHistoryOrderField = "STATUS"
	ProcedureHistoryOrderFieldReviewDue       ProcedureHistoryOrderField = "review_due"
	ProcedureHistoryOrderFieldReviewFrequency ProcedureHistoryOrderField = "REVIEW_FREQUENCY"
)

var AllProcedureHistoryOrderField = []ProcedureHistoryOrderField{
	ProcedureHistoryOrderFieldCreatedAt,
	ProcedureHistoryOrderFieldUpdatedAt,
	ProcedureHistoryOrderFieldRevision,
	ProcedureHistoryOrderFieldName,
	ProcedureHistoryOrderFieldStatus,
	ProcedureHistoryOrderFieldReviewDue,
	ProcedureHistoryOrderFieldReviewFrequency,
}

func (e ProcedureHistoryOrderField) IsValid() bool {
	switch e {
	case ProcedureHistoryOrderFieldCreatedAt, ProcedureHistoryOrderFieldUpdatedAt, ProcedureHistoryOrderFieldRevision, ProcedureHistoryOrderFieldName, ProcedureHistoryOrderFieldStatus, ProcedureHistoryOrderFieldReviewDue, ProcedureHistoryOrderFieldReviewFrequency:
		return true
	}
	return false
}

func (e ProcedureHistoryOrderField) String() string {
	return string(e)
}

func (e *ProcedureHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProcedureHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProcedureHistoryOrderField", str)
	}
	return nil
}

func (e ProcedureHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Procedure connections can be ordered.
type ProcedureOrderField string

const (
	ProcedureOrderFieldCreatedAt       ProcedureOrderField = "created_at"
	ProcedureOrderFieldUpdatedAt       ProcedureOrderField = "updated_at"
	ProcedureOrderFieldRevision        ProcedureOrderField = "revision"
	ProcedureOrderFieldName            ProcedureOrderField = "name"
	ProcedureOrderFieldStatus          ProcedureOrderField = "STATUS"
	ProcedureOrderFieldReviewDue       ProcedureOrderField = "review_due"
	ProcedureOrderFieldReviewFrequency ProcedureOrderField = "REVIEW_FREQUENCY"
)

var AllProcedureOrderField = []ProcedureOrderField{
	ProcedureOrderFieldCreatedAt,
	ProcedureOrderFieldUpdatedAt,
	ProcedureOrderFieldRevision,
	ProcedureOrderFieldName,
	ProcedureOrderFieldStatus,
	ProcedureOrderFieldReviewDue,
	ProcedureOrderFieldReviewFrequency,
}

func (e ProcedureOrderField) IsValid() bool {
	switch e {
	case ProcedureOrderFieldCreatedAt, ProcedureOrderFieldUpdatedAt, ProcedureOrderFieldRevision, ProcedureOrderFieldName, ProcedureOrderFieldStatus, ProcedureOrderFieldReviewDue, ProcedureOrderFieldReviewFrequency:
		return true
	}
	return false
}

func (e ProcedureOrderField) String() string {
	return string(e)
}

func (e *ProcedureOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProcedureOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProcedureOrderField", str)
	}
	return nil
}

func (e ProcedureOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ProgramHistory connections can be ordered.
type ProgramHistoryOrderField string

const (
	ProgramHistoryOrderFieldCreatedAt ProgramHistoryOrderField = "created_at"
	ProgramHistoryOrderFieldUpdatedAt ProgramHistoryOrderField = "updated_at"
	ProgramHistoryOrderFieldName      ProgramHistoryOrderField = "name"
	ProgramHistoryOrderFieldStatus    ProgramHistoryOrderField = "STATUS"
	ProgramHistoryOrderFieldStartDate ProgramHistoryOrderField = "start_date"
	ProgramHistoryOrderFieldEndDate   ProgramHistoryOrderField = "end_date"
)

var AllProgramHistoryOrderField = []ProgramHistoryOrderField{
	ProgramHistoryOrderFieldCreatedAt,
	ProgramHistoryOrderFieldUpdatedAt,
	ProgramHistoryOrderFieldName,
	ProgramHistoryOrderFieldStatus,
	ProgramHistoryOrderFieldStartDate,
	ProgramHistoryOrderFieldEndDate,
}

func (e ProgramHistoryOrderField) IsValid() bool {
	switch e {
	case ProgramHistoryOrderFieldCreatedAt, ProgramHistoryOrderFieldUpdatedAt, ProgramHistoryOrderFieldName, ProgramHistoryOrderFieldStatus, ProgramHistoryOrderFieldStartDate, ProgramHistoryOrderFieldEndDate:
		return true
	}
	return false
}

func (e ProgramHistoryOrderField) String() string {
	return string(e)
}

func (e *ProgramHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgramHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgramHistoryOrderField", str)
	}
	return nil
}

func (e ProgramHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ProgramMembershipHistory connections can be ordered.
type ProgramMembershipHistoryOrderField string

const (
	ProgramMembershipHistoryOrderFieldCreatedAt ProgramMembershipHistoryOrderField = "created_at"
	ProgramMembershipHistoryOrderFieldUpdatedAt ProgramMembershipHistoryOrderField = "updated_at"
	ProgramMembershipHistoryOrderFieldRole      ProgramMembershipHistoryOrderField = "ROLE"
)

var AllProgramMembershipHistoryOrderField = []ProgramMembershipHistoryOrderField{
	ProgramMembershipHistoryOrderFieldCreatedAt,
	ProgramMembershipHistoryOrderFieldUpdatedAt,
	ProgramMembershipHistoryOrderFieldRole,
}

func (e ProgramMembershipHistoryOrderField) IsValid() bool {
	switch e {
	case ProgramMembershipHistoryOrderFieldCreatedAt, ProgramMembershipHistoryOrderFieldUpdatedAt, ProgramMembershipHistoryOrderFieldRole:
		return true
	}
	return false
}

func (e ProgramMembershipHistoryOrderField) String() string {
	return string(e)
}

func (e *ProgramMembershipHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgramMembershipHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgramMembershipHistoryOrderField", str)
	}
	return nil
}

func (e ProgramMembershipHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which ProgramMembership connections can be ordered.
type ProgramMembershipOrderField string

const (
	ProgramMembershipOrderFieldCreatedAt ProgramMembershipOrderField = "created_at"
	ProgramMembershipOrderFieldUpdatedAt ProgramMembershipOrderField = "updated_at"
	ProgramMembershipOrderFieldRole      ProgramMembershipOrderField = "ROLE"
)

var AllProgramMembershipOrderField = []ProgramMembershipOrderField{
	ProgramMembershipOrderFieldCreatedAt,
	ProgramMembershipOrderFieldUpdatedAt,
	ProgramMembershipOrderFieldRole,
}

func (e ProgramMembershipOrderField) IsValid() bool {
	switch e {
	case ProgramMembershipOrderFieldCreatedAt, ProgramMembershipOrderFieldUpdatedAt, ProgramMembershipOrderFieldRole:
		return true
	}
	return false
}

func (e ProgramMembershipOrderField) String() string {
	return string(e)
}

func (e *ProgramMembershipOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgramMembershipOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgramMembershipOrderField", str)
	}
	return nil
}

func (e ProgramMembershipOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Program connections can be ordered.
type ProgramOrderField string

const (
	ProgramOrderFieldCreatedAt ProgramOrderField = "created_at"
	ProgramOrderFieldUpdatedAt ProgramOrderField = "updated_at"
	ProgramOrderFieldName      ProgramOrderField = "name"
	ProgramOrderFieldStatus    ProgramOrderField = "STATUS"
	ProgramOrderFieldStartDate ProgramOrderField = "start_date"
	ProgramOrderFieldEndDate   ProgramOrderField = "end_date"
)

var AllProgramOrderField = []ProgramOrderField{
	ProgramOrderFieldCreatedAt,
	ProgramOrderFieldUpdatedAt,
	ProgramOrderFieldName,
	ProgramOrderFieldStatus,
	ProgramOrderFieldStartDate,
	ProgramOrderFieldEndDate,
}

func (e ProgramOrderField) IsValid() bool {
	switch e {
	case ProgramOrderFieldCreatedAt, ProgramOrderFieldUpdatedAt, ProgramOrderFieldName, ProgramOrderFieldStatus, ProgramOrderFieldStartDate, ProgramOrderFieldEndDate:
		return true
	}
	return false
}

func (e ProgramOrderField) String() string {
	return string(e)
}

func (e *ProgramOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgramOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgramOrderField", str)
	}
	return nil
}

func (e ProgramOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which RiskHistory connections can be ordered.
type RiskHistoryOrderField string

const (
	RiskHistoryOrderFieldCreatedAt     RiskHistoryOrderField = "created_at"
	RiskHistoryOrderFieldUpdatedAt     RiskHistoryOrderField = "updated_at"
	RiskHistoryOrderFieldName          RiskHistoryOrderField = "name"
	RiskHistoryOrderFieldStatus        RiskHistoryOrderField = "STATUS"
	RiskHistoryOrderFieldRiskType      RiskHistoryOrderField = "risk_type"
	RiskHistoryOrderFieldCategory      RiskHistoryOrderField = "category"
	RiskHistoryOrderFieldImpact        RiskHistoryOrderField = "IMPACT"
	RiskHistoryOrderFieldLikelihood    RiskHistoryOrderField = "LIKELIHOOD"
	RiskHistoryOrderFieldScore         RiskHistoryOrderField = "score"
	RiskHistoryOrderFieldBusinessCosts RiskHistoryOrderField = "business_costs"
)

var AllRiskHistoryOrderField = []RiskHistoryOrderField{
	RiskHistoryOrderFieldCreatedAt,
	RiskHistoryOrderFieldUpdatedAt,
	RiskHistoryOrderFieldName,
	RiskHistoryOrderFieldStatus,
	RiskHistoryOrderFieldRiskType,
	RiskHistoryOrderFieldCategory,
	RiskHistoryOrderFieldImpact,
	RiskHistoryOrderFieldLikelihood,
	RiskHistoryOrderFieldScore,
	RiskHistoryOrderFieldBusinessCosts,
}

func (e RiskHistoryOrderField) IsValid() bool {
	switch e {
	case RiskHistoryOrderFieldCreatedAt, RiskHistoryOrderFieldUpdatedAt, RiskHistoryOrderFieldName, RiskHistoryOrderFieldStatus, RiskHistoryOrderFieldRiskType, RiskHistoryOrderFieldCategory, RiskHistoryOrderFieldImpact, RiskHistoryOrderFieldLikelihood, RiskHistoryOrderFieldScore, RiskHistoryOrderFieldBusinessCosts:
		return true
	}
	return false
}

func (e RiskHistoryOrderField) String() string {
	return string(e)
}

func (e *RiskHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskHistoryOrderField", str)
	}
	return nil
}

func (e RiskHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Risk connections can be ordered.
type RiskOrderField string

const (
	RiskOrderFieldCreatedAt     RiskOrderField = "created_at"
	RiskOrderFieldUpdatedAt     RiskOrderField = "updated_at"
	RiskOrderFieldName          RiskOrderField = "name"
	RiskOrderFieldStatus        RiskOrderField = "STATUS"
	RiskOrderFieldRiskType      RiskOrderField = "risk_type"
	RiskOrderFieldCategory      RiskOrderField = "category"
	RiskOrderFieldImpact        RiskOrderField = "IMPACT"
	RiskOrderFieldLikelihood    RiskOrderField = "LIKELIHOOD"
	RiskOrderFieldScore         RiskOrderField = "score"
	RiskOrderFieldBusinessCosts RiskOrderField = "business_costs"
)

var AllRiskOrderField = []RiskOrderField{
	RiskOrderFieldCreatedAt,
	RiskOrderFieldUpdatedAt,
	RiskOrderFieldName,
	RiskOrderFieldStatus,
	RiskOrderFieldRiskType,
	RiskOrderFieldCategory,
	RiskOrderFieldImpact,
	RiskOrderFieldLikelihood,
	RiskOrderFieldScore,
	RiskOrderFieldBusinessCosts,
}

func (e RiskOrderField) IsValid() bool {
	switch e {
	case RiskOrderFieldCreatedAt, RiskOrderFieldUpdatedAt, RiskOrderFieldName, RiskOrderFieldStatus, RiskOrderFieldRiskType, RiskOrderFieldCategory, RiskOrderFieldImpact, RiskOrderFieldLikelihood, RiskOrderFieldScore, RiskOrderFieldBusinessCosts:
		return true
	}
	return false
}

func (e RiskOrderField) String() string {
	return string(e)
}

func (e *RiskOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RiskOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RiskOrderField", str)
	}
	return nil
}

func (e RiskOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which StandardHistory connections can be ordered.
type StandardHistoryOrderField string

const (
	StandardHistoryOrderFieldCreatedAt     StandardHistoryOrderField = "created_at"
	StandardHistoryOrderFieldUpdatedAt     StandardHistoryOrderField = "updated_at"
	StandardHistoryOrderFieldRevision      StandardHistoryOrderField = "revision"
	StandardHistoryOrderFieldName          StandardHistoryOrderField = "name"
	StandardHistoryOrderFieldShortName     StandardHistoryOrderField = "short_name"
	StandardHistoryOrderFieldFramework     StandardHistoryOrderField = "framework"
	StandardHistoryOrderFieldGoverningBody StandardHistoryOrderField = "governing_body"
	StandardHistoryOrderFieldStatus        StandardHistoryOrderField = "STATUS"
	StandardHistoryOrderFieldStandardType  StandardHistoryOrderField = "standard_type"
)

var AllStandardHistoryOrderField = []StandardHistoryOrderField{
	StandardHistoryOrderFieldCreatedAt,
	StandardHistoryOrderFieldUpdatedAt,
	StandardHistoryOrderFieldRevision,
	StandardHistoryOrderFieldName,
	StandardHistoryOrderFieldShortName,
	StandardHistoryOrderFieldFramework,
	StandardHistoryOrderFieldGoverningBody,
	StandardHistoryOrderFieldStatus,
	StandardHistoryOrderFieldStandardType,
}

func (e StandardHistoryOrderField) IsValid() bool {
	switch e {
	case StandardHistoryOrderFieldCreatedAt, StandardHistoryOrderFieldUpdatedAt, StandardHistoryOrderFieldRevision, StandardHistoryOrderFieldName, StandardHistoryOrderFieldShortName, StandardHistoryOrderFieldFramework, StandardHistoryOrderFieldGoverningBody, StandardHistoryOrderFieldStatus, StandardHistoryOrderFieldStandardType:
		return true
	}
	return false
}

func (e StandardHistoryOrderField) String() string {
	return string(e)
}

func (e *StandardHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StandardHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StandardHistoryOrderField", str)
	}
	return nil
}

func (e StandardHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Standard connections can be ordered.
type StandardOrderField string

const (
	StandardOrderFieldCreatedAt     StandardOrderField = "created_at"
	StandardOrderFieldUpdatedAt     StandardOrderField = "updated_at"
	StandardOrderFieldRevision      StandardOrderField = "revision"
	StandardOrderFieldName          StandardOrderField = "name"
	StandardOrderFieldShortName     StandardOrderField = "short_name"
	StandardOrderFieldFramework     StandardOrderField = "framework"
	StandardOrderFieldGoverningBody StandardOrderField = "governing_body"
	StandardOrderFieldStatus        StandardOrderField = "STATUS"
	StandardOrderFieldStandardType  StandardOrderField = "standard_type"
)

var AllStandardOrderField = []StandardOrderField{
	StandardOrderFieldCreatedAt,
	StandardOrderFieldUpdatedAt,
	StandardOrderFieldRevision,
	StandardOrderFieldName,
	StandardOrderFieldShortName,
	StandardOrderFieldFramework,
	StandardOrderFieldGoverningBody,
	StandardOrderFieldStatus,
	StandardOrderFieldStandardType,
}

func (e StandardOrderField) IsValid() bool {
	switch e {
	case StandardOrderFieldCreatedAt, StandardOrderFieldUpdatedAt, StandardOrderFieldRevision, StandardOrderFieldName, StandardOrderFieldShortName, StandardOrderFieldFramework, StandardOrderFieldGoverningBody, StandardOrderFieldStatus, StandardOrderFieldStandardType:
		return true
	}
	return false
}

func (e StandardOrderField) String() string {
	return string(e)
}

func (e *StandardOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StandardOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StandardOrderField", str)
	}
	return nil
}

func (e StandardOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which SubcontrolHistory connections can be ordered.
type SubcontrolHistoryOrderField string

const (
	SubcontrolHistoryOrderFieldCreatedAt   SubcontrolHistoryOrderField = "created_at"
	SubcontrolHistoryOrderFieldUpdatedAt   SubcontrolHistoryOrderField = "updated_at"
	SubcontrolHistoryOrderFieldStatus      SubcontrolHistoryOrderField = "status"
	SubcontrolHistoryOrderFieldSource      SubcontrolHistoryOrderField = "SOURCE"
	SubcontrolHistoryOrderFieldControlType SubcontrolHistoryOrderField = "CONTROL_TYPE"
	SubcontrolHistoryOrderFieldCategory    SubcontrolHistoryOrderField = "category"
	SubcontrolHistoryOrderFieldSubcategory SubcontrolHistoryOrderField = "subcategory"
	SubcontrolHistoryOrderFieldRefCode     SubcontrolHistoryOrderField = "ref_code"
)

var AllSubcontrolHistoryOrderField = []SubcontrolHistoryOrderField{
	SubcontrolHistoryOrderFieldCreatedAt,
	SubcontrolHistoryOrderFieldUpdatedAt,
	SubcontrolHistoryOrderFieldStatus,
	SubcontrolHistoryOrderFieldSource,
	SubcontrolHistoryOrderFieldControlType,
	SubcontrolHistoryOrderFieldCategory,
	SubcontrolHistoryOrderFieldSubcategory,
	SubcontrolHistoryOrderFieldRefCode,
}

func (e SubcontrolHistoryOrderField) IsValid() bool {
	switch e {
	case SubcontrolHistoryOrderFieldCreatedAt, SubcontrolHistoryOrderFieldUpdatedAt, SubcontrolHistoryOrderFieldStatus, SubcontrolHistoryOrderFieldSource, SubcontrolHistoryOrderFieldControlType, SubcontrolHistoryOrderFieldCategory, SubcontrolHistoryOrderFieldSubcategory, SubcontrolHistoryOrderFieldRefCode:
		return true
	}
	return false
}

func (e SubcontrolHistoryOrderField) String() string {
	return string(e)
}

func (e *SubcontrolHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubcontrolHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubcontrolHistoryOrderField", str)
	}
	return nil
}

func (e SubcontrolHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Subcontrol connections can be ordered.
type SubcontrolOrderField string

const (
	SubcontrolOrderFieldCreatedAt   SubcontrolOrderField = "created_at"
	SubcontrolOrderFieldUpdatedAt   SubcontrolOrderField = "updated_at"
	SubcontrolOrderFieldStatus      SubcontrolOrderField = "status"
	SubcontrolOrderFieldSource      SubcontrolOrderField = "SOURCE"
	SubcontrolOrderFieldControlType SubcontrolOrderField = "CONTROL_TYPE"
	SubcontrolOrderFieldCategory    SubcontrolOrderField = "category"
	SubcontrolOrderFieldSubcategory SubcontrolOrderField = "subcategory"
	SubcontrolOrderFieldRefCode     SubcontrolOrderField = "ref_code"
)

var AllSubcontrolOrderField = []SubcontrolOrderField{
	SubcontrolOrderFieldCreatedAt,
	SubcontrolOrderFieldUpdatedAt,
	SubcontrolOrderFieldStatus,
	SubcontrolOrderFieldSource,
	SubcontrolOrderFieldControlType,
	SubcontrolOrderFieldCategory,
	SubcontrolOrderFieldSubcategory,
	SubcontrolOrderFieldRefCode,
}

func (e SubcontrolOrderField) IsValid() bool {
	switch e {
	case SubcontrolOrderFieldCreatedAt, SubcontrolOrderFieldUpdatedAt, SubcontrolOrderFieldStatus, SubcontrolOrderFieldSource, SubcontrolOrderFieldControlType, SubcontrolOrderFieldCategory, SubcontrolOrderFieldSubcategory, SubcontrolOrderFieldRefCode:
		return true
	}
	return false
}

func (e SubcontrolOrderField) String() string {
	return string(e)
}

func (e *SubcontrolOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubcontrolOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubcontrolOrderField", str)
	}
	return nil
}

func (e SubcontrolOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Subscriber connections can be ordered.
type SubscriberOrderField string

const (
	SubscriberOrderFieldCreatedAt    SubscriberOrderField = "created_at"
	SubscriberOrderFieldUpdatedAt    SubscriberOrderField = "updated_at"
	SubscriberOrderFieldEmail        SubscriberOrderField = "email"
	SubscriberOrderFieldActive       SubscriberOrderField = "active"
	SubscriberOrderFieldUnsubscribed SubscriberOrderField = "unsubscribed"
)

var AllSubscriberOrderField = []SubscriberOrderField{
	SubscriberOrderFieldCreatedAt,
	SubscriberOrderFieldUpdatedAt,
	SubscriberOrderFieldEmail,
	SubscriberOrderFieldActive,
	SubscriberOrderFieldUnsubscribed,
}

func (e SubscriberOrderField) IsValid() bool {
	switch e {
	case SubscriberOrderFieldCreatedAt, SubscriberOrderFieldUpdatedAt, SubscriberOrderFieldEmail, SubscriberOrderFieldActive, SubscriberOrderFieldUnsubscribed:
		return true
	}
	return false
}

func (e SubscriberOrderField) String() string {
	return string(e)
}

func (e *SubscriberOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriberOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubscriberOrderField", str)
	}
	return nil
}

func (e SubscriberOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which TFASetting connections can be ordered.
type TFASettingOrderField string

const (
	TFASettingOrderFieldCreatedAt TFASettingOrderField = "created_at"
	TFASettingOrderFieldUpdatedAt TFASettingOrderField = "updated_at"
)

var AllTFASettingOrderField = []TFASettingOrderField{
	TFASettingOrderFieldCreatedAt,
	TFASettingOrderFieldUpdatedAt,
}

func (e TFASettingOrderField) IsValid() bool {
	switch e {
	case TFASettingOrderFieldCreatedAt, TFASettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e TFASettingOrderField) String() string {
	return string(e)
}

func (e *TFASettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TFASettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TFASettingOrderField", str)
	}
	return nil
}

func (e TFASettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which TaskHistory connections can be ordered.
type TaskHistoryOrderField string

const (
	TaskHistoryOrderFieldCreatedAt TaskHistoryOrderField = "created_at"
	TaskHistoryOrderFieldUpdatedAt TaskHistoryOrderField = "updated_at"
	TaskHistoryOrderFieldTitle     TaskHistoryOrderField = "title"
	TaskHistoryOrderFieldStatus    TaskHistoryOrderField = "STATUS"
	TaskHistoryOrderFieldCategory  TaskHistoryOrderField = "category"
	TaskHistoryOrderFieldDue       TaskHistoryOrderField = "due"
	TaskHistoryOrderFieldCompleted TaskHistoryOrderField = "completed"
)

var AllTaskHistoryOrderField = []TaskHistoryOrderField{
	TaskHistoryOrderFieldCreatedAt,
	TaskHistoryOrderFieldUpdatedAt,
	TaskHistoryOrderFieldTitle,
	TaskHistoryOrderFieldStatus,
	TaskHistoryOrderFieldCategory,
	TaskHistoryOrderFieldDue,
	TaskHistoryOrderFieldCompleted,
}

func (e TaskHistoryOrderField) IsValid() bool {
	switch e {
	case TaskHistoryOrderFieldCreatedAt, TaskHistoryOrderFieldUpdatedAt, TaskHistoryOrderFieldTitle, TaskHistoryOrderFieldStatus, TaskHistoryOrderFieldCategory, TaskHistoryOrderFieldDue, TaskHistoryOrderFieldCompleted:
		return true
	}
	return false
}

func (e TaskHistoryOrderField) String() string {
	return string(e)
}

func (e *TaskHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskHistoryOrderField", str)
	}
	return nil
}

func (e TaskHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Task connections can be ordered.
type TaskOrderField string

const (
	TaskOrderFieldCreatedAt TaskOrderField = "created_at"
	TaskOrderFieldUpdatedAt TaskOrderField = "updated_at"
	TaskOrderFieldTitle     TaskOrderField = "title"
	TaskOrderFieldStatus    TaskOrderField = "STATUS"
	TaskOrderFieldCategory  TaskOrderField = "category"
	TaskOrderFieldDue       TaskOrderField = "due"
	TaskOrderFieldCompleted TaskOrderField = "completed"
)

var AllTaskOrderField = []TaskOrderField{
	TaskOrderFieldCreatedAt,
	TaskOrderFieldUpdatedAt,
	TaskOrderFieldTitle,
	TaskOrderFieldStatus,
	TaskOrderFieldCategory,
	TaskOrderFieldDue,
	TaskOrderFieldCompleted,
}

func (e TaskOrderField) IsValid() bool {
	switch e {
	case TaskOrderFieldCreatedAt, TaskOrderFieldUpdatedAt, TaskOrderFieldTitle, TaskOrderFieldStatus, TaskOrderFieldCategory, TaskOrderFieldDue, TaskOrderFieldCompleted:
		return true
	}
	return false
}

func (e TaskOrderField) String() string {
	return string(e)
}

func (e *TaskOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskOrderField", str)
	}
	return nil
}

func (e TaskOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which TemplateHistory connections can be ordered.
type TemplateHistoryOrderField string

const (
	TemplateHistoryOrderFieldCreatedAt    TemplateHistoryOrderField = "created_at"
	TemplateHistoryOrderFieldUpdatedAt    TemplateHistoryOrderField = "updated_at"
	TemplateHistoryOrderFieldName         TemplateHistoryOrderField = "name"
	TemplateHistoryOrderFieldTemplateType TemplateHistoryOrderField = "TEMPLATE_TYPE"
)

var AllTemplateHistoryOrderField = []TemplateHistoryOrderField{
	TemplateHistoryOrderFieldCreatedAt,
	TemplateHistoryOrderFieldUpdatedAt,
	TemplateHistoryOrderFieldName,
	TemplateHistoryOrderFieldTemplateType,
}

func (e TemplateHistoryOrderField) IsValid() bool {
	switch e {
	case TemplateHistoryOrderFieldCreatedAt, TemplateHistoryOrderFieldUpdatedAt, TemplateHistoryOrderFieldName, TemplateHistoryOrderFieldTemplateType:
		return true
	}
	return false
}

func (e TemplateHistoryOrderField) String() string {
	return string(e)
}

func (e *TemplateHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

func (e TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Template connections can be ordered.
type TemplateOrderField string

const (
	TemplateOrderFieldCreatedAt    TemplateOrderField = "created_at"
	TemplateOrderFieldUpdatedAt    TemplateOrderField = "updated_at"
	TemplateOrderFieldName         TemplateOrderField = "name"
	TemplateOrderFieldTemplateType TemplateOrderField = "TEMPLATE_TYPE"
)

var AllTemplateOrderField = []TemplateOrderField{
	TemplateOrderFieldCreatedAt,
	TemplateOrderFieldUpdatedAt,
	TemplateOrderFieldName,
	TemplateOrderFieldTemplateType,
}

func (e TemplateOrderField) IsValid() bool {
	switch e {
	case TemplateOrderFieldCreatedAt, TemplateOrderFieldUpdatedAt, TemplateOrderFieldName, TemplateOrderFieldTemplateType:
		return true
	}
	return false
}

func (e TemplateOrderField) String() string {
	return string(e)
}

func (e *TemplateOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

func (e TemplateOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which UserHistory connections can be ordered.
type UserHistoryOrderField string

const (
	UserHistoryOrderFieldCreatedAt   UserHistoryOrderField = "created_at"
	UserHistoryOrderFieldUpdatedAt   UserHistoryOrderField = "updated_at"
	UserHistoryOrderFieldFirstName   UserHistoryOrderField = "first_name"
	UserHistoryOrderFieldLastName    UserHistoryOrderField = "last_name"
	UserHistoryOrderFieldDisplayName UserHistoryOrderField = "display_name"
)

var AllUserHistoryOrderField = []UserHistoryOrderField{
	UserHistoryOrderFieldCreatedAt,
	UserHistoryOrderFieldUpdatedAt,
	UserHistoryOrderFieldFirstName,
	UserHistoryOrderFieldLastName,
	UserHistoryOrderFieldDisplayName,
}

func (e UserHistoryOrderField) IsValid() bool {
	switch e {
	case UserHistoryOrderFieldCreatedAt, UserHistoryOrderFieldUpdatedAt, UserHistoryOrderFieldFirstName, UserHistoryOrderFieldLastName, UserHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserHistoryOrderField) String() string {
	return string(e)
}

func (e *UserHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

func (e UserHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldCreatedAt   UserOrderField = "created_at"
	UserOrderFieldUpdatedAt   UserOrderField = "updated_at"
	UserOrderFieldFirstName   UserOrderField = "first_name"
	UserOrderFieldLastName    UserOrderField = "last_name"
	UserOrderFieldDisplayName UserOrderField = "display_name"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldCreatedAt,
	UserOrderFieldUpdatedAt,
	UserOrderFieldFirstName,
	UserOrderFieldLastName,
	UserOrderFieldDisplayName,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldCreatedAt, UserOrderFieldUpdatedAt, UserOrderFieldFirstName, UserOrderFieldLastName, UserOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which UserSettingHistory connections can be ordered.
type UserSettingHistoryOrderField string

const (
	UserSettingHistoryOrderFieldCreatedAt UserSettingHistoryOrderField = "created_at"
	UserSettingHistoryOrderFieldUpdatedAt UserSettingHistoryOrderField = "updated_at"
)

var AllUserSettingHistoryOrderField = []UserSettingHistoryOrderField{
	UserSettingHistoryOrderFieldCreatedAt,
	UserSettingHistoryOrderFieldUpdatedAt,
}

func (e UserSettingHistoryOrderField) IsValid() bool {
	switch e {
	case UserSettingHistoryOrderFieldCreatedAt, UserSettingHistoryOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e UserSettingHistoryOrderField) String() string {
	return string(e)
}

func (e *UserSettingHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserSettingHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserSettingHistoryOrderField", str)
	}
	return nil
}

func (e UserSettingHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which UserSetting connections can be ordered.
type UserSettingOrderField string

const (
	UserSettingOrderFieldCreatedAt UserSettingOrderField = "created_at"
	UserSettingOrderFieldUpdatedAt UserSettingOrderField = "updated_at"
)

var AllUserSettingOrderField = []UserSettingOrderField{
	UserSettingOrderFieldCreatedAt,
	UserSettingOrderFieldUpdatedAt,
}

func (e UserSettingOrderField) IsValid() bool {
	switch e {
	case UserSettingOrderFieldCreatedAt, UserSettingOrderFieldUpdatedAt:
		return true
	}
	return false
}

func (e UserSettingOrderField) String() string {
	return string(e)
}

func (e *UserSettingOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserSettingOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserSettingOrderField", str)
	}
	return nil
}

func (e UserSettingOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
